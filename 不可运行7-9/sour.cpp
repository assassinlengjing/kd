#include "sub.h"
#include <psapi.h>
#include <strsafe.h>



void __cdecl  abort()
{
  _NMSG_WRITE(0xAu);
  raise(22);
  _exit(3);
}
//+
char* __cdecl AdjustPointer(void* a1, const struct PMD* a2)
{
    int pdisp; // edx
    char* result; // eax

    pdisp = a2->pdisp;
    result = (char*)a1 + a2->mdisp;
    if (pdisp >= 0)
        result += pdisp + *  (_DWORD*)    (*(_DWORD*)((char*)a1 + pdisp) + a2->vdisp);
    return result;
}//???
//int __cdecl atexit(void (__cdecl *Func)())
//{
//  return (_onexit((_onexit_t)Func) != 0) - 1;
//}//
//int __cdecl atoi(const char *String)
//{
//  return atol(String);
//}//???
//
//long __cdecl atol(const char *String)
//{
//  int v3; // esi
//  const char *v4; // edi
//  int v5; // ebp
//  int v6; // ebx
//  int result; // eax
//
//  while ( cbMultiByte <= 1 ? *((_BYTE *)off_4B8414 + 2 * *(unsigned __int8 *)String) & 8 : _isctype(
//                                                                                             *(unsigned __int8 *)String,
//                                                                                             8) )
//    ++String;
//  v3 = *(unsigned __int8 *)String;
//  v4 = String + 1;
//  v5 = v3;
//  if ( v3 == 45 || v3 == 43 )
//    v3 = *(unsigned __int8 *)v4++;
//  v6 = 0;
//  while ( cbMultiByte <= 1 ? *((_BYTE *)off_4B8414 + 2 * v3) & 4 : _isctype(v3, 4) )
//  {
//    v6 = v3 + 10 * v6 - 48;
//    v3 = *(unsigned __int8 *)v4++;
//  }
//  result = v6;
//  if ( v5 == 45 )
//    return -v6;
//  return result;
//}

// positive sp value has been detected, the output may be wrong!
void AugmentSinCos(int a1, long double a2)
{
    long double v2; // st7
    __int16 v3; // fps
    long double v4; // st6
    bool v5; // c0
    char v6; // c2
    bool v7; // c3

    v2 = fabs(a2);
    v4 = (1.0 - v2) * (v2 + 1.0);
    v5 = v4 < 0.0;
    v6 = 0;
    v7 = v4 == 0.0;
    *(_WORD*)(a1 - 160) = v3;
    if ((*(_BYTE*)(a1 - 159) & 1) != 0)
    {
        if (*(char*)(a1 - 144) > 0)
            ////£¿£¿£¿JUMPOUT(0x4A4790); ???
        _rttosnpopde(a1);
    }
}
void  BuildCatchObject(
    struct EHExceptionRecord* a1,
    struct EHExceptionRecord* a2,
    struct EHRegistrationNode* a3,
    const struct _s_HandlerType* a4,
    const struct _s_CatchableType* a5)
{
    TypeDescriptor* pType; // eax
    ptrdiff_t dispCatchObj; // eax
    char** v7; // edi
    void* v8; // esi
    BOOL v9; // eax
    EXCEPTION_POINTERS* v10; // ecx
    int v11; // eax
    char* pExceptionObject; // eax
    char* v13; // eax
    BOOL v14; // eax
    int v15; // eax
    BOOL v16; // eax
    int v17; // eax
    char* v18; // eax
    BOOL v19; // eax
    int v20; // eax
    int v21; // eax
    void* v22; // [esp-8h] [ebp-30h]
    EXCEPTION_POINTERS* v23; // [esp-4h] [ebp-2Ch]
    EXCEPTION_POINTERS* v24; // [esp-4h] [ebp-2Ch]
    EXCEPTION_POINTERS* v25; // [esp-4h] [ebp-2Ch]
    EXCEPTION_POINTERS* v26; // [esp-4h] [ebp-2Ch]
    EXCEPTION_POINTERS* v27; // [esp-4h] [ebp-2Ch]
    EXCEPTION_POINTERS* v28; // [esp-4h] [ebp-2Ch]
    int sizeOrOffset; // [esp-4h] [ebp-2Ch]
    EXCEPTION_POINTERS* v30; // [esp-4h] [ebp-2Ch]
    EXCEPTION_POINTERS* v31; // [esp-4h] [ebp-2Ch]
    EXCEPTION_POINTERS* v32; // [esp-4h] [ebp-2Ch]

    pType = a4->pType;
    if (pType)
    {
        if (pType->name[0])
        {
            dispCatchObj = a4->dispCatchObj;
            if (dispCatchObj)
            {
                v7 = (char**)((char*)&a3[1] + dispCatchObj);
                if ((a4->adjectives & 8) != 0)
                {
                    v8 = a2;
                    v9 = _ValidateRead(a2->params.pExceptionObject, 1u);
                    v10 = v23;
                    if (v9)
                    {
                        v11 = _ValidateWrite(v7, 1u);
                        v10 = v24;
                        if (v11)
                        {
                            pExceptionObject = (char*)a2->params.pExceptionObject;
                            *v7 = pExceptionObject;
                            v13 = AdjustPointer(pExceptionObject, &a5->thisxDisplacement);
                        LABEL_8:
                            *v7 = v13;
                            return;
                        }
                    }
                LABEL_25:
                    sub_4A4022(v10, (int)a1, (int)v7, (int)v8);
                }
                v8 = (void*)a5;
                if ((a5->properties & 1) != 0)
                {
                    a1 = a2;
                    v14 = _ValidateRead(a2->params.pExceptionObject, 1u);
                    v10 = v25;
                    if (!v14)
                        goto LABEL_25;
                    v15 = _ValidateWrite(v7, 1u);
                    v10 = v26;
                    if (!v15)
                        goto LABEL_25;
                    memcpy_0(v7, a2->params.pExceptionObject, a5->sizeOrOffset);
                    if (a5->sizeOrOffset == 4 && *v7)
                    {
                        v13 = AdjustPointer(*v7, &a5->thisxDisplacement);
                        goto LABEL_8;
                    }
                }
                else
                {
                    a1 = a2;
                    v22 = a2->params.pExceptionObject;
                    if (a5->copyFunction)
                    {
                        v19 = _ValidateRead(v22, 1u);
                        v10 = v30;
                        if (!v19)
                            goto LABEL_25;
                        v20 = _ValidateWrite(v7, 1u);
                        v10 = v31;
                        if (!v20)
                            goto LABEL_25;
                        v21 = _ValidateExecute((FARPROC)a5->copyFunction);
                        v10 = v32;
                        if (!v21)
                            goto LABEL_25;
                        if ((a5->properties & 4) != 0)
                        {
                            AdjustPointer(a2->params.pExceptionObject, &a5->thisxDisplacement);
                            sub_4A273F((int)v7, (int)a5->copyFunction);
                        }
                        else
                        {
                            AdjustPointer(a2->params.pExceptionObject, &a5->thisxDisplacement);
                            sub_4A2738((int)v7, (int)a5->copyFunction);
                        }
                    }
                    else
                    {
                        v16 = _ValidateRead(v22, 1u);
                        v10 = v27;
                        if (!v16)
                            goto LABEL_25;
                        v17 = _ValidateWrite(v7, 1u);
                        v10 = v28;
                        if (!v17)
                            goto LABEL_25;
                        sizeOrOffset = a5->sizeOrOffset;
                        v18 = AdjustPointer(a2->params.pExceptionObject, &a5->thisxDisplacement);
                        memcpy_0(v7, v18, sizeOrOffset);
                    }
                }
            }
        }
    }
}
int __cdecl CallCatchBlock(
    struct EHExceptionRecord* a1,
    struct EHRegistrationNode* a2,
    struct _CONTEXT* a3,
    const struct _s_FuncInfo* a4,
    void* a5,
    int a6,
    unsigned int a7)
{
    int v7; // eax
    int v9; // [esp+Ch] [ebp-2Ch]
    __ehstate_t state; // [esp+10h] [ebp-28h]
    int v11; // [esp+18h] [ebp-20h]
    void* v12; // [esp+1Ch] [ebp-1Ch]

    state = a2[-1].state;
    v12 = lp;
    v11 = dword_4CB23C;
    lp = a1;
    dword_4CB23C = (int)a3;
    _CallCatchBlock2(a2, a4, a5, a6, a7);
    v9 = v7;
    a2[-1].state = state;
    lp = v12;
    dword_4CB23C = v11;
    if (a1->ExceptionCode == -529697949 && a1->NumberParameters == 3 && a1->params.magicNumber == 429065504 && v7)
    {
        //_abnormal_termination();???
        unknown_libname_34((int)a1);
    }
    return v9;
}//???
//void *__cdecl calloc(size_t Count, size_t Size)
//{
//  unsigned int v2; // esi
//  size_t v3; // ebx
//  void *v4; // edi
//  _DWORD *v5; // eax
//
//  v2 = Size * Count;
//  v3 = Size * Count;
//  if ( Size * Count <= 0xFFFFFFE0 )
//  {
//    if ( !v2 )
//      v2 = 1;
//    v2 = (v2 + 15) & 0xFFFFFFF0;
//  }
//  do
//  {
//    v4 = 0;
//    if ( v2 <= 0xFFFFFFE0 )
//    {
//      if ( v3 <= dword_4B8760 )
//      {
//        v5 = __sbh_alloc_block(v3);
//        v4 = v5;
//        if ( v5 )
//        {
//          memset(v5, 0, v3);
//          return v4;
//        }
//      }
//      v4 = HeapAlloc((HANDLE)hHeap, 8u, v2);
//      if ( v4 )
//        return v4;
//    }
//    if ( !dword_4CB3CC )
//      return v4;
//  }
//  while ( _callnewh(v2) );
//  return 0;
//}

//+
int CatchGuardHandler(
    EXCEPTION_POINTERS* a1,
    int a2,
    PEXCEPTION_RECORD ExceptionRecord,
    PVOID TargetFrame,
    struct _CONTEXT* a5)
{
    return __InternalCxxFrameHandler(
        a1,
        a2,
        ExceptionRecord,
        *((struct EHRegistrationNode**)TargetFrame + 3),
        a5,
        0,
        *((struct _s_FuncInfo**)TargetFrame + 2),
        *((_DWORD*)TargetFrame + 4),
        TargetFrame,
        0);
}
void __cdecl CatchIt(
    PEXCEPTION_RECORD ExceptionRecord,
    struct EHRegistrationNode* a2,
    struct _CONTEXT* a3,
    void* a4,
    const struct _s_FuncInfo* a5,
    const struct _s_HandlerType* a6,
    const struct _s_CatchableType* a7,
    const struct _s_TryBlockMapEntry* a8,
    int a9,
    PVOID TargetFrame)
{
    void* v10; // eax

    if (a7)
        BuildCatchObject((struct EHExceptionRecord*)a6, (struct EHExceptionRecord*)ExceptionRecord, a2, a6, a7);
    if (TargetFrame)
        _UnwindNestedFrames((struct _EXCEPTION_REGISTRATION_RECORD**)a6, TargetFrame, ExceptionRecord);
    else
        _UnwindNestedFrames((struct _EXCEPTION_REGISTRATION_RECORD**)a6, a2, ExceptionRecord);
    __FrameUnwindToState((int)a2, (int)a4, (int)a5, a8->tryLow);
    a2->state = (__ehstate_t)(a8->tryHigh + 1);//a2->state = a8->tryHigh + 1;
    v10 = (void*)CallCatchBlock((struct EHExceptionRecord*)ExceptionRecord, a2, a3, a5, a6->addressOfHandler, a9, 0x100u);
    if (v10)
        _JumpToContinuation(v10, a2);
}
void chsifnegret()
{
  ;
}
double  cintrinexit(_DWORD *a1, double result)
{
  char v2; // fps
  char v6; // al
  int v7; // ebx

  if ( dword_4CB224 )
    return result;
  dbl_4CB260 = result;
  v6 = *((_BYTE *)a1 - 144);
  if ( !v6 )
    goto checkinexact;
  if ( v6 == -1 || v6 == -2 )
  {
    if ( (HIWORD(dbl_4CB260) & 0x7FF0) == 0 )
    {
      *(_DWORD *)((char *)a1 - 142) = 4;
      //result = __FSCALE__(result, 1536.0);???????????
      if ( fabs(result) < 2.225073858507201e-308 )
        result = result * 0.0;
      goto haveerror;
    }
    if ( (HIWORD(dbl_4CB260) & 0x7FF0) == 32752 )
    {
      *(_DWORD *)((char *)a1 - 142) = 3;
      //??????result = __FSCALE__(result, -1536.0);
      //if ( fabs(result) > 1.797693134862316e308 )
      if ( fabs(result) > 1.79769313486 )
        result = result * INFINITY;
      goto haveerror;
    }
checkinexact:
    if ( (*(_WORD *)(a1 - 41) & 0x20) != 0 || (v2 & 0x20) == 0 )
      return result;
    *(_DWORD *)((char *)a1 - 142) = 8;
    goto haveerror;
  }
  *(_DWORD *)((char *)a1 - 142) = v6;
haveerror:
  v7 = *(a1 - 37) + 1;
  *(_DWORD *)((char *)a1 - 138) = v7;
  if ( !byte_4CB268 )
  {
    *(_DWORD *)((char *)a1 - 134) = a1[2];
    *(_DWORD *)((char *)a1 - 130) = a1[3];
    if ( *(_BYTE *)(v7 + 12) != 1 )
    {
      *(_DWORD *)((char *)a1 - 126) = a1[4];
      *(_DWORD *)((char *)a1 - 122) = a1[5];
    }
  }
  *(double *)((char *)a1 - 118) = result;
  _87except(*(char *)(*(a1 - 37) + 14), (int)a1 - 142, (unsigned __int16 *)a1 - 82);
  return *(double *)((char *)a1 - 118);
}
void __stdcall eh_vector_constructor_iterator(
        void *a1,
        unsigned int a2,
        int a3,
        void ( *a4)(void *),
        void ( *a5)(void *))
{
  int i; // [esp+10h] [ebp-1Ch]

  for ( i = 0; i < a3; ++i )
  {
    a4(a1);
    a1 = (char*)a1 + a2;
  }
}

int __cdecl CPtoLCID(int a1)
{
  switch ( a1 )
  {
    case 932:
      return 1041;
    case 936:
      return 2052;
    case 949:
      return 1042;
    case 950:
      return 1028;
  }
  return 0;
}
// attributes: thunk
double  ctranexit(_DWORD *a1, double result)
{
  byte_4CB268 = 0;
  return cintrinexit(a1, result);
}
void  delbuf(ios *thisx, int a2)
{
  *((_DWORD *)thisx + 7) = a2;
}
void __stdcall eh_vector_destructor_iterator(void *a1, unsigned int a2, int a3, void ( *a4)(void *))
{
  char *i; // [esp+30h] [ebp+8h]

  for ( i = (char *)a1 + a3 * a2; --a3 >= 0; a4(i) )
    i -= a2;
}
//ÏµÍ³º¯Êý
//ÏµÍ³º¯Êý
DNameNode*  DNameNode::new_DNameNode(DNameNode* thisxx)
{
	*(_DWORD*)thisxx = off_4AC2BC;
	*((_DWORD*)thisxx + 1) = 0;
	return thisxx;
}

//+
DNameNode* new_DNameNode(DNameNode* thisxx)
{
    *(_DWORD*)thisxx = off_4AC2BC;
    *((_DWORD*)thisxx + 1) = 0;
    return thisxx;
}

//DNameNode *__thiscall DNameNode::DNameNode(DNameNode *thisx)
//{
//  *(_DWORD *)this = -1;
//  *((_DWORD *)this + 1) = 0;
//  return thisx;
//}
void __cdecl doexit(UINT uExitCode, int a2, int a3)
{
  HANDLE CurrentProcess; // eax
  void (**v4)(void); // esi
  v4 = 0;
  if ( dword_4CB2B4 == 1 )
  {
    CurrentProcess = GetCurrentProcess();
    TerminateProcess(CurrentProcess, uExitCode);
  }
  dword_4CB2B0 = 1;
  byte_4CB2AC = a3;
  if ( !a2 )
  {
    if ( dword_4CC7D0 )
    {
      v4 = (void (**)(void))(dword_4CC7CC - 4);
      if ( dword_4CC7CC - 4 >= (unsigned int)dword_4CC7D0 )
      {
        do
        {
          if ( *v4 )
            (*v4)();
          --v4;
        }
        while ((int)v4 >= dword_4CC7D0 );
      }
    }
    //_initterm((void**)&dword_4B0038, (void**)&dword_4B0040);ÏÈ×¢ÊÍ
  }
  //_initterm((void**)&dword_4B0044, (void**)&dword_4B004C);
  if ( !a3 )
  {
    dword_4CB2B4 = 1;
    ExitProcess(uExitCode);
  }
}

BOOL __cdecl ExFilterRethrow(struct _EXCEPTION_POINTERS *a1)
{
  PEXCEPTION_RECORD ExceptionRecord; // eax

  ExceptionRecord = a1->ExceptionRecord;
  return a1->ExceptionRecord->ExceptionCode == -529697949
      && ExceptionRecord->NumberParameters == 3
      && ExceptionRecord->ExceptionInformation[0] == 429065504
      && !ExceptionRecord->ExceptionInformation[2];
}

//??
//void __cdecl exit(int Code)
//{
//  doexit(Code, 0, 0);
//}

void expbigret()
{
  ;
}
void __cdecl  fast_error_exit(DWORD NumberOfBytesWritten)
{
  if ( dword_4CB234 == 1 )
    _FF_MSGBANNER();
  _NMSG_WRITE(NumberOfBytesWritten);
  ExitProcess(0xFFu);
}

//int __cdecl fclose(myFILE *Stream)//Ã»ÓÃ
//{
//  int v1; // edi
//  int flag; // eax
//  int result; // eax
//
//  v1 = -1;
//  flag = Stream->_flag;
//  if ( (flag & 0x40) != 0 )
//  {
//    result = -1;
//  }
//  else
//  {
//    if ( (flag & 0x83) != 0 )
//    {
//      v1 = _flush((int*)Stream);
//      _freebuf((int)Stream);
//      if ( _close(Stream->_file) >= 0 )
//      {
//        if ( Stream->_tmpfname )
//        {
//          free((void*)Stream->_tmpfname);
//          Stream->_tmpfname = 0;
//        }
//      }
//      else
//      {
//        v1 = -1;
//      }
//    }
//    result = v1;
//  }
//  Stream->_flag = 0;
//  return result;
//}

double  fFASN(int a1, long double a2, long double a3)
{
  char v3; // cl
  double result; // st7
  char v5; // ch

  AugmentSinCos(a1, a3);
  result = atan2(a3, a2);
  if ( v5 )
    result = 3.141592653589793116 - result;
  if ( v3 )
    return -result;
  return result;
}

//int __cdecl fflush(myFILE *Stream)//Ã»ÓÃ
//{
//  if ( !Stream )
//    return flsall(0);
//  if ( _flush((_DWORD*)Stream) )
//    return -1;
//  if ( (Stream->_flag & 0x4000) != 0 )
//    return -(_commit(Stream->_file) != 0);
//  return 0;
//}

void  FindHandler(
        EXCEPTION_POINTERS *a1,
        int a2,
        int a3,
        int a4,
        PEXCEPTION_RECORD ExceptionRecord,
        struct EHRegistrationNode *a6,
        struct _CONTEXT *a7,
        void *a8,
        const struct _s_FuncInfo *a9,
        char a10,
        int a11,
        PVOID TargetFrame)
{
  PEXCEPTION_RECORD v12; // esi
  int v13; // edi
  const struct _s_TryBlockMapEntry *v14; // ebx
  int *v15; // eax
  const struct _s_CatchableType **v16; // edi
  EXCEPTION_POINTERS *v17; // [esp-10h] [ebp-28h]
  unsigned int v18; // [esp+0h] [ebp-18h] BYREF
  unsigned __int8 v19[4]; // [esp+4h] [ebp-14h]
  int state; // [esp+8h] [ebp-10h]
  int nCatches; // [esp+Ch] [ebp-Ch]
  int v22; // [esp+10h] [ebp-8h]
  unsigned int v23; // [esp+14h] [ebp-4h] BYREF
  const struct _s_HandlerType *ExceptionRecorda; // [esp+20h] [ebp+8h]

  v19[0] = 0;
  state = a6->state;
  if ( state < -1 || (a1 = (EXCEPTION_POINTERS *)a9, state >= a9->maxState) )
    sub_4A4022(a1, a2, a3, a4);
  v12 = ExceptionRecord;
  if ( ExceptionRecord->ExceptionCode != -529697949 )
    goto LABEL_35;
  if ( ExceptionRecord->NumberParameters == 3
    && ExceptionRecord->ExceptionInformation[0] == 429065504
    && !ExceptionRecord->ExceptionInformation[2] )
  {
    v12 = (PEXCEPTION_RECORD)lp;
    if ( !lp )
      return;
    a7 = (struct _CONTEXT *)dword_4CB23C;
    v19[0] = 1;
    if ( !_ValidateRead(lp, 1u) )
      sub_4A4022(v17, -529697949, 429065504, (int)v12);
    if ( v12->ExceptionCode != -529697949 )
      goto LABEL_35;
    if ( v12->NumberParameters == 3 && v12->ExceptionInformation[0] == 429065504 && !v12->ExceptionInformation[2] )
      sub_4A4022(v17, -529697949, 429065504, (int)v12);
  }
  if ( v12->ExceptionCode != -529697949 || v12->NumberParameters != 3 || v12->ExceptionInformation[0] != 429065504 )
  {
LABEL_35:
    if ( a10 )
      sub_4A3FCC();
    FindHandlerForForeignException(v12, a6, a7, a8, a9, state, a11, TargetFrame);
    return;
  }
  v13 = state;
  v14 = (_s_TryBlockMapEntry*)_GetRangeOfTrysToCheck(a9, a11, state, &v23, &v18);
  while ( v23 < v18 )
  {
    if ( v14->tryLow <= v13 && v13 <= v14->tryHigh )
    {
      ExceptionRecorda = (_s_HandlerType*)v14->pHandlerArray;
      nCatches = v14->nCatches;
      if ( nCatches > 0 )
      {
        while ( 1 )
        {
          v15 = *(int **)(v12->ExceptionInformation[2] + 12);
          v16 = (const struct _s_CatchableType **)(v15 + 1);
          v22 = *v15;
          if ( v22 > 0 )
            break;
LABEL_27:
          --nCatches;
          ++ExceptionRecorda;
          if ( nCatches <= 0 )
            goto LABEL_30;
        }
        while ( !TypeMatch(ExceptionRecorda, *v16, (const struct _s_ThrowInfo *)v12->ExceptionInformation[2]) )
        {
          --v22;
          ++v16;
          if ( v22 <= 0 )
            goto LABEL_27;
        }
        CatchIt(v12, a6, a7, a8, a9, ExceptionRecorda, *v16, v14, a11, TargetFrame);
      }
LABEL_30:
      v13 = state;
    }
    ++v23;
    ++v14;
  }
  if ( a10 )
    unknown_libname_34((int)v12);
}
void __cdecl FindHandlerForForeignException(
        PEXCEPTION_RECORD ExceptionRecord,
        struct EHRegistrationNode *a2,
        struct _CONTEXT *a3,
        void *a4,
        const struct _s_FuncInfo *a5,
        int a6,
        int a7,
        PVOID TargetFrame)
{
  const struct _s_TryBlockMapEntry *v8; // esi
  int v9; // eax
  int v10; // ecx
  unsigned int v11; // [esp+8h] [ebp-8h] BYREF
  unsigned int v12; // [esp+Ch] [ebp-4h] BYREF

  if ( !dword_4CB240
    || !_CallSETranslator(
          (struct EHExceptionRecord *)ExceptionRecord,
          a2,
          a3,
          a4,
          a5,
          a7,
          (struct EHRegistrationNode *)TargetFrame) )
  {
    v8 = (_s_TryBlockMapEntry*)_GetRangeOfTrysToCheck(a5, a7, a6, &v12, &v11);
    while ( v12 < v11 )
    {
      if ( a6 >= v8->tryLow && a6 <= v8->tryHigh )
      {
        v9 = (int)&v8->pHandlerArray[v8->nCatches];
        v10 = *(_DWORD *)(v9 - 12);
        if ( !v10 || !*(_BYTE *)(v10 + 8) )
          CatchIt(ExceptionRecord, a2, a3, a4, a5, (const struct _s_HandlerType *)(v9 - 16), 0, v8, a7, TargetFrame);
      }
      ++v12;
      ++v8;
    }
  }
}

//int __cdecl flsall(int a1)//Ã»ÓÃ
//{
//  signed int v1; // esi
//  int v2; // ebx
//  int i; // edi
//  myFILE *v4; // eax
//  int flag; // ecx
//  int result; // eax
//
//  v1 = 0;
//  v2 = 0;
//  for ( i = 0; v1 < (int)Count; ++v1 )
//  {
//    v4 = *(myFILE **)(dword_4CB688 + 4 * v1);
//    if ( v4 )
//    {
//      flag = v4->_flag;
//      if ( (flag & 0x83) != 0 )
//      {
//        if ( a1 == 1 )
//        {
//          if ( fflush(v4) != -1 )
//            ++v2;
//        }
//        else if ( !a1 && (flag & 2) != 0 && fflush(*(myFILE **)(dword_4CB688 + 4 * v1)) == -1 )
//        {
//          i = -1;
//        }
//      }
//    }
//  }
//  result = v2;
//  if ( a1 != 1 )
//    return i;
//  return result;
//}

//???
//void __cdecl free(void *Block)
//{
//  char *v1; // eax
//
//  if ( Block )
//  {
//    v1 = __sbh_find_block((int)Block);
//    if ( v1 )
//      __sbh_free_block((_DWORD*)v1, (unsigned int)Block);
//    else
//      HeapFree(hHeap, 0, Block);
//  }
//}
//struct _TaskCollectionBase* Concurrency::details::ContextBase::GetExecutingCollection(
//    Concurrency::details::ContextBase* thisxx)
//{
//    return (struct _TaskCollectionBase*)*((_DWORD*)thisxx + 13);
//}
//struct Concurrency::IExecutionContext*  Concurrency::details::VirtualProcessor::GetExecutingContext(
//    Concurrency::details::VirtualProcessor* thisxx)
//{
//    return (struct Concurrency::IExecutionContext*)*((_DWORD*)thisxx + 31);
//}
//struct Concurrency::details::UMSThreadProxy*  Concurrency::details::UMSFreeVirtualProcessorRoot::GetExecutingProxy(
//    Concurrency::details::UMSFreeVirtualProcessorRoot* thisxx)
//{
//    return (struct Concurrency::details::UMSThreadProxy*)*((_DWORD*)thisxx + 26);
//}
//unsigned int  Concurrency::details::VirtualProcessor::GetExecutionResourceId(
//    Concurrency::details::VirtualProcessor* thisxx)
//{
//    return *((_DWORD*)thisxx + 32);
//}
//unsigned __int16  GetGroup(
//    Concurrency::details::HardwareAffinity* thisxx)
//{
//    return *((_WORD*)thisxx + 2);
//}
//unsigned int Concurrency::details::VirtualProcessor::GetId(Concurrency::details::VirtualProcessor* thisxx)
//{
//	return *((_DWORD*)thisxx + 34);
//}
//unsigned int  Concurrency::details::ExecutionResource::GetNodeId(
//    Concurrency::details::ExecutionResource* thisxx)
//{
//    return *((_DWORD*)thisxx + 9);
//}
//
//unsigned int Concurrency::details::SchedulerBase::GetNumberOfBoundContexts(
//    Concurrency::details::SchedulerBase* thisxx)
//{
//    return *((_DWORD*)thisxx + 100);
//}
//unsigned int Concurrency::details::SchedulerProxy::GetNumBorrowedCores(
//    Concurrency::details::SchedulerProxy* thisxx)
//{
//    return *((_DWORD*)thisxx + 42);
//}
//unsigned int Concurrency::details::SchedulerProxy::GetNumExternalThreads(
//    Concurrency::details::SchedulerProxy* thisxx)
//{
//    return *((_DWORD*)thisxx + 45);
//}
//unsigned int  Concurrency::details::SchedulerProxy::GetQueueLength(
//    Concurrency::details::SchedulerProxy* thisxx)
//{
//    return *((_DWORD*)thisxx + 30);
//}
//struct Concurrency::ISchedulerProxy* Concurrency::details::SchedulerBase::GetSchedulerProxy(
//    Concurrency::details::SchedulerBase* thisxx)
//{
//    return (struct Concurrency::ISchedulerProxy*)*((_DWORD*)thisxx + 107);
//}
UINT __cdecl getSystemCP(UINT a1)
{
  UINT result; // eax

  result = a1;
  dword_4CB410 = 0;
  switch ( a1 )
  {
    case 0xFFFFFFFE:
      dword_4CB410 = 1;
      return GetOEMCP();
    case 0xFFFFFFFD:
      dword_4CB410 = 1;
      return GetACP();
    case 0xFFFFFFFC:
      result = CodePage;
      dword_4CB410 = 1;
      break;
  }
  return result;
}
__int64 __cdecl get_int64_arg(_DWORD *a1)
{
  *a1 += 8;
  return *(_QWORD *)(*a1 - 8);
}
int __cdecl get_int_arg(_DWORD *a1)
{
  *a1 += 4;
  return *(_DWORD *)(*a1 - 4);
}
__int16 __cdecl get_short_arg(_DWORD *a1)
{
  *a1 += 4;
  return *(_WORD *)(*a1 - 4);
}
int __fastcall hard(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return a1 * a3;
}
//unsigned int Id(Concurrency::details::SchedulerBase* thisxx)
//{
//	return *((_DWORD*)thisxx + 93);
//}
void  isintTOS(double a1)
{
  _ST6 = a1;
  __asm { frndint }
  if ( _ST6 == a1 )
  {
    _ST5 = a1 * (*(dbl*)dbl_4B83E2);//Ô­À´    a1 * dbl_4B83E2
    __asm { frndint }
  }
  isintTOSret();
}
void isintTOSret()
{
  ;
}
//???
//void *__cdecl malloc(size_t Size)
//{
//  return _nh_malloc(Size, dword_4CB3CC);
//}
char MarkedForDetachment(
    _BYTE* thisxx)
{
    return thisxx[20];
}
//void* __cdecl memcpy(void* a1, const void* Src, size_t Size)
//{
//    char* v3; // esi
//    char* v4; // edi
//    size_t v5; // ecx
//    void* result; // eax
//    char* v7; // esi
//    char* v8; // edi
//    size_t v9; // ecx
//
//    v3 = (char*)Src;
//    v4 = (char*)a1;
//    if (a1 > Src && a1 < (char*)Src + Size)
//    {
//        v7 = (char*)Src + Size - 4;
//        v8 = (char*)a1 + Size - 4;
//        if (((unsigned __int8)v8 & 3) == 0)
//        {
//            v9 = Size >> 2;
//            if (Size >> 2 >= 8)
//            {
//                while (v9)
//                {
//                    *(_DWORD*)v8 = *(_DWORD*)v7;
//                    v7 -= 4;
//                    v8 -= 4;
//                    --v9;
//                }
//                switch (Size & 3)
//                {
//                case 0u:
//                    goto TrailDown0;
//                case 1u:
//                    goto TrailDown1;
//                case 2u:
//                    goto TrailDown2;
//                case 3u:
//                    goto TrailDown3;
//                }
//            }
//            switch (Size & 3)
//            {
//            case 0u:
//                goto TrailDown0;
//            case 1u:
//                goto TrailDown1;
//            case 2u:
//                goto TrailDown2;
//            case 3u:
//                goto TrailDown3;
//            }
//        }
//        switch (Size)
//        {
//        case 0u:
//        TrailDown0:
//            result = a1;
//            break;
//        case 1u:
//        TrailDown1:
//            v8[3] = v7[3];
//            result = a1;
//            break;
//        case 2u:
//        TrailDown2:
//            v8[3] = v7[3];
//            v8[2] = v7[2];
//            result = a1;
//            break;
//        case 3u:
//        TrailDown3:
//            v8[3] = v7[3];
//            v8[2] = v7[2];
//            v8[1] = v7[1];
//            result = a1;
//            break;
//        default:
//            __asm { jmp     dword ptr ds : loc_4A2D64 + 4[eax * 4] }
//            return result;
//        }
//    }
//    else
//    {
//        if (((unsigned __int8)a1 & 3) != 0)
//        {
//            if (Size >= 4)
//                __asm { jmp     dword ptr ds : loc_4A2BDC + 4[eax * 4] }
//            __asm { jmp     dword ptr ds : TrailUp0[ecx * 4]; jumptable 004A2BB5 case 0 }
//        }
//        v5 = Size >> 2;
//        switch (v5)
//        {
//        case 0u:
//            goto UnwindUp0;
//        case 1u:
//            goto UnwindUp1;
//        case 2u:
//            goto UnwindUp2;
//        case 3u:
//            goto UnwindUp3;
//        case 4u:
//            goto UnwindUp4;
//        case 5u:
//            goto UnwindUp5;
//        case 6u:
//            goto UnwindUp6;
//        case 7u:
//            *((_DWORD*)a1 + v5 - 7) = *((_DWORD*)Src + v5 - 7);
//        UnwindUp6:
//            *((_DWORD*)a1 + v5 - 6) = *((_DWORD*)Src + v5 - 6);
//        UnwindUp5:
//            *((_DWORD*)a1 + v5 - 5) = *((_DWORD*)Src + v5 - 5);
//        UnwindUp4:
//            *((_DWORD*)a1 + v5 - 4) = *((_DWORD*)Src + v5 - 4);
//        UnwindUp3:
//            *((_DWORD*)a1 + v5 - 3) = *((_DWORD*)Src + v5 - 3);
//        UnwindUp2:
//            *((_DWORD*)a1 + v5 - 2) = *((_DWORD*)Src + v5 - 2);
//        UnwindUp1:
//            *((_DWORD*)a1 + v5 - 1) = *((_DWORD*)Src + v5 - 1);
//            v3 = (char*)Src + 4 * v5;
//            v4 = (char*)a1 + 4 * v5;
//        UnwindUp0:
//            switch (Size & 3)
//            {
//            case 0u:
//                goto TrailUp0;
//            case 1u:
//                goto TrailUp1;
//            case 2u:
//                goto TrailUp2;
//            case 3u:
//                goto TrailUp3;
//            }
//        default:
//            qmemcpy(a1, Src, 4 * v5);
//            v3 = (char*)Src + 4 * v5;
//            v4 = (char*)a1 + 4 * v5;
//            switch (Size & 3)
//            {
//            case 0u:
//            TrailUp0:
//                result = a1;
//                break;
//            case 1u:
//            TrailUp1:
//                *v4 = *v3;
//                result = a1;
//                break;
//            case 2u:
//            TrailUp2:
//                *v4 = *v3;
//                v4[1] = v3[1];
//                result = a1;
//                break;
//            case 3u:
//            TrailUp3:
//                *v4 = *v3;
//                v4[1] = v3[1];
//                v4[2] = v3[2];
//                result = a1;
//                break;
//            }
//            break;
//        }
//    }
//    return result;
//}
void* __cdecl memcpy_0(void* a1, const void* Src, size_t Size)
{
    //char* v3; // esi
    //char* v4; // edi
    //size_t v5; // ecx
    //void* result; // eax
    //char* v7; // esi
    //char* v8; // edi
    //size_t v9; // ecx

    //v3 = (char*)Src;
    //v4 = (char*)a1;
    //if (a1 > Src && a1 < (char*)Src + Size)
    //{
    //    v7 = (char*)Src + Size - 4;
    //    v8 = (char*)a1 + Size - 4;
    //    if (((unsigned __int8)v8 & 3) == 0)
    //    {
    //        v9 = Size >> 2;
    //        if (Size >> 2 >= 8)
    //        {
    //            while (v9)
    //            {
    //                *(_DWORD*)v8 = *(_DWORD*)v7;
    //                v7 -= 4;
    //                v8 -= 4;
    //                --v9;
    //            }
    //            switch (Size & 3)
    //            {
    //            case 0u:
    //                goto TrailDown0_0;
    //            case 1u:
    //                goto TrailDown1_0;
    //            case 2u:
    //                goto TrailDown2_0;
    //            case 3u:
    //                goto TrailDown3_0;
    //            }
    //        }
    //        switch (Size & 3)
    //        {
    //        case 0u:
    //            goto TrailDown0_0;
    //        case 1u:
    //            goto TrailDown1_0;
    //        case 2u:
    //            goto TrailDown2_0;
    //        case 3u:
    //            goto TrailDown3_0;
    //        }
    //    }
    //    switch (Size)
    //    {
    //    case 0u:
    //    TrailDown0_0:
    //        result = a1;
    //        break;
    //    case 1u:
    //    TrailDown1_0:
    //        v8[3] = v7[3];
    //        result = a1;
    //        break;
    //    case 2u:
    //    TrailDown2_0:
    //        v8[3] = v7[3];
    //        v8[2] = v7[2];
    //        result = a1;
    //        break;
    //    case 3u:
    //    TrailDown3_0:
    //        v8[3] = v7[3];
    //        v8[2] = v7[2];
    //        v8[1] = v7[1];
    //        result = a1;
    //        break;
    //    default:
    //        __asm { jmp     dword ptr ds : loc_4A6844 + 4[eax * 4] }
    //        return result;
    //    }
    //}
    //else
    //{
    //    if (((unsigned __int8)a1 & 3) != 0)
    //    {
    //        if (Size >= 4)
    //            __asm { jmp     dword ptr ds : loc_4A66BC + 4[eax * 4] }
    //        __asm { jmp     dword ptr ds : TrailUp0_0[ecx * 4]; jumptable 004A6695 case 0 }
    //    }
    //    v5 = Size >> 2;
    //    switch (v5)
    //    {
    //    case 0u:
    //        goto UnwindUp0_0;
    //    case 1u:
    //        goto UnwindUp1_0;
    //    case 2u:
    //        goto UnwindUp2_0;
    //    case 3u:
    //        goto UnwindUp3_0;
    //    case 4u:
    //        goto UnwindUp4_0;
    //    case 5u:
    //        goto UnwindUp5_0;
    //    case 6u:
    //        goto UnwindUp6_0;
    //    case 7u:
    //        *((_DWORD*)a1 + v5 - 7) = *((_DWORD*)Src + v5 - 7);
    //    UnwindUp6_0:
    //        *((_DWORD*)a1 + v5 - 6) = *((_DWORD*)Src + v5 - 6);
    //    UnwindUp5_0:
    //        *((_DWORD*)a1 + v5 - 5) = *((_DWORD*)Src + v5 - 5);
    //    UnwindUp4_0:
    //        *((_DWORD*)a1 + v5 - 4) = *((_DWORD*)Src + v5 - 4);
    //    UnwindUp3_0:
    //        *((_DWORD*)a1 + v5 - 3) = *((_DWORD*)Src + v5 - 3);
    //    UnwindUp2_0:
    //        *((_DWORD*)a1 + v5 - 2) = *((_DWORD*)Src + v5 - 2);
    //    UnwindUp1_0:
    //        *((_DWORD*)a1 + v5 - 1) = *((_DWORD*)Src + v5 - 1);
    //        v3 = (char*)Src + 4 * v5;
    //        v4 = (char*)a1 + 4 * v5;
    //    UnwindUp0_0:
    //        switch (Size & 3)
    //        {
    //        case 0u:
    //            goto TrailUp0_0;
    //        case 1u:
    //            goto TrailUp1_0;
    //        case 2u:
    //            goto TrailUp2_0;
    //        case 3u:
    //            goto TrailUp3_0;
    //        }
    //    default:
    //        qmemcpy(a1, Src, 4 * v5);
    //        v3 = (char*)Src + 4 * v5;
    //        v4 = (char*)a1 + 4 * v5;
    //        switch (Size & 3)
    //        {
    //        case 0u:
    //        TrailUp0_0:
    //            result = a1;
    //            break;
    //        case 1u:
    //        TrailUp1_0:
    //            *v4 = *v3;
    //            result = a1;
    //            break;
    //        case 2u:
    //        TrailUp2_0:
    //            *v4 = *v3;
    //            v4[1] = v3[1];
    //            result = a1;
    //            break;
    //        case 3u:
    //        TrailUp3_0:
    //            *v4 = *v3;
    //            v4[1] = v3[1];
    //            v4[2] = v3[2];
    //            result = a1;
    //            break;
    //        }
    //        break;
    //    }
    //}
    //return result;???????????
return {};
}
//
//void *__cdecl memset(void *a1, int Val, size_t Size)
//{
//  size_t v3; // edx
//  int v4; // eax
//  _BYTE *v5; // edi
//  int v6; // ecx
//  size_t v7; // ecx
//  unsigned int v8; // ecx
//
//  v3 = Size;
//  if ( !Size )
//    return a1;
//  LOBYTE(v4) = Val;
//  v5 = a1;
//  if ( Size < 4 )
//    goto LABEL_13;
//  v6 = -(int)a1 & 3;
//  if ( v6 )
//  {
//    v3 = Size - v6;
//    do
//    {
//      *v5++ = Val;
//      --v6;
//    }
//    while ( v6 );
//  }
//  v4 = 16843009 * (unsigned __int8)Val;
//  v7 = v3;
//  v3 &= 3u;
//  v8 = v7 >> 2;
//  if ( !v8 || (memset32(v5, v4, v8), v5 += 4 * v8, v3) )
//  {
//LABEL_13:
//    do
//    {
//      *v5++ = v4;
//      --v3;
//    }
//    while ( v3 );
//  }
//  return a1;
//}
void noerror()
{
  ;
}
void nullsub_1()
{
  ;
}
void __cdecl operator delete(void *Block)
{
  free(Block);
}
void *__cdecl operator new(size_t Size)
{
  return _nh_malloc(Size, 1);
  void* res = malloc(Size);
  memset(res,0,Size);
  return res;
}
_DWORD *__cdecl parse_cmdline(unsigned __int8 *a1, unsigned __int8 **a2, unsigned __int8 *a3, _DWORD *a4, _DWORD *a5)
{
  unsigned __int8 *v6; // esi
  unsigned __int8 **v7; // edi
  unsigned __int8 *v8; // eax
  unsigned __int8 v9; // dl
  unsigned __int8 v10; // dl
  unsigned int v11; // ebx
  unsigned int v12; // edx
  unsigned int v13; // ebx
  unsigned int v14; // ebx
  unsigned __int8 v15; // dl
  _DWORD *result; // eax
  int v17; // [esp+14h] [ebp+8h]
  BOOL v18; // [esp+24h] [ebp+18h]

  *a5 = 0;
  v6 = a3;
  v7 = a2;
  *a4 = 1;
  v8 = a1;
  if ( a2 )
  {
    *a2 = a3;
    v7 = ++a2;
  }
  if ( *a1 == 34 )
  {
    while ( 1 )
    {
      v9 = *++v8;
      if ( v9 == 34 || !v9 )
        break;
      if ( (byte_4CB581[v9] & 4) != 0 )
      {
        ++*a5;
        if ( v6 )
          *v6++ = *v8++;
      }
      ++*a5;
      if ( v6 )
        *v6++ = *v8;
    }
    ++*a5;
    if ( v6 )
      *v6++ = 0;
    if ( *v8 == 34 )
      ++v8;
  }
  else
  {
    do
    {
      ++*a5;
      if ( v6 )
        *v6++ = *v8;
      v10 = *v8++;
      if ( (byte_4CB581[v10] & 4) != 0 )
      {
        ++*a5;
        if ( v6 )
          *v6++ = *v8;
        ++v8;
      }
      if ( v10 == 32 )
        break;
      if ( !v10 )
      {
        --v8;
        goto LABEL_28;
      }
    }
    while ( v10 != 9 );
    if ( v6 )
      *(v6 - 1) = 0;
  }
LABEL_28:
  v18 = 0;
  while ( *v8 )
  {
    while ( *v8 == 32 || *v8 == 9 )
      ++v8;
    if ( !*v8 )
      break;
    if ( v7 )
    {
      *v7++ = v6;
      a2 = v7;
    }
    ++*a4;
    while ( 1 )
    {
      v17 = 1;
      v11 = 0;
      while ( *v8 == 92 )
      {
        ++v8;
        ++v11;
      }
      if ( *v8 == 34 )
      {
        if ( (v11 & 1) == 0 )
        {
          if ( v18 && v8[1] == 34 )
            ++v8;
          else
            v17 = 0;
          v7 = a2;
          v18 = !v18;
        }
        v11 >>= 1;
      }
      v12 = v11;
      v13 = v11 - 1;
      if ( v12 )
      {
        v14 = v13 + 1;
        do
        {
          if ( v6 )
            *v6++ = 92;
          ++*a5;
          --v14;
        }
        while ( v14 );
      }
      v15 = *v8;
      if ( !*v8 || !v18 && (v15 == 32 || v15 == 9) )
        break;
      if ( v17 )
      {
        if ( v6 )
        {
          if ( (byte_4CB581[v15] & 4) != 0 )
          {
            *v6++ = v15;
            ++v8;
            ++*a5;
          }
          *v6++ = *v8;
        }
        else if ( (byte_4CB581[v15] & 4) != 0 )
        {
          ++v8;
          ++*a5;
        }
        ++*a5;
      }
      ++v8;
    }
    if ( v6 )
      *v6++ = 0;
    ++*a5;
  }
  if ( v7 )
    *v7 = 0;
  result = a4;
  ++*a4;
  return result;
}
void postv()
{
  ;
}
int __cdecl raise(int Signal)
{
  int v1; // edi
  void (__cdecl *v3)(int); // esi
  int *v4; // eax
  int v5; // eax
  int v6; // ebx
  int v7; // edx
  int v8; // ecx
  _DWORD *v9; // edx

  v1 = Signal;
  switch ( Signal )
  {
    case 2:
      v3 = (void (__cdecl *)(int))dword_4CB420;
      v4 = &dword_4CB420;
      break;
    case 4:
    case 8:
    case 11:
      v5 = (_DWORD)siglookup(Signal);
      v3 = *(void (__cdecl **)(int))(v5 + 8);
      v4 = (int *)(v5 + 8);
      break;
    case 15:
      v3 = (void (__cdecl *)(int))dword_4CB42C;
      v4 = &dword_4CB42C;
      break;
    case 21:
      v3 = (void (__cdecl *)(int))dword_4CB424;
      v4 = &dword_4CB424;
      break;
    case 22:
      v3 = (void (__cdecl *)(int))dword_4CB428;
      v4 = &dword_4CB428;
      break;
    default:
      return -1;
  }
  if ( v3 == (void (__cdecl *)(int))1 )
    return 0;
  if ( !v3 )
    _exit(3);
  if ( Signal == 8 || Signal == 11 || Signal == 4 )
  {
    v6 = dword_4CB2B8;
    dword_4CB2B8 = 0;
    if ( Signal != 8 )
    {
LABEL_29:
      *v4 = 0;
      v3(v1);
      if ( v1 != 11 && v1 != 4 )
        return 0;
      goto LABEL_33;
    }
    v7 = (_DWORD)dword_4B86BC;
    //dword_4B86BC = 140;????
    Signal = v7;
  }
  else
  {
    v6 = Signal;
  }
  if ( v1 != 8 )
    goto LABEL_29;
  if ( dword_4B86B0 < dword_4B86B0 + dword_4B86B4 )
  {
    v8 = dword_4B86B4;
    v9 = (_DWORD *)(12 * dword_4B86B0 + 4949568);
    do
    {
      *v9 = 0;
      v9 += 3;
      --v8;
    }
    while ( v8 );
  }
  ((void (__cdecl *)(int, int))v3)(8, (_DWORD)dword_4B86BC);
LABEL_33:
  dword_4CB2B8 = v6;
  if ( v1 == 8 )
    //dword_4B86BC = Signal;??????????/
  return 0;
}//???
//int __cdecl rand()
//{
//  dword_4B82A0 = 214013 * dword_4B82A0 + 2531011;
//  return (dword_4B82A0 >> 16) & 0x7FFF;
//}// ???
//void *__cdecl realloc(void *Block, size_t Size)
//{
//  size_t v3; // esi
//  void *v4; // edi
//  char *v5; // eax
//  char *v6; // ebp
//  size_t v7; // eax
//  size_t v8; // eax
//
//  if ( !Block )
//    return malloc(Size);
//  v3 = Size;
//  if ( !Size )
//  {
//    free(Block);
//    return 0;
//  }
//  while ( 1 )
//  {
//    v4 = 0;
//    if ( v3 > 0xFFFFFFE0 )
//      goto LABEL_26;
//    v5 = __sbh_find_block((int)Block);
//    v6 = v5;
//    if ( !v5 )
//    {
//      if ( !v3 )
//        v3 = 1;
//      v3 = (v3 + 15) & 0xFFFFFFF0;
//      v4 = HeapReAlloc(hHeap, 0, Block, v3);
//      goto LABEL_25;
//    }
//    if ( v3 <= dword_4B8760 )
//    {
//      if ( __sbh_resize_block((_DWORD*)v5, (int)Block, v3) )
//        return Block;
//      v4 = __sbh_alloc_block(v3);
//      if ( v4 )
//        break;
//    }
//    if ( !v3 )
//      v3 = 1;
//    v3 = (v3 + 15) & 0xFFFFFFF0;
//    v4 = HeapAlloc(hHeap, 0, v3);
//    if ( !v4 )
//      goto LABEL_26;
//    v8 = *((_DWORD *)Block - 1) - 1;
//    if ( v8 >= v3 )
//      v8 = v3;
//    memcpy(v4, Block, v8);
//    __sbh_free_block((_DWORD*)v6, (unsigned int)Block);
//LABEL_25:
//    if ( v4 )
//      return v4;
//LABEL_26:
//    if ( !dword_4CB3CC )
//      return v4;
//    if ( !_callnewh(v3) )
//      return 0;
//  }
//  v7 = *((_DWORD *)Block - 1) - 1;
//  if ( v7 >= v3 )
//    v7 = v3;
//  memcpy(v4, Block, v7);
//  __sbh_free_block((_DWORD*)v6, (unsigned int)Block);
//  return v4;
//}
//ÏµÍ³º¯Êý
//void  Concurrency::details::UMSThreadScheduler::SetCompletionList(
//    Concurrency::details::UMSThreadScheduler* thisxx,
//    struct Concurrency::IUMSCompletionList* a2)
//{
//    *((_DWORD*)thisxx + 130) = (int)a2;
//}
//void  Concurrency::details::InternalContextBase::SetOversubscribedVProc(
//    Concurrency::details::InternalContextBase* thisxx,
//    struct Concurrency::details::VirtualProcessor* a2)
//{
//    *((_DWORD*)thisxx + 41) =(int) a2;
//}
//void  Concurrency::details::SchedulingRing::SetOwningNode(
//    Concurrency::details::SchedulingRing* thisxx,
//    struct Concurrency::details::SchedulingNode* a2)
//{
//    *((_DWORD*)thisxx + 1) = (int)a2;//*((_DWORD*)thisxx + 1) = a2;//
//}
int setSBCS()
{
  int result; // eax

  memset(&unk_4CB580, 0, 0x100u);
  *((_BYTE *)&unk_4CB580 + 256) = 0;
  result = 0;
  dword_4CB458 = 0;
  dword_4CB46C = 0;
  Locale = 0;
  dword_4CB460[0] = 0;
  dword_4CB460[1] = 0;
  dword_4CB460[2] = 0;
  return result;
}
unsigned int setSBUpLow()
{
  unsigned int i; // eax
  BYTE v1; // al
  BYTE *v2; // edx
  //unsigned char *v2; // edx
  unsigned int v3; // ecx
  unsigned int result; // eax
  WORD *j; // ecx
  char v6; // dl
  char v7; // cl
  WORD CharType[256]; // [esp+4h] [ebp-514h] BYREF
  CHAR v9[256]; // [esp+204h] [ebp-314h] BYREF
  CHAR DestStr[256]; // [esp+304h] [ebp-214h] BYREF
  CHAR SrcStr[256]; // [esp+404h] [ebp-114h] BYREF
  struct _cpinfo CPInfo; // [esp+504h] [ebp-14h] BYREF

  if ( GetCPInfo(dword_4CB458, &CPInfo) )
  {
    for ( i = 0; i < 0x100; ++i )
      SrcStr[i] = i;
    v1 = CPInfo.LeadByte[0];
    SrcStr[0] = 32;
    if ( CPInfo.LeadByte[0] )
    {
      v2 = &CPInfo.LeadByte[1];
      do
      {
        v3 = *v2;
        if ( v1 <= v3 )
          memset(&SrcStr[v1], 0x20u, v3 - v1 + 1);
        v2 += 2;
        v1 = *(v2 - 1);
      }
      while ( v1 );
    }
    __crtGetStringTypeA(1u, SrcStr, 256, (LPWORD)CharType, dword_4CB458, Locale, 0);
    __crtLCMapStringA(Locale, 0x100u, SrcStr, 256, DestStr, 256, dword_4CB458, 0);
    __crtLCMapStringA(Locale, 0x200u, SrcStr, 256, v9, 256, dword_4CB458, 0);
    result = 0;
    for ( j = CharType; ; ++j )
    {
      if ( (*j & 1) != 0 )
      {
        byte_4CB581[result] |= 0x10u;
        v6 = DestStr[result];
      }
      else
      {
        if ( (*j & 2) == 0 )
        {
          byte_4CB480[result] = 0;
          goto LABEL_16;
        }
        byte_4CB581[result] |= 0x20u;
        v6 = v9[result];
      }
      byte_4CB480[result] = v6;
LABEL_16:
      if ( ++result >= 0x100 )
        return result;
    }
  }
  for ( result = 0; result < 0x100; ++result )
  {
    if ( result >= 0x41 && result <= 0x5A )
    {
      byte_4CB581[result] |= 0x10u;
      v7 = result + 32;
LABEL_22:
      byte_4CB480[result] = v7;
      continue;
    }
    if ( result >= 0x61 && result <= 0x7A )
    {
      byte_4CB581[result] |= 0x20u;
      v7 = result - 32;
      goto LABEL_22;
    }
    byte_4CB480[result] = 0;
  }
  return result;
}
int *__cdecl siglookup(int a1)
{
  int *result; // eax

  result = &dword_4B8638;
  if ( *(int*)dword_4B863C != a1 )//Ô­À´ dword_4B863C
  {
    do
      result += 3;
    while ( (unsigned int)result < 12 * (int)dword_4B86B8 + 4949560 && result[1] != a1 );
  }
  if ( (unsigned int)result >= 12 * (int)dword_4B86B8 + 4949560 || result[1] != a1 )
    return 0;
  return result;
}
//
//int sprintf(char *const Buffer, const char *const Format, ...)
//{
//  int v2; // eax
//  bool v3; // sf
//  int v4; // esi
//  myFILE File; // [esp+4h] [ebp-20h] BYREF
//  va_list va; // [esp+34h] [ebp+10h] BYREF
//
//  va_start(va, Format);
//  File._base = (_DWORD)Buffer;
//  File._ptr = (_DWORD*)Buffer;
//  File._flag = 66;
//  File._cnt = 0x7FFFFFFF;
//  v2 = _output(&File, (int)Format, (int)va);
//  v3 = --File._cnt < 0;
//  v4 = v2;
//  if ( v3 )
//    _flsbuf(0, &File);
//  else
//    *File._ptr = 0;
//  return v4;
//}
void  start()
{
  //DWORD Version; // eax
  int wShowWindow; // eax
  HMODULE ModuleHandleA; // eax
  int v3; // [esp-4h] [ebp-78h]
  CHAR *lpCmdLine; // [esp+10h] [ebp-64h]
  int v5; // [esp+14h] [ebp-60h]
  struct _STARTUPINFOA StartupInfo; // [esp+18h] [ebp-5Ch] BYREF
  //CPPEH_RECORD ms_exc; // [esp+5Ch] [ebp-18h]

  //Version = GetVersion();//»ñÈ¡ÏµÍ³°æ±¾
  ////ÏµÍ³°æ±¾ÐÅÏ¢°ÕÁË
  //dword_4CB284 = BYTE1(Version);//
  //dword_4CB280 = (unsigned __int8)Version;
  //dword_4CB27C = BYTE1(Version) + ((unsigned __int8)Version << 8);
  //dword_4CB278 = HIWORD(Version);

  //if ( !_heap_init(0) )
  //  fast_error_exit(0x1Cu);
  //ms_exc.registration.TryLevel = 0;
  //_ioinit();
  //dword_4CC7D4 = (int)GetCommandLineA();
  //Block = __crtGetEnvironmentStringsA();
  ////Block = GetEnvironmentStringsW();
  //_setargv();
  //_setenvp();
  //_cinit();
  //StartupInfo.dwFlags = 0;
  GetStartupInfoA(&StartupInfo);
  //lpCmdLine = _wincmdln();
  if ( (StartupInfo.dwFlags & 1) != 0 )
    wShowWindow = StartupInfo.wShowWindow;
  else
    wShowWindow = 10;
  v3 = wShowWindow;
  ModuleHandleA = GetModuleHandleA(0);
  v5 = WinMain(ModuleHandleA, 0, lpCmdLine, v3);
  exit(v5);
}

DWORD __stdcall StartAddress(LPVOID lpThreadParameter)
{
  return sub_440A5D((_DWORD)lpThreadParameter);
}
char *__cdecl strcat(char *Destination, const char *Source)
{
  char *v2; // ecx
  int v4; // eax
  int v5; // eax
  char *v6; // edi
  const char *v7; // ecx
  int v8; // edx
  int v9; // eax
  char *result; // eax

  v2 = Destination;
  if ( ((unsigned __int8)Destination & 3) == 0 )
    goto find_end_of_dest_string_loop;
  do
  {
    if ( !*v2++ )
    {
start_byte_3:
      v6 = v2 - 1;
      goto copy_start;
    }
  }
  while ( ((unsigned __int8)v2 & 3) != 0 );
  while ( 1 )
  {
    do
    {
find_end_of_dest_string_loop:
      v4 = (*(_DWORD *)v2 + 2130640639) ^ ~*(_DWORD *)v2;
      v2 += 4;
    }
    while ( (v4 & 0x81010100) == 0 );
    v5 = *((_DWORD *)v2 - 1);
    if ( !(_BYTE)v5 )
      break;
    if ( !BYTE1(v5) )
    {
      v6 = v2 - 3;
      goto copy_start;
    }
    if ( (v5 & 0xFF0000) == 0 )
    {
      v6 = v2 - 2;
      goto copy_start;
    }
    if ( (v5 & 0xFF000000) == 0 )
      goto start_byte_3;
  }
  v6 = v2 - 4;
copy_start:
  v7 = Source;
  if ( ((unsigned __int8)Source & 3) == 0 )
    goto main_loop_entrance;
  while ( 1 )
  {
    LOBYTE(v8) = *v7++;
    if ( !(_BYTE)v8 )
      break;
    *v6++ = v8;
    if ( ((unsigned __int8)v7 & 3) == 0 )
    {
      while ( 1 )
      {
main_loop_entrance:
        v9 = (*(_DWORD *)v7 + 2130640639) ^ ~*(_DWORD *)v7;
        v8 = *(_DWORD *)v7;
        v7 += 4;
        if ( (v9 & 0x81010100) != 0 )
        {
          if ( !(_BYTE)v8 )
            goto _byte_0;
          if ( !BYTE1(v8) )
          {
            *(_WORD *)v6 = (unsigned __int8)v8;
            return Destination;
          }
          if ( (v8 & 0xFF0000) == 0 )
          {
            *(_WORD *)v6 = v8;
            result = Destination;
            v6[2] = 0;
            return result;
          }
          if ( (v8 & 0xFF000000) == 0 )
          {
            *(_DWORD *)v6 = v8;
            return Destination;
          }
        }
        *(_DWORD *)v6 = v8;
        v6 += 4;
      }
    }
  }
_byte_0:
  *v6 = v8;
  return Destination;
}
int __cdecl strcmp(const char *Str1, const char *Str2)
{
  const char *v2; // edx
  const char *v3; // ecx
  unsigned int v4; // eax
  bool v5; // cf
  unsigned int v6; // eax
  __int16 v8; // ax

  v2 = Str1;
  v3 = Str2;
  if ( ((unsigned __int8)Str1 & 3) == 0 )
  {
dodwords:
    while ( 1 )
    {
      v4 = *(_DWORD *)v2;
      v5 = (unsigned __int8)*(_DWORD *)v2 < (unsigned int)*v3;
      if ( (unsigned __int8)*(_DWORD *)v2 != *v3 )
        break;
      if ( !(_BYTE)v4 )
        return 0;
      v5 = BYTE1(v4) < (unsigned int)v3[1];
      if ( BYTE1(v4) != v3[1] )
        break;
      if ( !BYTE1(v4) )
        return 0;
      v6 = HIWORD(v4);
      v5 = (unsigned __int8)v6 < (unsigned int)v3[2];
      if ( (_BYTE)v6 != v3[2] )
        break;
      if ( !(_BYTE)v6 )
        return 0;
      v5 = BYTE1(v6) < (unsigned int)v3[3];
      if ( BYTE1(v6) != v3[3] )
        break;
      v3 += 4;
      v2 += 4;
      if ( !BYTE1(v6) )
        return 0;
    }
    return -2 * v5 + 1;
  }
  if ( ((unsigned __int8)Str1 & 1) != 0 )
  {
    v2 = Str1 + 1;
    v5 = *Str1 < (unsigned int)*Str2;
    if ( *Str1 != *Str2 )
      return -2 * v5 + 1;
    v3 = Str2 + 1;
    if ( !*Str1 )
      return 0;
    if ( ((unsigned __int8)v2 & 2) == 0 )
      goto dodwords;
  }
  v8 = *(_WORD *)v2;
  v2 += 2;
  v5 = (unsigned __int8)v8 < (unsigned int)*v3;
  if ( (_BYTE)v8 != *v3 )
    return -2 * v5 + 1;
  if ( !(_BYTE)v8 )
    return 0;
  v5 = HIBYTE(v8) < (unsigned int)v3[1];
  if ( HIBYTE(v8) == v3[1] )
  {
    if ( HIBYTE(v8) )
    {
      v3 += 2;
      goto dodwords;
    }
    return 0;
  }
  return -2 * v5 + 1;
}
//char *__cdecl strcpy(char *Destination, const char *Source)
//{
//  //JUMPOUT(0x4A3121);//c×Ô´øº¯Êý£¬²»ÓÃ¹Ü
//}
size_t __cdecl strlen(const char *Str)
{
  const char *v1; // ecx
  int v3; // eax
  int v4; // eax

  v1 = Str;
  if ( ((unsigned __int8)Str & 3) == 0 )
    goto main_loop_0;
  do
  {
    if ( !*v1++ )
      return v1 - 1 - Str;
  }
  while ( ((unsigned __int8)v1 & 3) != 0 );
  while ( 1 )
  {
    do
    {
main_loop_0:
      v3 = (*(_DWORD *)v1 + 2130640639) ^ ~*(_DWORD *)v1;
      v1 += 4;
    }
    while ( (v3 & 0x81010100) == 0 );
    v4 = *((_DWORD *)v1 - 1);
    if ( !(_BYTE)v4 )
      break;
    if ( !BYTE1(v4) )
      return v1 - 3 - Str;
    if ( (v4 & 0xFF0000) == 0 )
      return v1 - 2 - Str;
    if ( (v4 & 0xFF000000) == 0 )
      return v1 - 1 - Str;
  }
  return v1 - 4 - Str;
}
_BYTE *__cdecl strncnt(_BYTE *a1, int a2)
{
  _BYTE *v2; // eax
  int v3; // ecx

  v2 = a1;
  v3 = a2 - 1;
  if ( a2 )
  {
    do
    {
      if ( !*v2 )
        break;
      ++v2;
    }
    while ( v3-- );
  }
  if ( *v2 )
    return (_BYTE *)a2;
  else
    return (_BYTE *)(v2 - a1);
}
char *__cdecl strncpy(char *Destination, const char *Source, size_t Count)
{
  size_t v3; // ecx
  size_t v4; // ebx
  const char *v5; // esi
  char *v6; // edi
  size_t v7; // ecx
  char v8; // al
  size_t v10; // ecx
  int v11; // eax
  int v12; // edx

  v3 = Count;
  if ( !Count )
    return Destination;
  v4 = Count;
  v5 = Source;
  v6 = Destination;
  if ( ((unsigned __int8)Source & 3) == 0 )
  {
    v7 = Count >> 2;
    if ( Count >> 2 )
      goto main_loop_entrance_0;
copy_tail_loop:
    while ( 1 )
    {
      v8 = *v5++;
      *v6++ = v8;
      if ( !v8 )
        break;
      if ( !--v4 )
        return Destination;
    }
    while ( --v4 )
finish_loop:
      *v6++ = v8;
    return Destination;
  }
  do
  {
    v8 = *v5++;
    *v6++ = v8;
    if ( !--v3 )
      return Destination;
    if ( !v8 )
    {
      while ( ((unsigned __int8)v6 & 3) != 0 )
      {
        *v6++ = 0;
        if ( !--v3 )
          return Destination;
      }
      v4 = v3;
      v10 = v3 >> 2;
      if ( !v10 )
        goto finish_loop;
      goto fill_dwords_with_EOS;
    }
  }
  while ( ((unsigned __int8)v5 & 3) != 0 );
  LOBYTE(v4) = v3;
  v7 = v3 >> 2;
  if ( !v7 )
  {
tail_loop_start:
    v4 &= 3u;
    if ( v4 )
      goto copy_tail_loop;
    return Destination;
  }
  while ( 1 )
  {
main_loop_entrance_0:
    v11 = (*(_DWORD *)v5 + 2130640639) ^ ~*(_DWORD *)v5;
    v12 = *(_DWORD *)v5;
    v5 += 4;
    if ( (v11 & 0x81010100) == 0 )
      goto main_loop_1;
    if ( !(_BYTE)v12 )
      break;
    if ( !BYTE1(v12) )
    {
      *(_DWORD *)v6 = (unsigned __int8)v12;
      goto fill_with_EOS_dwords;
    }
    if ( (v12 & 0xFF0000) == 0 )
    {
      *(_DWORD *)v6 = (unsigned __int16)v12;
      goto fill_with_EOS_dwords;
    }
    if ( (v12 & 0xFF000000) == 0 )
    {
      *(_DWORD *)v6 = v12;
      goto fill_with_EOS_dwords;
    }
main_loop_1:
    *(_DWORD *)v6 = v12;
    v6 += 4;
    if ( !--v7 )
      goto tail_loop_start;
  }
  *(_DWORD *)v6 = 0;
fill_with_EOS_dwords:
  v6 += 4;
  v8 = 0;
  v10 = v7 - 1;
  if ( v10 )
  {
fill_dwords_with_EOS:
    v8 = 0;
    do
    {
      *(_DWORD *)v6 = 0;
      v6 += 4;
      --v10;
    }
    while ( v10 );
  }
  v4 &= 3u;
  if ( v4 )
    goto finish_loop;
  return Destination;
}


_BYTE* sub_401000(_BYTE* thisx)
{
    sub_47FC70(thisx);
    *(_DWORD*)thisx = (_DWORD)off_4AC230;//Ö¸ÕëÖ¸ÏòµÄÄÚÈÝµÈÓÚÁíÒ»¸öÖ¸ÕëµÄµØÖ·£¬²»ÊÇÖ¸ÕëÖ¸ÏòµÄÄÚÈÝµÈÓÚÁíÒ»¸öÖ¸ÕëÖ¸ÏòµÄÄÚÈÝ,ÓÃ(_DWORD)off_4AC230¾Í»á°Ñ¸ÃµØÖ·µÄµØÖ·¸øËüÁË£¬ÒªÖªµÀÇ¿ÖÆ×ª»»ÀàÐÍµ«ÊÇÊýÖµÊÇ²»»á±äµÄ
    sub_480737((_DWORD*)thisx, 6);
    sub_47FEB2(*((_DWORD*)thisx + 3), (LPCSTR)&byte_4B0060, &unk_4B0050, 1);
    sub_47FEB2(*((_DWORD*)thisx + 3) + 32, (LPCSTR)&byte_4B0088, &unk_4B0078, 0);
    sub_47FEB2(*((_DWORD*)thisx + 3) + 64, (LPCSTR)&byte_4B00B8, &unk_4B00A8, 1);
    sub_47FE72((_DWORD*)(*((_DWORD*)thisx + 3) + 96), (LPCSTR)&byte_4B00D0, 1, 0, 8, 4);
    sub_47FEB2(*((_DWORD*)thisx + 3) + 128, (LPCSTR)&byte_4B00E8, &unk_4B00DC, 1);
    sub_47FEB2(*((_DWORD*)thisx + 3) + 160, (LPCSTR)&byte_4B0104, &unk_4B00F8, 0);
    thisx[4] = 8;
    thisx[5] = 9;
    thisx[6] = 23;
    thisx[7] = 10;
    thisx[29] = 19;
    return thisx;
}


void sub_401119(_DWORD* thisx)
{
    *thisx = (_DWORD)off_4AC230;
    sub_47FCCF(thisx);
}
//int sub_401135(_CancellationTokenRegistration** thisx)//Ã»ÓÐ±»µ÷ÓÃ¹ý
//{
//    unsigned __int8* v3; // [esp+4h] [ebp-8h]
//    int v4; // [esp+8h] [ebp-4h]
//
//    v3 = (unsigned __int8*)unknown_libname_1((char*)unk_4B9B10);
//    sub_480016((_DWORD*)thisx[3], v3[75]);
//    sub_480016((_DWORD*)thisx[3] + 8, v3[76]);
//    sub_480016((_DWORD*)thisx[3] + 16, v3[72]);
//    sub_480016((_DWORD*)thisx[3] + 24, v3[26]);
//    sub_480016((_DWORD*)thisx[3] + 32, v3[95]);
//    sub_480016((_DWORD*)thisx[3] + 40, v3[96]);
//    v4 = sub_480227((_DWORD*)thisx);
//    v3[75] = (unsigned __int8)_GetToken(thisx[3]);
//    v3[76] = (unsigned __int8)_GetToken((_CancellationTokenRegistration*)((char*)thisx[3] + 32));
//    v3[72] = (unsigned __int8)_GetToken((_CancellationTokenRegistration*)((char*)thisx[3] + 64));
//    v3[26] = (unsigned __int8)_GetToken((_CancellationTokenRegistration*)((char*)thisx[3] + 96));
//    v3[95] = (unsigned __int8)_GetToken((_CancellationTokenRegistration*)((char*)thisx[3] + 128));
//    v3[96] = (unsigned __int8)_GetToken((_CancellationTokenRegistration*)((char*)thisx[3] + 160));
//    return v4;
//}
int __stdcall sub_401265(_DWORD** thisx, int a2)
{
    unsigned __int8* v4; // [esp+4h] [ebp-4h]

    sub_48070C((streambuf*)thisx, a2);
    v4 = (unsigned __int8*)unknown_libname_1((char*)unk_4B9B10);
    sub_480016(thisx[3], v4[75]);
    sub_480016(thisx[3] + 8, v4[76]);
    sub_480016(thisx[3] + 16, v4[72]);
    sub_480016(thisx[3] + 24, v4[26]);
    sub_480016(thisx[3] + 32, v4[95]);
    return sub_480016(thisx[3] + 40, v4[96]);
}
void* sub_401320(_DWORD* thisx, char a2)
{
    sub_401119(thisx);
    if ((a2 & 1) != 0)
        operator delete(thisx);
    return thisx;
}
void sub_401390(void* thisx)
{
    *(_DWORD*)thisx = (_DWORD)off_4AC244;
    *((_WORD*)thisx + 2) = 0;
    *((_DWORD*)thisx + 2) = 0;
    *((_WORD*)thisx + 6) = 0;
    *((_DWORD*)thisx + 4) = 0;
    *((_DWORD*)thisx + 5) = 0;
    *((_DWORD*)thisx + 6) = 0;
    *((_BYTE*)thisx + 28) = 0;
}
void sub_4013E8(void* thisx)
{
    *(_DWORD*)thisx = off_4AC244;
    sub_401404((int)thisx);
}

int sub_401404(int thisx)
{
    int result; // eax

    if (*(_DWORD*)(thisx + 8))
        (***(void(****)(_DWORD, int))(thisx + 8))(*(_DWORD*)(thisx + 8), 3);
    *(_WORD*)(thisx + 4) = 0;
    *(_DWORD*)(thisx + 8) = 0;
    if (*(_DWORD*)(thisx + 16))
        (***(void(****)(_DWORD, int))(thisx + 16))(*(_DWORD*)(thisx + 16), 3);
    result = thisx;
    *(_WORD*)(thisx + 12) = 0;
    *(_DWORD*)(thisx + 16) = 0;
    return result;
}
BOOL sub_4014A3(void* thisx, LPCSTR lpString2, LPCSTR a3)
{
    CHAR FileName[260]; // [esp+4h] [ebp-218h] BYREF
    CHAR String1[260]; // [esp+108h] [ebp-114h] BYREF
    int v7; // [esp+20Ch] [ebp-10h]
    int v8; // [esp+210h] [ebp-Ch]
    int v9; // [esp+214h] [ebp-8h]
    int v10; // [esp+218h] [ebp-4h]

    sub_401404((int)thisx);
    v8 = (int)thisx + 8;
    v7 = (int)thisx + 16;
    v10 = (int)thisx + 4;
    v9 = (int)thisx + 12;
    lstrcpyA(String1, lpString2);
    lstrcpyA(FileName, a3);
    return sub_47A55C(FileName,v7,v8,v9,v10, String1) != 0;
}
int sub_401531(_DWORD* thisx, LPCSTR lpFileName, int a3)
{
    if (!sub_49DA45((_DWORD*)unk_4BDC60, lpFileName, a3))
        return 0;
    thisx[5] = *(_DWORD*)a3;
    return 1;
}
int sub_401568(_DWORD* thisx, LPCSTR lpFileName, int a3)
{
    if (!sub_49DA45((_DWORD*)unk_4BDC60, lpFileName, a3))
        return 0;
    thisx[6] = *(_DWORD*)a3;
    return 1;
}
void sub_40159F(_DWORD* thisx, int a2, int a3, int a4)
{
    sub_4015C7((int)thisx, a2, a3, thisx[5], a4);
}
void sub_4015C7(int thisx, int a2, int a3, int a4, int a5)
{
    unsigned __int8 v6; // [esp+4h] [ebp-30h]
    unsigned __int16 v7; // [esp+8h] [ebp-2Ch]
    _BYTE* v8; // [esp+Ch] [ebp-28h]
    int v9[9]; // [esp+10h] [ebp-24h] BYREF

    if (a3 >= 0 && a3 < *(unsigned __int16*)(thisx + 4))
    {
        memset(v9, 0, sizeof(v9));
        v9[0] = 152 * a3 + *(_DWORD*)(thisx + 8);
        v9[1] = *(_DWORD*)(thisx + 16);
        BYTE1(v9[6]) = *(_BYTE*)(thisx + 28);
        v9[4] = a4;
        v9[7] = a5;
        v9[2] = *(_DWORD*)(thisx + 24);
        if (!*(_BYTE*)(thisx + 28))
        {
            v8 = (_BYTE*)(36 * a5 + dword_4B92E0);
            v6 = sub_4016F0(v8);
            v7 = (unsigned __int8)sub_401710(v8);
            LOWORD(v9[8]) = sub_475CB0((short*)v8);
            v9[8] = LOWORD(v9[8]);
            v9[3] = *(_DWORD*)(*((_DWORD*)dword_4B9360 + v6) + 4 * v7);
        }
        sub_478C4C((_DWORD*)a2, (int)v9);
    }
}

void* sub_4016C0(void* thisx, char a2)
{
    sub_4013E8(thisx);
    if ((a2 & 1) != 0)
        delete(thisx);
    return thisx;
}

char sub_4016F0(_BYTE* thisx)
{
    return thisx[18];
}

char sub_401710(_BYTE* thisx)
{
    return thisx[19];
} 
void sub_401730(void* thisx)
{
    *(_DWORD*)thisx = (_DWORD)off_4AC248;
    *((_BYTE*)thisx + 18) = 0;
}

 
void sub_40174E(void* thisx)
{
    *(_DWORD*)thisx = (_DWORD)off_4AC248;
}

 
LPSTR sub_401762(CHAR* thisx, LPCSTR lpString2)
{
    return lstrcpynA(thisx + 4, lpString2, 11);
}

 
BOOL sub_401782(_BYTE* thisx, int a2)
{
    int i; // [esp+4h] [ebp-4h]

    if (thisx[20] == 4)
        return a2 <= 10 || a2 == 16 || a2 == 23;
    for (i = 0; i < 3; ++i)
    {
        if (a2 == (unsigned __int8)thisx[i + 32])
            return 1;
    }
    return 0;
}

 
int sub_4017EE(_WORD* thisx, unsigned __int16 a2)
{
    int result; // eax

    result = a2;
    if (dword_4B936C <= a2)
        a2 = 0;
    thisx[8] = a2;
    return result;
}

 
int sub_40181C(unsigned __int8* thisx)
{
    int i; // [esp+4h] [ebp-8h]
    int v3; // [esp+8h] [ebp-4h]

    v3 = 0;
    for (i = 0; i < 3; ++i)
        v3 += thisx[i + 32] != 0;
    return v3;
}

 
void sub_401870(void* thisx)
{
    int i; // [esp+4h] [ebp-4h]

    sub_401E17((_DWORD*)thisx + 144);
    *(_DWORD*)thisx = (_DWORD)off_4AC24C;
    *((_BYTE*)thisx + 4) = 0;
    *((_BYTE*)thisx + 5) = 0;
    *((_BYTE*)thisx + 6) = 0;
    *((_BYTE*)thisx + 7) = 0;
    *((_BYTE*)thisx + 8) = 0;
    *((_BYTE*)thisx + 9) = 0;
    *((_BYTE*)thisx + 10) = 0;
    *((_BYTE*)thisx + 15) = 0;
    for (i = 0; i < 2; ++i)
    {
        *((_BYTE*)thisx + i + 11) = 0;
        *((_BYTE*)thisx + i + 13) = 0;
    }
    SetRect((LPRECT)thisx + 1, 0, 0, 0, 0);
    SetRect((LPRECT)thisx + 5, 0, 0, 0, 0);
}

 
void sub_401927(void* thisx)
{
    *(_DWORD*)thisx = (_DWORD)off_4AC24C;
    sub_401B16((int)thisx);
    sub_401E35((void**)thisx + 36);
}

 
int sub_40197E(_BYTE* thisx, HANDLE hFile, int a3, int a4)
{
    int Buffer; // [esp+4h] [ebp-8h] BYREF
    DWORD NumberOfBytesRead; // [esp+8h] [ebp-4h] BYREF

    sub_401B16((int)thisx);
    if (!a4)
    {
        ReadFile(hFile, thisx + 4, 1u, (LPDWORD)&NumberOfBytesRead, 0);
        ReadFile(hFile, thisx + 5, 1u, (LPDWORD)&NumberOfBytesRead, 0);
        ReadFile(hFile, thisx + 6, 1u, (LPDWORD)&NumberOfBytesRead, 0);
        ReadFile(hFile, &Buffer, 1u, (LPDWORD)&NumberOfBytesRead, 0);
        thisx[8] = (Buffer & 1) != 0;
        thisx[9] = (Buffer & 2) != 0;
        ReadFile(hFile, thisx + 7, 1u, (LPDWORD)&NumberOfBytesRead, 0);
        if (a3 == 2)
        {
            ReadFile(hFile, thisx + 10, 1u, (LPDWORD)&NumberOfBytesRead, 0);
            ReadFile(hFile, thisx + 11, 1u, (LPDWORD)&NumberOfBytesRead, 0);
            ReadFile(hFile, thisx + 13, 1u, (LPDWORD)&NumberOfBytesRead, 0);
            ReadFile(hFile, thisx + 15, 1u, (LPDWORD)&NumberOfBytesRead, 0);
        }
    }
    if (!sub_401ED9(thisx + 144 ,hFile, a3))
        return 0;
    ReadFile(hFile, thisx + 16, 0x10u, (LPDWORD)&NumberOfBytesRead, 0);
    ReadFile(hFile, thisx + 80, 0x10u, (LPDWORD)&NumberOfBytesRead, 0);
    return 1;
}

 //275·ÖÖ®Ò»
void** sub_401B16(int thisx)
{
    *(_BYTE*)(thisx + 4) = 0;
    *(_BYTE*)(thisx + 5) = 0;
    *(_BYTE*)(thisx + 6) = 0;
    *(_BYTE*)(thisx + 7) = 0;
    *(_BYTE*)(thisx + 8) = 0;
    SetRect((LPRECT)(thisx + 16), 0, 0, 0, 0);
    SetRect((LPRECT)(thisx + 80), 0, 0, 0, 0);
    return sub_401E48((void**)(thisx + 144));
}

 
_BYTE* sub_401B7C(_BYTE* thisx)
{
    int i; // [esp+4h] [ebp-4h]

    *(_WORD*)thisx = 0;
    thisx[6] = 0;
    thisx[7] = 0;
    for (i = 0; i < 2; ++i)
    {
        thisx[i + 2] = 0;
        thisx[i + 4] = 0;
    }
    return thisx;
}

 
int __stdcall sub_401BD0(_DWORD* thisx, char a1)
{
    return sub_401E83(thisx + 36, a1);
}

 
__int16 __stdcall sub_401BEF(_DWORD* thisx, char a2)
{
    int v2; // [esp+4h] [ebp-4h]

    v2 = sub_401BD0(thisx,a2);
    if (v2)
        return *(_WORD*)v2;
    else
        return 0;
}

 
char __stdcall sub_401C1E(_DWORD* thisx, char a2, int a3)
{
    int v3; // [esp+4h] [ebp-4h]

    v3 = sub_401BD0(thisx,a2);
    if (v3 && a2 >= 0 && a2 <= 1)
        return *(_BYTE*)(a2 + v3 + 2);
    else
        return 0;
}

 
char __stdcall sub_401C5B(_DWORD* thisx, char a2, int a3)
{
    int v3; // [esp+4h] [ebp-4h]

    v3 = sub_401BD0(thisx,a2);
    if (v3 && a2 >= 0 && a2 <= 1)
        return *(_BYTE*)(a2 + v3 + 4);
    else
        return 0;
}

 
char __stdcall sub_401C98(_DWORD* thisx, char a2)
{
    int v2; // [esp+4h] [ebp-4h]

    v2 = sub_401BD0(thisx, a2);
    if (v2)
        return *(_BYTE*)(v2 + 6);
    else
        return 0;
}

 
char __stdcall sub_401CC6(_DWORD* thisx, char a2)
{
    int v2; // [esp+4h] [ebp-4h]

    v2 = sub_401BD0(thisx,a2);
    if (v2)
        return *(_BYTE*)(v2 + 7);
    else
        return 0;
}

 
int __stdcall sub_401D24(_DWORD* thisx, char a2, char a3, int a4)
{
    int result; // eax

    result = sub_401BD0(thisx, a2);
    if (result && a3 >= 0 && a3 <= 1)
        *(_BYTE*)(a3 + result + 2) = a2;
    return result;
}

 
int __stdcall sub_401D62(_DWORD* thisx, char a2, char a3, int a4)
{
    int result; // eax

    result = sub_401BD0(thisx, a2);
    if (result && a3 >= 0 && a3 <= 1)
        *(_BYTE*)(a3 + result + 4) = a2;
    return result;
}

 
int sub_401DFE(char* thisx)
{
    return unknown_libname_3(thisx + 144);
}

 
_DWORD* sub_401E17(_DWORD* thisx)
{
    *(_BYTE*)thisx = 0;
    thisx[1] = 0;
    return thisx;
}

 
void** sub_401E35(void** thisx)
{
    return sub_401E48(thisx);
}

//275·ÖÖ®Ò»µÄÆ«ÒÆ144
void** sub_401E48(void** thisx)
{
    void** result; // eax

    result = thisx;
    if (thisx[1])
        operator delete(thisx[1]);
    *(_BYTE*)thisx = 0;
    thisx[1] = 0;
    return result;
}

 
int sub_401E83(_DWORD* thisx, unsigned __int8 a2)
{
    if (a2 < (int)*(unsigned __int8*)thisx)
        return thisx[1] + 8 * a2;
    else
        return 0;
}


 
int sub_401ED9(_BYTE* thisx, HANDLE hFile, int a3)
{
    void* v4; // [esp+0h] [ebp-28h]
    void* Block; // [esp+8h] [ebp-20h]
    int i; // [esp+10h] [ebp-18h]
    DWORD NumberOfBytesRead; // [esp+14h] [ebp-14h] BYREF
    int v9; // [esp+18h] [ebp-10h]
    int v10; // [esp+24h] [ebp-4h]

    sub_401E48((void**)thisx);
    if (a3)
        ReadFile(hFile, thisx, 1u, (LPDWORD)&NumberOfBytesRead, 0);
    else
        *thisx = 2;
    v9 = *thisx;
    Block = operator new(8 * v9);
    v10 = 0;
    if (Block)
    {
        sub_402080((int)Block, 8, v9, (void(*)(int))sub_401B7C);
        v4 = Block;
    }
    else
    {
        v4 = 0;
    }
    v10 = -1;
    *((_DWORD*)thisx + 1) = (_DWORD)v4;
    if (*((_DWORD*)thisx + 1))
    {
        for (i = 0; i < *thisx; ++i)
        {
            ReadFile(hFile, (LPVOID)(*((_DWORD*)thisx + 1) + 8 * i), 2u, (LPDWORD)&NumberOfBytesRead, 0);
            ReadFile(hFile, (LPVOID)(*((_DWORD*)thisx + 1) + 8 * i + 2), 1u, (LPDWORD)&NumberOfBytesRead, 0);
            ReadFile(hFile, (LPVOID)(*((_DWORD*)thisx + 1) + 8 * i + 4), 1u, (LPDWORD)&NumberOfBytesRead, 0);
            ReadFile(hFile, (LPVOID)(*((_DWORD*)thisx + 1) + 8 * i + 6), 1u, (LPDWORD)&NumberOfBytesRead, 0);
            ReadFile(hFile, (LPVOID)(*((_DWORD*)thisx + 1) + 8 * i + 7), 1u, (LPDWORD)&NumberOfBytesRead, 0);
        }
        return 1;
    }
    else
    {
        sub_401E48((void**)thisx);
        return 0;
    }
}

 
int __stdcall sub_402080(int a1, int a2, int a3, void(* a4)(int))
{
    int result; // eax

    while (1)
    {
        result = --a3;
        if (a3 < 0)
            break;
        a4(a1);
        a1 += a2;
    }
    return result;
}

 
_DWORD* sub_4020B0(_DWORD* thisx)
{
    thisx[9] = 3;
    *thisx = 0;
    thisx[3] = 0;
    *((_BYTE*)thisx + 4) = 0;
    thisx[2] = 0;
    *((_BYTE*)thisx + 17) = -1;
    *((_BYTE*)thisx + 40) = 0;
    thisx[8] = 0;
    thisx[11] = 0;
    thisx[12] = 83;
    *((_BYTE*)thisx + 30) = 0;
    return thisx;
}

 
void sub_40211F(void* thisx)
{
    sub_41807A((_DWORD*)thisx + 8);
    *(_DWORD*)thisx = off_4AC250;
    *((_DWORD*)thisx + 40) = 0;
    *((_WORD*)thisx + 93) = 0;
    *((_DWORD*)thisx + 82) = 0;
    *((_DWORD*)thisx + 83) = 0;
    *((_DWORD*)thisx + 84) = 0;
    *((_DWORD*)thisx + 106) = 1;
    *((_WORD*)thisx + 102) = 0;
    *((_BYTE*)thisx + 212) = 0;
    *((_BYTE*)thisx + 195) = 3;
    *((_DWORD*)thisx + 107) = 3;
    *((_DWORD*)thisx + 111) = 0;
    *((_BYTE*)thisx + 184) = 0;
    *((_DWORD*)thisx + 99) = 1;
    *((_DWORD*)thisx + 101) = 1;
    *((_DWORD*)thisx + 41) = 0;
    *((_BYTE*)thisx + 248) = 0;
    *((_DWORD*)thisx + 98) = 0;
    *((_DWORD*)thisx + 72) = 0;
    *((_DWORD*)thisx + 73) = 0;
    *((_BYTE*)thisx + 470) = 0;
    *((_BYTE*)thisx + 223) = 0x80;
    memset((char*)thisx + 230, 0, 3u);
    memset((char*)thisx + 453, 0, 8u);
    memset((char*)thisx + 461, 0, 8u);
    sub_423CF2((_BYTE*)thisx, 0, 0, 0, 0, 0, 0);
    *((_DWORD*)thisx + 33) = (_DWORD)thisx;
    *((_BYTE*)thisx + 176) = 0;
    *((_BYTE*)thisx + 177) = 0;
    *((_DWORD*)thisx + 45) = 0;
}

/*
void VirtualProcessorRoot::~VirtualProcessorRoot(
    VirtualProcessorRoot* thisx)
{
    *(_DWORD*)thisx = &off_4AC250;
    sub_418130((char*)thisx + 8, thisx);
}
*/








void __fastcall sub_40230C(int a1)
{
    int v1; // esi
    unsigned __int8 v2; // al
    unsigned __int8 v3; // al
    char v4; // al
    char v5; // al
    int v6; // esi
    int* v7; // eax
    int* v8; // eax
    char v10[16]; // [esp+8h] [ebp-C0h] BYREF
    char v11[16]; // [esp+18h] [ebp-B0h] BYREF
    int v12; // [esp+28h] [ebp-A0h]
    int v13; // [esp+2Ch] [ebp-9Ch]
    int j; // [esp+30h] [ebp-98h]
    int v15; // [esp+34h] [ebp-94h]
    int v16; // [esp+38h] [ebp-90h]
    int v17; // [esp+3Ch] [ebp-8Ch]
    int v18; // [esp+40h] [ebp-88h]
    int v19; // [esp+44h] [ebp-84h]
    int yTop; // [esp+48h] [ebp-80h]
    char* v21; // [esp+4Ch] [ebp-7Ch] BYREF
    int v22; // [esp+50h] [ebp-78h]
    int v23[2]; // [esp+54h] [ebp-74h] BYREF
    int v24; // [esp+5Ch] [ebp-6Ch]
    int v25; // [esp+60h] [ebp-68h]
    int v26; // [esp+64h] [ebp-64h]
    int v27; // [esp+68h] [ebp-60h]
    int v28; // [esp+6Ch] [ebp-5Ch]
    int v29; // [esp+70h] [ebp-58h]
    int v30; // [esp+74h] [ebp-54h]
    int i; // [esp+78h] [ebp-50h]
    int v32; // [esp+7Ch] [ebp-4Ch]
    _BYTE* v33; // [esp+80h] [ebp-48h]
    int v34; // [esp+84h] [ebp-44h]
    char v35; // [esp+88h] [ebp-40h]
    _BYTE* v36; // [esp+8Ch] [ebp-3Ch]
    int Src; // [esp+90h] [ebp-38h] BYREF
    int v38; // [esp+94h] [ebp-34h]
    int v39; // [esp+98h] [ebp-30h]
    int v40; // [esp+A8h] [ebp-20h]
    BOOL v41; // [esp+ACh] [ebp-1Ch]
    int v42; // [esp+C4h] [ebp-4h]

    if (*(_DWORD*)(a1 + 428) != 80)
    {
        v22 = *(_DWORD*)(a1 + 328);
        if (*(_BYTE*)(a1 + 474) && *(_BYTE*)(a1 + 475) && (*(_BYTE*)(a1 + 474) & 1) == 0)
            *(_DWORD*)(a1 + 328) += 100 * (*(_DWORD*)(a1 + 424) - (*(_DWORD*)(a1 + 424) == 0));
        sub_446442((int*)unk_4B9B10, a1, (int)v23);
        v26 = v23[0];
        v24 = v23[1];
        v36 = (_BYTE*)sub_4741F8((int)unk_4B9B10, v22 / 800, *(_DWORD*)(a1 + 332) / 800);
        v32 = sub_446497((int*)unk_4B9B10, v22 / 100, *(_DWORD*)(a1 + 332) / 100);
        if (v36 && sub_425C50(v36))
            v32 = 4 * (unsigned __int8)unknown_libname_6(v36);
        v30 = 0;
        LOBYTE(v28) = 0;
        v29 = 0;
        if (v36)
        {
            LOBYTE(v30) = sub_425C30(v36);
            v30 = (unsigned __int8)v30;
            LOBYTE(v28) = sub_425C70(v36);
            v29 = sub_425C90(v36);
        }
        v35 = sub_4464F6((int*)unk_4B9B10, v22 / 800, *(_DWORD*)(a1 + 332) / 800);
        sub_49C15E((int)&Src);
        if ((_BYTE)v28 && (*(_DWORD*)(a1 + 392) || v29))
        {
            v38 = v26 - 8;
            v1 = *(_DWORD*)(a1 + 332) / 100 - v32;
            v39 = v1 + sub_4464BA((int)unk_4B9B10) - 2;
            if (v36)
                v39 -= v30;
            Src = dword_4B9214;
            if ((unsigned __int8)v28 == 2)
            {
                if (dword_4B93B0 % 2u == (*(_BYTE*)(a1 + 184) & 1))
                    sub_49AB05((int)unk_4BDC60, &Src);
            }
            else if ((unsigned __int8)v28 == 1)
            {
                sub_49AB05((int)unk_4BDC60, &Src);
            }
        }
        if (!*(_BYTE*)(a1 + 176))
        {
            v38 = v26;
            v39 = v24;
            v40 = *(_DWORD*)(a1 + 424);
            if (Concurrency::details::UMSFreeVirtualProcessorRoot::GetExecutingProxy((Concurrency::details::UMSFreeVirtualProcessorRoot*)unk_4B9B10) == (struct Concurrency::details::UMSThreadProxy*)23)
            {
                Src = *(unsigned __int8*)(a1 + 195) + dword_4B9234;
                v42 = 8 * *(unsigned __int8*)(a1 + 193) + 4952720;
            }
            else if (*(unsigned __int8*)(a1 + 195) < 4u && sub_41BA53(a1, 0x26u, 0) || *(_DWORD*)(a1 + 524))
            {
                Src = *((__int16*)dword_4B9394 + *(unsigned __int16*)(a1 + 498)) + *(_DWORD*)(a1 + 196);
            }
            else
            {
                Src = *(unsigned __int8*)(a1 + 195) < 4u
                    && (sub_41BA53(a1, 0x26u, 0) || *(_DWORD*)(a1 + 524) || sub_425CD0((int*)unk_4B9B10) == 3 && *(_BYTE*)(a1 + 184)) ? *((__int16*)*(dword_4B9370 + *(unsigned __int8*)(a1 + 195)) + *(unsigned __int16*)(a1 + 498)) + *(_DWORD*)(a1 + 196) : *(_DWORD*)(a1 + 196);
            }
            sub_41CA3D((void*)a1, (int*)&v21);
            if (v21)
            {
                LOBYTE(v34) = sub_401DFE(v21);
                v34 = (unsigned __int8)v34;
                v25 = v38;
                v27 = v39;
                for (i = 0; i < v34 + 1; ++i)
                {
                    v2 = sub_425C10(v21);
                    if (v2 == i)
                        sub_409096(a1);
                    if (*(_DWORD*)(a1 + 480))
                    {
                        if (sub_425B70(v21))
                        {
                            v3 = sub_475EB0(v21);
                            if (v3 == i)
                            {
                                if (*(_DWORD*)(a1 + 428) == 142 && sub_425CB0(*(_BYTE**)(a1 + 480)) == 1)
                                    v19 = 0;
                                sub_498F3D(*(_DWORD*)(a1 + 480));
                                sub_490D23(*(_DWORD*)(a1 + 480));
                            }
                        }
                    }
                    if (i != v34)
                    {
                        v33 = (_BYTE*)sub_41EEB5((_BYTE*)a1, (int*)v21, i);
                        v4 = sub_401C1E((int*)v21, i, *(_DWORD*)(a1 + 424));
                        v38 = v4 + v25;
                        v5 = sub_401C5B((int*)v21, i, 0);
                        v39 = v5 + v27;
                        if (sub_401C98((int*)v21, i))
                            v40 = *(_DWORD*)(a1 + 424) == 0;
                        else
                            v40 = *(_DWORD*)(a1 + 424);
                        v41 = sub_401CC6((int*)v21, i) != 0;
                        yTop = 0;
                        if (*(_DWORD*)(a1 + 208))
                        {
                            v6 = sub_401C5B((int*)v21, i, 0) + *(_DWORD*)(a1 + 208);
                            yTop = v6 + 8 * (unsigned __int8)sub_425F90(v33);
                        }
                        sub_48FB00((int)v33, (int)&Src, (int)unk_4BDC60, &Src, yTop);
                    }
                }
                if (dword_4B93A8)
                {
                    v40 = 0;
                    v41 = 0;
                    for (j = 0; j < 2; ++j)
                    {
                        if (j)
                        {
                            if (j == 1)
                            {
                                v8 = sub_425B90(v21, (int*)v10, *(_DWORD*)(a1 + 424), 0);
                                v15 = *v8;
                                v16 = v8[1];
                                v17 = v8[2];
                                v18 = v8[3];
                            }
                        }
                        else
                        {
                            v7 = sub_425BD0(v21, (int*)v11, *(_DWORD*)(a1 + 424), 0);
                            v15 = *v7;
                            v16 = v7[1];
                            v17 = v7[2];
                            v18 = v7[3];
                        }
                        if (v15 || v16 || v17 || v18)
                        {
                            if (v15 > v17)
                            {
                                v13 = v15;
                                v15 = v17;
                                v17 = v13;
                            }
                            if (v16 > v18)
                            {
                                v12 = v16;
                                v16 = v18;
                                v18 = v12;
                            }
                            v38 = v15 + v26;
                            v39 = v16 + v24;
                            Src = dword_4B9210 + 4 * j;
                            sub_49AB05((int)unk_4BDC60, &Src);
                            v38 = v26 + v17 - 8;
                            v39 = v16 + v24;
                            Src = dword_4B9210 + 4 * j + 1;
                            sub_49AB05((int)unk_4BDC60, &Src);
                            v38 = v15 + v26;
                            v39 = v24 + v18 - 8;
                            Src = dword_4B9210 + 4 * j + 2;
                            sub_49AB05((int)unk_4BDC60, &Src);
                            v38 = v26 + v17 - 8;
                            v39 = v24 + v18 - 8;
                            Src = dword_4B9210 + 4 * j + 3;
                            sub_49AB05((int)unk_4BDC60, &Src);
                        }
                    }
                }
                if (*(_BYTE*)(a1 + 474) && *(_BYTE*)(a1 + 475) && (*(_BYTE*)(a1 + 474) & 1) == 0)
                    *(_DWORD*)(a1 + 328) = v22;
            }
        }
    }
}
int sub_402C05(int thisx)
{
    int result; // eax
    int v2; // esi
    int v3; // esi
    int v4; // eax
    int v5; // edx
    bool v6; // [esp+4h] [ebp-110h]
    bool v7; // [esp+8h] [ebp-10Ch]
    bool v8; // [esp+Ch] [ebp-108h]
    bool v9; // [esp+10h] [ebp-104h]
    int v10; // [esp+14h] [ebp-100h]
    int v11; // [esp+18h] [ebp-FCh]
    BOOL v12; // [esp+20h] [ebp-F4h]
    BOOL v13; // [esp+24h] [ebp-F0h]
    BOOL v14; // [esp+28h] [ebp-ECh]
    char v15; // [esp+2Ch] [ebp-E8h]
    int v16; // [esp+30h] [ebp-E4h]
    int v17; // [esp+34h] [ebp-E0h]
    int v18; // [esp+38h] [ebp-DCh]
    int v19; // [esp+3Ch] [ebp-D8h]
    int v20; // [esp+40h] [ebp-D4h]
    int v21; // [esp+44h] [ebp-D0h]
    int v22; // [esp+48h] [ebp-CCh]
    int v23; // [esp+4Ch] [ebp-C8h]
    BOOL v24; // [esp+50h] [ebp-C4h]
    BOOL v25; // [esp+54h] [ebp-C0h]
    BOOL v26; // [esp+58h] [ebp-BCh]
    int v28; // [esp+60h] [ebp-B4h]
    int v29; // [esp+64h] [ebp-B0h]
    char* v30; // [esp+68h] [ebp-ACh]
    int v31; // [esp+6Ch] [ebp-A8h]
    char v32; // [esp+70h] [ebp-A4h]
    int v33; // [esp+74h] [ebp-A0h]
    int v34; // [esp+78h] [ebp-9Ch]
    int v35; // [esp+7Ch] [ebp-98h]
    _DWORD* v36; // [esp+88h] [ebp-8Ch]
    _DWORD* v37; // [esp+8Ch] [ebp-88h]
    _DWORD* v38; // [esp+94h] [ebp-80h]
    _DWORD* v39; // [esp+98h] [ebp-7Ch]
    char v40; // [esp+9Ch] [ebp-78h]
    int v41; // [esp+A0h] [ebp-74h]
    char* v42; // [esp+A4h] [ebp-70h]
    int m; // [esp+A8h] [ebp-6Ch]
    int i; // [esp+ACh] [ebp-68h]
    int v45; // [esp+B0h] [ebp-64h]
    int j; // [esp+B4h] [ebp-60h]
    int k; // [esp+B4h] [ebp-60h]
    int v48; // [esp+B8h] [ebp-5Ch]
    int v49; // [esp+BCh] [ebp-58h]
    BOOL v50; // [esp+C0h] [ebp-54h]
    _DWORD* v51; // [esp+C8h] [ebp-4Ch]
    Concurrency::details::SchedulerProxy* v52; // [esp+CCh] [ebp-48h]
    BOOL v53; // [esp+D0h] [ebp-44h]
    int v54; // [esp+D4h] [ebp-40h]
    int v55; // [esp+D8h] [ebp-3Ch]
    _DWORD* v56; // [esp+DCh] [ebp-38h]
    int n; // [esp+E0h] [ebp-34h]
    int v58; // [esp+E4h] [ebp-30h]
    int v59; // [esp+E8h] [ebp-2Ch]
    int v60; // [esp+ECh] [ebp-28h]
    int v61; // [esp+F0h] [ebp-24h]
    int v62; // [esp+F8h] [ebp-1Ch]
    int v63; // [esp+FCh] [ebp-18h]
    BOOL v64; // [esp+100h] [ebp-14h]
    int v65; // [esp+104h] [ebp-10h]
    char* v66; // [esp+108h] [ebp-Ch]
    _BYTE* v67; // [esp+10Ch] [ebp-8h]
    _DWORD* v68; // [esp+110h] [ebp-4h]

    v61 = 0;
    v58 = 0;
    v59 = 0;
    v55 = 0;
    v53 = 0;
    v48 = 0;
    v65 = 0;
    *(_BYTE*)(thisx + 272) = 0;
    *(_DWORD*)(thisx + 276) = 0;
    *(_DWORD*)(thisx + 280) = 0;
    *(_DWORD*)(thisx + 268) = 0;
    *(_DWORD*)(thisx + 588) = 0;
    v67 = (_BYTE*)sub_425DF0((int)unk_4B9B10, *(unsigned __int8*)(thisx + 184));
    if (*(_BYTE*)(thisx + 474))
    {
        --* (_BYTE*)(thisx + 474);
        result = thisx;
        if (*(_BYTE*)(thisx + 474))
            return result;
        *(_BYTE*)(thisx + 475) = 0;
    }
    *(_DWORD*)(thisx + 340) = 0;
    *(_DWORD*)(thisx + 344) = 0;
    if (*(_DWORD*)(thisx + 392))
    {
        *(_DWORD*)(thisx + 380) = 0;
        *(_DWORD*)(thisx + 384) = 0;
    }
    else
    {
        *(_BYTE*)(thisx + 238) = 0;
    }
    if (*(_DWORD*)(thisx + 288) && (!*(_DWORD*)(thisx + 304) || sub_425D30(*(_DWORD**)(thisx + 304))))
    {
        *(_DWORD*)(thisx + 304) = 0;
        *(_DWORD*)(thisx + 288) = 0;
    }
    if (*(_BYTE*)(thisx + 178))
    {
        if (*(_DWORD*)(thisx + 164))
        {
            sub_4181B5(thisx + 8);
            v61 = *(char*)(thisx + 149);
            v58 = *(char*)(thisx + 150);
            v59 = *(char*)(thisx + 151);
            v55 = *(char*)(thisx + 152);
            v48 = *(char*)(thisx + 153);
            v53 = v48;
            v65 = *(char*)(thisx + 154);
            for (i = 0; i < 3; ++i)
            {
                if (*(_BYTE*)(i + thisx + 151))
                {
                    if (*(char*)(i + thisx + 230) < 0)
                        *(_BYTE*)(i + thisx + 230) = 0;
                    if (++ * (_BYTE*)(i + thisx + 230) == 6)
                        *(_BYTE*)(i + thisx + 230) = 5;
                }
                else if (*(char*)(i + thisx + 230) <= 0)
                {
                    if ((char)-- * (_BYTE*)(i + thisx + 230) == -6)
                        *(_BYTE*)(i + thisx + 230) = -5;
                }
                else
                {
                    *(_BYTE*)(i + thisx + 230) = 0;
                }
            }
        }
        else
        {
            if (dword_4B9974)
            {
                v61 = (char)sub_425D90(v67);
                v58 = (char)sub_425DB0(v67);
            }
            else
            {
                sub_476009((int*)&player_list[27 * *(unsigned __int8*)(thisx + 184)]);
                v2 = sub_476A79((int*)&player_list[27 * *(unsigned __int8*)(thisx + 184)]);
                v61 = v2 - sub_476A64((int*)&player_list[27 * *(unsigned __int8*)(thisx + 184)]);
                v3 = sub_476A4F((int*)&player_list[27 * *(unsigned __int8*)(thisx + 184)]);
                v58 = v3 - sub_476A3A((int*)&player_list[27 * *(unsigned __int8*)(thisx + 184)]);
            }
            for (j = 0; j < 6; ++j)
            {
                v45 = 0;
                if (dword_4B9974)
                {
                    if (j >= 3)
                    {
                        if (j == 5)
                            v45 = sub_425DD0(v67, 3);
                    }
                    else
                    {
                        v45 = sub_425DD0(v67, j);
                    }
                }
                else
                {
                    v45 = sub_476485((int*)&player_list[27 * *(unsigned __int8*)(thisx + 184)], j);
                }
                if (v45)
                {
                    if (*(char*)(j + thisx + 230) < 0)
                        *(_BYTE*)(j + thisx + 230) = 0;
                    if (++ * (_BYTE*)(j + thisx + 230) == 6)
                        *(_BYTE*)(j + thisx + 230) = 5;
                }
                else if (*(char*)(j + thisx + 230) <= 0)
                {
                    if ((char)-- * (_BYTE*)(j + thisx + 230) == -6)
                        *(_BYTE*)(j + thisx + 230) = -5;
                }
                else
                {
                    *(_BYTE*)(j + thisx + 230) = 0;
                }
            }
            if (*(char*)(thisx + 233) > 0)
            {
                *(_BYTE*)(thisx + 230) = *(_BYTE*)(thisx + 233);
                *(_BYTE*)(thisx + 231) = *(_BYTE*)(thisx + 233);
            }
            if (*(char*)(thisx + 234) > 0)
            {
                *(_BYTE*)(thisx + 230) = *(_BYTE*)(thisx + 234);
                *(_BYTE*)(thisx + 232) = *(_BYTE*)(thisx + 234);
            }
            for (k = 0; k < 3; ++k)
                *(_BYTE*)(k + thisx + 226) = *(char*)(k + thisx + 230) > 0;
            *(_BYTE*)(thisx + 229) = *(char*)(thisx + 235) > 0;
            v26 = *(char*)(thisx + 230) > 0 && *(char*)(thisx + 230) < 5;
            v59 = v26;
            v25 = *(char*)(thisx + 231) > 0 && *(char*)(thisx + 231) < 5;
            v55 = v25;
            v53 = *(char*)(thisx + 232) > 0;
            v24 = *(char*)(thisx + 232) > 0 && *(char*)(thisx + 232) < 5;
            v48 = v24;
            v65 = *(char*)(thisx + 235) > 0;
        }
    }
    else
    {
        if (*(_DWORD*)(thisx + 428) == 10)
            v61 = (*(_DWORD*)(thisx + 424) == 0) - *(_DWORD*)(thisx + 424);
        if (*(_DWORD*)(thisx + 428) == 82)
            v55 = 1;
        for (m = 0; m < 3; ++m)
            *(_BYTE*)(m + thisx + 230) = 0;
    }
    if (*(char*)(thisx + 224) <= 0)
        v23 = (*(char*)(thisx + 224) >= 0) - 1;
    else
        v23 = 1;
    if (v61 <= 0)
        v22 = (v61 >= 0) - 1;
    else
        v22 = 1;
    if (v23 == v22)
    {
        if (*(char*)(thisx + 224) <= 0)
            v21 = -*(char*)(thisx + 224);
        else
            v21 = *(char*)(thisx + 224);
        if (v21 < 5)
            *(_BYTE*)(thisx + 224) += v61;
    }
    else
    {
        *(_BYTE*)(thisx + 224) = v61;
    }
    if (*(char*)(thisx + 225) <= 0)
        v20 = (*(char*)(thisx + 225) >= 0) - 1;
    else
        v20 = 1;
    if (v58 <= 0)
        v19 = (v58 >= 0) - 1;
    else
        v19 = 1;
    if (v20 == v19)
    {
        if (*(char*)(thisx + 225) <= 0)
            v18 = -*(char*)(thisx + 225);
        else
            v18 = *(char*)(thisx + 225);
        if (v18 < 5)
            *(_BYTE*)(thisx + 225) += v58;
    }
    else
    {
        *(_BYTE*)(thisx + 225) = v58;
    }
    if (byte_4B99C8 && v65 && (v59 || v55 || v53) && !*(_BYTE*)(thisx + 556))
    {
        if (v59)
        {
            *(_BYTE*)(thisx + 556) = 1;
        }
        else if (v55)
        {
            *(_BYTE*)(thisx + 556) = 2;
        }
        else
        {
            *(_BYTE*)(thisx + 556) = 3;
        }
        if (v59)
            *(_BYTE*)(thisx + 230) = 5;
        if (v55)
            *(_BYTE*)(thisx + 231) = 5;
        if (v59 && v55)
            *(_BYTE*)(thisx + 233) = 5;
        if (v59 && v48)
            *(_BYTE*)(thisx + 234) = 5;
        *(_BYTE*)(thisx + 557) = 60;
        sub_43FFC3((int*)unk_4BDB28, dword_4B9AB4, -1, 100, 100, 0);
        v42 = (char*)sub_46622B((char*)unk_4B9B10, (char*)thisx, *(_BYTE*)(thisx + 556));
        if (v42 && sub_41BEA6((_DWORD*)thisx))
        {
            if (v59)
            {
                sub_421175((_DWORD*)(thisx + 8), 8, 600, (int)v42);
            }
            else if (v55)
            {
                sub_421175((_DWORD*)(thisx + 8), 7, 600, (int)v42);
            }
        }
        v59 = 0;
        v55 = 0;
    }
    if (*(int*)(thisx + 172) > 0)
    {
        if ((int)-- * (_DWORD*)(thisx + 172) <= 0)
        {
            *(_BYTE*)(thisx + 177) = 0;
            *(_BYTE*)(thisx + 176) = 0;
        }
        else
        {
            *(_BYTE*)(thisx + 177) = 1;
            v41 = 6;
            if (*(int*)(thisx + 172) < 300)
                v41 = *(_DWORD*)(thisx + 172) / 60 + 1;
            *(_BYTE*)(thisx + 176) = *(_DWORD*)(thisx + 172) / v41 % 2;
        }
    }
    if (*(_BYTE*)(thisx + 470))
    {
        if (*(_DWORD*)(thisx + 164))
        {
            if (!(*(_DWORD*)(thisx + 444) % 3))
                --* (_BYTE*)(thisx + 470);
        }
        else if (v59 || v55)
        {
            --* (_BYTE*)(thisx + 470);
        }
    }
    if (*(_DWORD*)(thisx + 412))
    {
        if (v61 <= 0)
        {
            if (v61 < 0)
                *(_DWORD*)(thisx + 424) = 0;
        }
        else
        {
            *(_DWORD*)(thisx + 424) = 1;
        }
    }
    if (v61)
    {
        *(_BYTE*)(thisx + 418) = 0;
        if (*(char*)(thisx + 417) <= 0)
            v17 = (*(char*)(thisx + 417) >= 0) - 1;
        else
            v17 = 1;
        if (v17 == v61)
        {
            *(_BYTE*)(thisx + 417) += v61;
        }
        else
        {
            *(_BYTE*)(thisx + 416) = 0;
            *(_BYTE*)(thisx + 417) = v61;
        }
        if (*(char*)(thisx + 417) <= 0)
            v16 = -*(char*)(thisx + 417);
        else
            v16 = *(char*)(thisx + 417);
        if (v16 >= 10)
        {
            *(_BYTE*)(thisx + 416) = 0;
        }
        else if (*(_BYTE*)(thisx + 416) == 2)
        {
            *(_BYTE*)(thisx + 416) = -1;
        }
        else
        {
            *(_BYTE*)(thisx + 416) = 1;
            *(_BYTE*)(thisx + 418) = 0;
        }
    }
    else
    {
        if (*(char*)(thisx + 417) <= 0)
            v15 = (*(char*)(thisx + 417) >= 0) - 1;
        else
            v15 = 1;
        *(_BYTE*)(thisx + 417) = v15;
        if ((char)++ * (_BYTE*)(thisx + 418) <= 10)
        {
            if (*(_BYTE*)(thisx + 416) == 1)
                *(_BYTE*)(thisx + 416) = 2;
        }
        else
        {
            *(_BYTE*)(thisx + 416) = 0;
        }
    }
    if (v58 <= 0)
    {
        if (v58)
        {
            *(_BYTE*)(thisx + 419) = 0;
        }
        else
        {
            *(_BYTE*)(thisx + 421) = 0;
            if ((char)++ * (_BYTE*)(thisx + 422) < 20 && *(_BYTE*)(thisx + 419) == 1)
            {
                *(_BYTE*)(thisx + 419) = 2;
            }
            else if (*(char*)(thisx + 422) >= 20)
            {
                *(_BYTE*)(thisx + 419) = 0;
            }
        }
    }
    else
    {
        *(_BYTE*)(thisx + 422) = 0;
        if ((char)++ * (_BYTE*)(thisx + 421) >= 10)
        {
            *(_BYTE*)(thisx + 419) = 0;
        }
        else if (*(_BYTE*)(thisx + 419) == 2)
        {
            *(_BYTE*)(thisx + 419) = -1;
        }
        else
        {
            *(_BYTE*)(thisx + 419) = 1;
        }
    }
    v54 = 0;
    if (*(unsigned __int8*)(thisx + 419) == 255
        && !*(_DWORD*)(thisx + 392)
        && *(_DWORD*)(thisx + 404)
        && !*(_DWORD*)(thisx + 304)
        && !*(_DWORD*)(thisx + 292)
        && !*(_DWORD*)(thisx + 480)
        && *(_DWORD*)(thisx + 428) != 69)
    {
        if (((v40 = sub_4464D3((int)unk_4B9B10, *(_DWORD*)(thisx + 328) / 800, *(_DWORD*)(thisx + 332) / 800), v40 == 1)
            || v40 == 3
            || v40 == 5)
            && !*(_DWORD*)(thisx + 424)
            || (v40 == 2 || v40 == 4 || v40 == 6) && *(_DWORD*)(thisx + 424))
        {
            v54 = 1;
        }
    }
    if (v58 >= 0)
    {
        if (v58)
        {
            *(_BYTE*)(thisx + 420) = 0;
        }
        else
        {
            *(_BYTE*)(thisx + 421) = 0;
            if ((char)++ * (_BYTE*)(thisx + 422) < 20 && *(_BYTE*)(thisx + 420) == 1)
            {
                *(_BYTE*)(thisx + 420) = 2;
            }
            else if (*(char*)(thisx + 422) >= 20)
            {
                *(_BYTE*)(thisx + 420) = 0;
            }
        }
    }
    else
    {
        *(_BYTE*)(thisx + 422) = 0;
        if ((char)++ * (_BYTE*)(thisx + 421) >= 10)
        {
            *(_BYTE*)(thisx + 420) = 0;
        }
        else if (*(_BYTE*)(thisx + 420) == 2)
        {
            *(_BYTE*)(thisx + 420) = -1;
        }
        else
        {
            *(_BYTE*)(thisx + 420) = 1;
        }
    }
    v66 = 0;
    if (!*(_DWORD*)(thisx + 480)
        && v59
        && v53
        && *(_DWORD*)(thisx + 408)
        && !*(_DWORD*)(thisx + 392)
        && *(_DWORD*)(thisx + 428) != 52
        && *(_DWORD*)(thisx + 428) != 53
        && *(_DWORD*)(thisx + 428) != 69
        && *(_DWORD*)(thisx + 428) != 10)
    {
        v66 = sub_447276((char*)unk_4B9B10, thisx);
    }
    if ((byte_4B99CA && *(int*)(thisx + 444) > 18 || !byte_4B99CA)
        && !v53
        && *(_DWORD*)(thisx + 428) == 77
        && !*(_DWORD*)(thisx + 340))
    {
        if (*(_DWORD*)(thisx + 392))
            *(_DWORD*)(thisx + 432) = 50;
        else
            *(_DWORD*)(thisx + 432) = 4;
        *(_DWORD*)(thisx + 444) = 0;
    }
    if (!*(_BYTE*)(thisx + 188)
        && !*(_DWORD*)(thisx + 304)
        && !*(_DWORD*)(thisx + 480)
        && (v59 || v55)
        && *(int*)(thisx + 428) > 2
        && *(int*)(thisx + 428) < 9)
    {
        *(_BYTE*)(thisx + 222) = 3;
        if (sub_41BA53(thisx, 0x85u, 0))
            *(_BYTE*)(thisx + 222) += 3;
    }
    v56 = 0;
    v52 = 0;
    if (*(_BYTE*)(thisx + 188) != 1
        && ((v59 || v55) && *(_DWORD*)(thisx + 428) != 10 || v48 && *(_DWORD*)(thisx + 428) == 10)
        && (*(_DWORD*)(thisx + 396)
            || *(_DWORD*)(thisx + 428) == 10
            || *(_DWORD*)(thisx + 428) == 7
            || *(_DWORD*)(thisx + 428) == 8)
        && !*(_DWORD*)(thisx + 304)
        && !*(_DWORD*)(thisx + 480))
    {
        if (!*(_DWORD*)(thisx + 392))
            v56 = (int*)sub_456B0D((unsigned char*)unk_4B9B10, (_DWORD*)thisx, 1);
        if (!*(_BYTE*)(thisx + 188) && !v56 && (*(_DWORD*)(thisx + 428) != 7 || *(int*)(thisx + 444) > 5))
            v52 = (Concurrency::details::SchedulerProxy*)sub_464229((char*)unk_4B9B10, (Concurrency::details::SchedulerBase*)thisx);
    }
    v68 = 0;
    if (v59)
        v68 = sub_446D6F((int*)unk_4B9B10, (Concurrency::details::SchedulerBase*)thisx);
    v62 = *(_DWORD*)(thisx + 428);
    if (v62 == 188)
        v62 = 10;
    *(_DWORD*)(thisx + 308) = 0;
    if (!*(_DWORD*)(thisx + 480)
        && *(unsigned __int8*)(thisx + 416) == 255
        && v62 == 10
        && sub_41BA53(thisx, 0x19u, 0)
        && !*(_DWORD*)(thisx + 288))
    {
        *(_DWORD*)(thisx + 308) = sub_457731((int*)unk_4B9B10, (_DWORD*)thisx);
    }
    v64 = *(_DWORD*)(thisx + 480) != 0;
    v49 = sub_41BA53(thisx, 0xAu, 0);
    if (sub_41BA53(thisx, 0x89u, 0))
    {
        if (*(_DWORD*)(thisx + 480))
        {
            LOBYTE(v4) = sub_425CB0(*(_BYTE**)(thisx + 480));
            if (sub_4771C5(3, v4))
                v64 = 0;
        }
    }
    if (*(_DWORD*)(thisx + 392))
    {
        if (v49)
        {
            v13 = !v64 && !v68 && !*(_BYTE*)(thisx + 177) && *(_DWORD*)(thisx + 404) && !*(_DWORD*)(thisx + 288);
            v50 = v13;
        }
        else
        {
            v50 = 0;
        }
    }
    else
    {
        v14 = !v64 && !v68 && !*(_BYTE*)(thisx + 177) && *(_DWORD*)(thisx + 396) && !*(_DWORD*)(thisx + 288);
        v50 = v14;
    }
    v51 = 0;
    if (!*(_BYTE*)(thisx + 188) && v48 && *(_DWORD*)(thisx + 428) == 10)
        v51 = (int*)sub_446814((int*)unk_4B9B10, (_DWORD*)thisx);
    v60 = 83;
    v63 = 0;
    if (*(_DWORD*)(thisx + 164))
        v63 = *(_DWORD*)(thisx + 16);
    if (v63 && *(_DWORD*)(thisx + 404))
    {
        if (*(_BYTE*)(thisx + 188) == 2)
        {
            if (v63 == 1)
            {
                v60 = 155;
            }
            else if ((v63 == 2 || v63 == 3) && *(__int16*)(thisx + 600) >= 100)
            {
                if (v63 == 2)
                    v60 = 204;
                else
                    v60 = 205;
            }
        }
        else if (*(_BYTE*)(thisx + 188) == 3)
        {
            if (v63 == 1)
            {
                v60 = 156;
            }
            else if ((v63 == 2 || v63 == 3) && *(__int16*)(thisx + 600) >= 100)
            {
                if (v63 == 2)
                    v60 = 206;
                else
                    v60 = 205;
            }
        }
    }
    v12 = *(_DWORD*)(thisx + 428) == 13 && *(int*)(thisx + 444) >= 2 || *(char*)(thisx + 608) > 0;
    if (*(char*)(thisx + 608) > 0 && v53)
    {
        v61 = 0;
        v58 = 0;
    }
    if (v58 < 0 && *(_DWORD*)(thisx + 428) == 69)
    {
        if (*(_DWORD*)(thisx + 304))
            sub_417EAD((int*)*(_DWORD*)(thisx + 304));
        sub_417E88((int*)thisx);
        *(_DWORD*)(thisx + 432) = 6;
        goto LABEL_921;
    }
    if (v60 != 83)
    {
        *(_DWORD*)(thisx + 432) = v60;
        goto LABEL_921;
    }
    if (!v61 && !v58 && *(_DWORD*)(thisx + 428) == 6)
    {
        *(_DWORD*)(thisx + 432) = 3;
        *(_DWORD*)(thisx + 444) = 0;
        goto LABEL_921;
    }
    if (!v61 && !v58 && *(_DWORD*)(thisx + 428) == 56)
    {
        *(_DWORD*)(thisx + 432) = 53;
        *(_DWORD*)(thisx + 444) = 0;
        goto LABEL_921;
    }
    if (*(_DWORD*)(thisx + 392)
        && v58 > 0
        && v59
        && v55
        && (*(_DWORD*)(thisx + 404)
            || *(int*)(thisx + 444) < 4 && (*(_DWORD*)(thisx + 428) == 128 || *(_DWORD*)(thisx + 428) == 127))
        && !*(_DWORD*)(thisx + 480)
        && !*(_DWORD*)(thisx + 304)
        && (*(_DWORD*)(thisx + 524) || sub_41BA53(thisx, 0x26u, 0)))
    {
        *(_DWORD*)(thisx + 432) = 95;
        goto LABEL_921;
    }
    if (v59 && v55 && *(_DWORD*)(thisx + 400))
    {
        *(_DWORD*)(thisx + 444) = 0;
        *(_DWORD*)(thisx + 396) = 0;
        *(_DWORD*)(thisx + 404) = 0;
        *(_DWORD*)(thisx + 400) = 0;
        if (*(_BYTE*)(thisx + 237) && *(_DWORD*)(thisx + 392)
            || v62 == 10
            || v62 == 125
            || v62 == 8
            || v62 == 126
            || v62 == 131
            || v62 == 166
            || v62 == 97)
        {
            *(_DWORD*)(thisx + 432) = 8;
            *(_DWORD*)(thisx + 348) = -(3 * sub_41D067(thisx, 0) / 2 + 405);
            *(_DWORD*)(thisx + 344) = 50 * v58;
            *(_BYTE*)(thisx + 236) = 3;
        }
        else
        {
            *(_DWORD*)(thisx + 432) = 7;
            *(_DWORD*)(thisx + 348) = -(3 * sub_41D067(thisx, 0) / 2 + 405);
            if (!*(_DWORD*)(thisx + 392))
            {
                *(_DWORD*)(thisx + 340) = 150 * v61;
                *(_DWORD*)(thisx + 344) = 50 * v58;
            }
            if (v61)
                *(_BYTE*)(thisx + 236) = 2;
            else
                *(_BYTE*)(thisx + 236) = 1;
        }
        if (!*(_DWORD*)(thisx + 392))
        {
            *(_DWORD*)(thisx + 372) += *(_DWORD*)(thisx + 364);
            *(_DWORD*)(thisx + 376) += *(_DWORD*)(thisx + 368);
        }
        *(_DWORD*)(thisx + 360) = 30;
        *(_DWORD*)(thisx + 352) = 0;
        *(_DWORD*)(thisx + 356) = 0;
        if (*(_DWORD*)(thisx + 292))
        {
            if (*(_DWORD*)(thisx + 304))
                sub_417E1D(*(_DWORD**)(thisx + 304));
            *(_DWORD*)(thisx + 304) = 0;
            *(_DWORD*)(thisx + 292) = 0;
        }
        goto LABEL_921;
    }
    if (*(_BYTE*)(thisx + 188) != 1 && byte_4B99CA && (v59 || v55) && v50 && sub_463F66((char*)unk_4B9B10, (_BYTE*)thisx))
    {
        *(_DWORD*)(thisx + 432) = 77;
        *(_BYTE*)(thisx + 221) = 0;
        *(_DWORD*)(thisx + 444) = 0;
        goto LABEL_921;
    }
    if (v56)
    {
        *(_DWORD*)(thisx + 432) = 27;
        sub_41E5C9(thisx, v56);
        goto LABEL_921;
    }
    if (v52)
    {
        if (*(_DWORD*)(thisx + 392) || unknown_libname_12((int*)v52) == 2 || unknown_libname_12((int*)v52) == 5)
        {
            sub_43FFC3((int*)unk_4BDB28, dword_4B9A1C, -1, 100, 100, 0);
            if (v59)
                *(_BYTE*)(thisx + 230) = 5;
            if (v55)
                *(_BYTE*)(thisx + 231) = 5;
            if (v59 && v55)
                *(_BYTE*)(thisx + 233) = 5;
            if (v59 && v48)
                *(_BYTE*)(thisx + 234) = 5;
        }
        else
        {
            sub_43FFC3((int*)unk_4BDB28, dword_4B9A74, -1, 100, 100, 0);
            *(_DWORD*)(thisx + 432) = 28;
        }
        sub_41F24C(thisx, v52);
        goto LABEL_921;
    }
    if (v66)
    {
        *(_DWORD*)(thisx + 280) = 1;
        *(_DWORD*)(thisx + 304) = (int)v66;
        if (sub_425D70((int*)v66) == *(_DWORD*)(thisx + 424))
            *(_DWORD*)(thisx + 432) = 58;
        else
            *(_DWORD*)(thisx + 432) = 57;
        sub_41B6CF(*(_DWORD**)(thisx + 304), thisx, 1);
        *(_BYTE*)(thisx + 258) = 2;
        goto LABEL_921;
    }
    if (*(_DWORD*)(thisx + 428) == 15 && *(unsigned __int8*)(thisx + 420) == 255 && sub_41BA53(thisx, 0x27u, 0))
    {
        *(_DWORD*)(thisx + 432) = 96;
        goto LABEL_921;
    }
    if (v54)
    {
        *(_DWORD*)(thisx + 432) = 131;
        *(_DWORD*)(thisx + 444) = 0;
        *(_DWORD*)(thisx + 372) = 300 * *(_DWORD*)(thisx + 424) - 300 * (*(_DWORD*)(thisx + 424) == 0);
        *(_DWORD*)(thisx + 352) = *(_DWORD*)(thisx + 372) / -30;
        goto LABEL_921;
    }
    if ((!*(_DWORD*)(thisx + 304)
        || *(_DWORD*)(thisx + 428) == 3
        || *(_DWORD*)(thisx + 428) == 4
        || *(_DWORD*)(thisx + 428) == 5)
        && *(unsigned __int8*)(thisx + 419) == 255
        && sub_41BA53(thisx, 0x23u, 0)
        && *(_DWORD*)(thisx + 404)
        && !*(_DWORD*)(thisx + 288)
        && !*(_DWORD*)(thisx + 480))
    {
        *(_DWORD*)(thisx + 432) = 177;
        goto LABEL_921;
    }
    if (!*(_DWORD*)(thisx + 480)
        && *(unsigned __int8*)(thisx + 416) == 255
        && *(_DWORD*)(thisx + 428) == 10
        && sub_41BA53(thisx, 0x36u, 0)
        && !*(_DWORD*)(thisx + 288))
    {
        *(_DWORD*)(thisx + 432) = 188;
        goto LABEL_921;
    }
    if (*(_DWORD*)(thisx + 308))
    {
        *(_DWORD*)(thisx + 432) = 167;
        goto LABEL_921;
    }
    if (!*(_DWORD*)(thisx + 480)
        && !*(_DWORD*)(thisx + 288)
        && *(_BYTE*)(thisx + 225) == 1
        && *(_DWORD*)(thisx + 428) == 8
        && sub_41BA53(thisx, 7u, 0))
    {
        *(_DWORD*)(thisx + 432) = 150;
        goto LABEL_921;
    }
    if (sub_41BA53(thisx, 0x14u, 0)
        && !*(_DWORD*)(thisx + 288)
        && *(char*)(thisx + 231) <= -2
        && *(char*)(thisx + 232) <= -2
        && *(_BYTE*)(thisx + 230) == 5
        && *(_DWORD*)(thisx + 404)
        && (!*(_DWORD*)(thisx + 304) || *(_DWORD*)(thisx + 428) == 4 || *(_DWORD*)(thisx + 428) == 5)
        && !*(_DWORD*)(thisx + 480))
    {
        *(_DWORD*)(thisx + 432) = 91;
        goto LABEL_921;
    }
    if (sub_41BA53(thisx, 0x15u, 0)
        && !*(_DWORD*)(thisx + 288)
        && *(char*)(thisx + 231) <= -2
        && *(char*)(thisx + 232) <= -2
        && *(_BYTE*)(thisx + 230) == 5
        && *(_DWORD*)(thisx + 404)
        && (!*(_DWORD*)(thisx + 304)
            || *(_DWORD*)(thisx + 428) == 3
            || *(_DWORD*)(thisx + 428) == 4
            || *(_DWORD*)(thisx + 428) == 5)
        && !*(_DWORD*)(thisx + 480))
    {
        *(_DWORD*)(thisx + 432) = 92;
        goto LABEL_921;
    }
    if (!*(_DWORD*)(thisx + 480) && !*(_DWORD*)(thisx + 288) && v59 && v12 && sub_41BA53(thisx, 4u, 0))
    {
        *(_DWORD*)(thisx + 432) = 147;
        goto LABEL_921;
    }
    if (!*(_DWORD*)(thisx + 288) && v59 && v12 && sub_41BA53(thisx, 0xDu, 0) && !*(_DWORD*)(thisx + 480))
    {
        *(_DWORD*)(thisx + 432) = 156;
        goto LABEL_921;
    }
    if (!*(_DWORD*)(thisx + 288)
        && v59
        && v12
        && sub_41BA53(thisx, 0xFu, 0)
        && (!*(_DWORD*)(thisx + 480) || sub_494AA9(*(_BYTE**)(thisx + 480), 2)))
    {
        *(_DWORD*)(thisx + 432) = 158;
        goto LABEL_921;
    }
    if (!*(_DWORD*)(thisx + 288) && v59 && v12 && sub_41BA53(thisx, 0x48u, 0))
    {
        *(_DWORD*)(thisx + 436) = 0;
        *(_DWORD*)(thisx + 432) = 200;
        goto LABEL_921;
    }
    if (!*(_DWORD*)(thisx + 480)
        && !*(_DWORD*)(thisx + 288)
        && v59
        && *(char*)(thisx + 225) > 0
        && *(_DWORD*)(thisx + 404)
        && *(_DWORD*)(thisx + 392)
        && sub_41BA53(thisx, 0x25u, 0))
    {
        *(_DWORD*)(thisx + 432) = 179;
        goto LABEL_921;
    }
    if (v59 && *(_DWORD*)(thisx + 404))
    {
        v39 = 0;
        v38 = 0;
        if (!*(_BYTE*)(thisx + 188) && !v68)
            v39 = (int*)sub_446814((int*)unk_4B9B10, (_DWORD*)thisx);
        if (!*(_BYTE*)(thisx + 188) && !v68 && !v39)
            v38 = (int*)sub_446A62((int*)unk_4B9B10, (_DWORD*)thisx, 0);
        if (*(_DWORD*)(thisx + 428) == 52)
        {
            *(_DWORD*)(thisx + 432) = 57;
            *(_BYTE*)(thisx + 258) = 0;
            if (!*(_DWORD*)(thisx + 304))
            {
            LABEL_517:
                sub_417DCC(thisx);
            LABEL_608:
                if (*(_DWORD*)(thisx + 432) == 124 || *(_DWORD*)(thisx + 432) == 128)
                {
                    if (*(_BYTE*)(thisx + 476))
                    {
                        *(_DWORD*)(thisx + 432) = 163;
                    }
                    else if (sub_41BA53(thisx, 2u, 0))
                    {
                        *(_DWORD*)(thisx + 432) = 145;
                    }
                    else if (sub_41BA53(thisx, 0x2Fu, 0))
                    {
                        *(_DWORD*)(thisx + 432) = 182;
                    }
                    else if (sub_41BA53(thisx, 0x12u, 0))
                    {
                        *(_DWORD*)(thisx + 432) = 160;
                    }
                }
                goto LABEL_803;
            }
        }
        else
        {
            if (*(_DWORD*)(thisx + 428) != 53 && *(_DWORD*)(thisx + 428) != 56)
            {
                if (*(_DWORD*)(thisx + 428) == 82 && *(_DWORD*)(thisx + 312))
                {
                    if (*(_DWORD*)(thisx + 4) && sub_43F0C8((int*)*(_DWORD*)(thisx + 4)))
                    {
                        *(_DWORD*)(thisx + 432) = 85;
                        *(_DWORD*)(thisx + 320) = 1;
                        *(_DWORD*)(thisx + 304) = *(_DWORD*)(thisx + 312);
                        sub_42101A((int*)*(_DWORD*)(thisx + 304));
                    }
                    else
                    {
                        *(_DWORD*)(thisx + 432) = 57;
                        *(_BYTE*)(thisx + 258) = 0;
                        *(_DWORD*)(thisx + 304) = *(_DWORD*)(thisx + 312);
                        sub_421051(*(_DWORD**)(thisx + 304));
                        sub_41B6F5(thisx);
                    }
                }
                else if (*(_DWORD*)(thisx + 428) == 69)
                {
                    *(_DWORD*)(thisx + 432) = 70;
                    *(_DWORD*)(thisx + 444) = 0;
                }
                else if (*(_DWORD*)(thisx + 480))
                {
                    if (!*(_BYTE*)(thisx + 473))
                    {
                        if (sub_425CB0(*(_BYTE**)(thisx + 480)) == 12)
                        {
                            *(_DWORD*)(thisx + 432) = 143;
                        }
                        else if (sub_41BA53(thisx, 0x20u, 0) && sub_494AA9(*(_BYTE**)(thisx + 480), 1))
                        {
                            *(_DWORD*)(thisx + 432) = 174;
                        }
                        else if (sub_41BA53(thisx, 0x21u, 0) && sub_494AA9(*(_BYTE**)(thisx + 480), 1))
                        {
                            *(_DWORD*)(thisx + 432) = 175;
                        }
                        else if (sub_41BA53(thisx, 2u, 0) && sub_425CB0(*(_BYTE**)(thisx + 480)) == 1)
                        {
                            *(_DWORD*)(thisx + 432) = 145;
                        }
                        else if (sub_41BA53(thisx, 0x2Fu, 0) && sub_425CB0(*(_BYTE**)(thisx + 480)) == 1)
                        {
                            *(_DWORD*)(thisx + 432) = 182;
                        }
                        else if (sub_41BA53(thisx, 0x1Cu, 0))
                        {
                            *(_DWORD*)(thisx + 432) = 170;
                        }
                        else if (sub_425CB0(*(_BYTE**)(thisx + 480)) == 1
                            && sub_474032((char*)unk_4B9B10, (Concurrency::details::SchedulerBase*)thisx)
                            && !*(_DWORD*)(thisx + 392))
                        {
                            *(_DWORD*)(thisx + 432) = 134;
                        }
                        else
                        {
                            *(_DWORD*)(thisx + 432) = 142;
                        }
                    }
                }
                else if (*(_DWORD*)(thisx + 288))
                {
                    if (*(_DWORD*)(thisx + 392))
                        *(_DWORD*)(thisx + 432) = 66;
                    else
                        *(_DWORD*)(thisx + 432) = 65;
                    if (*(_DWORD*)(thisx + 304)
                        || (*(_DWORD*)(thisx + 304) = sub_465804((int*)unk_4B9B10, (int*)thisx)) != 0
                        && sub_425D50((int*)*(_DWORD*)(thisx + 304)))
                    {
                        sub_41745B(*(_DWORD**)(thisx + 304), *(_BYTE*)(thisx + 184));
                    }
                    else
                    {
                        sub_417E1D((_DWORD*)thisx);
                    }
                }
                else if (v68)
                {
                    *(_DWORD*)(thisx + 280) = 1;
                    *(_DWORD*)(thisx + 432) = 57;
                    *(_BYTE*)(thisx + 258) = 1;
                    *(_DWORD*)(thisx + 304) = (int)v68;
                    sub_41B6CF(v68, thisx, 1);
                }
                else if (v62 == 10)
                {
                    if (sub_41BA53(thisx, 0x17u, 0))
                    {
                        *(_DWORD*)(thisx + 432) = 165;
                    }
                    else if (sub_41BA53(thisx, 0x18u, 0))
                    {
                        *(_DWORD*)(thisx + 432) = 166;
                    }
                    else if (sub_41BA53(thisx, 0x28u, 0))
                    {
                        *(_DWORD*)(thisx + 432) = 97;
                    }
                    else if (sub_41BA53(thisx, 0x35u, 0))
                    {
                        *(_DWORD*)(thisx + 436) = *(_DWORD*)(thisx + 444);
                        *(_DWORD*)(thisx + 432) = 187;
                    }
                    else
                    {
                        *(_DWORD*)(thisx + 432) = 126;
                    }
                }
                else if (!sub_474032((char*)unk_4B9B10, (Concurrency::details::SchedulerBase*)thisx) || *(_DWORD*)(thisx + 392))
                {
                    if (*(_DWORD*)(thisx + 428) == 7 && *(int*)(thisx + 348) > 0 && sub_41BA53(thisx, 9u, 0))
                    {
                        *(_DWORD*)(thisx + 432) = 152;
                    }
                    else if ((*(_DWORD*)(thisx + 428) == 7 && *(_BYTE*)(thisx + 236) == 2 || *(_DWORD*)(thisx + 428) == 8)
                        && sub_41BA53(thisx, 0x11u, 0))
                    {
                        *(_DWORD*)(thisx + 432) = 159;
                    }
                    else if (*(_DWORD*)(thisx + 428) == 7 && *(_BYTE*)(thisx + 236) == 1 && sub_41BA53(thisx, 0x13u, 0))
                    {
                        *(_DWORD*)(thisx + 432) = 161;
                    }
                    else if (*(_DWORD*)(thisx + 428) == 8)
                    {
                        if (sub_41BA53(thisx, 0x17u, 0))
                        {
                            *(_DWORD*)(thisx + 432) = 165;
                        }
                        else if (!sub_41BA53(thisx, 0x28u, 0) || sub_41BA53(thisx, 0x29u, 0))
                        {
                            *(_DWORD*)(thisx + 432) = 130;
                        }
                        else
                        {
                            *(_DWORD*)(thisx + 432) = 97;
                        }
                    }
                    else if (*(_DWORD*)(thisx + 428) == 7 || *(_DWORD*)(thisx + 428) == 50 || *(_DWORD*)(thisx + 428) == 51)
                    {
                        *(_DWORD*)(thisx + 432) = 128;
                    }
                    else if (v39)
                    {
                        *(_DWORD*)(thisx + 432) = 64;
                        *(_DWORD*)(thisx + 288) = 1;
                        *(_DWORD*)(thisx + 304) = (int)v39;
                    }
                    else if (v38)
                    {
                        *(_DWORD*)(thisx + 432) = 133;
                    }
                    else
                    {
                        *(_DWORD*)(thisx + 432) = 124;
                    }
                }
                else
                {
                    *(_DWORD*)(thisx + 436) = 0;
                    *(_DWORD*)(thisx + 432) = 134;
                }
                goto LABEL_608;
            }
            *(_DWORD*)(thisx + 432) = 58;
            *(_BYTE*)(thisx + 258) = 0;
            if (!*(_DWORD*)(thisx + 304))
                goto LABEL_517;
        }
        sub_41B6F5(thisx);
        goto LABEL_608;
    }
    if (!*(_DWORD*)(thisx + 288) && v55 && v12 && sub_41BA53(thisx, 3u, 0) && !*(_DWORD*)(thisx + 480))
    {
        *(_DWORD*)(thisx + 432) = 146;
        goto LABEL_921;
    }
    if (!*(_DWORD*)(thisx + 288) && v55 && v12 && sub_41BA53(thisx, 0xCu, 0) && !*(_DWORD*)(thisx + 480))
    {
        *(_DWORD*)(thisx + 432) = 155;
        goto LABEL_921;
    }
    if (!*(_DWORD*)(thisx + 288) && v55 && v12 && sub_41BA53(thisx, 0x48u, 0))
    {
        *(_DWORD*)(thisx + 436) = 1;
        *(_DWORD*)(thisx + 432) = 200;
        goto LABEL_921;
    }
    if (!v55 || !*(_DWORD*)(thisx + 404))
    {
        if (v51)
        {
            *(_DWORD*)(thisx + 432) = 64;
            *(_DWORD*)(thisx + 288) = 1;
            *(_DWORD*)(thisx + 304) = (int)v51;
        }
        else if (*(_BYTE*)(thisx + 188) == 1 || !v53 || !v50 || *(_BYTE*)(thisx + 608))
        {
            if ((*(_DWORD*)(thisx + 424) && v61 < 0 || !*(_DWORD*)(thisx + 424) && v61 > 0) && *(_DWORD*)(thisx + 428) == 10)
            {
                *(_DWORD*)(thisx + 432) = 11;
                *(_DWORD*)(thisx + 444) = 0;
                *(_BYTE*)(thisx + 237) = 0;
            }
            else if (*(_DWORD*)(thisx + 428) != 11 && *(_DWORD*)(thisx + 428) != 188)
            {
                if (*(_DWORD*)(thisx + 428) == 10)
                {
                    v35 = 3 * sub_41CA5F(thisx, 0) + 20;
                    if (v35 < 50)
                        v35 = 50;
                    *(_DWORD*)(thisx + 340) = v35 * *(_DWORD*)(thisx + 424) - v35 * (*(_DWORD*)(thisx + 424) == 0);
                    *(_DWORD*)(thisx + 380) = *(_DWORD*)(thisx + 340);
                    *(_DWORD*)(thisx + 344) = v35 * v58 / 3;
                    *(_DWORD*)(thisx + 384) = *(_DWORD*)(thisx + 344);
                    *(_DWORD*)(thisx + 352) = *(_DWORD*)(thisx + 340) / -30;
                    if (*(int*)(thisx + 344) <= 0)
                        v11 = (*(_DWORD*)(thisx + 344) >= 0) - 1;
                    else
                        v11 = 1;
                    *(_DWORD*)(thisx + 356) = *(_DWORD*)(thisx + 344) / -30 - v11 * (*(_DWORD*)(thisx + 344) % 30 != 0);
                }
                else if (v61
                    && (*(char*)(thisx + 417) <= 0 ? (v10 = (*(char*)(thisx + 417) >= 0) - 1) : (v10 = 1),
                        v61 == v10
                        && *(unsigned __int8*)(thisx + 416) == 255
                        && *(_DWORD*)(thisx + 396)
                        && !*(_DWORD*)(thisx + 292)))
                {
                    *(_DWORD*)(thisx + 432) = 10;
                    *(_DWORD*)(thisx + 444) = 0;
                    v34 = 3 * sub_41CA5F(thisx, 0) + 20;
                    if (v34 < 50)
                        v34 = 50;
                    *(_DWORD*)(thisx + 340) = v34 * v61;
                    *(_DWORD*)(thisx + 380) = *(_DWORD*)(thisx + 340);
                    *(_DWORD*)(thisx + 344) = v34 * v58 / 3;
                    *(_DWORD*)(thisx + 384) = *(_DWORD*)(thisx + 344);
                    *(_DWORD*)(thisx + 352) = -10 * v61;
                    *(_DWORD*)(thisx + 356) = -3 * v58;
                    *(_DWORD*)(thisx + 396) = 0;
                    *(_BYTE*)(thisx + 237) = 1;
                }
                else if ((!*(_BYTE*)(thisx + 178) || v59) && *(_DWORD*)(thisx + 428) == 94 && *(int*)(thisx + 444) > 60)
                {
                    *(_DWORD*)(thisx + 432) = 176;
                }
                else if ((!*(_DWORD*)(thisx + 304)
                    || *(_DWORD*)(thisx + 428) == 3
                    || *(_DWORD*)(thisx + 428) == 4
                    || *(_DWORD*)(thisx + 428) == 5)
                    && *(unsigned __int8*)(thisx + 420) == 255
                    && sub_41BA53(thisx, 0x22u, 0)
                    && *(_DWORD*)(thisx + 404)
                    && !*(_DWORD*)(thisx + 288)
                    && !*(_DWORD*)(thisx + 480))
                {
                    *(_DWORD*)(thisx + 432) = 94;
                }
                else if ((v61 || v58) && (*(_DWORD*)(thisx + 428) == 7 || *(_DWORD*)(thisx + 428) == 8))
                {
                    *(_DWORD*)(thisx + 372) += 3 * v61;
                    *(_DWORD*)(thisx + 376) += 3 * v58;
                }
                else if ((v61 || v58) && (*(_DWORD*)(thisx + 428) == 53 || *(_DWORD*)(thisx + 428) == 56))
                {
                    if (*(_DWORD*)(thisx + 428) != 56)
                        *(_DWORD*)(thisx + 444) = 0;
                    *(_DWORD*)(thisx + 432) = 56;
                    v33 = sub_4224A7((void*)thisx);
                    *(_DWORD*)(thisx + 372) = v33 * v61;
                    *(_DWORD*)(thisx + 376) = 7 * v33 * v58 / 10;
                    if (v61)
                        *(_DWORD*)(thisx + 424) = v61 > 0;
                }
                else if (!v61 && !v58
                    || *(_DWORD*)(thisx + 392)
                    || *(_DWORD*)(thisx + 480)
                    || (*(_DWORD*)(thisx + 428) != 77 || *(unsigned __int8*)(thisx + 221) < 5u)
                    && (*(char*)(thisx + 608) <= 0 || v53))
                {
                    if ((v61 || v58) && *(_DWORD*)(thisx + 396) && !*(_DWORD*)(thisx + 292))
                    {
                        if (*(_DWORD*)(thisx + 428) != 6)
                            *(_DWORD*)(thisx + 444) = 0;
                        *(_DWORD*)(thisx + 432) = 6;
                        v31 = sub_4224A7((void*)thisx);
                        *(_DWORD*)(thisx + 340) = v31 * v61;
                        *(_DWORD*)(thisx + 380) = *(_DWORD*)(thisx + 340);
                        *(_DWORD*)(thisx + 344) = 7 * v31 * v58 / 10;
                        *(_DWORD*)(thisx + 384) = *(_DWORD*)(thisx + 344);
                        *(_DWORD*)(thisx + 352) = 0;
                        *(_DWORD*)(thisx + 356) = 0;
                        if (v61 && !*(_DWORD*)(thisx + 480))
                        {
                            v30 = 0;
                            if (!*(_BYTE*)(thisx + 188))
                                v30 = (char*)sub_465E7E((char*)unk_4B9B10, (_DWORD*)thisx);
                            if (v30)
                            {
                                *(_BYTE*)(thisx + 272) = 2;
                                *(_DWORD*)(thisx + 312) = (int)v30;
                                sub_425D10((int*)v30, thisx);
                            }
                            else
                            {
                                v29 = sub_444DE2(
                                    (int*)unk_4B9B10,
                                    *(unsigned __int8*)(thisx + 184),
                                    (struct Concurrency::ISchedulerProxy*)0xF,
                                    1,
                                    16,
                                    0);
                                if (v29 >= 0)
                                {
                                    *(_BYTE*)(thisx + 272) = 1;
                                    *(_DWORD*)(thisx + 304) = sub_446714(unk_4B9B10, v29);
                                }
                            }
                        }
                        if (!*(_BYTE*)(thisx + 188)
                            && v58 > 0
                            && !*(_BYTE*)(thisx + 272)
                            && !*(_DWORD*)(thisx + 288)
                            && !*(_DWORD*)(thisx + 292)
                            && !*(_DWORD*)(thisx + 480))
                        {
                            v28 = sub_444DE2(
                                (int*)unk_4B9B10,
                                *(unsigned __int8*)(thisx + 184),
                                (struct Concurrency::ISchedulerProxy*)0x2C,
                                0,
                                6,
                                2);
                            if (v28 == -1)
                                v28 = sub_444DE2(
                                    (int*)unk_4B9B10,
                                    *(unsigned __int8*)(thisx + 184),
                                    (struct Concurrency::ISchedulerProxy*)0x2D,
                                    0,
                                    6,
                                    2);
                            if (v28 >= 0)
                            {
                                *(_DWORD*)(thisx + 304) = sub_446714((int*)unk_4B9B10, v28);
                                if (*(_DWORD*)(thisx + 304) && sub_41B65C(*(_DWORD*)(thisx + 304)))
                                {
                                    sub_417BBB(*(_DWORD*)(thisx + 304), thisx);
                                    *(_DWORD*)(thisx + 432) = 69;
                                    *(_DWORD*)(thisx + 376) = 0;
                                    *(_DWORD*)(thisx + 344) = 0;
                                    *(_DWORD*)(thisx + 356) = 0;
                                }
                                else
                                {
                                    *(_DWORD*)(thisx + 304) = 0;
                                }
                            }
                        }
                    }
                }
                else
                {
                    if (*(_DWORD*)(thisx + 164))
                    {
                        v32 = sub_424268((int*)thisx + 8);
                        v9 = v32 >= 2 && v32 <= 4;
                        v8 = v32 >= 6 && v32 <= 8;
                        *(_BYTE*)(thisx + 224) = v9 - v8;
                        v7 = v32 >= 4 && v32 <= 6;
                        v6 = v32 == 1 || v32 == 2 || v32 == 8;
                        *(_BYTE*)(thisx + 225) = v7 - v6;
                        v61 = *(char*)(thisx + 224);
                        v58 = *(char*)(thisx + 225);
                    }
                    *(_DWORD*)(thisx + 436) = v61;
                    *(_DWORD*)(thisx + 440) = v58;
                    *(_DWORD*)(thisx + 432) = 26;
                    *(_DWORD*)(thisx + 444) = 0;
                }
            }
        }
        else
        {
            *(_DWORD*)(thisx + 432) = 77;
            *(_BYTE*)(thisx + 221) = 0;
            *(_DWORD*)(thisx + 444) = 0;
        }
        goto LABEL_921;
    }
    v37 = 0;
    v36 = 0;
    if (!*(_BYTE*)(thisx + 188) && !v68)
    {
        if (sub_41BA53(thisx, 0x30u, 0))
            v37 = (int*)sub_446A62((int*)unk_4B9B10, (_DWORD*)thisx, 1);
        if (!v37)
            v36 = (int*)sub_446A62((int*)unk_4B9B10, (_DWORD*)thisx, 0);
    }
    switch (*(_DWORD*)(thisx + 428))
    {
    case '4':
        *(_DWORD*)(thisx + 432) = 62;
        break;
    case '5':
    case '8':
        *(_DWORD*)(thisx + 432) = 63;
        break;
    case 'R':
        if (*(_DWORD*)(thisx + 312))
            sub_421051(*(_DWORD**)(thisx + 312));
        sub_421051((_DWORD*)thisx);
        *(_BYTE*)(thisx + 231) = 5;
        *(_BYTE*)(thisx + 233) = 5;
        break;
    case 'E':
        if (sub_41BA53(thisx, 0x2Au, 0))
            *(_DWORD*)(thisx + 432) = 100;
        else
            *(_DWORD*)(thisx + 432) = 139;
        break;
    default:
        if (*(_DWORD*)(thisx + 480))
        {
            if (!*(_BYTE*)(thisx + 473))
            {
                if (!*(_DWORD*)(thisx + 392) && *(_BYTE*)(thisx + 237) && sub_41BA53(thisx, 0x1Du, 0))
                {
                    *(_DWORD*)(thisx + 432) = 171;
                }
                else if (*(_DWORD*)(thisx + 392) && *(_BYTE*)(thisx + 237) && sub_41BA53(thisx, 0x1Eu, 0))
                {
                    *(_DWORD*)(thisx + 432) = 172;
                }
                else if (!*(_DWORD*)(thisx + 392) && *(_BYTE*)(thisx + 237) && sub_41BA53(thisx, 0x1Fu, 0))
                {
                    *(_DWORD*)(thisx + 432) = 173;
                }
                else if (!*(_DWORD*)(thisx + 392) && *(_BYTE*)(thisx + 237) && sub_41BA53(thisx, 0x2Cu, 0))
                {
                    *(_DWORD*)(thisx + 432) = 180;
                }
                else if (!*(_DWORD*)(thisx + 392) && *(_BYTE*)(thisx + 237) && sub_41BA53(thisx, 0x31u, 0))
                {
                    *(_DWORD*)(thisx + 432) = 183;
                }
                else if (*(_DWORD*)(thisx + 392) && *(_BYTE*)(thisx + 237) && sub_41BA53(thisx, 0x32u, 0))
                {
                    *(_DWORD*)(thisx + 432) = 184;
                }
                else if (!*(_DWORD*)(thisx + 392) && *(_BYTE*)(thisx + 237) && sub_41BA53(thisx, 0x33u, 0))
                {
                    *(_DWORD*)(thisx + 432) = 185;
                }
                else if (*(_DWORD*)(thisx + 392) && *(_BYTE*)(thisx + 237) && sub_41BA53(thisx, 0x34u, 0))
                {
                    *(_DWORD*)(thisx + 432) = 186;
                }
                else if (*(_DWORD*)(thisx + 392) && *(_BYTE*)(thisx + 237) && sub_41BA53(thisx, 0x3Cu, 0))
                {
                    *(_DWORD*)(thisx + 432) = 189;
                }
                else if (!*(_DWORD*)(thisx + 392) && *(_BYTE*)(thisx + 237) && sub_41BA53(thisx, 0x3Du, 0))
                {
                    *(_DWORD*)(thisx + 432) = 190;
                }
                else if (*(_DWORD*)(thisx + 392) && *(_BYTE*)(thisx + 237) && sub_41BA53(thisx, 0x3Eu, 0))
                {
                    *(_DWORD*)(thisx + 432) = 191;
                }
                else if (!*(_DWORD*)(thisx + 392) && *(_BYTE*)(thisx + 237) && sub_41BA53(thisx, 0x3Fu, 0))
                {
                    *(_DWORD*)(thisx + 432) = 192;
                }
                else if (*(_DWORD*)(thisx + 392) && *(_BYTE*)(thisx + 237) && sub_41BA53(thisx, 0x40u, 0))
                {
                    *(_DWORD*)(thisx + 432) = 193;
                }
                else if (!*(_DWORD*)(thisx + 392) && *(_BYTE*)(thisx + 237) && sub_41BA53(thisx, 0x41u, 0))
                {
                    *(_DWORD*)(thisx + 432) = 194;
                }
                else if (*(_DWORD*)(thisx + 392) && *(_BYTE*)(thisx + 237) && sub_41BA53(thisx, 0x42u, 0))
                {
                    *(_DWORD*)(thisx + 432) = 195;
                }
                else if (!*(_DWORD*)(thisx + 392) && *(_BYTE*)(thisx + 237) && sub_41BA53(thisx, 0x43u, 0))
                {
                    *(_DWORD*)(thisx + 432) = 196;
                }
                else if (*(_DWORD*)(thisx + 392) && *(_BYTE*)(thisx + 237) && sub_41BA53(thisx, 0x44u, 0))
                {
                    *(_DWORD*)(thisx + 432) = 197;
                }
                else if (*(_DWORD*)(thisx + 392) && *(_BYTE*)(thisx + 237) && sub_41BA53(thisx, 0x45u, 0))
                {
                    *(_DWORD*)(thisx + 432) = 198;
                }
                else if (*(_BYTE*)(thisx + 237) && sub_41BA53(thisx, 0x46u, 0))
                {
                    switch (rand() % 18)
                    {
                    case 0:
                        *(_DWORD*)(thisx + 432) = 171;
                        break;
                    case 1:
                        *(_DWORD*)(thisx + 432) = 172;
                        break;
                    case 2:
                        *(_DWORD*)(thisx + 432) = 173;
                        break;
                    case 3:
                        *(_DWORD*)(thisx + 432) = 180;
                        break;
                    case 4:
                        *(_DWORD*)(thisx + 432) = 183;
                        break;
                    case 5:
                        *(_DWORD*)(thisx + 432) = 184;
                        break;
                    case 6:
                        *(_DWORD*)(thisx + 432) = 185;
                        break;
                    case 7:
                        *(_DWORD*)(thisx + 432) = 186;
                        break;
                    case 8:
                        *(_DWORD*)(thisx + 432) = 189;
                        break;
                    case 9:
                        *(_DWORD*)(thisx + 432) = 190;
                        break;
                    case 10:
                        *(_DWORD*)(thisx + 432) = 191;
                        break;
                    case 11:
                        *(_DWORD*)(thisx + 432) = 192;
                        break;
                    case 12:
                        *(_DWORD*)(thisx + 432) = 193;
                        break;
                    case 13:
                        *(_DWORD*)(thisx + 432) = 194;
                        break;
                    case 14:
                        *(_DWORD*)(thisx + 432) = 195;
                        break;
                    case 15:
                        *(_DWORD*)(thisx + 432) = 196;
                        break;
                    case 16:
                        *(_DWORD*)(thisx + 432) = 197;
                        break;
                    case 17:
                        *(_DWORD*)(thisx + 432) = 198;
                        break;
                    default:
                        goto LABEL_797;
                    }
                }
                else
                {
                    *(_DWORD*)(thisx + 432) = 143;
                }
            }
        }
        else if (*(_DWORD*)(thisx + 288))
        {
            if (*(_DWORD*)(thisx + 392))
                *(_DWORD*)(thisx + 432) = 68;
            else
                *(_DWORD*)(thisx + 432) = 67;
            if (*(_DWORD*)(thisx + 304)
                || (*(_DWORD*)(thisx + 304) = sub_465804((int*)unk_4B9B10, (int*)thisx)) != 0
                && sub_425D50((int*)*(_DWORD*)(thisx + 304)))
            {
                sub_417173(*(_DWORD*)(thisx + 304), *(_BYTE*)(thisx + 184));
            }
            else
            {
                sub_417E1D((_DWORD*)thisx);
            }
        }
        else if (v62 != 10 || sub_41BA53(thisx, 0x16u, 0))
        {
            if (!sub_474032((char*)unk_4B9B10, (Concurrency::details::SchedulerBase*)thisx) || *(_DWORD*)(thisx + 392))
            {
                if (v68)
                {
                    *(_DWORD*)(thisx + 432) = 64;
                    *(_DWORD*)(thisx + 288) = 1;
                    *(_DWORD*)(thisx + 304) = (int)v68;
                }
                else if (v37)
                {
                    *(_DWORD*)(thisx + 432) = 102;
                    *(_DWORD*)(thisx + 304) = (int)v37;
                    *(_DWORD*)(thisx + 280) = 1;
                }
                else if (v36)
                {
                    if (sub_41BA53(thisx, 5u, 0))
                        *(_DWORD*)(thisx + 432) = 148;
                    else
                        *(_DWORD*)(thisx + 432) = 132;
                }
                else if (sub_41BA53(thisx, 0x16u, 0))
                {
                    *(_DWORD*)(thisx + 432) = 164;
                }
                else if (*(_DWORD*)(thisx + 428) == 8)
                {
                    if (sub_41BA53(thisx, 0xEu, 0))
                        *(_DWORD*)(thisx + 432) = 157;
                    else
                        *(_DWORD*)(thisx + 432) = 129;
                }
                else if (*(_DWORD*)(thisx + 428) == 7 && *(int*)(thisx + 348) > 0 && sub_41BA53(thisx, 8u, 0))
                {
                    *(_DWORD*)(thisx + 432) = 151;
                }
                else if (*(_DWORD*)(thisx + 428) == 7 || *(_DWORD*)(thisx + 428) == 50 || *(_DWORD*)(thisx + 428) == 51)
                {
                    if (sub_41BA53(thisx, 0xBu, 0))
                    {
                        *(_DWORD*)(thisx + 432) = 154;
                    }
                    else if (sub_41BA53(thisx, 0xEu, 0))
                    {
                        *(_DWORD*)(thisx + 432) = 157;
                    }
                    else
                    {
                        *(_DWORD*)(thisx + 432) = 127;
                    }
                }
                else
                {
                    *(_DWORD*)(thisx + 432) = 123;
                }
            }
            else
            {
                *(_DWORD*)(thisx + 436) = 1;
                *(_DWORD*)(thisx + 432) = 134;
            }
        }
        else
        {
            *(_DWORD*)(thisx + 432) = 125;
        }
        break;
    }
LABEL_797:
    if (*(_DWORD*)(thisx + 432) == 123 || *(_DWORD*)(thisx + 432) == 127)
    {
        if (sub_41BA53(thisx, 0x2Eu, 0))
        {
            *(_DWORD*)(thisx + 432) = 181;
        }
        else if (sub_41BA53(thisx, 1u, 0))
        {
            *(_DWORD*)(thisx + 432) = 144;
        }
    }
LABEL_803:
    *(_DWORD*)(thisx + 444) = 0;
    *(_DWORD*)(thisx + 396) = 0;
    *(_DWORD*)(thisx + 404) = 0;
LABEL_921:
    if (*(_BYTE*)(thisx + 220))
    {
        if (!-- * (_BYTE*)(thisx + 220))
        {
            *(_DWORD*)(thisx + 216) = 0;
            if (sub_41BA53(thisx, 0x80u, 0))
            {
                *(_BYTE*)(thisx + 558) = 5;
                *(_DWORD*)(thisx + 560) = 30;
            }
            else if (sub_41BA53(thisx, 0x81u, 0))
            {
                *(_BYTE*)(thisx + 558) = 8;
                *(_DWORD*)(thisx + 560) = 50;
            }
        }
    }
    if (*(_BYTE*)(thisx + 473))
        --* (_BYTE*)(thisx + 473);
    if (*(_BYTE*)(thisx + 222))
        --* (_BYTE*)(thisx + 222);
    for (n = 0; n < 8; ++n)
    {
        if (*(_BYTE*)(n + thisx + 453) && *(unsigned __int8*)(n + thisx + 453) != 255)
            --* (_BYTE*)(n + thisx + 453);
    }
    if (*(_BYTE*)(thisx + 557))
    {
        if (!-- * (_BYTE*)(thisx + 557))
            *(_BYTE*)(thisx + 556) = 0;
    }
    if (*(_BYTE*)(thisx + 592))
        --* (_BYTE*)(thisx + 592);
    if (*(_WORD*)(thisx + 596))
    {
        if (!-- * (_WORD*)(thisx + 596))
        {
            *(_BYTE*)(thisx + 593) = 0;
            *(_WORD*)(thisx + 594) = 0;
        }
    }
    result = thisx;
    if (*(int*)(thisx + 428) > 83 && *(_DWORD*)(thisx + 444) == 1)
    {
        if (*(_BYTE*)(thisx + 237))
            v5 = *(_DWORD*)(thisx + 572) + 1;
        else
            v5 = *(_DWORD*)(thisx + 572) - 1;
        *(_DWORD*)(thisx + 572) = v5;
        if (*(_DWORD*)(thisx + 392) && *(_BYTE*)(thisx + 236))
        {
            result = thisx;
            ++* (_DWORD*)(thisx + 576);
        }
        else
        {
            result = thisx;
            --* (_DWORD*)(thisx + 576);
        }
    }
    if (!*(_BYTE*)(thisx + 188))
    {
        result = thisx;
        if (*(_DWORD*)(thisx + 304) || *(_DWORD*)(thisx + 480))
            *(_BYTE*)(thisx + 222) = 0;
    }
    return result;
}
int sub_407756(int thisx, int a2, int a3, int a4)
{
    int v4; // edx
    int v5; // eax
    int result; // eax
    int v8; // [esp+4h] [ebp-70h]
    struct Concurrency::ISchedulerProxy* SchedulerProxy; // [esp+8h] [ebp-6Ch]
    int v10; // [esp+8h] [ebp-6Ch]
    int i; // [esp+Ch] [ebp-68h]
    __int16 v12[3]; // [esp+10h] [ebp-64h] BYREF
    char v13; // [esp+16h] [ebp-5Eh]
    __int16 v14; // [esp+18h] [ebp-5Ch]
    char v15; // [esp+1Bh] [ebp-59h]
    int v16; // [esp+24h] [ebp-50h]
    int v17; // [esp+48h] [ebp-2Ch]
    int v18; // [esp+4Ch] [ebp-28h]
    int v19; // [esp+50h] [ebp-24h]
    int v20; // [esp+54h] [ebp-20h]
    char v21; // [esp+58h] [ebp-1Ch]
    int v22; // [esp+5Ch] [ebp-18h]
    int v23; // [esp+60h] [ebp-14h]
    int v24; // [esp+64h] [ebp-10h]
    int v25; // [esp+68h] [ebp-Ch]
    int v26; // [esp+6Ch] [ebp-8h]
    int v27; // [esp+70h] [ebp-4h]

    if (a2)
        ++* (_DWORD*)(thisx + 568);
    else
        ++* (_DWORD*)(thisx + 564);
    v25 = *(_DWORD*)a3;
    LOBYTE(v27) = *(_BYTE*)(a3 + 4);
    if (a2)
    {
        if (*(_BYTE*)(thisx + 558))
            --* (_BYTE*)(thisx + 558);
        if (*(int*)(thisx + 560) > 0)
            *(_DWORD*)(thisx + 560) -= v25;
        if (!*(_BYTE*)(thisx + 558) || *(int*)(thisx + 560) <= 0)
        {
            *(_BYTE*)(thisx + 558) = 0;
            *(_DWORD*)(thisx + 560) = 0;
        }
        v24 = 0;
        if (*(char*)(thisx + 608) > 0 && *(char*)(thisx + 232) > 0)
        {
            *(_DWORD*)(thisx + 432) = 77;
            *(_BYTE*)(thisx + 608) = 0;
        }
        if (*(_DWORD*)(a3 + 20) && (unsigned __int8)v27 != 4 && *(_DWORD*)(thisx + 432) == 77)
        {
            v24 = 1;
            if (*(_DWORD*)(thisx + 392)
                || *(int*)(thisx + 444) >= 8
                || !sub_41BA53(thisx, 0x1Au, 0)
                || !*(_DWORD*)(a3 + 32)
                || Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a3 + 32)) == (struct Concurrency::ISchedulerProxy*)168)
            {
                if (*(unsigned __int8*)(thisx + 221) != 255)
                {
                    ++* (_BYTE*)(thisx + 221);
                    v23 = sub_417924(thisx, 3, 1) / 8 + 5;
                    if (sub_41BA53(thisx, 0xAu, 0))
                        v23 += 5;
                    if (*(unsigned __int8*)(thisx + 221) > v23)
                    {
                        v24 = 0;
                        *(_BYTE*)(thisx + 474) = 6;
                        *(_BYTE*)(thisx + 475) = 1;
                    }
                }
            }
            else
            {
                *(_DWORD*)(thisx + 432) = 168;
            }
        }
        *(_DWORD*)(a3 + 24) = v24;
        if (v24)
        {
            *(_DWORD*)(thisx + 444) = 8;
            if (*(_DWORD*)(thisx + 392))
            {
                *(int*)(thisx + 372) /= 2;
                *(_DWORD*)(thisx + 340) = 50 * (*(_DWORD*)(a3 + 12) - (*(_DWORD*)(a3 + 12) == 0));
                *(_DWORD*)(thisx + 348) = -60;
                if ((unsigned __int8)v27 == 1 || (unsigned __int8)v27 == 3 || (unsigned __int8)v27 == 5)
                    *(_DWORD*)(thisx + 340) *= 2;
            }
            else
            {
                *(_DWORD*)(thisx + 340) = 100 * (*(_DWORD*)(a3 + 12) - (*(_DWORD*)(a3 + 12) == 0));
                *(_DWORD*)(thisx + 352) = *(_DWORD*)(thisx + 340) / -5;
                if ((unsigned __int8)v27 == 1 || (unsigned __int8)v27 == 3 || (unsigned __int8)v27 == 5)
                    *(_DWORD*)(thisx + 340) *= 3;
            }
            if (!sub_41BA53(thisx, 0xAu, 0) && !sub_41BA53(thisx, 0x1Au, 0))
            {
                v25 /= 4;
                if (!v25)
                    v25 = 1;
                if (*(unsigned __int16*)(thisx + 214) >= v25)
                    *(_WORD*)(thisx + 214) -= v25;
                else
                    *(_WORD*)(thisx + 214) = 0;
            }
            sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A28, -1, 100, 100, 0);
        LABEL_248:
            if (*(_DWORD*)(thisx + 164))
                sub_41F0CA((_DWORD*)(thisx + 8), *(_DWORD*)(a3 + 32));
            goto LABEL_352;
        }
        if (*(_DWORD*)(a3 + 48) == 112)
        {
            sub_41EF8A((_WORD*)thisx, v25);
            sub_41F169((_WORD*)thisx, *(unsigned __int16*)(thisx + 242));
        }
        else
        {
            sub_41261C((_WORD*)thisx, v25, *(_DWORD*)(a3 + 32), 1);
            if (!*(_BYTE*)(thisx + 558) && !*(_DWORD*)(thisx + 560))
            {
                if (v25 >= 3)
                    v4 = v25 + *(_DWORD*)(thisx + 216);
                else
                    v4 = *(_DWORD*)(thisx + 216) + 3;
                *(_DWORD*)(thisx + 216) = v4;
            }
            if (!*(_BYTE*)(thisx + 220))
                *(_BYTE*)(thisx + 220) = -76;
        }
        *(_DWORD*)(thisx + 268) = 1;
        switch (*(_DWORD*)(thisx + 428))
        {
        case '4':
        case '5':
        case '8':
            if (*(_DWORD*)(thisx + 304) && *(_DWORD*)(thisx + 304) != *(_DWORD*)(a3 + 32))
                sub_417FC1(*(_DWORD*)(thisx + 304));
            sub_417EE0(thisx);
            goto LABEL_98;
        case 'V':
            if (*(_DWORD*)(thisx + 304))
                sub_417C83(*(_DWORD*)(thisx + 304));
        LABEL_68:
            sub_417DCC(thisx);
        LABEL_98:
            if (*(_DWORD*)(thisx + 288))
            {
                if (*(_DWORD*)(thisx + 304))
                    sub_417E42(*(_DWORD*)(thisx + 304));
                sub_417E1D((_DWORD*)thisx);
            }
            else if (*(_DWORD*)(thisx + 292))
            {
                if (*(_DWORD*)(thisx + 304))
                    sub_417E1D(*(_DWORD**)(thisx + 304));
                sub_417E42(thisx);
            }
            else if (*(_DWORD*)(thisx + 304))
            {
                *(_DWORD*)(thisx + 304) = 0;
            }
            sub_423CF2((_BYTE*)thisx, 0, 0, 0, 0, 0, 0);
            v19 = 1;
            v21 = -1;
            LOBYTE(v20) = *(_BYTE*)(a3 + 30);
            if ((unsigned __int8)v20 != 3
                && (*(_DWORD*)(thisx + 428) == 44 || *(_DWORD*)(thisx + 428) == 46 || *(_DWORD*)(thisx + 428) == 78))
            {
                v22 = 46;
            }
            else if ((unsigned __int8)v20 != 3
                && (*(_DWORD*)(thisx + 428) == 45 || *(_DWORD*)(thisx + 428) == 47 || *(_DWORD*)(thisx + 428) == 79))
            {
                v22 = 47;
            }
            else if ((_BYTE)v27 && (unsigned __int8)v27 != 255)
            {
                switch ((unsigned __int8)v27)
                {
                case 1u:
                    v22 = 37;
                    break;
                case 2u:
                    v22 = 34;
                    break;
                case 3u:
                    v22 = 36;
                    break;
                case 4u:
                    v22 = 17;
                    break;
                case 5u:
                    v22 = 35;
                    break;
                case 6u:
                    v22 = 18;
                    break;
                case 7u:
                    v22 = 19;
                    break;
                case 8u:
                    v22 = 20;
                    break;
                case 9u:
                    v22 = 21;
                    break;
                case 0xAu:
                    v22 = 22;
                    break;
                case 0xBu:
                    v22 = 39;
                    break;
                case 0xCu:
                    v22 = 30;
                    *(_DWORD*)(thisx + 424) = *(_DWORD*)(thisx + 424) == 0;
                    *(_DWORD*)(a3 + 12) = *(_DWORD*)(a3 + 12) == 0;
                    break;
                case 0xDu:
                    v22 = 33;
                    break;
                case 0xEu:
                    v22 = 23;
                    break;
                case 0xFu:
                    v22 = 20;
                    break;
                case 0x10u:
                    v22 = 21;
                    break;
                case 0x11u:
                    v22 = 40;
                    break;
                }
            }
            else
            {
                if (*(_DWORD*)(thisx + 432) == 76 && !*(_DWORD*)(thisx + 444))
                    v19 = 0;
                if (*(int*)(thisx + 216) <= 30)
                {
                    if (*(_DWORD*)(thisx + 392))
                    {
                        if (*(int*)(thisx + 216) <= 20)
                        {
                            v22 = 16;
                        }
                        else
                        {
                            v22 = 34;
                            v21 = 5;
                        }
                    }
                    else if (*(int*)(thisx + 216) > 26 || *(_DWORD*)(thisx + 428) == 135 || *(_DWORD*)(thisx + 428) == 89)
                    {
                        v21 = 5;
                        v22 = 34;
                    }
                    else if (*(int*)(thisx + 216) <= 12)
                    {
                        v22 = 14;
                    }
                    else
                    {
                        v22 = 15;
                    }
                }
                else
                {
                    v22 = 36;
                }
            }
            if (*(_BYTE*)(thisx + 558) || *(int*)(thisx + 560) > 0)
                v19 = 0;
            if ((unsigned __int8)v27 == 12)
            {
                v19 = 1;
            }
            else if (*(_DWORD*)(thisx + 428) == 138
                || *(_DWORD*)(thisx + 428) == 136
                || *(_DWORD*)(thisx + 428) == 137
                || *(_DWORD*)(thisx + 428) == 55
                || *(_DWORD*)(thisx + 428) == 61
                || *(_DWORD*)(thisx + 428) == 78
                || *(_DWORD*)(thisx + 428) == 79)
            {
                v19 = 0;
            }
            else if (*(int*)(thisx + 428) > 31
                && *(int*)(thisx + 428) < 43
                && (!(_BYTE)v20 && *(_DWORD*)(thisx + 428) >= v22
                    || (unsigned __int8)v20 == 1 && *(_DWORD*)(thisx + 428) > v22
                    || (unsigned __int8)v20 == 3))
            {
                v19 = 0;
            }
            if (*(_DWORD*)(a3 + 48) != 83)
            {
                v22 = *(_DWORD*)(a3 + 48);
                v19 = 1;
                if (*(_DWORD*)(a3 + 48) == 112)
                {
                    *(_DWORD*)(thisx + 304) = *(_DWORD*)(a3 + 32);
                    *(_DWORD*)(thisx + 440) = (unsigned __int8)sub_425EF0(*(_BYTE**)(a3 + 32));
                }
            }
            if (v19)
            {
                *(_DWORD*)(thisx + 432) = v22;
                if (*(int*)(thisx + 432) > 32 && *(int*)(thisx + 432) < 41)
                {
                    v18 = *(_DWORD*)(a3 + 8);
                    if (*(__int16*)(thisx + 246) < v18)
                        *(_WORD*)(thisx + 246) = v18;
                }
                if (*(_DWORD*)(thisx + 432) == 46 || *(_DWORD*)(thisx + 432) == 47)
                {
                    v17 = *(_DWORD*)(a3 + 36);
                    if (v17 == 132 || v17 == 133)
                    {
                        sub_41F1A3((unsigned __int8*)thisx, 18);
                    }
                    else if (v17 == 148)
                    {
                        sub_41F1A3((unsigned __int8*)thisx, 8);
                    }
                }
                *(_DWORD*)(thisx + 436) = *(_DWORD*)(a3 + 12);
                if (*(_DWORD*)(thisx + 432) == 38
                    || *(_DWORD*)(thisx + 432) == 17
                    || *(_DWORD*)(thisx + 432) == 18
                    || *(_DWORD*)(thisx + 432) == 19
                    || *(_DWORD*)(thisx + 432) == 20
                    || *(_DWORD*)(thisx + 432) == 21
                    || *(_DWORD*)(thisx + 432) == 22
                    || *(_DWORD*)(thisx + 432) == 23
                    || *(_DWORD*)(thisx + 432) == 24
                    || *(_DWORD*)(thisx + 432) == 25)
                {
                    sub_4810C0(v12);
                    sub_424B7E(*(_DWORD*)(thisx + 432), (int)v12);
                    v15 = 11;
                    if (!*(_DWORD*)(a3 + 12))
                        v16 = -v16;
                    if (*(char*)(a3 + 17) >= 0)
                    {
                        v13 = *(_BYTE*)(a3 + 16);
                        v14 = *(char*)(a3 + 17);
                    }
                    sub_42455B(thisx, v12);
                }
                *(_DWORD*)(thisx + 444) = 0;
                *(_DWORD*)(thisx + 396) = 0;
                *(_DWORD*)(thisx + 404) = 0;
            }
            if (!*(_BYTE*)(thisx + 558) && !*(_DWORD*)(thisx + 560))
            {
                if (*(_DWORD*)(thisx + 480) && *(_DWORD*)(thisx + 432) != 14)
                    sub_41F6DE((_DWORD*)thisx);
                if (*(_DWORD*)(thisx + 428) == 94)
                    sub_464C06((char*)unk_4B9B10, 2, thisx);
            }
            if (*(_DWORD*)(thisx + 432) != 38
                && *(_DWORD*)(thisx + 432) != 17
                && *(_DWORD*)(thisx + 432) != 18
                && *(_DWORD*)(thisx + 432) != 19
                && *(_DWORD*)(thisx + 432) != 20
                && *(_DWORD*)(thisx + 432) != 21
                && *(_DWORD*)(thisx + 432) != 22
                && *(_DWORD*)(thisx + 432) != 23
                && *(_DWORD*)(thisx + 432) != 24
                && *(_DWORD*)(thisx + 432) != 25)
            {
                if (*(_BYTE*)(a3 + 16))
                {
                    sub_4747D2((int*)unk_4B9B10, *(char*)(a3 + 16), *(char*)(a3 + 17));
                }
                else
                {
                    if (*(char*)(a3 + 17) != -1)
                        v21 = *(_BYTE*)(a3 + 17);
                    if (v21 == -1)
                    {
                        if ((unsigned __int8)v27 == 1)
                            sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A10, -1, 100, 100, 0);
                        else
                            sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A0C, -1, 100, 100, 0);
                    }
                    else
                    {
                        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[v21], -1, 100, 100, 0);
                    }
                }
            }
            goto LABEL_248;
        case 'W':
            if (*(_DWORD*)(thisx + 304))
                sub_417DCC(*(_DWORD*)(thisx + 304));
            break;
        default:
            switch (*(_DWORD*)(thisx + 428))
            {
            case 'R':
                if (*(_DWORD*)(thisx + 312))
                    sub_421051(*(_DWORD**)(thisx + 312));
                sub_421051((_DWORD*)thisx);
                goto LABEL_98;
            case '6':
            case '7':
                if (*(_DWORD*)(thisx + 304))
                    sub_417EE0(*(_DWORD*)(thisx + 304));
                sub_417FC1(thisx);
                goto LABEL_98;
            case '9':
            case ':':
                if (*(_DWORD*)(thisx + 304))
                    sub_417C83(*(_DWORD*)(thisx + 304));
                goto LABEL_68;
            }
            if (*(_DWORD*)(thisx + 428) != 59 && *(_DWORD*)(thisx + 428) != 60)
            {
                if (*(_DWORD*)(thisx + 428) == 69 || *(_DWORD*)(thisx + 428) == 70 || *(_DWORD*)(thisx + 428) == 139)
                {
                    if (*(_DWORD*)(thisx + 304))
                        sub_417EAD(*(_DWORD**)(thisx + 304));
                    sub_417E88((_DWORD*)thisx);
                }
                goto LABEL_98;
            }
            if (*(_DWORD*)(thisx + 304))
                sub_417DCC(*(_DWORD*)(thisx + 304));
            break;
        }
        sub_417C83(thisx);
        goto LABEL_98;
    }
    if (a4)
    {
        *(_BYTE*)(thisx + *(unsigned __int8*)(a3 + 40) + 461) = 10;
    }
    else
    {
        *(_BYTE*)(thisx + *(unsigned __int8*)(a3 + 40) + 453) = *(_BYTE*)(thisx + 452);
        if (!*(_DWORD*)(thisx + 480)
            && !*(_DWORD*)(thisx + 392)
            && !*(_BYTE*)(thisx + 272)
            && !*(_BYTE*)(thisx + 248)
            && (*(_DWORD*)(thisx + 424) && *(char*)(thisx + 224) > 0 || !*(_DWORD*)(thisx + 424) && *(char*)(thisx + 224) < 0))
        {
            *(_BYTE*)(thisx + 272) = 1;
            *(_DWORD*)(thisx + 304) = *(_DWORD*)(a3 + 44);
        }
        if (*(_DWORD*)(thisx + 428) == 135)
        {
            v5 = rand();
            sub_41261C((_WORD*)thisx, v5 % 10 + 1, 0, 1);
            *(_DWORD*)(thisx + 432) = 34;
            *(_DWORD*)(thisx + 436) = *(_DWORD*)(a3 + 12) == 0;
            *(_DWORD*)(thisx + 444) = 0;
        }
        else if (!*(_DWORD*)(thisx + 268))
        {
            if (*(_BYTE*)(thisx + 195) == 3 && *(_DWORD*)(thisx + 428) == 125 && !*(_DWORD*)(thisx + 436))
            {
                *(_DWORD*)(thisx + 436) = *(_DWORD*)(thisx + 444);
                *(int*)(thisx + 372) /= -2;
                *(_DWORD*)(thisx + 348) = -300;
            }
            if (*(_DWORD*)(thisx + 428) != 146 || *(_DWORD*)(thisx + 436))
            {
                if (*(_DWORD*)(thisx + 428) != 147 || *(_DWORD*)(thisx + 436))
                {
                    if (*(_DWORD*)(thisx + 428) == 129
                        && (!*(_DWORD*)(thisx + 164) && (*(_BYTE*)(thisx + 224) || *(char*)(thisx + 225) < 0)
                            || *(_DWORD*)(thisx + 164) && !(rand() % 2))
                        && sub_41BA53(thisx, 6u, 0))
                    {
                        *(_DWORD*)(thisx + 436) = 1;
                        *(_DWORD*)(thisx + 432) = 149;
                        *(_DWORD*)(thisx + 372) = 200 * (*(_DWORD*)(thisx + 424) - (*(_DWORD*)(thisx + 424) == 0));
                        *(_DWORD*)(thisx + 376) = 0;
                        *(_DWORD*)(thisx + 360) = 20;
                        if ((!*(_DWORD*)(thisx + 424) || *(char*)(thisx + 224) <= 0)
                            && (*(_DWORD*)(thisx + 424) || *(char*)(thisx + 224) >= 0))
                        {
                            if (*(_DWORD*)(thisx + 424) && *(char*)(thisx + 224) < 0
                                || !*(_DWORD*)(thisx + 424) && *(char*)(thisx + 224) > 0)
                            {
                                *(_DWORD*)(thisx + 372) = -*(_DWORD*)(thisx + 372);
                                *(_DWORD*)(thisx + 348) = -400;
                            }
                        }
                        else
                        {
                            *(_DWORD*)(thisx + 348) = -400;
                        }
                        if (*(char*)(thisx + 225) < 0)
                        {
                            *(int*)(thisx + 372) /= 2;
                            *(_DWORD*)(thisx + 348) = -400;
                        }
                    }
                    else if (*(_DWORD*)(thisx + 428) != 97 || *(_DWORD*)(a3 + 48) == 83)
                    {
                        if (*(_DWORD*)(thisx + 428) != 130
                            || *(_DWORD*)(thisx + 268)
                            || (*(_DWORD*)(thisx + 164)
                                || (!*(_DWORD*)(thisx + 424) || *(char*)(thisx + 224) <= 0)
                                && (*(_DWORD*)(thisx + 424) || *(char*)(thisx + 224) >= 0))
                            && (!*(_DWORD*)(thisx + 164) || rand() % 2)
                            || !sub_41BA53(thisx, 0x29u, 0))
                        {
                            if (*(_DWORD*)(thisx + 428) == 84)
                            {
                                if (*(_DWORD*)(thisx + 392))
                                    *(_DWORD*)(thisx + 432) = 51;
                                else
                                    *(_DWORD*)(thisx + 432) = 13;
                            }
                            else if (*(_DWORD*)(thisx + 428) == 85 && *(_DWORD*)(thisx + 320))
                            {
                                *(_DWORD*)(thisx + 312) = sub_466127((char*)unk_4B9B10, (_BYTE*)thisx, thisx + 453);
                            }
                            else if (*(_DWORD*)(thisx + 428) == 206 && *(int*)(thisx + 444) < 10)
                            {
                                *(_DWORD*)(thisx + 432) = 201;
                            }
                        }
                        else
                        {
                            v8 = 1;
                            SchedulerProxy = Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a3 + 44));
                            if (SchedulerProxy == (struct Concurrency::ISchedulerProxy*)77
                                || SchedulerProxy == (struct Concurrency::ISchedulerProxy*)153
                                || SchedulerProxy == (struct Concurrency::ISchedulerProxy*)113
                                || SchedulerProxy == (struct Concurrency::ISchedulerProxy*)114)
                            {
                                v8 = 0;
                            }
                            v10 = sub_425F30(*(_DWORD**)(a3 + 44));
                            if (v10 == 77 || v10 == 153 || v10 == 113 || v10 == 114)
                                v8 = 0;
                            if (sub_4211AC(*(char**)(a3 + 44))
                                && !(unsigned __int8)sub_425EB0(*(char**)(a3 + 44))
                                && sub_425E90(*(unsigned char**)(a3 + 44))
                                && v8)
                            {
                                *(_DWORD*)(thisx + 432) = 99;
                                *(_DWORD*)(thisx + 304) = *(_DWORD*)(a3 + 44);
                                *(_DWORD*)(thisx + 280) = 1;
                                *(_BYTE*)(a3 + 28) = 0;
                            }
                        }
                    }
                    else
                    {
                        if (*(_DWORD*)(a3 + 12) != *(_DWORD*)(thisx + 424))
                            *(_DWORD*)(thisx + 424) = *(_DWORD*)(thisx + 424) == 0;
                        *(_DWORD*)(thisx + 432) = 98;
                        *(_DWORD*)(thisx + 304) = *(_DWORD*)(a3 + 44);
                        for (i = 0; i < 8; ++i)
                            *(_BYTE*)(i + thisx + 453) = -1;
                    }
                }
                else
                {
                    *(_DWORD*)(thisx + 436) = 1;
                    *(int*)(thisx + 372) /= 2;
                    *(_DWORD*)(thisx + 344) = 0;
                    *(_DWORD*)(thisx + 360) = 20;
                    if ((!*(_DWORD*)(thisx + 424) || *(char*)(thisx + 224) <= 0)
                        && (*(_DWORD*)(thisx + 424) || *(char*)(thisx + 224) >= 0))
                    {
                        if (*(_DWORD*)(thisx + 424) && *(char*)(thisx + 224) < 0
                            || !*(_DWORD*)(thisx + 424) && *(char*)(thisx + 224) > 0)
                        {
                            *(_DWORD*)(thisx + 372) = -*(_DWORD*)(thisx + 372);
                            *(_DWORD*)(thisx + 376) = 0;
                            *(_DWORD*)(thisx + 348) = -400;
                        }
                    }
                    else
                    {
                        *(_DWORD*)(thisx + 376) = 0;
                        *(_DWORD*)(thisx + 348) = -400;
                    }
                    if (*(char*)(thisx + 225) < 0)
                    {
                        *(int*)(thisx + 372) /= 2;
                        *(_DWORD*)(thisx + 376) = 0;
                        *(_DWORD*)(thisx + 348) = -500;
                    }
                }
            }
            else
            {
                *(_DWORD*)(thisx + 436) = 1;
                *(int*)(thisx + 372) /= 2;
            }
        }
    }
LABEL_352:
    v26 = 0;
    if (a2)
    {
        result = sub_425E30(thisx);
        v26 = result;
        if (*(_DWORD*)(a3 + 32))
        {
            result = (unsigned __int8)sub_425E70(*(char**)(a3 + 32));
            if (result == 1)
                v26 = 1;
        }
    }
    else
    {
        if (*(_DWORD*)(a3 + 44))
            v26 = sub_425E30(*(_DWORD*)(a3 + 44));
        result = *(unsigned __int8*)(thisx + 188);
        if (result == 1)
            LOBYTE(v27) = -1;
    }
    if (!a2 && (result = thisx, *(_DWORD*)(thisx + 428) == 206) && *(int*)(thisx + 444) < 10
        || a2
        && *(_DWORD*)(a3 + 32)
        && (result = (int)Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a3 + 32)),
            result == 206)
        && (result = sub_425ED0(*(_DWORD**)(a3 + 32)), result < 10))
    {
        *(_BYTE*)(thisx + 474) = 10;
        result = a3;
        *(_BYTE*)(a3 + 28) = 10;
    }
    if (v26 || byte_4B99C9 && (unsigned __int8)v27 != 255)
    {
        if (v26)
        {
            result = thisx;
            if (*(_BYTE*)(thisx + 188) == 1 && a2)
            {
                if ((unsigned __int8)v27 == 255)
                {
                    result = thisx;
                    *(_BYTE*)(thisx + 474) = 7;
                }
                else
                {
                    *(_BYTE*)(thisx + 474) = 11;
                }
            }
            else
            {
                *(_BYTE*)(thisx + 474) = 7;
            }
        }
        else
        {
            result = thisx;
            *(_BYTE*)(thisx + 474) = *(_BYTE*)(a3 + 28);
        }
        if (a2)
        {
            result = thisx;
            *(_BYTE*)(thisx + 475) = 1;
        }
        else if (!*(_DWORD*)(thisx + 268))
        {
            *(_BYTE*)(thisx + 475) = 0;
        }
    }
    return result;
} 
void sub_408F50(int thisx, double a2, double a3, double a4, int a5)
{
    if (*(_DWORD*)(thisx + 432) == *(_DWORD*)(thisx + 428))
    {
        if (!*(_BYTE*)(thisx + 474))
        {
            *(_DWORD*)(thisx + 284) = 0;
            ++* (_DWORD*)(thisx + 444);
            sub_4097FE(thisx, a2, a3, a4);
            while (*(_DWORD*)(thisx + 432) != *(_DWORD*)(thisx + 428))
            {
                sub_409273(thisx, *(_DWORD*)(thisx + 432));
                if (a5)
                {
                    if (*(_DWORD*)(thisx + 428) == 69 || *(_DWORD*)(thisx + 428) == 70)
                        break;
                }
                *(_DWORD*)(thisx + 444) = 1;
                sub_4097FE(thisx, a2, a3, a4);
            }
        }
    }
    else
    {
        sub_409273(thisx, *(_DWORD*)(thisx + 432));
        if (!a5 || *(_DWORD*)(thisx + 428) != 69 && *(_DWORD*)(thisx + 428) != 70)
        {
            *(_DWORD*)(thisx + 444) = 1;
            sub_4097FE(thisx, a2, a3, a4);
            if (*(_DWORD*)(thisx + 428) != 3 && *(char*)(thisx + 608) > 0)
                *(_BYTE*)(thisx + 608) = 0;
        }
    }
}

 
unsigned __int8 sub_409096(int thisx)
{
    char v1; // al
    int v2; // esi
    int v3; // esi
    char v4; // al
    int v5; // esi
    int v6; // ebx
    unsigned __int8 v7; // al
    int v9; // [esp-10h] [ebp-78h]
    int v10; // [esp-Ch] [ebp-74h]
    int v11; // [esp-4h] [ebp-6Ch]
    int v13[2]; // [esp+Ch] [ebp-5Ch] BYREF
    int v14; // [esp+14h] [ebp-54h]
    int v15; // [esp+18h] [ebp-50h]
    int v16; // [esp+1Ch] [ebp-4Ch]
    _BYTE* v17; // [esp+20h] [ebp-48h] BYREF
    int v18; // [esp+24h] [ebp-44h]
    int v19; // [esp+28h] [ebp-40h]
    _BYTE* v20; // [esp+2Ch] [ebp-3Ch]
    int v21; // [esp+30h] [ebp-38h] BYREF
    int v22; // [esp+34h] [ebp-34h]
    int v23; // [esp+38h] [ebp-30h]
    int v24; // [esp+48h] [ebp-20h]
    int v25; // [esp+4Ch] [ebp-1Ch]

    sub_446442((_DWORD*)unk_4B9B10, thisx, (int)v13);
    v15 = v13[0];
    v14 = v13[1];
    sub_41CA3D((void*)thisx, (_DWORD*)&v17);
    v20 = (_BYTE*)sub_41EEB5((_BYTE*)thisx, (_DWORD*)v17, 0);
    sub_49C15E((int)&v21);
    v24 = *(_DWORD*)(thisx + 424);
    v1 = sub_425F90(v17);
    v2 = v1 + v15;
    v22 = sub_401C1E((_DWORD*)v17, 0, *(_DWORD*)(thisx + 424)) + v2;
    v3 = sub_425F50(v17);
    v16 = sub_401C5B((_DWORD*)v17, 0, 0) + v3;
    v23 = v16 + v14;
    v18 = -1;
    if (*(int*)(thisx + 208) > 0)
    {
        v18 = -*(_DWORD*)(thisx + 208) - v16;
        if (v18 < 0)
            v18 = 0;
    }
    v19 = 8;
    if (*(_DWORD*)(thisx + 424))
    {
        v4 = sub_401C1E((_DWORD*)v17, 0, *(_DWORD*)(thisx + 424));
        v5 = v4 + v15;
        v6 = 8 * (unsigned __int8)sub_425F50(v20);
        v22 = v5 + v6 - sub_425F90(v17) - 8;
        v19 = -v19;
    }
    if (unknown_libname_6(v17))
    {
        v24 = *(_DWORD*)(thisx + 424) == 0;
        v22 += v19;
    }
    if (sub_425FD0(v17))
    {
        v25 = 1;
        v23 += 8;
    }
    v11 = v18;
    v10 = *(_DWORD*)(*((_DWORD*)dword_4B9360 + *(unsigned __int8*)(thisx + 192)) + 4 * *(unsigned __int16*)(thisx + 498));
    v9 = *(unsigned __int16*)(thisx + 190);
    v7 = unknown_libname_5(v17);
    return sub_478682(&v21, v7, v9, v10, -1, v11);
}

 
int sub_409273(int thisx, int a2)
{
    int result; // eax
    int v4; // [esp+8h] [ebp-4h]

    *(_DWORD*)(thisx + 428) = a2;
    if (!*(_BYTE*)(thisx + 470) && *(_BYTE*)(thisx + 471) == 1 && (a2 == 44 || a2 == 45 || a2 == 46 || a2 == 47))
    {
        v4 = *(__int16*)(thisx + 246) + 150 - sub_423AC3(thisx, 1);
        if (v4 >= 30)
        {
            if (v4 <= 255)
                *(_BYTE*)(thisx + 470) = v4;
            else
                *(_BYTE*)(thisx + 470) = -1;
        }
        else
        {
            *(_BYTE*)(thisx + 470) = 30;
        }
        *(_BYTE*)(thisx + 471) = 0;
        *(_BYTE*)(thisx + 472) = 0;
        *(_WORD*)(thisx + 246) = 0;
    }
    switch (a2)
    {
    case 3:
    case 4:
    case 5:
    case 6:
        *(_DWORD*)(thisx + 396) = 1;
        *(_DWORD*)(thisx + 400) = 1;
        *(_DWORD*)(thisx + 404) = 1;
        result = thisx;
        *(_DWORD*)(thisx + 408) = 1;
        *(_DWORD*)(thisx + 412) = 1;
        *(_DWORD*)(thisx + 392) = 0;
        break;
    case 7:
    case 8:
    case 51:
        *(_DWORD*)(thisx + 396) = 0;
        *(_DWORD*)(thisx + 412) = 1;
        *(_DWORD*)(thisx + 400) = 0;
        result = thisx;
        *(_DWORD*)(thisx + 404) = 0;
        *(_DWORD*)(thisx + 408) = 0;
        *(_DWORD*)(thisx + 392) = 1;
        break;
    case 10:
    case 11:
    case 188:
        *(_DWORD*)(thisx + 396) = 0;
        *(_DWORD*)(thisx + 412) = 0;
        *(_DWORD*)(thisx + 400) = 1;
        result = thisx;
        *(_DWORD*)(thisx + 404) = 1;
        *(_DWORD*)(thisx + 408) = 0;
        *(_DWORD*)(thisx + 392) = 0;
        break;
    case 12:
    case 13:
        *(_DWORD*)(thisx + 396) = 0;
        *(_DWORD*)(thisx + 412) = 1;
        *(_DWORD*)(thisx + 400) = 0;
        result = thisx;
        *(_DWORD*)(thisx + 404) = 0;
        *(_DWORD*)(thisx + 408) = 0;
        *(_DWORD*)(thisx + 392) = 0;
        break;
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 30:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 50:
    case 61:
    case 66:
    case 68:
    case 73:
    case 76:
    case 90:
    case 110:
    case 117:
    case 118:
    case 127:
    case 128:
    case 129:
    case 130:
    case 132:
    case 133:
    case 136:
    case 137:
    case 138:
    case 139:
    case 140:
    case 146:
    case 147:
    case 149:
    case 150:
    case 151:
    case 152:
    case 154:
    case 155:
    case 156:
    case 157:
    case 158:
    case 159:
    case 161:
    case 178:
    case 179:
    case 187:
        *(_DWORD*)(thisx + 396) = 0;
        *(_DWORD*)(thisx + 412) = 0;
        *(_DWORD*)(thisx + 400) = 0;
        result = thisx;
        *(_DWORD*)(thisx + 404) = 0;
        *(_DWORD*)(thisx + 408) = 0;
        *(_DWORD*)(thisx + 392) = 1;
        break;
    case 52:
    case 53:
    case 69:
    case 82:
        *(_DWORD*)(thisx + 396) = 0;
        *(_DWORD*)(thisx + 412) = 0;
        *(_DWORD*)(thisx + 400) = 0;
        result = thisx;
        *(_DWORD*)(thisx + 404) = 1;
        *(_DWORD*)(thisx + 408) = 0;
        *(_DWORD*)(thisx + 392) = 0;
        break;
    case 56:
        *(_DWORD*)(thisx + 396) = 0;
        *(_DWORD*)(thisx + 412) = 1;
        *(_DWORD*)(thisx + 400) = 0;
        result = thisx;
        *(_DWORD*)(thisx + 404) = 1;
        *(_DWORD*)(thisx + 408) = 0;
        *(_DWORD*)(thisx + 392) = 0;
        break;
    case 74:
    case 77:
    case 80:
    case 91:
    case 92:
    case 94:
    case 95:
    case 97:
    case 98:
    case 142:
    case 143:
    case 144:
    case 145:
    case 160:
    case 162:
    case 163:
    case 164:
    case 165:
    case 170:
    case 171:
    case 172:
    case 173:
    case 174:
    case 175:
    case 176:
    case 177:
    case 180:
    case 181:
    case 182:
    case 183:
    case 184:
    case 185:
    case 186:
    case 189:
    case 190:
    case 191:
    case 192:
    case 193:
    case 194:
    case 195:
    case 196:
    case 197:
    case 198:
        *(_DWORD*)(thisx + 396) = 0;
        *(_DWORD*)(thisx + 412) = 0;
        *(_DWORD*)(thisx + 400) = 0;
        result = thisx;
        *(_DWORD*)(thisx + 404) = 0;
        *(_DWORD*)(thisx + 408) = 0;
        break;
    case 125:
    case 126:
    case 131:
        *(_DWORD*)(thisx + 396) = 0;
        *(_DWORD*)(thisx + 412) = 0;
        *(_DWORD*)(thisx + 400) = 1;
        result = thisx;
        *(_DWORD*)(thisx + 404) = 0;
        *(_DWORD*)(thisx + 408) = 0;
        *(_DWORD*)(thisx + 392) = 0;
        break;
    default:
        *(_DWORD*)(thisx + 396) = 0;
        *(_DWORD*)(thisx + 412) = 0;
        *(_DWORD*)(thisx + 400) = 0;
        *(_DWORD*)(thisx + 404) = 0;
        result = thisx;
        *(_DWORD*)(thisx + 408) = 0;
        *(_DWORD*)(thisx + 392) = 0;
        break;
    }
    return result;
}

 
void sub_4097DF(void* thisx, int a2)
{
	sub_446442((int*)unk_4B9B10, (int)thisx, a2);
}

 
void sub_4097FE(int a1, double a2, double a3, double a4)
{
    int v4; // esi
    int v5; // esi
    unsigned __int16 v6; // ax
    unsigned __int16 v7; // ax
    int v8; // esi
    int v9; // esi
    int v10; // eax
    int v11; // [esp+4h] [ebp-12Ch]
    int v12; // [esp+8h] [ebp-128h]
    bool v13; // [esp+Ch] [ebp-124h]
    bool v14; // [esp+10h] [ebp-120h]
    bool v15; // [esp+14h] [ebp-11Ch]
    bool v16; // [esp+18h] [ebp-118h]
    int j; // [esp+20h] [ebp-110h]
    int v19; // [esp+24h] [ebp-10Ch]
    int v20; // [esp+28h] [ebp-108h]
    int i; // [esp+2Ch] [ebp-104h]
    int k; // [esp+2Ch] [ebp-104h]
    int v23; // [esp+30h] [ebp-100h]
    char v24[24]; // [esp+34h] [ebp-FCh]
    int v25; // [esp+4Ch] [ebp-E4h] BYREF
    int v26; // [esp+50h] [ebp-E0h]
    int v27; // [esp+54h] [ebp-DCh]
    char v28; // [esp+58h] [ebp-D8h]
    BOOL v29; // [esp+5Ch] [ebp-D4h]
    int v30; // [esp+60h] [ebp-D0h]
    struct Concurrency::ISchedulerProxy* v31; // [esp+64h] [ebp-CCh]
    int v32; // [esp+68h] [ebp-C8h]
    int v33; // [esp+6Ch] [ebp-C4h]
    int v34; // [esp+70h] [ebp-C0h]
    int v35; // [esp+74h] [ebp-BCh]
    int v36; // [esp+78h] [ebp-B8h]
    int v37; // [esp+7Ch] [ebp-B4h]
    int v38; // [esp+80h] [ebp-B0h]
    int v39; // [esp+84h] [ebp-ACh]
    int v40; // [esp+88h] [ebp-A8h]
    int v41; // [esp+8Ch] [ebp-A4h]
    int v42; // [esp+90h] [ebp-A0h]
    char v43; // [esp+94h] [ebp-9Ch]
    int v44; // [esp+98h] [ebp-98h]
    int v45; // [esp+9Ch] [ebp-94h] BYREF
    int v46; // [esp+A4h] [ebp-8Ch]
    int v47; // [esp+A8h] [ebp-88h]
    int v48; // [esp+ACh] [ebp-84h]
    int v49; // [esp+B0h] [ebp-80h]
    int v50[6]; // [esp+B4h] [ebp-7Ch] BYREF
    int v51; // [esp+CCh] [ebp-64h]
    int v52; // [esp+D0h] [ebp-60h]
    int v53; // [esp+D4h] [ebp-5Ch]
    int v54; // [esp+D8h] [ebp-58h]
    int v55; // [esp+DCh] [ebp-54h]
    int v56; // [esp+E0h] [ebp-50h]
    int v57; // [esp+E4h] [ebp-4Ch]
    int v58; // [esp+E8h] [ebp-48h]
    int v59; // [esp+ECh] [ebp-44h]
    int v60; // [esp+F0h] [ebp-40h]
    int v61; // [esp+F4h] [ebp-3Ch]
    int v62; // [esp+F8h] [ebp-38h]
    int v63; // [esp+FCh] [ebp-34h]
    int v64; // [esp+100h] [ebp-30h]
    int v65; // [esp+104h] [ebp-2Ch]
    struct Concurrency::ISchedulerProxy* v66; // [esp+108h] [ebp-28h]
    struct Concurrency::ISchedulerProxy* v67; // [esp+10Ch] [ebp-24h]
    struct Concurrency::ISchedulerProxy* SchedulerProxy; // [esp+110h] [ebp-20h]
    int v69; // [esp+118h] [ebp-18h]
    _DWORD v70[2]; // [esp+11Ch] [ebp-14h] BYREF
    char v71; // [esp+124h] [ebp-Ch]
    int v72; // [esp+128h] [ebp-8h]
    int v73; // [esp+12Ch] [ebp-4h]

    if (*(int*)(a1 + 428) >= 44 && *(int*)(a1 + 428) <= 47 && !*(_WORD*)(a1 + 214))
    {
        if (*(_DWORD*)(a1 + 428) == 44 || *(_DWORD*)(a1 + 428) == 46)
            *(_DWORD*)(a1 + 432) = 78;
        else
            *(_DWORD*)(a1 + 432) = 79;
        return;
    }
    if (*(_DWORD*)(a1 + 444) == 1)
    {
        *(_BYTE*)(a1 + 253) = 0;
        *(_BYTE*)(a1 + 213) = -1;
        *(_BYTE*)(a1 + 257) = 0;
        *(_BYTE*)(a1 + 249) = 0;
        *(_WORD*)(a1 + 244) = 0;
        *(_BYTE*)(a1 + 254) = 0;
        *(_BYTE*)(a1 + 255) = 1;
        *(_BYTE*)(a1 + 256) = 6;
        *(_BYTE*)(a1 + 250) = 5;
        *(_BYTE*)(a1 + 251) = 1;
        *(_BYTE*)(a1 + 252) = 1;
        *(_BYTE*)(a1 + 452) = -1;
        *(_BYTE*)(a1 + 259) = 0;
        *(_BYTE*)(a1 + 260) = 0;
        *(_DWORD*)(a1 + 264) = 83;
        if (*(int*)(a1 + 428) > 83)
            sub_4239D3(a1, 5);
        if (*(int*)(a1 + 428) > 203 && *(_DWORD*)(a1 + 444) == 1)
        {
            sub_4239D3(a1, -100);
            sub_473DA5((int*)unk_4B9B10, 60, a1);
            sub_43FFC3((int*)unk_4BDB28, dword_4B9AE0, -1, 100, 100, 0);
            sub_442863(v70);
            v72 = 0;
            v71 = 19;
            v70[1] = -16;
            v73 = a1;
            sub_4561A5((char*)unk_4B9B10, (int)v70);
        }
    }
    if (*(int*)(a1 + 428) > 83)
    {
        sub_426990(a1, a2, a3, a4);
        return;
    }
    switch (*(_DWORD*)(a1 + 428))
    {
    case 3:
        *(_BYTE*)(a1 + 212) = 0;
        if (*(_DWORD*)(a1 + 288))
            *(_WORD*)(a1 + 204) = 44;
        else
            *(_WORD*)(a1 + 204) = 0;
        if (*(_DWORD*)(a1 + 480))
        {
            if (sub_494AA9(*(_BYTE**)(a1 + 480), 0))
            {
                *(_WORD*)(a1 + 204) = 135;
            }
            else if (sub_425CB0(*(_BYTE**)(a1 + 480)) == 12)
            {
                *(_WORD*)(a1 + 204) = 215;
            }
        }
        if (*(char*)(a1 + 608) > 0)
            *(_WORD*)(a1 + 204) = *(char*)(a1 + 608);
        *(_DWORD*)(a1 + 444) = 0;
        *(_DWORD*)(a1 + 448) = 0;
        *(_DWORD*)(a1 + 396) = 1;
        *(_DWORD*)(a1 + 404) = 1;
        *(_DWORD*)(a1 + 412) = 1;
        *(_DWORD*)(a1 + 400) = 1;
        *(_BYTE*)(a1 + 237) = 0;
        return;
    case 0x4D:
        *(_BYTE*)(a1 + 212) = 0;
        *(_DWORD*)(a1 + 408) = *(int*)(a1 + 444) < 4 && !*(_DWORD*)(a1 + 392);
        if (*(_DWORD*)(a1 + 392))
        {
            *(_WORD*)(a1 + 204) = 238;
        }
        else if (sub_41BA53(a1, 0xAu, 0))
        {
            *(_WORD*)(a1 + 204) = 68;
        }
        else
        {
            *(_WORD*)(a1 + 204) = 61;
        }
        return;
    case 4:
    case 5:
        *(_BYTE*)(a1 + 237) = 0;
        *(_DWORD*)(a1 + 448) = 0;
        *(_BYTE*)(a1 + 212) = 0;
        if (*(_DWORD*)(a1 + 480))
        {
            if (sub_494AA9(*(_BYTE**)(a1 + 480), 0))
            {
                *(_WORD*)(a1 + 204) = 135;
            }
            else if (sub_425CB0(*(_BYTE**)(a1 + 480)) == 12)
            {
                *(_WORD*)(a1 + 204) = 215;
            }
            else
            {
                *(_WORD*)(a1 + 204) = 0;
            }
        }
        else
        {
            *(_WORD*)(a1 + 204) = 3 * (*(_DWORD*)(a1 + 428) == 5) + 4 * (*(_DWORD*)(a1 + 428) == 4);
        }
        if (*(int*)(a1 + 444) > 60)
        {
            *(_DWORD*)(a1 + 432) = 3;
            *(_DWORD*)(a1 + 444) = 0;
        }
        return;
    case 6:
        if (*(_DWORD*)(a1 + 444) == 40)
            *(_DWORD*)(a1 + 444) = 0;
        v69 = 0;
        if (*(_DWORD*)(a1 + 288))
            v69 = 45;
        if (*(_DWORD*)(a1 + 480))
        {
            if (sub_494AA9(*(_BYTE**)(a1 + 480), 0))
            {
                v69 = 135;
            }
            else if (sub_425CB0(*(_BYTE**)(a1 + 480)) == 12)
            {
                v69 = 215;
            }
        }
        *(_BYTE*)(a1 + 212) = 0;
        if (*(_BYTE*)(a1 + 188) == 1)
        {
            *(_BYTE*)(a1 + 212) = 1;
            if (*(int*)(a1 + 444) >= 10)
            {
                if (*(int*)(a1 + 444) >= 20)
                {
                    if (*(int*)(a1 + 444) >= 30)
                    {
                        if (*(int*)(a1 + 444) < 40)
                            *(_WORD*)(a1 + 204) = 0;
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 2;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 1;
                }
            }
            else
            {
                *(_WORD*)(a1 + 204) = 2;
            }
        }
        else if (*(int*)(a1 + 444) >= 10)
        {
            if (*(int*)(a1 + 444) >= 20)
            {
                if (*(int*)(a1 + 444) >= 30)
                {
                    if (*(int*)(a1 + 444) < 40)
                        *(_WORD*)(a1 + 204) = v69;
                }
                else
                {
                    *(_WORD*)(a1 + 204) = v69 + 2;
                }
            }
            else
            {
                *(_WORD*)(a1 + 204) = v69;
            }
        }
        else
        {
            *(_WORD*)(a1 + 204) = v69 + 1;
        }
        return;
    case 0x38:
        *(_BYTE*)(a1 + 212) = 0;
        if (*(_DWORD*)(a1 + 444) == 20)
            *(_DWORD*)(a1 + 444) = 0;
        if (*(int*)(a1 + 444) >= 10)
            *(_WORD*)(a1 + 204) = 30;
        else
            *(_WORD*)(a1 + 204) = 43;
        if (*(_DWORD*)(a1 + 304))
        {
            if (sub_425F30((int*)*(_DWORD*)(a1 + 304)) != 55)
            {
                sub_417EE0(a1);
                *(_DWORD*)(a1 + 432) = 6;
            }
        }
        else
        {
            *(_DWORD*)(a1 + 432) = 6;
        }
        return;
    case 7:
        if (*(_DWORD*)(a1 + 444) == 1)
        {
            sub_43FFC3((int*)unk_4BDB28, dword_4B9A04, -1, 100, 100, 0);
            *(_DWORD*)(a1 + 436) = 0;
            ++* (_BYTE*)(a1 + 238);
        }
        if (*(_DWORD*)(a1 + 444) == 8 && *(_BYTE*)(a1 + 238) == 1 && sub_41BA53(a1, 0x86u, 0))
            *(_DWORD*)(a1 + 400) = 1;
        if (!*(_DWORD*)(a1 + 436) && *(int*)(a1 + 444) < 8 && (*(char*)(a1 + 230) <= 0 || *(char*)(a1 + 231) <= 0))
        {
            *(_DWORD*)(a1 + 436) = 1;
            *(int*)(a1 + 348) /= 2;
        }
        *(_BYTE*)(a1 + 212) = 0;
        if (*(_DWORD*)(a1 + 288))
        {
            if (*(int*)(a1 + 348) >= 0)
                *(_WORD*)(a1 + 204) = 53;
            else
                *(_WORD*)(a1 + 204) = 52;
        }
        else if (*(_DWORD*)(a1 + 480) && sub_494AA9(*(_BYTE**)(a1 + 480), 0))
        {
            if (*(int*)(a1 + 444) >= 8)
                *(_WORD*)(a1 + 204) = 139;
            else
                *(_WORD*)(a1 + 204) = 6;
        }
        else if (*(_DWORD*)(a1 + 480) && sub_425CB0(*(_BYTE**)(a1 + 480)) == 12)
        {
            if (*(int*)(a1 + 444) >= 8)
                *(_WORD*)(a1 + 204) = 221;
            else
                *(_WORD*)(a1 + 204) = 222;
        }
        else if (*(int*)(a1 + 444) >= 8)
        {
            *(_WORD*)(a1 + 204) = 5;
        }
        else
        {
            *(_WORD*)(a1 + 204) = 6;
        }
        if (*(_DWORD*)(a1 + 444) == 8)
            *(_DWORD*)(a1 + 404) = 1;
        return;
    case 8:
        *(_BYTE*)(a1 + 212) = 0;
        if (*(_DWORD*)(a1 + 444) == 1)
        {
            *(_DWORD*)(a1 + 436) = 0;
            sub_43FFC3((int*)unk_4BDB28, dword_4B9A04, -1, 100, 100, 0);
            ++* (_BYTE*)(a1 + 238);
            if (sub_41BA53(a1, 0x2Bu, 0))
            {
                *(_BYTE*)(a1 + 248) = 0;
                v4 = sub_417924(a1, 3, 1);
                v5 = sub_41D067(a1, 1) / 2 + v4;
                v6 = sub_41CA5F(a1, 1);
                sub_41F169((_WORD*)a1, (v5 + v6 / 2) / 3);
                memset((void*)(a1 + 453), 0, 8u);
                memset((void*)(a1 + 461), 0, 8u);
            }
        }
        if (*(_DWORD*)(a1 + 444) == 8 && *(_BYTE*)(a1 + 238) == 1 && sub_41BA53(a1, 0x86u, 0))
            *(_DWORD*)(a1 + 400) = 1;
        if (!*(_DWORD*)(a1 + 436) && *(int*)(a1 + 444) < 8 && (*(char*)(a1 + 230) <= 0 || *(char*)(a1 + 231) <= 0))
        {
            *(_DWORD*)(a1 + 436) = 1;
            *(int*)(a1 + 348) /= 2;
        }
        if (*(_DWORD*)(a1 + 288))
        {
            if (*(int*)(a1 + 348) >= 0)
                *(_WORD*)(a1 + 204) = 53;
            else
                *(_WORD*)(a1 + 204) = 52;
        }
        else if (*(_DWORD*)(a1 + 480) && sub_494AA9(*(_BYTE**)(a1 + 480), 0))
        {
            if (*(int*)(a1 + 444) >= 8)
                *(_WORD*)(a1 + 204) = 139;
            else
                *(_WORD*)(a1 + 204) = 6;
        }
        else if (*(_DWORD*)(a1 + 480) && sub_425CB0(*(_BYTE**)(a1 + 480)) == 12)
        {
            if (*(int*)(a1 + 444) >= 8)
                *(_WORD*)(a1 + 204) = 221;
            else
                *(_WORD*)(a1 + 204) = 222;
        }
        else if (*(_DWORD*)(a1 + 480) || !sub_41BA53(a1, 0x2Bu, 0))
        {
            if (*(int*)(a1 + 444) >= 8)
                *(_WORD*)(a1 + 204) = 5;
            else
                *(_WORD*)(a1 + 204) = 6;
        }
        else
        {
            if (!(*(_DWORD*)(a1 + 444) % 6))
            {
                memset((void*)(a1 + 453), 0, 8u);
                memset((void*)(a1 + 461), 0, 8u);
            }
            *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 4 % 4 + 190;
        }
        if (*(_DWORD*)(a1 + 444) == 8)
            *(_DWORD*)(a1 + 404) = 1;
        return;
    case 0xC:
    case 0xD:
        *(_BYTE*)(a1 + 212) = 0;
        *(_DWORD*)(a1 + 448) = 0;
        if (*(_DWORD*)(a1 + 288))
        {
            *(_WORD*)(a1 + 204) = 45;
        }
        else if (*(_DWORD*)(a1 + 480) && sub_425CB0(*(_BYTE**)(a1 + 480)) == 12)
        {
            *(_WORD*)(a1 + 204) = 222;
        }
        else
        {
            *(_WORD*)(a1 + 204) = 6;
        }
        if (*(int*)(a1 + 444) > 6)
            *(_DWORD*)(a1 + 432) = 3;
        return;
    case 0x1B:
    case 0x1C:
        *(_BYTE*)(a1 + 212) = 0;
        if (*(_DWORD*)(a1 + 480) && sub_425CB0(*(_BYTE**)(a1 + 480)) == 12)
            *(_WORD*)(a1 + 204) = 222;
        else
            *(_WORD*)(a1 + 204) = 6;
        if (*(int*)(a1 + 444) >= 12)
        {
            if (*(_BYTE*)(a1 + 237))
                *(_DWORD*)(a1 + 432) = 10;
            else
                *(_DWORD*)(a1 + 432) = 3;
        }
        return;
    case 0xA:
        *(_BYTE*)(a1 + 212) = 0;
        if (*(_DWORD*)(a1 + 444) == 1)
            *(_DWORD*)(a1 + 448) = 0;
        ++* (_DWORD*)(a1 + 448);
        if (*(_DWORD*)(a1 + 288))
        {
            *(_WORD*)(a1 + 204) = 2 * (*(_DWORD*)(a1 + 444) / 10 % 2) + 46;
        }
        else if (*(_DWORD*)(a1 + 480) && sub_494AA9(*(_BYTE**)(a1 + 480), 0))
        {
            *(_WORD*)(a1 + 204) = 3 * (*(_DWORD*)(a1 + 444) / 5 % 2) + 135;
        }
        else if (*(_DWORD*)(a1 + 480) && sub_425CB0(*(_BYTE**)(a1 + 480)) == 12)
        {
            *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 5 % 3 + 218;
        }
        else if (*(_BYTE*)(a1 + 188) == 1)
        {
            *(_BYTE*)(a1 + 212) = 1;
            if (*(int*)(a1 + 444) >= 7)
            {
                if (*(int*)(a1 + 444) >= 14)
                {
                    if (*(int*)(a1 + 444) >= 21)
                    {
                        if (*(int*)(a1 + 444) < 28)
                            *(_WORD*)(a1 + 204) = 0;
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 2;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 1;
                }
            }
            else
            {
                *(_WORD*)(a1 + 204) = 2;
            }
            if (*(_DWORD*)(a1 + 444) == 28)
                *(_DWORD*)(a1 + 444) = 0;
            if (!(*(_DWORD*)(a1 + 444) % 10))
                sub_43FFC3((int*)unk_4BDB28, dword_4B9AC8, -1, 100, 100, 0);
        }
        else if (*(_BYTE*)(a1 + 188) == 2 || *(_BYTE*)(a1 + 188) == 3)
        {
            *(_BYTE*)(a1 + 212) = 1;
            *(_WORD*)(a1 + 204) = 3 * (*(_DWORD*)(a1 + 444) / 5 % 2);
        }
        else
        {
            *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 5 % 6 + 7;
        }
        return;
    case 0xB:
        *(_BYTE*)(a1 + 212) = 0;
        *(_DWORD*)(a1 + 448) = 0;
        if (*(_DWORD*)(a1 + 444) == 1 && (*(_BYTE*)(a1 + 188) == 2 || *(_BYTE*)(a1 + 188) == 3))
        {
            *(_DWORD*)(a1 + 352) *= 2;
            *(_DWORD*)(a1 + 356) *= 2;
        }
        if (*(_DWORD*)(a1 + 288))
            *(_WORD*)(a1 + 204) = 45;
        else
            *(_WORD*)(a1 + 204) = 4;
        if (*(_DWORD*)(a1 + 480) && sub_494AA9(*(_BYTE**)(a1 + 480), 0))
            *(_WORD*)(a1 + 204) = 135;
        if (*(_DWORD*)(a1 + 480) && sub_425CB0(*(_BYTE**)(a1 + 480)) == 12)
        {
            *(_WORD*)(a1 + 204) = 215;
        }
        else if (*(_DWORD*)(a1 + 480))
        {
            *(_WORD*)(a1 + 204) = 0;
        }
        if (*(int*)(a1 + 444) >= 30)
        {
            if (*(_DWORD*)(a1 + 288))
                *(_DWORD*)(a1 + 432) = 3;
            else
                *(_DWORD*)(a1 + 432) = 4;
            *(_DWORD*)(a1 + 444) = 0;
        }
        return;
    case 0x32:
    case 0x33:
        *(_DWORD*)(a1 + 360) = 30;
        if (*(unsigned __int8*)(a1 + 238) <= 1u && sub_41BA53(a1, 0x86u, 0))
            *(_DWORD*)(a1 + 400) = 1;
        *(_BYTE*)(a1 + 212) = 0;
        if (*(_DWORD*)(a1 + 288))
        {
            if (*(int*)(a1 + 444) >= 6)
                *(_WORD*)(a1 + 204) = 53;
            else
                *(_WORD*)(a1 + 204) = 52;
        }
        else if (*(_DWORD*)(a1 + 480) && sub_494AA9(*(_BYTE**)(a1 + 480), 0))
        {
            if (*(int*)(a1 + 444) >= 6)
                *(_WORD*)(a1 + 204) = 139;
            else
                *(_WORD*)(a1 + 204) = 6;
        }
        if (*(_DWORD*)(a1 + 480) && sub_425CB0(*(_BYTE**)(a1 + 480)) == 12)
        {
            if (*(int*)(a1 + 444) >= 6)
                *(_WORD*)(a1 + 204) = 221;
            else
                *(_WORD*)(a1 + 204) = 222;
        }
        else if (*(int*)(a1 + 444) >= 6)
        {
            *(_WORD*)(a1 + 204) = 25;
        }
        else
        {
            *(_WORD*)(a1 + 204) = 6;
        }
        if (*(_DWORD*)(a1 + 444) == 5)
        {
            *(_DWORD*)(a1 + 412) = 1;
            *(_DWORD*)(a1 + 404) = 1;
        }
        return;
    case 0x45:
        if (*(_DWORD*)(a1 + 304))
        {
            *(_BYTE*)(a1 + 212) = 0;
            *(_WORD*)(a1 + 204) = 56;
            SchedulerProxy = Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304));
            if (SchedulerProxy == (struct Concurrency::ISchedulerProxy*)71)
            {
                *(_DWORD*)(a1 + 432) = 72;
                *(_DWORD*)(a1 + 444) = 0;
            }
            else if (SchedulerProxy != (struct Concurrency::ISchedulerProxy*)44
                && SchedulerProxy != (struct Concurrency::ISchedulerProxy*)45
                && SchedulerProxy != (struct Concurrency::ISchedulerProxy*)46
                && SchedulerProxy != (struct Concurrency::ISchedulerProxy*)47)
            {
                *(_DWORD*)(a1 + 432) = 12;
                *(_DWORD*)(a1 + 304) = 0;
                *(_DWORD*)(a1 + 444) = 0;
            }
        }
        else
        {
            *(_DWORD*)(a1 + 432) = 12;
            *(_DWORD*)(a1 + 444) = 0;
        }
        return;
    case 0x46:
        if (*(_DWORD*)(a1 + 304))
        {
            *(_BYTE*)(a1 + 212) = 0;
            *(_BYTE*)(a1 + 213) = -1;
            if (*(int*)(a1 + 444) >= 8)
            {
                if (*(int*)(a1 + 444) < 10)
                    *(_WORD*)(a1 + 204) = 58;
            }
            else
            {
                *(_WORD*)(a1 + 204) = 57;
            }
            if (*(_DWORD*)(a1 + 444) == 8)
            {
                v7 = sub_41CB3B(a1, 1);
                sub_41EF8A((_WORD*)a1, v7 / 15);
                sub_417C15(*(_DWORD*)(a1 + 304), *(_BYTE*)(a1 + 242));
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A0C, -1, 100, 100, 0);
            }
            if (*(int*)(a1 + 444) >= 20)
                *(_DWORD*)(a1 + 432) = 69;
            v67 = Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304));
            if (v67 == (struct Concurrency::ISchedulerProxy*)71)
            {
                *(_DWORD*)(a1 + 432) = 72;
                *(_DWORD*)(a1 + 444) = 0;
            }
            else if (v67 != (struct Concurrency::ISchedulerProxy*)44
                && v67 != (struct Concurrency::ISchedulerProxy*)45
                && v67 != (struct Concurrency::ISchedulerProxy*)46
                && v67 != (struct Concurrency::ISchedulerProxy*)47)
            {
                *(_DWORD*)(a1 + 432) = 12;
                *(_DWORD*)(a1 + 304) = 0;
                *(_DWORD*)(a1 + 444) = 0;
            }
        }
        else
        {
            *(_DWORD*)(a1 + 432) = 12;
            *(_DWORD*)(a1 + 444) = 0;
        }
        return;
    case 0x47:
        if (*(_DWORD*)(a1 + 304))
        {
            *(_BYTE*)(a1 + 212) = 0;
            if (*(_DWORD*)(a1 + 444) == 1)
            {
                *(_BYTE*)(a1 + 223) = 0x80;
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A1C, -1, 100, 100, 0);
            }
            if (*(int*)(a1 + 444) >= 3)
            {
                if (*(int*)(a1 + 444) >= 9)
                {
                    if (*(int*)(a1 + 444) >= 13)
                    {
                        if (*(int*)(a1 + 444) >= 17)
                            *(_WORD*)(a1 + 204) = 252;
                        else
                            *(_WORD*)(a1 + 204) = 251;
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 250;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 249;
                }
            }
            else
            {
                *(_WORD*)(a1 + 204) = 24;
            }
            if (*(_DWORD*)(a1 + 444) == 13)
            {
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A14, -1, 100, 100, 0);
            }
            else if (*(_DWORD*)(a1 + 444) == 22)
            {
                *(_DWORD*)(a1 + 424) = *(_DWORD*)(a1 + 424) == 0;
                v66 = Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304));
                if (v66 == (struct Concurrency::ISchedulerProxy*)44 || v66 == (struct Concurrency::ISchedulerProxy*)45)
                {
                    sub_417BBB(*(_DWORD*)(a1 + 304), a1);
                    *(_DWORD*)(a1 + 432) = 69;
                }
                else
                {
                    *(_DWORD*)(a1 + 304) = 0;
                    *(_DWORD*)(a1 + 432) = 3;
                }
            }
        }
        else
        {
            *(_DWORD*)(a1 + 432) = 3;
        }
        return;
    case 0x48:
        if (*(_DWORD*)(a1 + 304))
        {
            if (*(_DWORD*)(a1 + 444) == 1)
            {
                *(_BYTE*)(a1 + 223) = 127;
                if (*(_DWORD*)(a1 + 304))
                {
                    v8 = sub_425D70((_DWORD*)a1);
                    *(_DWORD*)(a1 + 436) = v8 == sub_425D70(*(_DWORD**)(a1 + 304));
                }
            }
            *(_BYTE*)(a1 + 212) = 0;
            if (*(_DWORD*)(a1 + 436))
            {
                if (*(int*)(a1 + 444) >= 9)
                {
                    if (*(int*)(a1 + 444) >= 13)
                    {
                        if (*(int*)(a1 + 444) >= 17)
                            *(_WORD*)(a1 + 204) = 18;
                        else
                            *(_WORD*)(a1 + 204) = 17;
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 16;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 13;
                }
            }
            else if (*(int*)(a1 + 444) >= 9)
            {
                if (*(int*)(a1 + 444) >= 13)
                {
                    if (*(int*)(a1 + 444) >= 17)
                        *(_WORD*)(a1 + 204) = 27;
                    else
                        *(_WORD*)(a1 + 204) = 28;
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 26;
                }
            }
            else
            {
                *(_WORD*)(a1 + 204) = 13;
            }
            if (*(_DWORD*)(a1 + 444) == 21)
            {
                if (*(_DWORD*)(a1 + 436) == 1)
                    *(_DWORD*)(a1 + 432) = 44;
                else
                    *(_DWORD*)(a1 + 432) = 45;
            }
        }
        else
        {
            *(_DWORD*)(a1 + 432) = 3;
        }
        return;
    case 0x3E:
        if (*(int*)(a1 + 444) < 30 && *(_DWORD*)(a1 + 304))
        {
            if (*(_DWORD*)(a1 + 444) == 1)
            {
                *(_DWORD*)(a1 + 424) = *(_DWORD*)(a1 + 424) == 0;
                sub_426050(*(_DWORD**)(a1 + 304), 135);
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A24, -1, 100, 100, 0);
            }
            *(_BYTE*)(a1 + 212) = 0;
            if (*(int*)(a1 + 444) >= 8)
            {
                if (*(int*)(a1 + 444) >= 21)
                    *(_WORD*)(a1 + 204) = 41;
                else
                    *(_WORD*)(a1 + 204) = 40;
            }
            else
            {
                *(_WORD*)(a1 + 204) = 39;
            }
        }
        else
        {
            *(_DWORD*)(a1 + 432) = 4;
            *(_DWORD*)(a1 + 304) = 0;
            *(_DWORD*)(a1 + 444) = 0;
        }
        return;
    case 0x3F:
        if (*(int*)(a1 + 444) < 30 && *(_DWORD*)(a1 + 304))
        {
            if (*(_DWORD*)(a1 + 444) == 1)
                sub_426050(*(_DWORD**)(a1 + 304), 89);
            *(_BYTE*)(a1 + 212) = 0;
            if (*(int*)(a1 + 444) >= 8)
            {
                if (*(int*)(a1 + 444) >= 18)
                    *(_WORD*)(a1 + 204) = 41;
                else
                    *(_WORD*)(a1 + 204) = 40;
            }
            else
            {
                *(_WORD*)(a1 + 204) = 42;
            }
        }
        else
        {
            *(_DWORD*)(a1 + 432) = 4;
            *(_DWORD*)(a1 + 304) = 0;
            *(_DWORD*)(a1 + 444) = 0;
        }
        return;
    case 0x39:
        if (*(_DWORD*)(a1 + 304) && *(_DWORD*)(a1 + 444) == 1)
        {
            v65 = 0;
            if (*(_BYTE*)(a1 + 195))
            {
                switch (*(_BYTE*)(a1 + 195))
                {
                case 1:
                    v65 = 27 * sub_4175B4(a1, 1) / 100;
                    break;
                case 2:
                    v65 = 26 * sub_4175B4(a1, 1) / 100;
                    break;
                case 3:
                    v65 = 30 * sub_4175B4(a1, 1) / 100;
                    break;
                }
            }
            else
            {
                v65 = 28 * sub_4175B4(a1, 1) / 100;
            }
            if (*(_BYTE*)(a1 + 258) == 1)
            {
                v65 = 12 * v65 / 10;
            }
            else if (*(_BYTE*)(a1 + 258) == 2)
            {
                v65 = 7 * v65 / 10;
            }
            if (!v65)
                v65 = 1;
            sub_41EF8A(*(_WORD**)(a1 + 304), v65);
            *(_DWORD*)(a1 + 340) = 0;
            *(_DWORD*)(a1 + 344) = 0;
            *(_DWORD*)(a1 + 352) = 0;
            *(_DWORD*)(a1 + 356) = 0;
        }
        if (*(_BYTE*)(a1 + 188) == 1)
        {
            if (*(_DWORD*)(a1 + 444) == 1 && *(_DWORD*)(a1 + 304))
                sub_423CF2(*(_BYTE**)(a1 + 304), 0, 0, 0, 0, 0, 0);
            *(_BYTE*)(a1 + 212) = 1;
            if (*(int*)(a1 + 444) >= 46)
            {
                if (*(int*)(a1 + 444) >= 50)
                {
                    if (*(_DWORD*)(a1 + 444) == 51)
                        *(_DWORD*)(a1 + 304) = 0;
                    *(_WORD*)(a1 + 204) = 57;
                }
                else
                {
                    if (*(_DWORD*)(a1 + 444) == 46)
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A24, -1, 100, 100, 0);
                    *(_WORD*)(a1 + 204) = 56;
                }
            }
            else
            {
                *(_WORD*)(a1 + 204) = (*(_DWORD*)(a1 + 444) - 1) / 5 % 3 + 53;
                if ((*(_DWORD*)(a1 + 444) - 1) % 15 == 5)
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A5C, -1, 100, 100, 0);
            }
            if (*(_DWORD*)(a1 + 444) == 68 || *(int*)(a1 + 444) < 51 && !*(_DWORD*)(a1 + 304))
            {
                *(_DWORD*)(a1 + 424) = *(_DWORD*)(a1 + 424) == 0;
                *(_DWORD*)(a1 + 432) = 3;
            }
            return;
        }
        switch (*(_BYTE*)(a1 + 195))
        {
        case 0:
            if (*(_DWORD*)(a1 + 304))
            {
                if (*(_DWORD*)(a1 + 444) != 1)
                {
                    switch (*(_DWORD*)(a1 + 444))
                    {
                    case 5:
                        sub_423CF2(*(_BYTE**)(a1 + 304), 1, -8, 1, 0, 1, -4);
                        goto LABEL_407;
                    case 9:
                        sub_423CF2(*(_BYTE**)(a1 + 304), 1, 8, 1, 0, 1, -8);
                        goto LABEL_407;
                    case 0x29:
                        sub_423CF2(*(_BYTE**)(a1 + 304), 1, -10, 1, 0, 1, -16);
                        goto LABEL_407;
                    }
                    if (*(_DWORD*)(a1 + 444) != 49)
                        goto LABEL_407;
                }
                sub_423CF2(*(_BYTE**)(a1 + 304), 1, -16, 1, 0, 1, 0);
            }
        LABEL_407:
            if (*(int*)(a1 + 444) >= 5)
            {
                if (*(int*)(a1 + 444) >= 9)
                {
                    if (*(int*)(a1 + 444) >= 41)
                    {
                        if (*(int*)(a1 + 444) >= 49)
                        {
                            if (*(int*)(a1 + 444) >= 53)
                            {
                                if (*(int*)(a1 + 444) < 57)
                                {
                                    *(_BYTE*)(a1 + 212) = 0;
                                    *(_WORD*)(a1 + 204) = 30;
                                }
                            }
                            else
                            {
                                *(_BYTE*)(a1 + 212) = 0;
                                *(_WORD*)(a1 + 204) = 31;
                            }
                        }
                        else
                        {
                            *(_BYTE*)(a1 + 212) = 0;
                            *(_WORD*)(a1 + 204) = 30;
                        }
                    }
                    else
                    {
                        *(_BYTE*)(a1 + 212) = 1;
                        *(_WORD*)(a1 + 204) = 11;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 30;
                }
            }
            else
            {
                *(_BYTE*)(a1 + 212) = 0;
                *(_WORD*)(a1 + 204) = 31;
            }
            if (*(int*)(a1 + 444) >= 81)
            {
                *(_DWORD*)(a1 + 432) = 3;
                *(_DWORD*)(a1 + 304) = 0;
                *(_DWORD*)(a1 + 444) = 0;
            }
            return;
        case 1:
            if (*(_DWORD*)(a1 + 304) && *(_DWORD*)(a1 + 444) == 1)
                sub_423CF2(*(_BYTE**)(a1 + 304), 1, -16, 1, 0, 1, 0);
            *(_BYTE*)(a1 + 212) = 1;
            if (*(int*)(a1 + 444) >= 5)
            {
                if (*(int*)(a1 + 444) >= 10)
                {
                    if (*(int*)(a1 + 444) >= 15)
                    {
                        if (*(int*)(a1 + 444) >= 20)
                        {
                            if (*(int*)(a1 + 444) >= 32)
                            {
                                if (*(int*)(a1 + 444) >= 50)
                                {
                                    *(_BYTE*)(a1 + 212) = 0;
                                    *(_WORD*)(a1 + 204) = 6;
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 13;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 13;
                                if (*(_DWORD*)(a1 + 436) == 1 && *(_DWORD*)(a1 + 444) % 6 <= 2)
                                    *(_WORD*)(a1 + 204) = 14;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 12;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 11;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 10;
                }
            }
            else
            {
                *(_BYTE*)(a1 + 212) = 0;
                *(_WORD*)(a1 + 204) = 31;
            }
            if (*(_DWORD*)(a1 + 444) == 15)
            {
                *(_DWORD*)(a1 + 348) = -300;
                *(_DWORD*)(a1 + 392) = 1;
            }
            else if (*(_DWORD*)(a1 + 444) == 16)
            {
                *(_DWORD*)(a1 + 348) = 0;
                *(_DWORD*)(a1 + 360) = 15;
            }
            if (*(int*)(a1 + 444) > 60)
            {
                *(_DWORD*)(a1 + 432) = 4;
                *(_DWORD*)(a1 + 304) = 0;
            }
            break;
        case 2:
            if (*(_DWORD*)(a1 + 304))
            {
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    sub_423CF2(*(_BYTE**)(a1 + 304), 1, -16, 1, 0, 1, 0);
                }
                else if (*(_DWORD*)(a1 + 444) == 8)
                {
                    sub_423CF2(*(_BYTE**)(a1 + 304), 1, -8, 1, 0, 1, -8);
                }
            }
            *(_BYTE*)(a1 + 212) = 1;
            if (*(_DWORD*)(a1 + 444) == 1)
            {
                *(_DWORD*)(a1 + 436) = 0;
                *(_DWORD*)(a1 + 340) = 0;
                *(_DWORD*)(a1 + 344) = 0;
            }
            if (*(int*)(a1 + 444) >= 8)
            {
                if (*(_DWORD*)(a1 + 444) == 8)
                {
                    *(_BYTE*)(a1 + 212) = 1;
                    *(_WORD*)(a1 + 204) = 17;
                    *(_DWORD*)(a1 + 392) = 1;
                    *(_DWORD*)(a1 + 348) = -380;
                    *(_DWORD*)(a1 + 360) = 20;
                }
                else if (*(_DWORD*)(a1 + 436))
                {
                    *(_WORD*)(a1 + 204) = 5;
                    *(_DWORD*)(a1 + 304) = 0;
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 17;
                }
            }
            else
            {
                *(_BYTE*)(a1 + 212) = 0;
                *(_WORD*)(a1 + 204) = 31;
            }
            break;
        case 3:
            if (*(_DWORD*)(a1 + 304))
            {
                switch (*(_DWORD*)(a1 + 444))
                {
                case 1:
                    sub_423CF2(*(_BYTE**)(a1 + 304), 1, 16, 1, 0, 0, 0);
                    break;
                case 8:
                    sub_423CF2(*(_BYTE**)(a1 + 304), 1, -4, 1, 0, 1, -16);
                    break;
                case 0xC:
                    sub_423CF2(*(_BYTE**)(a1 + 304), 1, -14, 1, 0, 1, -8);
                    break;
                case 0xE:
                    sub_423CF2(*(_BYTE**)(a1 + 304), 1, -16, 1, 0, 1, -4);
                    break;
                }
            }
            if (*(int*)(a1 + 444) >= 8)
            {
                if (*(int*)(a1 + 444) >= 12)
                {
                    if (*(int*)(a1 + 444) >= 16)
                    {
                        if (*(int*)(a1 + 444) >= 20)
                        {
                            if (*(int*)(a1 + 444) >= 28)
                            {
                                if (*(int*)(a1 + 444) >= 32)
                                {
                                    if (*(int*)(a1 + 444) >= 36)
                                    {
                                        *(_WORD*)(a1 + 204) = 4;
                                    }
                                    else
                                    {
                                        *(_BYTE*)(a1 + 212) = 0;
                                        *(_WORD*)(a1 + 204) = 2;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 15;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 16;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 17;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 16;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 15;
                }
            }
            else
            {
                *(_BYTE*)(a1 + 212) = 1;
                *(_WORD*)(a1 + 204) = 14;
            }
            if (*(_DWORD*)(a1 + 444) == 1)
                *(_DWORD*)(a1 + 424) = *(_DWORD*)(a1 + 424) == 0;
            if (*(int*)(a1 + 444) >= 40)
            {
                *(_DWORD*)(a1 + 432) = 4;
                *(_DWORD*)(a1 + 304) = 0;
            }
            break;
        }
        return;
    case 0x3B:
        if (*(_DWORD*)(a1 + 304) && *(_DWORD*)(a1 + 444) == 1)
        {
            *(_BYTE*)(a1 + 324) = sub_4264F0(*(_BYTE**)(a1 + 304));
            *(_DWORD*)(a1 + 372) = 0;
            *(_DWORD*)(a1 + 376) = 0;
            *(_DWORD*)(a1 + 340) = 0;
            *(_DWORD*)(a1 + 344) = 0;
            *(_DWORD*)(a1 + 352) = 0;
            *(_DWORD*)(a1 + 356) = 0;
        }
        if (*(_DWORD*)(a1 + 304))
        {
            if (sub_425E70(*(_BYTE**)(a1 + 304)) == 1)
            {
                v63 = sub_426090(*(_DWORD**)(a1 + 304));
                v62 = sub_4260B0(*(_DWORD**)(a1 + 304));
                v64 = sub_4260D0(*(_DWORD**)(a1 + 304));
                *(_BYTE*)(a1 + 212) = 0;
                v60 = *(_DWORD*)(a1 + 328);
                v59 = v62;
                v61 = *(_DWORD*)(a1 + 336);
                *(_DWORD*)(a1 + 392) = 1;
                if (*(_DWORD*)(a1 + 444) == 1)
                    *(_DWORD*)(a1 + 424) = sub_425D70(*(_DWORD**)(a1 + 304)) == 0;
                if (*(int*)(a1 + 444) >= 46)
                {
                    if (*(int*)(a1 + 444) >= 50)
                    {
                        if (*(_DWORD*)(a1 + 444) == 50)
                        {
                            v60 = v63 - 1200 * ((*(_DWORD*)(a1 + 424) == 0) - *(_DWORD*)(a1 + 424));
                            *(_DWORD*)(a1 + 424) = *(_DWORD*)(a1 + 424) == 0;
                            *(_WORD*)(a1 + 204) = 197;
                        }
                    }
                    else
                    {
                        v60 = 200 * ((*(_DWORD*)(a1 + 424) == 0) - *(_DWORD*)(a1 + 424)) + v63;
                        v61 = v64 - 1300;
                        *(_BYTE*)(a1 + 223) = sub_426030(*(_BYTE**)(a1 + 304)) + 1;
                        *(_WORD*)(a1 + 204) = 199;
                    }
                }
                else
                {
                    v60 = 1200 * ((*(_DWORD*)(a1 + 424) == 0) - *(_DWORD*)(a1 + 424)) + v63;
                    v61 = v64 - 1300;
                    *(_BYTE*)(a1 + 223) = sub_426030(*(_BYTE**)(a1 + 304)) - 1;
                    *(_WORD*)(a1 + 204) = (*(_DWORD*)(a1 + 444) - 1) / 5 % 3;
                    if (*(_WORD*)(a1 + 204))
                        *(_WORD*)(a1 + 204) = 197;
                    else
                        *(_WORD*)(a1 + 204) = 198;
                    if ((*(_DWORD*)(a1 + 444) - 1) % 15 == 5)
                        sub_41261C((_WORD*)a1, 3 * *(unsigned __int16*)(a1 + 242) / 4, 0, 1);
                }
                *(_DWORD*)(a1 + 372) = v60 - *(_DWORD*)(a1 + 328);
                *(_DWORD*)(a1 + 340) = 0;
                *(_DWORD*)(a1 + 352) = 0;
                *(_DWORD*)(a1 + 376) = v59 - *(_DWORD*)(a1 + 332);
                *(_DWORD*)(a1 + 344) = 0;
                *(_DWORD*)(a1 + 356) = 0;
                *(_DWORD*)(a1 + 348) = v61 - *(_DWORD*)(a1 + 336);
                *(_DWORD*)(a1 + 360) = 0;
                if (*(_DWORD*)(a1 + 444) == 51)
                {
                    *(_DWORD*)(a1 + 304) = 0;
                    *(_DWORD*)(a1 + 432) = 38;
                    *(_DWORD*)(a1 + 372) = 350 * ((*(_DWORD*)(a1 + 424) == 0) - *(_DWORD*)(a1 + 424));
                    *(_DWORD*)(a1 + 340) = 0;
                    *(_DWORD*)(a1 + 352) = 0;
                    *(_DWORD*)(a1 + 376) = 0;
                    *(_DWORD*)(a1 + 344) = 0;
                    *(_DWORD*)(a1 + 356) = 0;
                    *(_DWORD*)(a1 + 348) = -500;
                    *(_DWORD*)(a1 + 360) = 30;
                }
            }
            else if (*(_BYTE*)(a1 + 324))
            {
                switch (*(_BYTE*)(a1 + 324))
                {
                case 1:
                    *(_BYTE*)(a1 + 223) = sub_426030(*(_BYTE**)(a1 + 304)) - 1;
                    *(_DWORD*)(a1 + 360) = 0;
                    *(_DWORD*)(a1 + 348) = 0;
                    *(_BYTE*)(a1 + 212) = 0;
                    if (*(int*)(a1 + 444) >= 5)
                    {
                        if (*(int*)(a1 + 444) >= 20)
                            *(_WORD*)(a1 + 204) = 17;
                        else
                            *(_WORD*)(a1 + 204) = 16;
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 15;
                    }
                    if (*(_DWORD*)(a1 + 444) == 28)
                    {
                        sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                        *(_DWORD*)(a1 + 432) = 44;
                        *(_DWORD*)(a1 + 304) = 0;
                    }
                    if (*(_DWORD*)(a1 + 444) == 5)
                    {
                        *(_DWORD*)(a1 + 424) = *(_DWORD*)(a1 + 424) == 0;
                        v53 = *(unsigned __int16*)(a1 + 242) / 3;
                        if (!v53)
                            v53 = 1;
                        sub_41261C((_WORD*)a1, v53, *(_DWORD*)(a1 + 304), 1);
                    }
                    if (*(_DWORD*)(a1 + 444) == 24)
                    {
                        v52 = 2 * *(unsigned __int16*)(a1 + 242) / 3;
                        if (!v52)
                            v52 = 1;
                        sub_41261C((_WORD*)a1, v52, *(_DWORD*)(a1 + 304), 1);
                    }
                    break;
                case 2:
                    *(_BYTE*)(a1 + 223) = sub_426030(*(_BYTE**)(a1 + 304)) - 1;
                    if (*(int*)(a1 + 444) >= 8)
                    {
                        if (*(_DWORD*)(a1 + 436))
                        {
                            if (*(_DWORD*)(a1 + 436) == 1)
                            {
                                *(_DWORD*)(a1 + 436) = 2;
                                *(_DWORD*)(a1 + 392) = 0;
                                *(_DWORD*)(a1 + 336) = -100
                                    * sub_446497(
                                        (int*)unk_4B9B10,
                                        *(_DWORD*)(a1 + 328) / 100,
                                        *(_DWORD*)(a1 + 332) / 100);
                                sub_41261C((_WORD*)a1, *(unsigned __int16*)(a1 + 242), *(_DWORD*)(a1 + 304), 1);
                            }
                            else if (*(_DWORD*)(a1 + 436) == 2)
                            {
                                *(_DWORD*)(a1 + 436) = 3;
                                *(_DWORD*)(a1 + 392) = 1;
                                *(_DWORD*)(a1 + 348) = -200;
                                *(_DWORD*)(a1 + 360) = 20;
                                *(_DWORD*)(a1 + 372) = 100 * (*(_DWORD*)(a1 + 424) - (*(_DWORD*)(a1 + 424) == 0));
                                *(_WORD*)(a1 + 204) = 18;
                            }
                        }
                        else
                        {
                            *(_DWORD*)(a1 + 392) = 1;
                            *(_BYTE*)(a1 + 212) = 0;
                            *(_DWORD*)(a1 + 424) = sub_425D70(*(_DWORD**)(a1 + 304));
                            if (*(int*)(a1 + 444) >= 24)
                                *(_WORD*)(a1 + 204) = 33;
                            else
                                *(_WORD*)(a1 + 204) = 22;
                            if (sub_426010(*(_DWORD**)(a1 + 304)) == 1)
                            {
                                sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                                *(_DWORD*)(a1 + 436) = 1;
                            }
                        }
                    }
                    else
                    {
                        *(_BYTE*)(a1 + 212) = 0;
                        *(_WORD*)(a1 + 204) = 14;
                        *(_DWORD*)(a1 + 436) = 0;
                    }
                    break;
                case 3:
                    *(_BYTE*)(a1 + 212) = 0;
                    *(_BYTE*)(a1 + 223) = sub_426030(*(_BYTE**)(a1 + 304)) - 1;
                    if (*(int*)(a1 + 444) >= 8)
                    {
                        if (*(int*)(a1 + 444) >= 12)
                        {
                            if (*(int*)(a1 + 444) >= 24)
                                *(_WORD*)(a1 + 204) = 17;
                            else
                                *(_WORD*)(a1 + 204) = 19;
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 71;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 13;
                    }
                    if (*(_DWORD*)(a1 + 444) == 8)
                    {
                        *(_DWORD*)(a1 + 392) = 1;
                    }
                    else if (*(_DWORD*)(a1 + 444) == 16)
                    {
                        sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                        *(_DWORD*)(a1 + 392) = 0;
                        *(_DWORD*)(a1 + 336) = -100
                            * sub_446497(
                                (int*)unk_4B9B10,
                                *(_DWORD*)(a1 + 328) / 100,
                                *(_DWORD*)(a1 + 332) / 100);
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A10, -1, 100, 100, 0);
                        sub_41261C((_WORD*)a1, *(unsigned __int16*)(a1 + 242), *(_DWORD*)(a1 + 304), 1);
                    }
                    if (*(int*)(a1 + 444) >= 40)
                    {
                        *(_DWORD*)(a1 + 432) = 44;
                        *(_DWORD*)(a1 + 304) = 0;
                    }
                    break;
                }
            }
            else
            {
                *(_BYTE*)(a1 + 223) = sub_426030(*(_BYTE**)(a1 + 304)) - 1;
                *(_BYTE*)(a1 + 212) = 0;
                v58 = sub_426090(*(_DWORD**)(a1 + 304));
                v57 = sub_4260D0(*(_DWORD**)(a1 + 304));
                *(_DWORD*)(a1 + 392) = 1;
                v55 = *(_DWORD*)(a1 + 328);
                v56 = *(_DWORD*)(a1 + 336);
                if (*(int*)(a1 + 444) >= 5)
                {
                    if (*(int*)(a1 + 444) >= 9)
                    {
                        if (*(int*)(a1 + 444) >= 17)
                        {
                            if (*(int*)(a1 + 444) >= 41)
                            {
                                if (*(int*)(a1 + 444) >= 49)
                                {
                                    if (*(int*)(a1 + 444) >= 56)
                                    {
                                        if (*(_DWORD*)(a1 + 444) == 56)
                                        {
                                            sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                                            *(_DWORD*)(a1 + 340) = 100;
                                            if (*(_DWORD*)(a1 + 424))
                                                *(_DWORD*)(a1 + 340) = -*(_DWORD*)(a1 + 340);
                                            *(_DWORD*)(a1 + 348) = -250;
                                            *(_DWORD*)(a1 + 360) = 30;
                                        }
                                    }
                                    else
                                    {
                                        if (*(_DWORD*)(a1 + 444) == 49)
                                        {
                                            sub_43FFC3((int*)unk_4BDB28, dword_4B9A20, -1, 100, 100, 0);
                                            sub_41261C((_WORD*)a1, *(unsigned __int16*)(a1 + 242), *(_DWORD*)(a1 + 304), 1);
                                        }
                                        v56 = v57;
                                        v54 = -100 * sub_446497((int*)unk_4B9B10, v55 / 100, *(_DWORD*)(a1 + 332) / 100);
                                        *(_DWORD*)(a1 + 392) = v54 > v57;
                                        *(_WORD*)(a1 + 204) = 33;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 22;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 32;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 20;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 19;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 21;
                }
                if (*(int*)(a1 + 444) > 100)
                {
                    *(_DWORD*)(a1 + 432) = 3;
                    *(_DWORD*)(a1 + 304) = 0;
                    *(_DWORD*)(a1 + 444) = 0;
                }
            }
            return;
        }
        goto LABEL_499;
    case 0x3A:
        if (*(_DWORD*)(a1 + 304) && *(_DWORD*)(a1 + 444) == 1)
        {
            v51 = 0;
            if (*(_BYTE*)(a1 + 195))
            {
                switch (*(_BYTE*)(a1 + 195))
                {
                case 1:
                    v51 = 35 * sub_4175B4(a1, 1) / 100;
                    break;
                case 2:
                    v51 = 30 * sub_4175B4(a1, 1) / 100;
                    break;
                case 3:
                    v51 = 40 * sub_4175B4(a1, 1) / 100;
                    break;
                }
            }
            else
            {
                v51 = 38 * sub_4175B4(a1, 1) / 100;
            }
            if (*(_BYTE*)(a1 + 258) == 1)
            {
                v51 = 12 * v51 / 10;
            }
            else if (*(_BYTE*)(a1 + 258) == 2)
            {
                v51 = 7 * v51 / 10;
            }
            if (!v51)
                v51 = 1;
            sub_41EF8A(*(_WORD**)(a1 + 304), v51);
            *(_DWORD*)(a1 + 372) = 0;
            *(_DWORD*)(a1 + 376) = 0;
            *(_DWORD*)(a1 + 340) = 0;
            *(_DWORD*)(a1 + 344) = 0;
            *(_DWORD*)(a1 + 352) = 0;
            *(_DWORD*)(a1 + 356) = 0;
        }
        if (*(_BYTE*)(a1 + 195))
        {
            switch (*(_BYTE*)(a1 + 195))
            {
            case 1:
                if (*(_DWORD*)(a1 + 304))
                {
                    if (*(_DWORD*)(a1 + 444) == 1)
                    {
                        sub_423CF2(*(_BYTE**)(a1 + 304), 1, 0, 1, 0, 1, -24);
                    }
                    else if (*(_DWORD*)(a1 + 444) == 10)
                    {
                        sub_423CF2(*(_BYTE**)(a1 + 304), 1, 0, 1, 0, 0, 0);
                    }
                }
                *(_BYTE*)(a1 + 212) = 1;
                if (*(int*)(a1 + 444) >= 8)
                {
                    if (*(int*)(a1 + 444) >= 24)
                    {
                        if (*(int*)(a1 + 444) >= 40)
                        {
                            *(_BYTE*)(a1 + 212) = 0;
                            *(_WORD*)(a1 + 204) = 6;
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 17;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 16;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 15;
                }
                if (*(int*)(a1 + 444) >= 56)
                {
                    *(_DWORD*)(a1 + 432) = 4;
                    *(_DWORD*)(a1 + 304) = 0;
                }
                break;
            case 2:
                if (*(_DWORD*)(a1 + 304))
                {
                    if (*(_DWORD*)(a1 + 444) == 1)
                    {
                        sub_423CF2(*(_BYTE**)(a1 + 304), 1, 0, 1, 0, 1, -24);
                    }
                    else if (*(_DWORD*)(a1 + 444) == 20)
                    {
                        sub_423CF2(*(_BYTE**)(a1 + 304), 1, 0, 1, 0, 1, 0);
                    }
                }
                *(_BYTE*)(a1 + 212) = 0;
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_DWORD*)(a1 + 436) = 0;
                    *(_DWORD*)(a1 + 340) = 0;
                    *(_DWORD*)(a1 + 344) = 0;
                    *(_DWORD*)(a1 + 348) = -350;
                    *(_DWORD*)(a1 + 360) = 20;
                    *(_DWORD*)(a1 + 392) = 1;
                }
                else if (*(_DWORD*)(a1 + 444) == 20)
                {
                    *(_DWORD*)(a1 + 348) = 300;
                }
                if (*(int*)(a1 + 444) >= 4)
                {
                    if (*(int*)(a1 + 444) >= 20)
                        *(_WORD*)(a1 + 204) = 33;
                    else
                        *(_WORD*)(a1 + 204) = 53;
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 52;
                }
                break;
            case 3:
                if (*(_DWORD*)(a1 + 304))
                {
                    if (*(_DWORD*)(a1 + 444) == 1)
                    {
                        sub_423CF2(*(_BYTE**)(a1 + 304), 1, -16, 1, 0, 0, 0);
                    }
                    else if (*(_DWORD*)(a1 + 444) == 12)
                    {
                        sub_423CF2(*(_BYTE**)(a1 + 304), 1, 0, 1, 0, 1, -16);
                    }
                }
                if (*(int*)(a1 + 444) >= 4)
                {
                    if (*(int*)(a1 + 444) >= 8)
                    {
                        if (*(int*)(a1 + 444) >= 12)
                        {
                            if (*(int*)(a1 + 444) >= 16)
                            {
                                if (*(int*)(a1 + 444) >= 20)
                                {
                                    if (*(int*)(a1 + 444) >= 28)
                                    {
                                        if (*(int*)(a1 + 444) >= 36)
                                        {
                                            *(_BYTE*)(a1 + 212) = 0;
                                            *(_WORD*)(a1 + 204) = 20;
                                        }
                                        else
                                        {
                                            *(_WORD*)(a1 + 204) = 18;
                                        }
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 19;
                                    }
                                }
                                else
                                {
                                    *(_BYTE*)(a1 + 212) = 1;
                                    *(_WORD*)(a1 + 204) = 18;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 20;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 21;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 30;
                    }
                }
                else
                {
                    *(_BYTE*)(a1 + 212) = 0;
                    *(_WORD*)(a1 + 204) = 31;
                }
                if (*(_DWORD*)(a1 + 444) == 16)
                {
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A18, -1, 100, 100, 0);
                    *(_DWORD*)(a1 + 304) = 0;
                }
                if (*(int*)(a1 + 444) >= 44)
                    *(_DWORD*)(a1 + 432) = 4;
                break;
            }
        }
        else
        {
            if (*(_DWORD*)(a1 + 304))
            {
                switch (*(_DWORD*)(a1 + 444))
                {
                case 1:
                    sub_423CF2(*(_BYTE**)(a1 + 304), 1, -16, 1, 0, 1, 0);
                    break;
                case 0xC:
                    sub_423CF2(*(_BYTE**)(a1 + 304), 1, 4, 1, 0, 1, -12);
                    break;
                case 0x18:
                    sub_423CF2(*(_BYTE**)(a1 + 304), 1, 20, 1, 0, 1, 0);
                    break;
                }
            }
            if (*(int*)(a1 + 444) >= 6)
            {
                if (*(int*)(a1 + 444) >= 12)
                {
                    if (*(int*)(a1 + 444) >= 24)
                    {
                        if (*(int*)(a1 + 444) >= 30)
                        {
                            if (*(int*)(a1 + 444) >= 54)
                            {
                                *(_BYTE*)(a1 + 212) = 0;
                                *(_WORD*)(a1 + 204) = 6;
                            }
                            else
                            {
                                *(_BYTE*)(a1 + 212) = 1;
                                *(_WORD*)(a1 + 204) = 13;
                            }
                        }
                        else
                        {
                            *(_BYTE*)(a1 + 212) = 1;
                            *(_WORD*)(a1 + 204) = 12;
                        }
                    }
                    else
                    {
                        *(_BYTE*)(a1 + 212) = 1;
                        *(_WORD*)(a1 + 204) = 11;
                    }
                }
                else
                {
                    *(_BYTE*)(a1 + 212) = 0;
                    *(_WORD*)(a1 + 204) = 30;
                }
            }
            else
            {
                *(_BYTE*)(a1 + 212) = 0;
                *(_WORD*)(a1 + 204) = 31;
            }
            if (*(int*)(a1 + 444) >= 64)
            {
                *(_DWORD*)(a1 + 432) = 3;
                *(_DWORD*)(a1 + 304) = 0;
                *(_DWORD*)(a1 + 444) = 0;
            }
        }
        return;
    case 0x3C:
        if (*(_DWORD*)(a1 + 304) && *(_DWORD*)(a1 + 444) == 1)
        {
            *(_DWORD*)(a1 + 424) = sub_425D70(*(_DWORD**)(a1 + 304));
            *(_BYTE*)(a1 + 324) = sub_4264F0(*(_BYTE**)(a1 + 304));
            *(_DWORD*)(a1 + 372) = 0;
            *(_DWORD*)(a1 + 376) = 0;
            *(_DWORD*)(a1 + 340) = 0;
            *(_DWORD*)(a1 + 344) = 0;
            *(_DWORD*)(a1 + 352) = 0;
            *(_DWORD*)(a1 + 356) = 0;
        }
        if (*(_DWORD*)(a1 + 304))
        {
            if (*(_BYTE*)(a1 + 324))
            {
                switch (*(_BYTE*)(a1 + 324))
                {
                case 1:
                    *(_BYTE*)(a1 + 212) = 0;
                    *(_BYTE*)(a1 + 223) = sub_426030(*(_BYTE**)(a1 + 304)) + 1;
                    *(_DWORD*)(a1 + 392) = 1;
                    if (*(int*)(a1 + 444) >= 10)
                    {
                        if (*(_DWORD*)(a1 + 444) == 10)
                        {
                            *(_DWORD*)(a1 + 360) = 16;
                        }
                        else if (*(int*)(a1 + 444) >= 24)
                        {
                            if (*(_DWORD*)(a1 + 444) == 24)
                            {
                                *(_DWORD*)(a1 + 348) = 0;
                                *(_DWORD*)(a1 + 360) = 0;
                                sub_43FFC3((int*)unk_4BDB28, dword_4B9A10, -1, 100, 100, 0);
                                *(_WORD*)(a1 + 204) = 17;
                                sub_41261C((_WORD*)a1, *(unsigned __int16*)(a1 + 242), *(_DWORD*)(a1 + 304), 1);
                            }
                            else if (*(int*)(a1 + 444) >= 35)
                            {
                                if (*(_DWORD*)(a1 + 444) == 35)
                                {
                                    *(_DWORD*)(a1 + 348) = -16;
                                    *(_DWORD*)(a1 + 360) = 16;
                                    sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 18;
                                }
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 18;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 18;
                        *(_DWORD*)(a1 + 348) = 0;
                    }
                    break;
                case 2:
                    *(_BYTE*)(a1 + 212) = 0;
                    *(_WORD*)(a1 + 204) = 18;
                    if (*(_DWORD*)(a1 + 444) == 1)
                    {
                        *(_DWORD*)(a1 + 436) = 0;
                        *(_DWORD*)(a1 + 392) = 1;
                    }
                    if (*(int*)(a1 + 444) >= 20)
                    {
                        if (sub_426010(*(_DWORD**)(a1 + 304)))
                        {
                            if (sub_426010(*(_DWORD**)(a1 + 304)) != 1 || *(_DWORD*)(a1 + 436))
                            {
                                if (*(_DWORD*)(a1 + 436) == 1)
                                    *(_WORD*)(a1 + 204) = 17;
                            }
                            else
                            {
                                sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                                sub_41261C((_WORD*)a1, *(unsigned __int16*)(a1 + 242), *(_DWORD*)(a1 + 304), 1);
                                *(_DWORD*)(a1 + 436) = 1;
                                *(_WORD*)(a1 + 204) = 17;
                                *(_DWORD*)(a1 + 336) = sub_446497(
                                    (int*)unk_4B9B10,
                                    *(_DWORD*)(a1 + 328) / 100,
                                    *(_DWORD*)(a1 + 332) / 100);
                                *(_DWORD*)(a1 + 392) = 0;
                            }
                        }
                        else
                        {
                            *(_BYTE*)(a1 + 223) = sub_426030(*(_BYTE**)(a1 + 304)) - 1;
                        }
                    }
                    else
                    {
                        *(_BYTE*)(a1 + 223) = sub_426030(*(_BYTE**)(a1 + 304)) + 1;
                    }
                    if (*(int*)(a1 + 444) > 34)
                    {
                        *(_DWORD*)(a1 + 392) = 0;
                        *(_DWORD*)(a1 + 304) = 0;
                        *(_DWORD*)(a1 + 432) = 44;
                    }
                    break;
                case 3:
                    if (*(_DWORD*)(a1 + 444) == 1)
                    {
                        *(_BYTE*)(a1 + 212) = 0;
                        *(_BYTE*)(a1 + 223) = sub_426030(*(_BYTE**)(a1 + 304)) - 1;
                        *(_DWORD*)(a1 + 436) = 0;
                    }
                    if (!*(_DWORD*)(a1 + 436))
                    {
                        if (*(int*)(a1 + 444) >= 12)
                        {
                            if (*(int*)(a1 + 444) >= 16)
                            {
                                if (*(int*)(a1 + 444) > 24)
                                    *(_WORD*)(a1 + 204) = 19;
                            }
                            else
                            {
                                *(_DWORD*)(a1 + 392) = 1;
                                *(_WORD*)(a1 + 204) = 17;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 16;
                        }
                        if (*(_DWORD*)(a1 + 444) == 16)
                        {
                            sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                            *(_DWORD*)(a1 + 340) = 600;
                            if (sub_425D70(*(_DWORD**)(a1 + 304)))
                                *(_DWORD*)(a1 + 340) = -*(_DWORD*)(a1 + 340);
                            *(_DWORD*)(a1 + 348) = -50;
                            *(_DWORD*)(a1 + 360) = 10;
                            *(_DWORD*)(a1 + 432) = 61;
                        }
                    }
                    break;
                }
            }
            else
            {
                *(_BYTE*)(a1 + 223) = sub_426030(*(_BYTE**)(a1 + 304)) - 1;
                *(_BYTE*)(a1 + 212) = 0;
                v50[5] = sub_426090(*(_DWORD**)(a1 + 304));
                v50[4] = sub_4260D0(*(_DWORD**)(a1 + 304));
                *(_DWORD*)(a1 + 392) = 1;
                v50[2] = *(_DWORD*)(a1 + 328);
                v50[3] = *(_DWORD*)(a1 + 336);
                if (*(int*)(a1 + 444) >= 12)
                {
                    if (*(int*)(a1 + 444) >= 24)
                    {
                        if (*(int*)(a1 + 444) < 54)
                            *(_WORD*)(a1 + 204) = 33;
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 17;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 16;
                }
                if (*(_DWORD*)(a1 + 444) == 24)
                {
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A20, -1, 100, 100, 0);
                    sub_41261C((_WORD*)a1, *(unsigned __int16*)(a1 + 242), *(_DWORD*)(a1 + 304), 1);
                }
                else if (*(int*)(a1 + 444) >= 54)
                {
                    sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                    *(_DWORD*)(a1 + 392) = 0;
                    *(_DWORD*)(a1 + 432) = 44;
                    *(_DWORD*)(a1 + 304) = 0;
                    *(_DWORD*)(a1 + 444) = 0;
                    *(_DWORD*)(a1 + 436) = 0;
                }
            }
            return;
        }
    LABEL_499:
        sub_417C83(a1);
        return;
    case 0x3D:
        if (*(_DWORD*)(a1 + 444) == 1)
        {
            *(_DWORD*)(a1 + 436) = 0;
            *(_WORD*)(a1 + 204) = 49;
            *(_BYTE*)(a1 + 248) = 2;
            *(_BYTE*)(a1 + 253) = 1;
            sub_41F169((_WORD*)a1, 2 * *(unsigned __int16*)(a1 + 242));
            *(_BYTE*)(a1 + 213) = 5;
            memset((void*)(a1 + 453), 0, 8u);
            memset((void*)(a1 + 461), 0, 8u);
            *(_BYTE*)(a1 + 257) = 1;
            if (*(_DWORD*)(a1 + 304))
            {
                *(_BYTE*)(a1 + (unsigned __int8)sub_425EF0(*(_BYTE**)(a1 + 304)) + 453) = -1;
                *(_DWORD*)(a1 + 316) = *(_DWORD*)(a1 + 304);
                *(_DWORD*)(a1 + 304) = 0;
            }
        }
        if (*(_DWORD*)(a1 + 436) == 1)
        {
            *(_DWORD*)(a1 + 444) = 2;
            *(_DWORD*)(a1 + 436) = 2;
            *(_BYTE*)(a1 + 257) = 2;
            *(_DWORD*)(a1 + 340) = -*(_DWORD*)(a1 + 372) / 2;
            *(_WORD*)(a1 + 204) = 28;
            sub_43FFC3((int*)unk_4BDB28, dword_4B9A10, -1, 100, 100, 0);
            sub_41261C((_WORD*)a1, *(unsigned __int16*)(a1 + 242), *(_DWORD*)(a1 + 316), 1);
            if (*(_DWORD*)(a1 + 392))
            {
                *(_DWORD*)(a1 + 432) = 29;
                *(_DWORD*)(a1 + 304) = 0;
            }
        }
        else if (*(_DWORD*)(a1 + 436) == 2 && *(int*)(a1 + 444) > 10)
        {
            *(_DWORD*)(a1 + 432) = 45;
            *(_DWORD*)(a1 + 304) = 0;
        }
        return;
    case 0xE:
        *(_BYTE*)(a1 + 212) = 0;
        if (sub_425FF0((int*)a1))
            *(_WORD*)(a1 + 204) = 158;
        else
            *(_WORD*)(a1 + 204) = 13;
        if (*(int*)(a1 + 444) > 15)
            *(_DWORD*)(a1 + 432) = 3;
        if (*(int*)(a1 + 444) <= 1)
        {
            *(_DWORD*)(a1 + 372) = 0;
            if (*(_DWORD*)(a1 + 436))
                *(_DWORD*)(a1 + 372) = 100;
            else
                *(_DWORD*)(a1 + 372) = -100;
            *(_DWORD*)(a1 + 376) = 0;
            *(_DWORD*)(a1 + 436) = 0;
            *(_DWORD*)(a1 + 344) = 0;
            *(_DWORD*)(a1 + 352) = *(_DWORD*)(a1 + 372) / -5;
            *(_DWORD*)(a1 + 356) = 0;
            *(_DWORD*)(a1 + 348) = 0;
            *(_DWORD*)(a1 + 360) = 0;
        }
        return;
    case 0xF:
        *(_BYTE*)(a1 + 212) = 0;
        if (*(_DWORD*)(a1 + 444) == 1)
        {
            *(_DWORD*)(a1 + 360) = 0;
            *(_DWORD*)(a1 + 356) = 0;
            *(_DWORD*)(a1 + 352) = 0;
            *(_DWORD*)(a1 + 348) = 0;
            *(_DWORD*)(a1 + 344) = 0;
            *(_DWORD*)(a1 + 340) = 0;
            *(_DWORD*)(a1 + 376) = 0;
            *(_DWORD*)(a1 + 372) = 0;
        }
        if (*(int*)(a1 + 444) >= 10)
            *(_WORD*)(a1 + 204) = 15;
        else
            *(_WORD*)(a1 + 204) = 14;
        if (*(int*)(a1 + 444) > 120)
            *(_DWORD*)(a1 + 432) = 3;
        return;
    case 0x10:
        *(_BYTE*)(a1 + 212) = 0;
        if (*(int*)(a1 + 444) >= 5)
            *(_WORD*)(a1 + 204) = 16;
        else
            *(_WORD*)(a1 + 204) = 13;
        if (*(int*)(a1 + 444) <= 1)
        {
            if (*(_DWORD*)(a1 + 436))
                *(_DWORD*)(a1 + 372) = 100;
            else
                *(_DWORD*)(a1 + 372) = -100;
            *(_DWORD*)(a1 + 340) = 0;
            *(_DWORD*)(a1 + 344) = 0;
            *(_DWORD*)(a1 + 352) = 0;
            *(_DWORD*)(a1 + 356) = 0;
            *(_DWORD*)(a1 + 436) = 0;
            *(_DWORD*)(a1 + 348) = -180;
            *(_DWORD*)(a1 + 360) = 30;
        }
        return;
    case 0x11:
    case 0x17:
    case 0x18:
    case 0x19:
        *(_BYTE*)(a1 + 212) = 0;
        switch (*(_DWORD*)(a1 + 428))
        {
        case 0x17:
            *(_BYTE*)(a1 + 248) = 14;
            *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 8 % 2 + 174;
            break;
        case 0x18:
            *(_BYTE*)(a1 + 248) = 15;
            *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 4 % 2 + 176;
            break;
        case 0x19:
            *(_BYTE*)(a1 + 248) = 16;
            *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 4 % 3 + 178;
            break;
        case 0x11:
            *(_BYTE*)(a1 + 248) = 4;
            *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 4 % 2 + 72;
            break;
        }
        *(_BYTE*)(a1 + 255) = 0;
        *(_BYTE*)(a1 + 253) = 1;
        sub_41F169((_WORD*)a1, 30);
        *(_BYTE*)(a1 + 213) = -1;
        if (*(int*)(a1 + 444) <= 1)
        {
            memset((void*)(a1 + 453), 0, 8u);
            memset((void*)(a1 + 461), 0, 8u);
        }
        return;
    case 0x12:
    case 0x14:
    case 0x15:
    case 0x16:
        if (*(int*)(a1 + 444) <= 1)
        {
            *(_BYTE*)(a1 + 251) = 0;
            memset((void*)(a1 + 453), 0, 8u);
            memset((void*)(a1 + 461), 0, 8u);
        }
        *(_BYTE*)(a1 + 212) = 0;
        switch (*(_DWORD*)(a1 + 428))
        {
        case 0x12:
            *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 8 % 2 + 174;
            break;
        case 0x14:
            *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 4 % 2 + 176;
            break;
        case 0x15:
            *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 4 % 3 + 178;
            break;
        case 0x16:
            *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 4 % 2 + 185;
            break;
        }
        return;
    case 0x13:
        if (*(int*)(a1 + 444) <= 1)
        {
            memset((void*)(a1 + 453), 0, 8u);
            memset((void*)(a1 + 461), 0, 8u);
        }
        if (!((*(_DWORD*)(a1 + 444) - 1) % 4))
            *(_DWORD*)(a1 + 424) = *(_DWORD*)(a1 + 424) == 0;
        *(_BYTE*)(a1 + 212) = 0;
        if (*(int*)(a1 + 348) >= 0)
            *(_WORD*)(a1 + 204) = 19;
        else
            *(_WORD*)(a1 + 204) = 16;
        return;
    case 0x25:
        *(_BYTE*)(a1 + 212) = 0;
        if (*(int*)(a1 + 444) <= 1)
        {
            *(_DWORD*)(a1 + 372) = 0;
            *(_DWORD*)(a1 + 380) = 0;
            if (*(_DWORD*)(a1 + 436))
                *(_DWORD*)(a1 + 372) = 400;
            else
                *(_DWORD*)(a1 + 372) = -400;
            *(_DWORD*)(a1 + 436) = 0;
            *(_DWORD*)(a1 + 340) = 0;
            *(_DWORD*)(a1 + 352) = 0;
            *(_DWORD*)(a1 + 356) = 0;
            *(_DWORD*)(a1 + 344) = 0;
            *(_DWORD*)(a1 + 348) = -620;
            *(_DWORD*)(a1 + 360) = 40;
        }
        if (*(int*)(a1 + 444) >= 14)
        {
            if (*(int*)(a1 + 444) >= 21)
            {
                *(_WORD*)(a1 + 204) = 19;
            }
            else if ((!*(_DWORD*)(a1 + 424) || *(int*)(a1 + 372) >= 0)
                && (*(_DWORD*)(a1 + 424) || *(int*)(a1 + 372) <= 0))
            {
                *(_WORD*)(a1 + 204) = 28;
            }
            else
            {
                *(_WORD*)(a1 + 204) = 17;
            }
        }
        else if ((!*(_DWORD*)(a1 + 424) || *(int*)(a1 + 372) >= 0)
            && (*(_DWORD*)(a1 + 424) || *(int*)(a1 + 372) <= 0))
        {
            *(_WORD*)(a1 + 204) = 26;
        }
        else
        {
            *(_WORD*)(a1 + 204) = 16;
        }
        return;
    case 0x22:
        *(_BYTE*)(a1 + 212) = 0;
        if (*(int*)(a1 + 444) <= 1)
        {
            *(_DWORD*)(a1 + 380) = 0;
            *(_DWORD*)(a1 + 372) = 0;
            if (*(_DWORD*)(a1 + 436) == 1)
            {
                *(_DWORD*)(a1 + 372) = 200;
            }
            else if (!*(_DWORD*)(a1 + 436))
            {
                *(_DWORD*)(a1 + 372) = -200;
            }
            *(_DWORD*)(a1 + 436) = 0;
            *(_DWORD*)(a1 + 352) = 0;
            *(_DWORD*)(a1 + 356) = 0;
            *(_DWORD*)(a1 + 344) = 0;
            *(_DWORD*)(a1 + 348) = -500;
            *(_DWORD*)(a1 + 360) = 40;
        }
        if ((!*(_DWORD*)(a1 + 424) || *(int*)(a1 + 372) >= 0) && (*(_DWORD*)(a1 + 424) || *(int*)(a1 + 372) <= 0))
            *(_WORD*)(a1 + 204) = 26;
        else
            *(_WORD*)(a1 + 204) = 16;
        return;
    case 0x24:
        if (*(int*)(a1 + 444) <= 1)
        {
            *(_DWORD*)(a1 + 380) = 0;
            *(_DWORD*)(a1 + 372) = 0;
            if (*(_DWORD*)(a1 + 436))
                *(_DWORD*)(a1 + 372) = 400;
            else
                *(_DWORD*)(a1 + 372) = -400;
            *(_DWORD*)(a1 + 352) = 0;
            *(_DWORD*)(a1 + 356) = 0;
            *(_DWORD*)(a1 + 340) = 0;
            *(_DWORD*)(a1 + 344) = 0;
            *(_DWORD*)(a1 + 348) = -300;
            *(_DWORD*)(a1 + 360) = 30;
        }
        *(_BYTE*)(a1 + 212) = 0;
        if ((!*(_DWORD*)(a1 + 424) || *(int*)(a1 + 372) >= 0) && (*(_DWORD*)(a1 + 424) || *(int*)(a1 + 372) <= 0))
            *(_WORD*)(a1 + 204) = 26;
        else
            *(_WORD*)(a1 + 204) = 16;
        return;
    case 0x26:
        if (*(_DWORD*)(a1 + 444) == 1)
        {
            *(_DWORD*)(a1 + 380) = 0;
            *(_DWORD*)(a1 + 352) = 0;
            *(_DWORD*)(a1 + 356) = 0;
        }
        *(_BYTE*)(a1 + 212) = 0;
        *(_WORD*)(a1 + 204) = 16;
        return;
    case 0x23:
        *(_BYTE*)(a1 + 212) = 0;
        if (*(int*)(a1 + 444) <= 1)
        {
            *(_DWORD*)(a1 + 380) = 0;
            *(_DWORD*)(a1 + 372) = 0;
            if (*(_DWORD*)(a1 + 436))
                *(_DWORD*)(a1 + 372) = 100;
            else
                *(_DWORD*)(a1 + 372) = -100;
            *(_DWORD*)(a1 + 436) = 0;
            *(_DWORD*)(a1 + 352) = 0;
            *(_DWORD*)(a1 + 356) = 0;
            *(_DWORD*)(a1 + 340) = 0;
            *(_DWORD*)(a1 + 344) = 0;
            *(_DWORD*)(a1 + 348) = -700;
            *(_DWORD*)(a1 + 360) = 30;
        }
        if ((!*(_DWORD*)(a1 + 424) || *(int*)(a1 + 372) >= 0) && (*(_DWORD*)(a1 + 424) || *(int*)(a1 + 372) <= 0))
            *(_WORD*)(a1 + 204) = 26;
        else
            *(_WORD*)(a1 + 204) = 16;
        return;
    case 0x1D:
        if (*(_DWORD*)(a1 + 444) == 1)
        {
            *(_DWORD*)(a1 + 392) = 1;
            *(_DWORD*)(a1 + 352) = 0;
            *(_DWORD*)(a1 + 356) = 0;
        }
        *(_DWORD*)(a1 + 380) = 0;
        *(_BYTE*)(a1 + 212) = 0;
        if ((!*(_DWORD*)(a1 + 424) || *(int*)(a1 + 372) >= 0) && (*(_DWORD*)(a1 + 424) || *(int*)(a1 + 372) <= 0))
            *(_WORD*)(a1 + 204) = 26;
        else
            *(_WORD*)(a1 + 204) = 16;
        return;
    case 0x27:
        *(_BYTE*)(a1 + 212) = 0;
        if (*(int*)(a1 + 444) <= 1)
        {
            *(_DWORD*)(a1 + 180) = 1;
            *(_BYTE*)(a1 + 177) = 1;
            *(_DWORD*)(a1 + 372) = 0;
            *(_DWORD*)(a1 + 380) = 0;
            if (*(_DWORD*)(a1 + 436))
                *(_DWORD*)(a1 + 372) = 600;
            else
                *(_DWORD*)(a1 + 372) = -600;
            *(_DWORD*)(a1 + 340) = 0;
            *(_DWORD*)(a1 + 352) = 0;
            *(_DWORD*)(a1 + 356) = 0;
            *(_DWORD*)(a1 + 344) = 0;
            *(_DWORD*)(a1 + 376) = 0;
            *(_DWORD*)(a1 + 348) = -600;
            *(_DWORD*)(a1 + 360) = 0;
            *(_DWORD*)(a1 + 440) = 0;
        }
        if ((!*(_DWORD*)(a1 + 424) || *(int*)(a1 + 372) >= 0) && (*(_DWORD*)(a1 + 424) || *(int*)(a1 + 372) <= 0))
            *(_WORD*)(a1 + 204) = 26;
        else
            *(_WORD*)(a1 + 204) = 16;
        if (*(_DWORD*)(a1 + 440))
        {
            if (*(_DWORD*)(a1 + 440) + 60 == *(_DWORD*)(a1 + 444))
            {
                v47 = sub_446465((char*)unk_4B9B10);
                sub_446442((int*)unk_4B9B10, a1, (int)&v45);
                v49 = 800 * sub_44647E((char*)unk_4B9B10);
                if (*(int*)(a1 + 332) >= 0)
                {
                    if (*(_DWORD*)(a1 + 332) >= v49)
                        *(_DWORD*)(a1 + 332) = v49 - 100;
                }
                else
                {
                    *(_DWORD*)(a1 + 332) = 0;
                }
                if (v45 >= -32)
                {
                    *(_DWORD*)(a1 + 328) = 100 * v47;
                    v46 = 800;
                }
                else
                {
                    *(_DWORD*)(a1 + 328) = 100 * (v47 + 320);
                    v46 = -800;
                }
                do
                {
                    *(_DWORD*)(a1 + 328) += v46;
                    v48 = sub_446497((int*)unk_4B9B10, *(_DWORD*)(a1 + 328) / 100, *(_DWORD*)(a1 + 332) / 100);
                } while (v48 == 1020);
                *(int*)(a1 + 372) /= 2;
                *(_DWORD*)(a1 + 336) = -48000;
                *(_DWORD*)(a1 + 348) = 0;
                *(_DWORD*)(a1 + 360) = 30;
                *(_DWORD*)(a1 + 180) = 0;
                *(_BYTE*)(a1 + 177) = 0;
            }
        }
        else
        {
            sub_446442((int*)unk_4B9B10, a1, (int)v50);
            if (v50[0] < -32 || v50[0] > 352)
                *(_DWORD*)(a1 + 440) = *(_DWORD*)(a1 + 444);
        }
        return;
    case 0x1E:
        if (*(int*)(a1 + 444) <= 1)
        {
            *(_DWORD*)(a1 + 380) = 0;
            *(_DWORD*)(a1 + 372) = 0;
            if (*(_DWORD*)(a1 + 436))
                *(_DWORD*)(a1 + 372) = 400;
            else
                *(_DWORD*)(a1 + 372) = -400;
            *(_DWORD*)(a1 + 352) = 0;
            *(_DWORD*)(a1 + 356) = 0;
            *(_DWORD*)(a1 + 340) = 0;
            *(_DWORD*)(a1 + 344) = 0;
            *(_DWORD*)(a1 + 348) = -150;
            *(_DWORD*)(a1 + 360) = 30;
        }
        *(_BYTE*)(a1 + 212) = 0;
        if ((!*(_DWORD*)(a1 + 424) || *(int*)(a1 + 372) >= 0) && (*(_DWORD*)(a1 + 424) || *(int*)(a1 + 372) <= 0))
            *(_WORD*)(a1 + 204) = 26;
        else
            *(_WORD*)(a1 + 204) = 16;
        return;
    case 0x21:
        *(_BYTE*)(a1 + 212) = 0;
        if (*(int*)(a1 + 444) <= 1)
        {
            *(_DWORD*)(a1 + 380) = 0;
            *(_DWORD*)(a1 + 372) = 0;
            if (*(_DWORD*)(a1 + 436))
                *(_DWORD*)(a1 + 372) = 200;
            else
                *(_DWORD*)(a1 + 372) = -200;
            *(_DWORD*)(a1 + 436) = 0;
            *(_DWORD*)(a1 + 352) = 0;
            *(_DWORD*)(a1 + 356) = 0;
            *(_DWORD*)(a1 + 344) = 0;
            *(_DWORD*)(a1 + 348) = -250;
            *(_DWORD*)(a1 + 360) = 40;
        }
        if ((!*(_DWORD*)(a1 + 424) || *(int*)(a1 + 372) >= 0) && (*(_DWORD*)(a1 + 424) || *(int*)(a1 + 372) <= 0))
            *(_WORD*)(a1 + 204) = 26;
        else
            *(_WORD*)(a1 + 204) = 16;
        return;
    case 0x28:
        if (*(_DWORD*)(a1 + 444) == 1)
        {
            *(_DWORD*)(a1 + 436) = 0;
        }
        else if (*(_DWORD*)(a1 + 444) == 8)
        {
            *(_DWORD*)(a1 + 436) = 1;
        }
        *(_BYTE*)(a1 + 212) = 0;
        if (*(int*)(a1 + 444) >= 8)
            *(_WORD*)(a1 + 204) = 17;
        else
            *(_WORD*)(a1 + 204) = 16;
        *(_DWORD*)(a1 + 348) = 800;
        return;
    case 0x2A:
        *(_BYTE*)(a1 + 212) = 0;
        if (*(int*)(a1 + 444) <= 1)
        {
            if (*(_DWORD*)(a1 + 436))
                *(_DWORD*)(a1 + 380) = 120;
            else
                *(_DWORD*)(a1 + 380) = -120;
        }
        v44 = *(_DWORD*)(a1 + 444) / 8 % 4;
        if (v44)
        {
            switch (v44)
            {
            case 1:
                *(_WORD*)(a1 + 204) = 22;
                break;
            case 2:
                *(_WORD*)(a1 + 204) = 21;
                break;
            case 3:
                *(_WORD*)(a1 + 204) = 20;
                break;
            }
        }
        else
        {
            *(_WORD*)(a1 + 204) = 23;
        }
        if (*(_DWORD*)(a1 + 436))
            *(_DWORD*)(a1 + 340) = 120;
        else
            *(_DWORD*)(a1 + 340) = -120;
        if (*(int*)(a1 + 444) > 32)
        {
            if ((!*(_DWORD*)(a1 + 424) || *(int*)(a1 + 340) >= 0) && (*(_DWORD*)(a1 + 424) || *(int*)(a1 + 340) <= 0))
                *(_DWORD*)(a1 + 432) = 45;
            else
                *(_DWORD*)(a1 + 432) = 44;
            *(_DWORD*)(a1 + 444) = 0;
        }
        return;
    case 0x2C:
        *(_BYTE*)(a1 + 212) = 0;
        *(_WORD*)(a1 + 204) = 18;
        if (*(_BYTE*)(a1 + 470))
            --* (_BYTE*)(a1 + 470);
        if (!*(_BYTE*)(a1 + 470))
        {
            *(_BYTE*)(a1 + 608) = 0;
            *(_DWORD*)(a1 + 432) = 48;
            *(_DWORD*)(a1 + 444) = 0;
        }
        return;
    case 0x2D:
        *(_BYTE*)(a1 + 212) = 0;
        *(_WORD*)(a1 + 204) = 27;
        if (*(_BYTE*)(a1 + 470))
            --* (_BYTE*)(a1 + 470);
        if (!*(_BYTE*)(a1 + 470))
        {
            *(_BYTE*)(a1 + 608) = 0;
            *(_DWORD*)(a1 + 432) = 48;
            *(_DWORD*)(a1 + 444) = 0;
        }
        return;
    case 0x2E:
        *(_BYTE*)(a1 + 212) = 0;
        *(_WORD*)(a1 + 204) = 17;
        if (*(_BYTE*)(a1 + 470))
            --* (_BYTE*)(a1 + 470);
        if (*(_BYTE*)(a1 + 470))
        {
            if (*(int*)(a1 + 444) > 12)
            {
                *(_DWORD*)(a1 + 432) = 44;
                *(_DWORD*)(a1 + 444) = 0;
            }
        }
        else
        {
            if (*(_WORD*)(a1 + 214))
                *(_DWORD*)(a1 + 432) = 48;
            else
                *(_DWORD*)(a1 + 432) = 78;
            *(_DWORD*)(a1 + 444) = 0;
        }
        return;
    case 0x2F:
        *(_BYTE*)(a1 + 212) = 0;
        *(_WORD*)(a1 + 204) = 28;
        if (*(_BYTE*)(a1 + 470))
            --* (_BYTE*)(a1 + 470);
        if (*(_BYTE*)(a1 + 470))
        {
            if (*(int*)(a1 + 444) > 12)
            {
                *(_DWORD*)(a1 + 432) = 45;
                *(_DWORD*)(a1 + 444) = 0;
            }
        }
        else
        {
            if (*(_WORD*)(a1 + 214))
                *(_DWORD*)(a1 + 432) = 48;
            else
                *(_DWORD*)(a1 + 432) = 79;
            *(_DWORD*)(a1 + 444) = 0;
        }
        return;
    }
    if (*(_DWORD*)(a1 + 428) != 48)
    {
        switch (*(_DWORD*)(a1 + 428))
        {
        case 'I':
            if (*(_DWORD*)(a1 + 444) == 2)
                v42 = 0;
            if (*(_DWORD*)(a1 + 444) == 1)
            {
                *(_DWORD*)(a1 + 292) = 0;
                *(_DWORD*)(a1 + 392) = 1;
                *(_BYTE*)(a1 + 252) = 0;
                sub_423CF2((_BYTE*)a1, 1, 0, 1, 0, 1, -20);
            }
            *(_BYTE*)(a1 + 212) = 0;
            if (*(int*)(a1 + 444) >= 4)
            {
                if (*(int*)(a1 + 444) >= 12)
                    *(_WORD*)(a1 + 204) = 258;
                else
                    *(_WORD*)(a1 + 204) = 259;
            }
            else
            {
                *(_WORD*)(a1 + 204) = 6;
            }
            if (*(_DWORD*)(a1 + 444) == 12)
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A10, -1, 100, 100, 0);
            if (*(int*)(a1 + 444) >= 20
                || *(int*)(a1 + 444) > 1
                && (!*(_DWORD*)(a1 + 304)
                    || Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) != (struct Concurrency::ISchedulerProxy*)74))
            {
                sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                *(_DWORD*)(a1 + 432) = 50;
                *(_DWORD*)(a1 + 360) = 30;
                *(_DWORD*)(a1 + 304) = 0;
            }
            return;
        case 'J':
            if (*(_DWORD*)(a1 + 444) == 1)
            {
                if (*(_DWORD*)(a1 + 304))
                {
                    if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) == (struct Concurrency::ISchedulerProxy*)73)
                    {
                        *(_DWORD*)(a1 + 288) = 0;
                        *(_BYTE*)(a1 + 252) = 0;
                        if (*(_DWORD*)(a1 + 392))
                        {
                            *(_DWORD*)(a1 + 372) = 0;
                            *(_DWORD*)(a1 + 376) = 0;
                            *(_DWORD*)(a1 + 340) = 0;
                            *(_DWORD*)(a1 + 344) = 0;
                            *(_DWORD*)(a1 + 348) = 0;
                            *(_DWORD*)(a1 + 352) = 0;
                            *(_DWORD*)(a1 + 356) = 0;
                            *(_DWORD*)(a1 + 360) = 0;
                        }
                    }
                }
            }
            *(_BYTE*)(a1 + 212) = 0;
            if (*(int*)(a1 + 444) >= 12)
                *(_WORD*)(a1 + 204) = 13;
            else
                *(_WORD*)(a1 + 204) = 14;
            if (*(int*)(a1 + 444) >= 20
                || !*(_DWORD*)(a1 + 304)
                || Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) != (struct Concurrency::ISchedulerProxy*)73)
            {
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A48, -1, 100, 100, 0);
                *(_DWORD*)(a1 + 432) = 40;
                *(_DWORD*)(a1 + 304) = 0;
            }
            return;
        case '1':
            *(_BYTE*)(a1 + 212) = 0;
            *(_WORD*)(a1 + 204) = 24;
            *(_DWORD*)(a1 + 352) = 0;
            *(_DWORD*)(a1 + 356) = 0;
            *(_DWORD*)(a1 + 340) = 350 * *(_DWORD*)(a1 + 436);
            *(_DWORD*)(a1 + 344) = 180 * *(_DWORD*)(a1 + 440);
            *(_DWORD*)(a1 + 380) = *(_DWORD*)(a1 + 340);
            *(_DWORD*)(a1 + 384) = *(_DWORD*)(a1 + 344);
            if (*(int*)(a1 + 444) > 10)
            {
                *(_DWORD*)(a1 + 432) = 3;
                *(_DWORD*)(a1 + 444) = 0;
                *(_DWORD*)(a1 + 216) = 0;
                *(_BYTE*)(a1 + 220) = 1;
                *(_BYTE*)(a1 + 471) = 1;
                *(_DWORD*)(a1 + 296) = 0;
            }
            return;
        case 'R':
            if (*(_DWORD*)(a1 + 444) == 1)
            {
                *(_DWORD*)(a1 + 372) = 0;
                *(_DWORD*)(a1 + 376) = 0;
                *(_DWORD*)(a1 + 340) = 0;
                *(_DWORD*)(a1 + 344) = 0;
                *(_DWORD*)(a1 + 348) = 0;
                *(_DWORD*)(a1 + 352) = 0;
                *(_DWORD*)(a1 + 356) = 0;
                *(_DWORD*)(a1 + 360) = 0;
                if (*(_DWORD*)(a1 + 312))
                {
                    *(_DWORD*)(a1 + 424) = sub_426090(*(_DWORD**)(a1 + 312)) > *(_DWORD*)(a1 + 328);
                    if (*(_DWORD*)(a1 + 320))
                    {
                        sub_4211F5(a1);
                        Concurrency::details::SchedulingRing::SetOwningNode(
                            *(Concurrency::details::SchedulingRing**)(a1 + 312),
                            *(struct Concurrency::details::SchedulingNode**)(a1 + 4));
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A1C, -1, 100, 100, 0);
                    }
                }
            }
            if (!*(_DWORD*)(a1 + 320) && *(_DWORD*)(a1 + 312))
            {
                *(_DWORD*)(a1 + 372) = 1400 * ((*(_DWORD*)(a1 + 424) == 0) - *(_DWORD*)(a1 + 424))
                    + sub_426090(*(_DWORD**)(a1 + 312))
                    - *(_DWORD*)(a1 + 328);
                *(_DWORD*)(a1 + 376) = sub_4260B0(*(_DWORD**)(a1 + 312)) - *(_DWORD*)(a1 + 332);
            }
            *(_BYTE*)(a1 + 212) = 0;
            *(_WORD*)(a1 + 204) = 29;
            if (*(int*)(a1 + 444) > 1
                && (!*(_DWORD*)(a1 + 312)
                    || Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 312)) != (struct Concurrency::ISchedulerProxy*)82))
            {
                sub_421051((_DWORD*)a1);
            }
            return;
        case '4':
        case '5':
            if (*(_BYTE*)(a1 + 188) == 1)
            {
                *(_BYTE*)(a1 + 212) = 1;
                *(_WORD*)(a1 + 204) = 52;
            }
            else
            {
                *(_BYTE*)(a1 + 212) = 0;
                *(_WORD*)(a1 + 204) = 29;
            }
            if (*(_DWORD*)(a1 + 304))
            {
                v41 = sub_425F30((int*)*(_DWORD*)(a1 + 304));
                if ((*(_DWORD*)(a1 + 428) != 52 || v41 == 54) && (*(_DWORD*)(a1 + 428) != 53 || v41 == 55))
                    sub_423CF2(*(_BYTE**)(a1 + 304), 1, -16, 1, 0, 0, 0);
                else
                    *(_DWORD*)(a1 + 444) = 121;
            }
            else
            {
                *(_DWORD*)(a1 + 444) = 121;
            }
            if (*(int*)(a1 + 444) > 120)
            {
                *(_DWORD*)(a1 + 432) = 3;
                *(_DWORD*)(a1 + 444) = 0;
                sub_417EE0(a1);
            }
            return;
        case '6':
            if (*(_DWORD*)(a1 + 304))
            {
                *(_BYTE*)(a1 + 212) = 0;
                *(_WORD*)(a1 + 204) = 14;
                v40 = sub_426090(*(_DWORD**)(a1 + 304));
                v39 = sub_425D70(*(_DWORD**)(a1 + 304));
                v38 = 1600 * (v39 - (v39 == 0)) + v40;
                if (sub_425E70(*(_BYTE**)(a1 + 304)) == 1)
                {
                    *(_WORD*)(a1 + 204) = 13;
                    v38 = 1200 * (v39 - (v39 == 0)) + v40;
                    v37 = sub_4260D0(*(_DWORD**)(a1 + 304));
                    v36 = v37 - 1300;
                    *(_DWORD*)(a1 + 348) = v37 - 1300 - *(_DWORD*)(a1 + 336);
                    *(_DWORD*)(a1 + 392) = 1;
                }
                *(_DWORD*)(a1 + 372) = v38 - *(_DWORD*)(a1 + 328);
                if (*(int*)(a1 + 444) > 120)
                {
                    *(_DWORD*)(a1 + 432) = 75;
                    *(_DWORD*)(a1 + 304) = 0;
                    *(_DWORD*)(a1 + 444) = 0;
                }
                return;
            }
            break;
        case '7':
            if (*(_DWORD*)(a1 + 304))
            {
                v35 = sub_426090(*(_DWORD**)(a1 + 304));
                v10 = sub_425D70(*(_DWORD**)(a1 + 304));
                v34 = v10;
                v33 = 1600 * ((__PAIR64__(v10, v10) - 1) >> 32) + v35;
                *(_BYTE*)(a1 + 212) = 0;
                if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) == (struct Concurrency::ISchedulerProxy*)56)
                    *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 10 % 2 + 34;
                else
                    *(_WORD*)(a1 + 204) = 34;
                *(_DWORD*)(a1 + 424) = v34;
                if (*(int*)(a1 + 444) > 120)
                {
                    *(_DWORD*)(a1 + 432) = 75;
                    *(_DWORD*)(a1 + 304) = 0;
                    *(_DWORD*)(a1 + 444) = 0;
                    *(_DWORD*)(a1 + 372) = 0;
                    *(_DWORD*)(a1 + 376) = 0;
                    *(_DWORD*)(a1 + 348) = 0;
                    sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                }
                return;
            }
            break;
        default:
            switch (*(_DWORD*)(a1 + 428))
            {
            case 0x40:
                *(_BYTE*)(a1 + 212) = 0;
                *(_WORD*)(a1 + 204) = 6;
                if (*(int*)(a1 + 444) > 8)
                {
                    *(_DWORD*)(a1 + 432) = *(_BYTE*)(a1 + 237) ? 10 : 3;
                    *(_DWORD*)(a1 + 444) = 0;
                    if (*(_DWORD*)(a1 + 304))
                    {
                        if ((v31 = Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)),
                            v32 = sub_425F30((int*)*(_DWORD*)(a1 + 304)),
                            v31 == (struct Concurrency::ISchedulerProxy*)44)
                            && v32 == 44
                            || v31 == (struct Concurrency::ISchedulerProxy*)45 && v32 == 45)
                        {
                            if (sub_425D50((int*)*(_DWORD*)(a1 + 304)))
                                *(_DWORD*)(a1 + 288) = 0;
                            else
                                sub_41714D(*(_DWORD**)(a1 + 304), a1);
                        }
                        else
                        {
                            *(_DWORD*)(a1 + 288) = 0;
                        }
                    }
                    else
                    {
                        *(_DWORD*)(a1 + 288) = 0;
                    }
                    if (!*(_DWORD*)(a1 + 288))
                        *(_DWORD*)(a1 + 304) = 0;
                }
                break;
            case 0x43:
            case 0x44:
                *(_BYTE*)(a1 + 212) = 0;
                *(_WORD*)(a1 + 204) = 29;
                *(_DWORD*)(a1 + 288) = 0;
                *(_DWORD*)(a1 + 304) = 0;
                if (*(_DWORD*)(a1 + 444) == 1)
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                if (*(int*)(a1 + 444) > 20 && *(_DWORD*)(a1 + 428) == 67)
                {
                    *(_DWORD*)(a1 + 432) = 4;
                    *(_DWORD*)(a1 + 444) = 0;
                }
                break;
            case 0x41:
            case 0x42:
                *(_BYTE*)(a1 + 212) = 0;
                *(_WORD*)(a1 + 204) = 29;
                *(_DWORD*)(a1 + 288) = 0;
                *(_DWORD*)(a1 + 304) = 0;
                if (*(_DWORD*)(a1 + 444) == 1)
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                if (*(int*)(a1 + 444) > 20 && *(_DWORD*)(a1 + 428) == 65)
                {
                    *(_DWORD*)(a1 + 432) = 4;
                    *(_DWORD*)(a1 + 444) = 0;
                }
                break;
            case 0x4B:
                *(_BYTE*)(a1 + 212) = 0;
                *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 20 % 2 + 59;
                if (*(int*)(a1 + 444) > 120)
                {
                    *(_DWORD*)(a1 + 432) = 3;
                    *(_DWORD*)(a1 + 444) = 0;
                }
                break;
            case 0x4C:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_DWORD*)(a1 + 372) = 0;
                    *(_DWORD*)(a1 + 376) = 0;
                    *(_DWORD*)(a1 + 340) = 0;
                    *(_DWORD*)(a1 + 344) = 0;
                    *(_DWORD*)(a1 + 348) = -300;
                    *(_DWORD*)(a1 + 352) = 0;
                    *(_DWORD*)(a1 + 356) = 0;
                    *(_DWORD*)(a1 + 360) = 30;
                    *(_DWORD*)(a1 + 304) = 0;
                }
                *(_BYTE*)(a1 + 212) = 0;
                *(_WORD*)(a1 + 204) = 16;
                break;
            case 0x1A:
                *(_BYTE*)(a1 + 212) = 0;
                if (*(_DWORD*)(a1 + 444) == 1)
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A18, -1, 100, 100, 0);
                if ((*(int*)(a1 + 444) >= 20 || *(_DWORD*)(a1 + 440))
                    && (*(int*)(a1 + 444) >= 12 || !*(_DWORD*)(a1 + 440)))
                {
                    *(_WORD*)(a1 + 204) = 24;
                    *(_DWORD*)(a1 + 340) = 0;
                    *(_DWORD*)(a1 + 344) = 0;
                }
                else
                {
                    *(_DWORD*)(a1 + 372) = 500 * *(_DWORD*)(a1 + 436);
                    *(_DWORD*)(a1 + 376) = 180 * *(_DWORD*)(a1 + 440);
                    if (*(_DWORD*)(a1 + 372))
                    {
                        if ((*(_DWORD*)(a1 + 424) || *(int*)(a1 + 372) >= 0)
                            && (!*(_DWORD*)(a1 + 424) || *(int*)(a1 + 372) <= 0))
                        {
                            *(_WORD*)(a1 + 204) = 77 - *(_DWORD*)(a1 + 444) / 4 % 4;
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 4 % 4 + 74;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 24;
                    }
                }
                if (*(int*)(a1 + 444) >= 24 && !*(_DWORD*)(a1 + 440) || *(int*)(a1 + 444) >= 14 && *(_DWORD*)(a1 + 440))
                    *(_DWORD*)(a1 + 432) = 4;
                break;
            case 0x4E:
            case 0x4F:
                *(_BYTE*)(a1 + 212) = 0;
                if (*(_DWORD*)(a1 + 428) == 78)
                    *(_WORD*)(a1 + 204) = 18 - *(_DWORD*)(a1 + 444) / 10 % 2;
                else
                    *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 10 % 2 + 27;
                *(_BYTE*)(a1 + 176) = *(_DWORD*)(a1 + 444) / 5 % 2;
                if (*(_DWORD*)(a1 + 444) == 3)
                {
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A30, -1, 100, 100, 0);
                    *(_BYTE*)(a1 + 177) = 1;
                }
                if (*(int*)(a1 + 444) >= 80)
                {
                    *(_DWORD*)(a1 + 432) = 80;
                    *(_BYTE*)(a1 + 176) = 1;
                    *(_BYTE*)(a1 + 178) = 0;
                }
                break;
            case 0x51:
                switch (*(_BYTE*)(a1 + 188))
                {
                case 1:
                    *(_BYTE*)(a1 + 212) = 1;
                    if (*(int*)(a1 + 444) >= 5)
                    {
                        if (*(int*)(a1 + 444) >= 10)
                        {
                            if (*(int*)(a1 + 444) >= 15)
                            {
                                if (*(int*)(a1 + 444) >= 20)
                                    *(_WORD*)(a1 + 204) = 60;
                                else
                                    *(_WORD*)(a1 + 204) = 9;
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 8;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 7;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 6;
                    }
                    if (*(_DWORD*)(a1 + 444) == 4)
                    {
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A24, -1, 100, 100, 0);
                    }
                    else if (*(_DWORD*)(a1 + 444) == 8)
                    {
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A10, -1, 100, 100, 0);
                    }
                    break;
                case 2:
                    *(_BYTE*)(a1 + 212) = 1;
                    if (*(int*)(a1 + 444) >= 4)
                    {
                        if (*(int*)(a1 + 444) >= 8)
                        {
                            if (*(int*)(a1 + 444) >= 12)
                            {
                                if (*(int*)(a1 + 444) >= 26)
                                    *(_WORD*)(a1 + 204) = 115;
                                else
                                    *(_WORD*)(a1 + 204) = 19;
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 18;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 17;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 12;
                    }
                    if (*(_DWORD*)(a1 + 444) == 8)
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A10, -1, 100, 100, 0);
                    break;
                case 3:
                    *(_BYTE*)(a1 + 212) = 1;
                    if (*(int*)(a1 + 444) >= 4)
                    {
                        if (*(int*)(a1 + 444) >= 8)
                        {
                            if (*(int*)(a1 + 444) >= 12)
                            {
                                if (*(int*)(a1 + 444) >= 22)
                                {
                                    if (*(int*)(a1 + 444) >= 26)
                                        *(_WORD*)(a1 + 204) = 115;
                                    else
                                        *(_WORD*)(a1 + 204) = 16;
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 15;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 14;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 13;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 12;
                    }
                    if (*(_DWORD*)(a1 + 444) == 8)
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A10, -1, 100, 100, 0);
                    break;
                default:
                    if (*(_BYTE*)(a1 + 195))
                    {
                        switch (*(_BYTE*)(a1 + 195))
                        {
                        case 1:
                            *(_BYTE*)(a1 + 212) = 1;
                            if (*(int*)(a1 + 444) >= 4)
                            {
                                if (*(int*)(a1 + 444) >= 8)
                                {
                                    if (*(int*)(a1 + 444) >= 10)
                                    {
                                        if (*(int*)(a1 + 444) >= 21)
                                        {
                                            if (*(int*)(a1 + 444) >= 25)
                                            {
                                                *(_BYTE*)(a1 + 212) = 0;
                                                *(_WORD*)(a1 + 204) = 69;
                                            }
                                            else
                                            {
                                                *(_WORD*)(a1 + 204) = 8;
                                            }
                                        }
                                        else
                                        {
                                            *(_WORD*)(a1 + 204) = 7;
                                        }
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 6;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 5;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 4;
                            }
                            if (*(_DWORD*)(a1 + 444) == 8)
                                sub_43FFC3((int*)unk_4BDB28, dword_4B9A10, -1, 100, 100, 0);
                            break;
                        case 2:
                            *(_BYTE*)(a1 + 212) = 1;
                            if (*(int*)(a1 + 444) >= 4)
                            {
                                if (*(int*)(a1 + 444) >= 8)
                                {
                                    if (*(int*)(a1 + 444) >= 12)
                                    {
                                        if (*(int*)(a1 + 444) >= 16)
                                        {
                                            if (*(int*)(a1 + 444) >= 20)
                                            {
                                                if (*(int*)(a1 + 444) >= 24)
                                                {
                                                    if (*(int*)(a1 + 444) >= 28)
                                                    {
                                                        if (*(int*)(a1 + 444) >= 32)
                                                        {
                                                            *(_BYTE*)(a1 + 212) = 0;
                                                            *(_WORD*)(a1 + 204) = 69;
                                                        }
                                                        else
                                                        {
                                                            *(_BYTE*)(a1 + 212) = 0;
                                                            *(_WORD*)(a1 + 204) = 3;
                                                        }
                                                    }
                                                    else
                                                    {
                                                        *(_WORD*)(a1 + 204) = 11;
                                                    }
                                                }
                                                else
                                                {
                                                    *(_WORD*)(a1 + 204) = 10;
                                                }
                                            }
                                            else
                                            {
                                                *(_WORD*)(a1 + 204) = 9;
                                            }
                                        }
                                        else
                                        {
                                            *(_WORD*)(a1 + 204) = 8;
                                        }
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 7;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 6;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 5;
                            }
                            if (*(_DWORD*)(a1 + 444) == 8)
                                sub_43FFC3((int*)unk_4BDB28, dword_4B9A10, -1, 100, 100, 0);
                            break;
                        case 3:
                            *(_BYTE*)(a1 + 212) = 1;
                            if (*(int*)(a1 + 444) >= 4)
                            {
                                if (*(int*)(a1 + 444) >= 8)
                                {
                                    if (*(int*)(a1 + 444) >= 12)
                                    {
                                        if (*(int*)(a1 + 444) >= 16)
                                        {
                                            if (*(int*)(a1 + 444) >= 20)
                                            {
                                                if (*(int*)(a1 + 444) >= 24)
                                                {
                                                    *(_BYTE*)(a1 + 212) = 0;
                                                    *(_WORD*)(a1 + 204) = 69;
                                                }
                                                else
                                                {
                                                    *(_WORD*)(a1 + 204) = 5;
                                                }
                                            }
                                            else
                                            {
                                                *(_WORD*)(a1 + 204) = 3;
                                            }
                                        }
                                        else
                                        {
                                            *(_WORD*)(a1 + 204) = 9;
                                        }
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 8;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 7;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 6;
                            }
                            if (*(_DWORD*)(a1 + 444) == 8)
                                sub_43FFC3((int*)unk_4BDB28, dword_4B9A10, -1, 100, 100, 0);
                            break;
                        case 4:
                            *(_BYTE*)(a1 + 212) = 1;
                            if (*(int*)(a1 + 444) >= 4)
                            {
                                if (*(int*)(a1 + 444) >= 8)
                                {
                                    if (*(int*)(a1 + 444) >= 12)
                                    {
                                        if (*(int*)(a1 + 444) >= 16)
                                        {
                                            if (*(int*)(a1 + 444) >= 26)
                                            {
                                                if (*(int*)(a1 + 444) >= 30)
                                                {
                                                    if (*(int*)(a1 + 444) >= 34)
                                                    {
                                                        if (*(int*)(a1 + 444) >= 38)
                                                        {
                                                            *(_BYTE*)(a1 + 212) = 0;
                                                            *(_WORD*)(a1 + 204) = 69;
                                                        }
                                                        else
                                                        {
                                                            *(_WORD*)(a1 + 204) = 6;
                                                        }
                                                    }
                                                    else
                                                    {
                                                        *(_WORD*)(a1 + 204) = 7;
                                                    }
                                                }
                                                else
                                                {
                                                    *(_WORD*)(a1 + 204) = 11;
                                                }
                                            }
                                            else
                                            {
                                                *(_WORD*)(a1 + 204) = 10;
                                            }
                                        }
                                        else
                                        {
                                            *(_WORD*)(a1 + 204) = 9;
                                        }
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 8;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 7;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 6;
                            }
                            if (*(_DWORD*)(a1 + 444) == 12)
                                sub_43FFC3((int*)unk_4BDB28, dword_4B9A10, -1, 100, 100, 0);
                            break;
                        }
                    }
                    else
                    {
                        *(_BYTE*)(a1 + 212) = 1;
                        if (*(int*)(a1 + 444) >= 4)
                        {
                            if (*(int*)(a1 + 444) >= 8)
                            {
                                if (*(int*)(a1 + 444) >= 20)
                                {
                                    if (*(int*)(a1 + 444) >= 25)
                                    {
                                        *(_BYTE*)(a1 + 212) = 0;
                                        *(_WORD*)(a1 + 204) = 69;
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 4;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 6;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 5;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 4;
                        }
                        if (*(_DWORD*)(a1 + 444) == 8)
                            sub_43FFC3((int*)unk_4BDB28, dword_4B9A10, -1, 100, 100, 0);
                    }
                    break;
                }
                break;
            default:
                if (*(_DWORD*)(a1 + 428))
                {
                    if (*(_DWORD*)(a1 + 428) == 80)
                    {
                        if (*(_DWORD*)(a1 + 444) == 1)
                        {
                            *(_BYTE*)(a1 + 212) = 0;
                            *(_WORD*)(a1 + 204) = 27;
                            *(_BYTE*)(a1 + 177) = 1;
                            *(_BYTE*)(a1 + 176) = 1;
                            *(_BYTE*)(a1 + 556) = 0;
                            *(_BYTE*)(a1 + 557) = 0;
                            *(_DWORD*)(a1 + 172) = 0;
                            sub_467E7D((int)unk_4B9B10, (_BYTE*)a1);
                            v30 = sub_425CD0((int*)unk_4B9B10);
                            if ((v30 == 1 || !v30 || v30 == 4) && byte_4B99CB && !*(_DWORD*)(a1 + 392))
                            {
                                v25 = *(_DWORD*)(a1 + 328) / 100;
                                v26 = *(_DWORD*)(a1 + 332) / 100;
                                v27 = sub_446497((int*)unk_4B9B10, v25, v26);
                                for (i = 0; i < 22; ++i)
                                    v24[i] = 1;
                                v20 = sub_465AFA((unsigned char*)unk_4B9B10);
                                v29 = byte_4B999A != 0;
                                v23 = 22;
                                if (v30 == 4 && !(rand() % 2))
                                {
                                    v20 = 0;
                                    for (j = 7; j < 14; ++j)
                                        v24[j] = 0;
                                    v23 = 15;
                                }
                                if (!v29)
                                {
                                    v24[15] = 0;
                                    v24[16] = 0;
                                    v23 -= 2;
                                }
                                if (!v20)
                                {
                                    v24[20] = 0;
                                    --v23;
                                }
                                v19 = rand() % v23;
                                for (k = 0; k < 22; ++k)
                                {
                                    if (v24[k])
                                    {
                                        if (!v19)
                                            break;
                                        --v19;
                                    }
                                }
                                v28 = k + 1;
                                sub_456A74((char*)unk_4B9B10, (int)&v25);
                            }
                        }
                    }
                    else if (*(_DWORD*)(a1 + 428) == 1)
                    {
                        *(_BYTE*)(a1 + 212) = 0;
                        *(_BYTE*)(a1 + 178) = 0;
                        *(_BYTE*)(a1 + 176) = *(_DWORD*)(a1 + 444) / 2 % 2;
                        if (*(_DWORD*)(a1 + 444) == 1)
                            sub_468011((char*)unk_4B9B10, (_BYTE*)a1);
                        if (*(_DWORD*)(a1 + 444) / 8 % 3 > 1)
                            *(_WORD*)(a1 + 204) = 70;
                        else
                            *(_WORD*)(a1 + 204) = 3;
                        if (*(int*)(a1 + 444) >= 120)
                        {
                            if (*(_DWORD*)(a1 + 392))
                                *(_DWORD*)(a1 + 432) = 51;
                            else
                                *(_DWORD*)(a1 + 432) = 4;
                            *(_BYTE*)(a1 + 178) = 1;
                            *(_BYTE*)(a1 + 177) = 0;
                            *(_BYTE*)(a1 + 176) = 0;
                        }
                    }
                }
                else
                {
                    *(_BYTE*)(a1 + 212) = 0;
                    *(_BYTE*)(a1 + 178) = 0;
                    if (sub_425FF0((int*)a1))
                    {
                        if (sub_494AA9(*(_BYTE**)(a1 + 480), 0))
                        {
                            if (*(_DWORD*)(a1 + 444) / 8 % 3 > 1)
                                *(_WORD*)(a1 + 204) = 157;
                            else
                                *(_WORD*)(a1 + 204) = 135;
                        }
                        else if (*(_DWORD*)(a1 + 444) / 8 % 3 > 1)
                        {
                            *(_WORD*)(a1 + 204) = 156;
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 0;
                        }
                    }
                    else if (*(_BYTE*)(a1 + 188) == 2)
                    {
                        *(_BYTE*)(a1 + 212) = 1;
                        if (*(_DWORD*)(a1 + 444) / 8 % 3 > 1)
                            *(_WORD*)(a1 + 204) = 117;
                        else
                            *(_WORD*)(a1 + 204) = 116;
                    }
                    else if (*(_BYTE*)(a1 + 188) == 3)
                    {
                        *(_BYTE*)(a1 + 212) = 1;
                        if (*(_DWORD*)(a1 + 444) / 8 % 3 > 1)
                            *(_WORD*)(a1 + 204) = 119;
                        else
                            *(_WORD*)(a1 + 204) = 118;
                    }
                    else if (*(_DWORD*)(a1 + 444) / 8 % 3 > 1)
                    {
                        *(_WORD*)(a1 + 204) = 70;
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 3;
                    }
                    if (*(int*)(a1 + 444) >= 120)
                    {
                        *(_DWORD*)(a1 + 432) = 4;
                        *(_BYTE*)(a1 + 178) = 1;
                    }
                }
                break;
            }
            return;
        }
        sub_417FC1(a1);
        return;
    }
    *(_BYTE*)(a1 + 608) = 0;
    if (sub_41BA53(a1, 0x8Bu, 0) && *(_DWORD*)(a1 + 444) == 1 && *(char*)(a1 + 232) > 0)
        *(_BYTE*)(a1 + 608) = *(_BYTE*)(a1 + 204);
    *(_BYTE*)(a1 + 212) = 0;
    *(_WORD*)(a1 + 204) = 24;
    if (*(_DWORD*)(a1 + 444) == 1)
    {
        *(_BYTE*)(a1 + 469) = 1;
        *(_DWORD*)(a1 + 216) = 0;
        *(_BYTE*)(a1 + 220) = 1;
        *(_BYTE*)(a1 + 471) = 1;
        if (sub_41BA53(a1, 0x8Bu, 0) && *(_DWORD*)(a1 + 296))
        {
            *(_DWORD*)(a1 + 432) = 71;
            *(_DWORD*)(a1 + 296) = 0;
            *(_DWORD*)(a1 + 300) = 0;
            return;
        }
        sub_417EAD((int*)a1);
        if (*(_DWORD*)(a1 + 292) && *(_DWORD*)(a1 + 304))
        {
            v9 = *(unsigned __int8*)(a1 + 193);
            if (v9 != (unsigned __int8)sub_426070(*(_BYTE**)(a1 + 304)))
            {
                *(_DWORD*)(a1 + 432) = 73;
                sub_426050(*(_DWORD**)(a1 + 304), 74);
                return;
            }
            if (byte_4B99C8)
                sub_4211F5(*(_DWORD*)(a1 + 304));
        }
        if (sub_41BEA6((_DWORD*)a1))
        {
            v43 = sub_423D47((int*)a1 + 8);
            v16 = v43 >= 2 && v43 <= 4;
            v15 = v43 >= 6 && v43 <= 8;
            *(_BYTE*)(a1 + 224) = v16 - v15;
            v14 = v43 >= 4 && v43 <= 6;
            v13 = v43 == 1 || v43 == 2 || v43 == 8;
            *(_BYTE*)(a1 + 225) = v14 - v13;
        }
    }
    if (*(_DWORD*)(a1 + 444) == 1 && (*(_BYTE*)(a1 + 224) || *(_BYTE*)(a1 + 225)))
    {
        *(_DWORD*)(a1 + 432) = 49;
        if (*(char*)(a1 + 224) <= 0)
            v12 = (*(char*)(a1 + 224) >= 0) - 1;
        else
            v12 = 1;
        *(_DWORD*)(a1 + 436) = v12;
        if (*(char*)(a1 + 225) <= 0)
            v11 = (*(char*)(a1 + 225) >= 0) - 1;
        else
            v11 = 1;
        *(_DWORD*)(a1 + 440) = v11;
    }
    if (*(int*)(a1 + 444) > 10)
    {
        *(_DWORD*)(a1 + 432) = 3;
        *(_DWORD*)(a1 + 444) = 0;
        *(_DWORD*)(a1 + 296) = 0;
    }
    if (*(char*)(a1 + 608) > 0)
    {
        *(_WORD*)(a1 + 204) = *(char*)(a1 + 608);
        *(_DWORD*)(a1 + 432) = 3;
        *(_DWORD*)(a1 + 444) = 0;
        *(_DWORD*)(a1 + 296) = 0;
    }
}

 
int sub_41242D(int thisx)
{
    int result; // eax

    result = thisx;
    if (*(_DWORD*)(thisx + 304))
    {
        result = sub_425F30((_DWORD*)(thisx + 304));
        if (result == 15)
        {
            if (*(_DWORD*)(thisx + 424) == sub_425D70((_DWORD*)*(_DWORD*)(thisx + 304)))
                *(_DWORD*)(thisx + 432) = 53;
            else
                *(_DWORD*)(thisx + 432) = 52;
            if (*(_BYTE*)(thisx + 188) == 1)
                *(_DWORD*)(thisx + 432) = 52;
            *(_BYTE*)(thisx + 223) = 0x80;
            sub_412502(*(_DWORD*)(thisx + 304), (_DWORD)thisx);
            result = sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A1C, -1, 100, 100, 0);
            *(_DWORD*)(thisx + 444) = 0;
        }
        else
        {
            *(_DWORD*)(thisx + 304) = 0;
        }
    }
    return result;
}

 
int sub_412502(int thisx, int a2)
{
    int result; // eax

    if ((unsigned __int8)sub_425E70((char*)a2) == 1)
        *(_DWORD*)(thisx + 424) = sub_425D70((_DWORD*)a2) == 0;
    if (sub_425D70((_DWORD*)a2) == *(_DWORD*)(thisx + 424))
    {
        *(_DWORD*)(thisx + 432) = 55;
        *(_DWORD*)(thisx + 340) = 1600 * (*(_DWORD*)(thisx + 424) - (*(_DWORD*)(thisx + 424) == 0))
            + sub_426090((_DWORD*)a2)
            - *(_DWORD*)(thisx + 328);
    }
    else
    {
        *(_DWORD*)(thisx + 432) = 54;
        *(_DWORD*)(thisx + 340) = 1600 * ((*(_DWORD*)(thisx + 424) == 0) - *(_DWORD*)(thisx + 424))
            + sub_426090((_DWORD*)a2)
            - *(_DWORD*)(thisx + 328);
    }
    *(_DWORD*)(thisx + 304) = a2;
    *(_BYTE*)(thisx + 272) = 0;
    *(_DWORD*)(thisx + 332) = sub_4260B0((int*)a2);
    result = (unsigned __int8)sub_426030((char*)a2) - 1;
    *(_BYTE*)(thisx + 223) = result;
    return result;
}

 
void sub_41261C(_WORD* thisx, int a2, int a3, int a4)
{
    if ((unsigned __int16)thisx[107] - a2 > 0)
        thisx[107] -= a2;
    else
        thisx[107] = 0;
    sub_4234E6((int)thisx, -a2);
    sub_4239D3((int)thisx, a2 / 5 + 1);
    if (a3)
    {
        sub_4234E6(a3, a2);
        sub_4239D3(a3, a2 / 5 + 1);
    }
    if (a4)
    {
        if (a2)
            sub_446744((_DWORD*)unk_4B9B10, a2, (int)thisx);
    }
}

 
void sub_4126CE(int thisx, double a2, double a3, double a4)
{
    int v4; // eax
    char* v5; // eax
    char* v6; // eax
    char* v7; // eax
    int v8; // esi
    int v9; // eax
    unsigned __int16 v10; // ax
    unsigned __int16 v11; // ax
    unsigned __int8 v12; // al
    int v13; // eax
    unsigned __int8 v14; // al
    int v15; // [esp-8h] [ebp-19Ch]
    int v16; // [esp-8h] [ebp-19Ch]
    int v17; // [esp+4h] [ebp-190h]
    int v18; // [esp+8h] [ebp-18Ch]
    int v19; // [esp+Ch] [ebp-188h]
    int v20; // [esp+10h] [ebp-184h]
    int v21; // [esp+14h] [ebp-180h]
    int v22; // [esp+18h] [ebp-17Ch]
    int v23; // [esp+1Ch] [ebp-178h]
    int v24; // [esp+20h] [ebp-174h]
    int v25; // [esp+24h] [ebp-170h]
    int v26; // [esp+28h] [ebp-16Ch]
    int v27; // [esp+2Ch] [ebp-168h]
    int v28; // [esp+30h] [ebp-164h]
    int v29; // [esp+34h] [ebp-160h]
    int v30; // [esp+38h] [ebp-15Ch]
    int v31; // [esp+3Ch] [ebp-158h]
    int v32; // [esp+40h] [ebp-154h]
    int v33; // [esp+44h] [ebp-150h]
    int v34; // [esp+48h] [ebp-14Ch]
    int v35; // [esp+4Ch] [ebp-148h]
    int v37[2]; // [esp+54h] [ebp-140h] BYREF
    char v38; // [esp+5Ch] [ebp-138h]
    int v39; // [esp+60h] [ebp-134h]
    int v40; // [esp+64h] [ebp-130h]
    int v41[2]; // [esp+68h] [ebp-12Ch] BYREF
    _DWORD* v42; // [esp+70h] [ebp-124h]
    int v43; // [esp+74h] [ebp-120h]
    int v44; // [esp+78h] [ebp-11Ch]
    int v45; // [esp+7Ch] [ebp-118h]
    char v46; // [esp+80h] [ebp-114h]
    struct Concurrency::ISchedulerProxy* SchedulerProxy; // [esp+84h] [ebp-110h]
    int v48; // [esp+88h] [ebp-10Ch]
    int v49; // [esp+8Ch] [ebp-108h]
    __int16* v50; // [esp+90h] [ebp-104h]
    char v51; // [esp+94h] [ebp-100h]
    int v52; // [esp+98h] [ebp-FCh]
    char v53; // [esp+9Ch] [ebp-F8h]
    int v54; // [esp+A0h] [ebp-F4h]
    int v55; // [esp+A4h] [ebp-F0h]
    int v56; // [esp+A8h] [ebp-ECh]
    int v57; // [esp+ACh] [ebp-E8h] BYREF
    int v58; // [esp+B4h] [ebp-E0h]
    int v59; // [esp+B8h] [ebp-DCh]
    int v60; // [esp+BCh] [ebp-D8h]
    int v61; // [esp+C0h] [ebp-D4h]
    int v62; // [esp+C4h] [ebp-D0h]
    int v63; // [esp+C8h] [ebp-CCh]
    int v64; // [esp+CCh] [ebp-C8h]
    int v65; // [esp+D0h] [ebp-C4h]
    int v66; // [esp+D4h] [ebp-C0h]
    int v67; // [esp+D8h] [ebp-BCh]
    int v68; // [esp+DCh] [ebp-B8h]
    int v69; // [esp+E0h] [ebp-B4h]
    int v70; // [esp+E4h] [ebp-B0h]
    int v71; // [esp+E8h] [ebp-ACh]
    int v72; // [esp+ECh] [ebp-A8h]
    int v73; // [esp+F0h] [ebp-A4h]
    int v74; // [esp+F4h] [ebp-A0h]
    int v75; // [esp+F8h] [ebp-9Ch]
    int v76; // [esp+FCh] [ebp-98h]
    int v77; // [esp+100h] [ebp-94h]
    int j; // [esp+104h] [ebp-90h]
    int v79; // [esp+108h] [ebp-8Ch]
    int i; // [esp+10Ch] [ebp-88h]
    int v81; // [esp+110h] [ebp-84h]
    int v82; // [esp+114h] [ebp-80h]
    int v83; // [esp+118h] [ebp-7Ch]
    int v84; // [esp+11Ch] [ebp-78h]
    int v85; // [esp+120h] [ebp-74h]
    int v86; // [esp+124h] [ebp-70h]
    __int16* v87; // [esp+128h] [ebp-6Ch]
    int v88; // [esp+12Ch] [ebp-68h]
    int v89; // [esp+130h] [ebp-64h]
    int v90; // [esp+134h] [ebp-60h]
    int v91; // [esp+138h] [ebp-5Ch]
    int v92; // [esp+13Ch] [ebp-58h]
    int v93; // [esp+140h] [ebp-54h]
    int v94; // [esp+144h] [ebp-50h]
    int v95; // [esp+148h] [ebp-4Ch]
    int v96; // [esp+14Ch] [ebp-48h]
    int v97; // [esp+150h] [ebp-44h]
    int v98; // [esp+154h] [ebp-40h]
    int v99; // [esp+158h] [ebp-3Ch]
    int v100; // [esp+15Ch] [ebp-38h]
    __int16 v101; // [esp+160h] [ebp-34h]
    int v102; // [esp+164h] [ebp-30h]
    int v103; // [esp+168h] [ebp-2Ch]
    int v104; // [esp+16Ch] [ebp-28h]
    int v105; // [esp+170h] [ebp-24h]
    int v106; // [esp+174h] [ebp-20h]
    int v107; // [esp+178h] [ebp-1Ch]
    int v108; // [esp+17Ch] [ebp-18h]
    int v109; // [esp+180h] [ebp-14h]
    int v110; // [esp+184h] [ebp-10h]
    Concurrency::details::_UnrealizedChore* v111; // [esp+188h] [ebp-Ch]
    int v112; // [esp+18Ch] [ebp-8h]
    int v113; // [esp+190h] [ebp-4h]

    if (*(_BYTE*)(thisx + 474))
        return;
    if (*(_DWORD*)(thisx + 292))
    {
        *(_DWORD*)(thisx + 372) = 0;
        *(_DWORD*)(thisx + 376) = 0;
        *(_DWORD*)(thisx + 340) = 0;
        *(_DWORD*)(thisx + 344) = 0;
        *(_DWORD*)(thisx + 348) = 0;
        *(_DWORD*)(thisx + 352) = 0;
        *(_DWORD*)(thisx + 356) = 0;
        *(_DWORD*)(thisx + 360) = 0;
    }
    v82 = *(_DWORD*)(thisx + 364);
    v85 = *(_DWORD*)(thisx + 368);
    *(_DWORD*)(thisx + 364) = 0;
    *(_DWORD*)(thisx + 368) = 0;
    if (*(_DWORD*)(thisx + 180))
    {
        *(_DWORD*)(thisx + 340) += *(_DWORD*)(thisx + 352);
        *(_DWORD*)(thisx + 344) += *(_DWORD*)(thisx + 356);
        *(_DWORD*)(thisx + 348) += *(_DWORD*)(thisx + 360);
        *(_DWORD*)(thisx + 372) += *(_DWORD*)(thisx + 340);
        *(_DWORD*)(thisx + 376) += *(_DWORD*)(thisx + 344);
        *(_DWORD*)(thisx + 328) += *(_DWORD*)(thisx + 372);
        *(_DWORD*)(thisx + 332) += *(_DWORD*)(thisx + 376);
        *(_DWORD*)(thisx + 336) += *(_DWORD*)(thisx + 348);
        return;
    }
    if (!*(_DWORD*)(thisx + 392) && *(_DWORD*)(thisx + 336) == -102000)
    {
        v79 = sub_44647E((char*)unk_4B9B10);
        v81 = sub_446465((char*)unk_4B9B10) / 8;
        for (i = 0; i < v79; ++i)
        {
            for (j = v81; j < v81 + 40; ++j)
            {
                v77 = sub_446497((int*)unk_4B9B10, 8 * j, 8 * i);
                if (v77 != 1020)
                {
                    *(_DWORD*)(thisx + 328) = 800 * j;
                    *(_DWORD*)(thisx + 332) = 800 * i;
                    *(_DWORD*)(thisx + 336) = -100 * v77;
                    return;
                }
            }
        }
    }
    v86 = *(_DWORD*)(thisx + 328);
    v99 = *(_DWORD*)(thisx + 328) / 100;
    v92 = *(_DWORD*)(thisx + 332) / 100;
    v103 = 100 * sub_446497((int*)unk_4B9B10, *(_DWORD*)(thisx + 328) / 100, *(_DWORD*)(thisx + 332) / 100);
    if (*(int*)(thisx + 336) <= 0 || v103 < 0)
    {
        if (*(_DWORD*)(thisx + 428) && *(int*)(thisx + 336) > 3200 && v103 < 0)
        {
        LABEL_22:
            sub_4259A4((_DWORD*)thisx, a2, a3, a4);
            return;
        }
    }
    else
    {
        *(_DWORD*)(thisx + 336) = 0;
    }
    v103 = 100 * sub_446497((int*)unk_4B9B10, *(_DWORD*)(thisx + 328) / 100, *(_DWORD*)(thisx + 332) / 100);
    if (v103 != 102000 && -*(_DWORD*)(thisx + 336) < v103)
        *(_DWORD*)(thisx + 336) = -v103;
    v87 = 0;
    v111 = 0;
    v104 = *(_DWORD*)(thisx + 208);
    *(_DWORD*)(thisx + 208) = 0;
    v111 = (Concurrency::details::_UnrealizedChore*)sub_4741F8(
        (int)unk_4B9B10,
        *(_DWORD*)(thisx + 328) / 800,
        *(_DWORD*)(thisx + 332) / 800);
    if (v111)
    {
        LOWORD(v106) = sub_4260F0((short*)v111);
        v87 = (__int16*)sub_474471((int)unk_4B9B10, v106);
    }
    else
    {
        LOWORD(v106) = 0;
        v87 = 0;
    }
    LOBYTE(v108) = sub_4464F6((int*)unk_4B9B10, *(_DWORD*)(thisx + 328) / 800, *(_DWORD*)(thisx + 332) / 800);
    LOBYTE(v76) = sub_4464D3((int)unk_4B9B10, *(_DWORD*)(thisx + 328) / 800, *(_DWORD*)(thisx + 332) / 800);
    if (v111 && !*(_DWORD*)(thisx + 392))
    {
        *(_DWORD*)(thisx + 364) = sub_426110((short*)v111);
        *(_DWORD*)(thisx + 368) = sub_426130((short*)v111);
    }
    if (*(_DWORD*)(thisx + 428) && (unsigned __int8)v108 == 7 && -v103 <= *(_DWORD*)(thisx + 336))
        goto LABEL_22;
    if ((_WORD)v106 && (v87[26] & 1) != 0 && -v103 <= *(_DWORD*)(thisx + 336))
    {
        sub_42455B(thisx, v87);
    }
    else if ((unsigned __int8)v108 == 10 && -v103 <= *(_DWORD*)(thisx + 336))
    {
        sub_41D3D7(thisx);
        v85 = 0;
        v82 = 0;
        v99 = *(_DWORD*)(thisx + 328) / 100;
        v92 = *(_DWORD*)(thisx + 332) / 100;
    }
    else if ((_BYTE)v76 && (unsigned __int8)v108 == 13 && !*(_DWORD*)(thisx + 392))
    {
        LOBYTE(v75) = ((unsigned __int8)v76 + 1) / 2;
        switch ((unsigned __int8)v75)
        {
        case 1u:
            *(_DWORD*)(thisx + 364) = 30;
            break;
        case 2u:
            *(_DWORD*)(thisx + 364) = 60;
            break;
        case 3u:
            *(_DWORD*)(thisx + 364) = 120;
            break;
        }
        if ((v76 & 1) == 1)
            *(_DWORD*)(thisx + 364) = -*(_DWORD*)(thisx + 364);
    }
    if (v82 != *(_DWORD*)(thisx + 364) && *(_DWORD*)(thisx + 364))
    {
        if (v82 <= 0)
            v35 = (v82 >= 0) - 1;
        else
            v35 = 1;
        if (*(int*)(thisx + 364) <= 0)
            v34 = (*(_DWORD*)(thisx + 364) >= 0) - 1;
        else
            v34 = 1;
        if (v35 == v34)
            v82 -= *(_DWORD*)(thisx + 364);
        *(_DWORD*)(thisx + 372) += v82;
    }
    if (v85 != *(_DWORD*)(thisx + 368) && *(_DWORD*)(thisx + 364))
    {
        if (v85 <= 0)
            v33 = (v85 >= 0) - 1;
        else
            v33 = 1;
        if (*(int*)(thisx + 368) <= 0)
            v32 = (*(_DWORD*)(thisx + 368) >= 0) - 1;
        else
            v32 = 1;
        if (v33 == v32)
            v82 = v85 - *(_DWORD*)(thisx + 368);
        *(_DWORD*)(thisx + 376) += v85;
    }
    if (*(_DWORD*)(thisx + 304))
    {
        if ((*(_BYTE*)(thisx + 602) & 1) != 0)
        {
            v73 = sub_426090(*(_DWORD**)(thisx + 304));
            v4 = sub_425D70(*(_DWORD**)(thisx + 304));
            v74 = 100 * ((v4 == 0) - (v4 != 0));
            *(_DWORD*)(thisx + 372) = v74 * *(char*)(thisx + 603) + v73 - *(_DWORD*)(thisx + 328);
            *(_DWORD*)(thisx + 340) = 0;
            *(_DWORD*)(thisx + 352) = 0;
            *(_DWORD*)(thisx + 364) = 0;
        }
        if ((*(_BYTE*)(thisx + 604) & 1) != 0)
        {
            v72 = sub_4260B0(*(_DWORD**)(thisx + 304));
            *(_DWORD*)(thisx + 376) = 100 * *(char*)(thisx + 605) + v72 - *(_DWORD*)(thisx + 332);
            *(_DWORD*)(thisx + 344) = 0;
            *(_DWORD*)(thisx + 356) = 0;
            *(_DWORD*)(thisx + 368) = 0;
        }
        if ((*(_BYTE*)(thisx + 606) & 1) != 0)
        {
            v71 = sub_4260D0(*(_DWORD**)(thisx + 304));
            *(_DWORD*)(thisx + 348) = 100 * *(char*)(thisx + 607) + v71 - *(_DWORD*)(thisx + 336);
            *(_DWORD*)(thisx + 356) = 0;
        }
    }
    v105 = *(_DWORD*)(thisx + 340);
    v100 = *(_DWORD*)(thisx + 344);
    if (!*(_DWORD*)(thisx + 392))
    {
        LOBYTE(v70) = 100;
        if (v111)
            LOBYTE(v70) = sub_426150((char*)v111);
        v105 = v105 * (unsigned __int8)v70 / 100;
        if (!v105)
        {
            if (*(int*)(thisx + 340) <= 0)
                v31 = (*(_DWORD*)(thisx + 340) >= 0) - 1;
            else
                v31 = 1;
            v105 = v31;
        }
        v100 = v100 * (unsigned __int8)v70 / 100;
        if (!v100)
        {
            if (*(int*)(thisx + 344) <= 0)
                v30 = (*(_DWORD*)(thisx + 344) >= 0) - 1;
            else
                v30 = 1;
            v100 = v30;
        }
    }
    if (!*(_DWORD*)(thisx + 340))
    {
        v69 = *(_DWORD*)(thisx + 352);
        if (!*(_DWORD*)(thisx + 392))
        {
            if (v111)
            {
                LOBYTE(v68) = Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime(v111);
                v69 = (150 - (unsigned __int8)v68) * v69 / 100;
                if (!v69)
                {
                    if (*(int*)(thisx + 352) <= 0)
                        v29 = (*(_DWORD*)(thisx + 352) >= 0) - 1;
                    else
                        v29 = 1;
                    v69 = v29;
                }
            }
        }
        v105 += v69;
        *(_DWORD*)(thisx + 340) = v69;
    }
    if (!*(_DWORD*)(thisx + 344))
    {
        v67 = *(_DWORD*)(thisx + 356);
        if (!*(_DWORD*)(thisx + 392))
        {
            if (v111)
            {
                LOBYTE(v66) = Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime(v111);
                v67 = (150 - (unsigned __int8)v66) * v67 / 100;
                if (!v67)
                {
                    if (*(int*)(thisx + 356) <= 0)
                        v28 = (*(_DWORD*)(thisx + 356) >= 0) - 1;
                    else
                        v28 = 1;
                    v67 = v28;
                }
            }
        }
        v100 += v67;
        *(_DWORD*)(thisx + 344) = v67;
    }
    v83 = v105 + *(_DWORD*)(thisx + 372);
    v88 = v100 + *(_DWORD*)(thisx + 376);
    if ((*(int*)(thisx + 380) <= 0 || *(_DWORD*)(thisx + 372) >= *(_DWORD*)(thisx + 380) || v83 < *(_DWORD*)(thisx + 380))
        && (*(int*)(thisx + 380) >= 0 || *(_DWORD*)(thisx + 372) <= *(_DWORD*)(thisx + 380) || v83 > *(_DWORD*)(thisx + 380)))
    {
        if (!*(_DWORD*)(thisx + 380)
            || *(int*)(thisx + 380) > 0 && v83 <= *(_DWORD*)(thisx + 380)
            || *(int*)(thisx + 380) < 0 && v83 >= *(_DWORD*)(thisx + 380))
        {
            *(_DWORD*)(thisx + 372) = v83;
        }
    }
    else
    {
        *(_DWORD*)(thisx + 372) = *(_DWORD*)(thisx + 380);
    }
    if ((*(int*)(thisx + 384) <= 0 || *(_DWORD*)(thisx + 376) >= *(_DWORD*)(thisx + 384) || v88 < *(_DWORD*)(thisx + 384))
        && (*(int*)(thisx + 384) >= 0 || *(_DWORD*)(thisx + 376) <= *(_DWORD*)(thisx + 384) || v88 > *(_DWORD*)(thisx + 384)))
    {
        if (!*(_DWORD*)(thisx + 384)
            || *(int*)(thisx + 384) > 0 && v88 <= *(_DWORD*)(thisx + 384)
            || *(int*)(thisx + 384) < 0 && v88 >= *(_DWORD*)(thisx + 384))
        {
            *(_DWORD*)(thisx + 376) = v88;
        }
    }
    else
    {
        *(_DWORD*)(thisx + 376) = *(_DWORD*)(thisx + 384);
    }
    v105 = *(_DWORD*)(thisx + 372);
    v100 = *(_DWORD*)(thisx + 376);
    if (*(_BYTE*)(thisx + 178))
    {
        v105 += *(_DWORD*)(thisx + 364);
        v100 += *(_DWORD*)(thisx + 368);
    }
    v112 = 0;
    v63 = (v105 + *(_DWORD*)(thisx + 328)) / 800;
    v62 = (v100 + *(_DWORD*)(thisx + 332)) / 800;
    v5 = sub_426210((char*)unk_4B9B10);
    v65 = sub_4897D0(v5) / 8;
    v6 = sub_426210((char*)unk_4B9B10);
    v64 = sub_4261D0(v6);
    if (v63 <= 0 || v63 >= v65 - 1 || v62 <= 0 || v62 >= v64)
    {
        if (v63 >= 0)
        {
            if (v63 >= v65)
                v63 = v65 - 1;
        }
        else
        {
            v63 = 0;
        }
        if (v62 >= 0)
        {
            if (v62 >= v64)
                v62 = v64 - 1;
        }
        else
        {
            v62 = 0;
        }
        if (sub_4464F6((int*)unk_4B9B10, v63, v62) == 7)
            v112 = 1;
    }
    v96 = 0;
    if (!v112)
    {
        v7 = sub_426210((char*)unk_4B9B10);
        v61 = sub_4897D0(v7);
        v59 = sub_446465((char*)unk_4B9B10);
        v60 = *(_DWORD*)(thisx + 328);
        v56 = *(_DWORD*)(thisx + 332);
        *(_DWORD*)(thisx + 328) += v105;
        *(_DWORD*)(thisx + 332) += v100;
        v58 = *(_DWORD*)(thisx + 328) / 100;
        sub_4097DF((void*)thisx, (int)&v57);
        *(_DWORD*)(thisx + 328) = v60;
        *(_DWORD*)(thisx + 332) = v56;
        v55 = 0;
        if (v58 < 8 || v58 >= v61 - 8 || !*(_DWORD*)(thisx + 164) || sub_425CD0((int*)unk_4B9B10) != 3)
        {
            if (v57 < 8)
            {
                v105 = 100 * v59 + 800 - *(_DWORD*)(thisx + 328);
                if (*(int*)(thisx + 372) < 0 && *(int*)(thisx + 340) > 0)
                    *(_DWORD*)(thisx + 372) = 0;
                v55 = 1;
                v96 = 1;
            }
            if (v57 >= 312)
            {
                v105 = 100 * (v59 + 311) - *(_DWORD*)(thisx + 328);
                if (*(int*)(thisx + 372) > 0 && *(int*)(thisx + 340) < 0)
                    *(_DWORD*)(thisx + 372) = 0;
                v55 = 1;
                v96 = 1;
            }
        }
        if (v55
            && (*(_DWORD*)(thisx + 428) == 147 && !*(_DWORD*)(thisx + 436)
                || *(_DWORD*)(thisx + 428) == 187
                || *(_DWORD*)(thisx + 428) == 104 && *(_DWORD*)(thisx + 304)))
        {
            if (*(_DWORD*)(thisx + 428) == 104)
                *(_DWORD*)(thisx + 424) = *(_DWORD*)(thisx + 424) == 0;
            *(_DWORD*)(thisx + 372) = -*(_DWORD*)(thisx + 372);
            v105 = -v105;
            *(_DWORD*)(thisx + 352) = -*(_DWORD*)(thisx + 352);
        }
        if (v55
            && (*(_DWORD*)(thisx + 428) == 178
                || *(_DWORD*)(thisx + 428) == 179
                || *(_DWORD*)(thisx + 428) == 120 && !*(_DWORD*)(thisx + 304)))
        {
            if (*(_DWORD*)(thisx + 428) == 178 || *(_DWORD*)(thisx + 428) == 120)
            {
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A48, -1, 100, 100, 0);
                sub_41261C((_WORD*)thisx, *(unsigned __int16*)(thisx + 242), *(_DWORD*)(thisx + 316), 1);
            }
            *(_DWORD*)(thisx + 432) = 34;
            *(_DWORD*)(thisx + 436) = v57 < 160;
            *(_DWORD*)(thisx + 444) = 0;
            *(_DWORD*)(thisx + 352) = 0;
        }
        if (v55 && *(_DWORD*)(thisx + 428) == 61)
        {
            *(_DWORD*)(thisx + 436) = 1;
            *(_DWORD*)(thisx + 372) = -*(_DWORD*)(thisx + 372) / 2;
            *(_DWORD*)(thisx + 348) = -300;
            *(_DWORD*)(thisx + 360) = 30;
        }
        if (v100 + *(_DWORD*)(thisx + 332) >= 0)
        {
            v8 = v100 + *(_DWORD*)(thisx + 332);
            if (v8 >= 800 * sub_44647E((char*)unk_4B9B10))
            {
                v9 = sub_44647E((char*)unk_4B9B10);
                *(_DWORD*)(thisx + 332) = 800 * v9 - 1 - v100;
                v55 = 1;
            }
        }
        else
        {
            *(_DWORD*)(thisx + 332) = -v100;
            v55 = 1;
        }
        if (v55 && *(_DWORD*)(thisx + 428) == 88)
        {
            sub_41261C((_WORD*)thisx, *(unsigned __int16*)(thisx + 242), 0, 1);
            sub_43FFC3((int*)unk_4BDB28, dword_4B9A10, -1, 100, 100, 0);
            *(_DWORD*)(thisx + 432) = 34;
            *(_DWORD*)(thisx + 436) = v57 < 160;
            *(_DWORD*)(thisx + 444) = 0;
            *(_DWORD*)(thisx + 352) = 0;
        }
    }
    v98 = (v105 + *(_DWORD*)(thisx + 328)) / 100;
    v89 = (v100 + *(_DWORD*)(thisx + 332)) / 100;
    v97 = v98;
    v84 = v89;
    v109 = 0;
    v90 = 0;
    LOBYTE(v110) = 0;
    LOBYTE(v107) = 0;
    v101 = 0;
    v94 = 0;
    v102 = 0;
    v103 = 100 * sub_446497((int*)unk_4B9B10, v99, v89);
    v91 = *(_DWORD*)(thisx + 336) + v103 - v102;
    if (v103 >= 102000 || (!*(_DWORD*)(thisx + 392) || v91 > 0) && (*(_DWORD*)(thisx + 392) || v91 > 799))
    {
        v90 = 1;
        LOBYTE(v107) = sub_4464F6((int*)unk_4B9B10, v99 / 8, v89 / 8);
        v101 = sub_4744A9((int*)unk_4B9B10, v99 / 8, v89 / 8);
    }
    else
    {
        *(_DWORD*)(thisx + 332) += v100;
    }
    LOBYTE(v93) = sub_4464D3((int)unk_4B9B10, v99 / 8, v92 / 8);
    LOBYTE(v95) = sub_4464D3((int)unk_4B9B10, v98 / 8, *(_DWORD*)(thisx + 332) / 800);
    v113 = 100 * sub_446497((int*)unk_4B9B10, v99, v92);
    v103 = 100 * sub_446497((int*)unk_4B9B10, v98, v92);
    if (!*(_DWORD*)(thisx + 392) && ((_BYTE)v93 || (_BYTE)v95))
    {
        LOBYTE(v54) = v93;
        if (!(_BYTE)v93)
            LOBYTE(v54) = v95;
        v102 = 800;
    }
    while (v105)
    {
        v103 = 100 * sub_446497((int*)unk_4B9B10, v97, v92);
        v53 = sub_4464F6((int*)unk_4B9B10, v97 / 8, v92 / 8);
        v52 = *(_DWORD*)(thisx + 336) + v103 - v102;
        if (v103 < 102000 && (v52 <= 400 && !*(_DWORD*)(thisx + 392) || v52 <= 0 && *(_DWORD*)(thisx + 392)))
        {
            if (v109)
            {
                if ((_BYTE)v93 || (_BYTE)v95)
                {
                    *(_DWORD*)(thisx + 328) = 100 * v97;
                }
                else if (v105 >= 0)
                {
                    if (v105 > 0)
                        *(_DWORD*)(thisx + 328) = 100 * v97 + 700;
                }
                else
                {
                    *(_DWORD*)(thisx + 328) = 100 * v97;
                }
            }
            else
            {
                *(_DWORD*)(thisx + 328) += v105;
            }
            break;
        }
        if (((_BYTE)v93 || (_BYTE)v95) && (v52 <= 0 ? (v27 = -v52) : (v27 = v52), v27 <= 800 && v103 - v113 <= 400))
        {
            *(_DWORD*)(thisx + 336) = -v103;
        }
        else
        {
            v109 = 1;
            LOBYTE(v110) = v53;
            LOWORD(v106) = sub_4744A9((int*)unk_4B9B10, v97 / 8, v92 / 8);
            if ((_BYTE)v93 || (_BYTE)v95)
            {
                if (v105 <= 0)
                    v26 = (v105 >= 0) - 1;
                else
                    v26 = 1;
                v97 -= v26;
            }
            else
            {
                v97 = 8 * (v97 / 8);
                if (v105 <= 0)
                    v25 = (v105 >= 0) - 1;
                else
                    v25 = 1;
                v97 -= 8 * v25;
            }
        }
    }
    if (!v109 && !v90 && v105 && v100)
    {
        v97 = v98;
        v84 = v89;
        while (++v94 <= 100)
        {
            v103 = 100 * sub_446497((int*)unk_4B9B10, v97, v84);
            v51 = sub_4464F6((int*)unk_4B9B10, v97 / 8, v84 / 8);
            v91 = *(_DWORD*)(thisx + 336) + v103 - v102;
            if (v103 < 102000 && (v91 <= 400 && !*(_DWORD*)(thisx + 392) || v91 <= 0 && *(_DWORD*)(thisx + 392)))
            {
                if (v109)
                {
                    if ((_BYTE)v93 || (_BYTE)v95)
                    {
                        *(_DWORD*)(thisx + 328) = 100 * v97;
                    }
                    else if (v105 >= 0)
                    {
                        if (v105 > 0)
                            *(_DWORD*)(thisx + 328) = 100 * v97 + 700;
                    }
                    else
                    {
                        *(_DWORD*)(thisx + 328) = 100 * v97;
                    }
                }
                break;
            }
            if (((_BYTE)v93 || (_BYTE)v95) && (v91 <= 0 ? (v24 = -v91) : (v24 = v91), v24 <= 800 && v103 - v113 <= 400))
            {
                *(_DWORD*)(thisx + 336) = -v103;
            }
            else
            {
                v109 = 1;
                LOBYTE(v110) = v51;
                LOWORD(v106) = sub_4744A9((int*)unk_4B9B10, v97 / 8, v84 / 8);
                if ((_BYTE)v93 || (_BYTE)v95)
                {
                    if (v105 <= 0)
                        v23 = (v105 >= 0) - 1;
                    else
                        v23 = 1;
                    v97 -= v23;
                }
                else
                {
                    v97 = 8 * (v97 / 8);
                    if (v105 <= 0)
                        v22 = (v105 >= 0) - 1;
                    else
                        v22 = 1;
                    v97 -= 8 * v22;
                }
            }
        }
    }
    if (v109 || v90)
    {
        v87 = (__int16*)sub_474471((int)unk_4B9B10, v106);
        v50 = (__int16*)sub_474471((int)unk_4B9B10, v101);
        if (v87 && v109 && (v87[26] & 2) != 0)
        {
            sub_42455B(thisx, v87);
        }
        else if (v50 && v90 && (v50[26] & 2) != 0)
        {
            sub_42455B(thisx, v50);
        }
        else if (v109
            && (unsigned __int8)v110 == 1
            && !*(_DWORD*)(thisx + 392)
            && (*(_DWORD*)(thisx + 428) == 10
                || !*(_DWORD*)(thisx + 392) && *(_DWORD*)(thisx + 428) == 125
                || *(_DWORD*)(thisx + 428) == 126
                || *(_DWORD*)(thisx + 428) == 135
                || *(_DWORD*)(thisx + 428) == 89))
        {
            *(_DWORD*)(thisx + 424) = *(_DWORD*)(thisx + 424) == 0;
            *(_DWORD*)(thisx + 372) = -*(_DWORD*)(thisx + 372);
            *(_DWORD*)(thisx + 352) = -*(_DWORD*)(thisx + 352);
        }
        else
        {
            if (*(_DWORD*)(thisx + 428) && ((unsigned __int8)v110 == 7 || (unsigned __int8)v107 == 7))
                goto LABEL_373;
            if (v109
                && (*(_DWORD*)(thisx + 428) == 178
                    || *(_DWORD*)(thisx + 428) == 179
                    || !*(_DWORD*)(thisx + 392)
                    && (*(_DWORD*)(thisx + 428) == 10
                        || *(_DWORD*)(thisx + 428) == 135
                        || *(_DWORD*)(thisx + 428) == 89
                        || *(_DWORD*)(thisx + 428) == 120 && !*(_DWORD*)(thisx + 304))))
            {
                if (*(_DWORD*)(thisx + 428) == 178 || *(_DWORD*)(thisx + 428) == 120)
                {
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A48, -1, 100, 100, 0);
                    sub_41261C((_WORD*)thisx, *(unsigned __int16*)(thisx + 242), *(_DWORD*)(thisx + 316), 1);
                }
                *(_DWORD*)(thisx + 432) = 34;
                *(_DWORD*)(thisx + 436) = *(int*)(thisx + 372) < 0;
                *(_DWORD*)(thisx + 444) = 0;
                *(_DWORD*)(thisx + 352) = 0;
                sub_41F6DE((_DWORD*)thisx);
                if (*(_DWORD*)(thisx + 304) && *(_DWORD*)(thisx + 288))
                {
                    sub_417E42(*(_DWORD*)(thisx + 304));
                    sub_417E1D((_DWORD*)thisx);
                }
            }
            else if ((v109 || v90) && *(_DWORD*)(thisx + 428) == 88)
            {
                sub_41261C((_WORD*)thisx, *(unsigned __int16*)(thisx + 242), 0, 1);
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A10, -1, 100, 100, 0);
                *(_DWORD*)(thisx + 432) = 34;
                *(_DWORD*)(thisx + 436) = *(int*)(thisx + 372) < 0;
                *(_DWORD*)(thisx + 444) = 0;
                *(_DWORD*)(thisx + 352) = 0;
            }
            else if (v109
                && (*(_DWORD*)(thisx + 428) == 147 && !*(_DWORD*)(thisx + 436)
                    || *(_DWORD*)(thisx + 428) == 155
                    || *(_DWORD*)(thisx + 428) == 158
                    || *(_DWORD*)(thisx + 428) == 187
                    || *(_DWORD*)(thisx + 428) == 104 && *(_DWORD*)(thisx + 304)))
            {
                if (*(_DWORD*)(thisx + 428) == 104)
                    *(_DWORD*)(thisx + 424) = *(_DWORD*)(thisx + 424) == 0;
                *(_DWORD*)(thisx + 372) = -*(_DWORD*)(thisx + 372);
                *(_DWORD*)(thisx + 352) = -*(_DWORD*)(thisx + 352);
            }
            else if (v109 && *(_DWORD*)(thisx + 428) == 61)
            {
                *(_DWORD*)(thisx + 436) = 1;
                *(_DWORD*)(thisx + 372) = -*(_DWORD*)(thisx + 372) / 2;
                *(_DWORD*)(thisx + 348) = -300;
                *(_DWORD*)(thisx + 360) = 30;
            }
        }
    }
    *(_DWORD*)(thisx + 336) += *(_DWORD*)(thisx + 348);
    *(int*)(thisx + 388) %= 100;
    *(_DWORD*)(thisx + 388) += 100 * (*(_DWORD*)(thisx + 328) / 100) - 100 * (v86 / 100);
    if (v96 && *(_DWORD*)(thisx + 364) + *(_DWORD*)(thisx + 372))
        *(_DWORD*)(thisx + 388) += *(_DWORD*)(thisx + 364) + *(_DWORD*)(thisx + 372);
    *(_BYTE*)(thisx + 609) = sub_4464F6((int*)unk_4B9B10, *(_DWORD*)(thisx + 328) / 800, *(_DWORD*)(thisx + 332) / 800);
    if (*(_DWORD*)(thisx + 428) == 54 || *(_DWORD*)(thisx + 428) == 141 || *(_DWORD*)(thisx + 292))
        goto LABEL_654;
    v103 = 100 * sub_446497((int*)unk_4B9B10, *(_DWORD*)(thisx + 328) / 100, *(_DWORD*)(thisx + 332) / 100);
    LOBYTE(v49) = sub_4464D3((int)unk_4B9B10, *(_DWORD*)(thisx + 328) / 800, *(_DWORD*)(thisx + 332) / 800);
    LOBYTE(v93) = sub_4464D3((int)unk_4B9B10, v86 / 800, *(_DWORD*)(thisx + 332) / 800);
    if (*(_DWORD*)(thisx + 428) == 55 && *(_DWORD*)(thisx + 304))
    {
        v48 = sub_4260D0(*(_DWORD**)(thisx + 304));
        if (-v48 - v103 <= 800)
            *(_DWORD*)(thisx + 336) = -v103;
        else
            *(_DWORD*)(thisx + 336) = v48;
    }
    if ((_BYTE)v49 || (_BYTE)v93)
    {
        if (!(_BYTE)v49)
            LOBYTE(v49) = v93;
        if (*(int*)(thisx + 388) <= 0)
            v21 = (*(_DWORD*)(thisx + 388) >= 0) - 1;
        else
            v21 = 1;
        v102 = v21 * (*(_DWORD*)(thisx + 336) + v103);
        if ((v49 & 1) == 0)
            v102 = -v102;
    }
    if (v103 < 102000 && -*(_DWORD*)(thisx + 336) < v103 && *(_DWORD*)(thisx + 392))
    {
        v111 = (Concurrency::details::_UnrealizedChore*)sub_4741F8(
            (int)unk_4B9B10,
            *(_DWORD*)(thisx + 328) / 800,
            *(_DWORD*)(thisx + 332) / 800);
        if (v111)
        {
            LOWORD(v106) = sub_4260F0((short*)v111);
            v87 = (__int16*)sub_474471((int)unk_4B9B10, v106);
        }
        else
        {
            LOWORD(v106) = 0;
            v87 = 0;
        }
        LOBYTE(v108) = sub_4464F6((int*)unk_4B9B10, *(_DWORD*)(thisx + 328) / 800, *(_DWORD*)(thisx + 332) / 800);
        if (*(_DWORD*)(thisx + 428)
            && ((unsigned __int8)v108 == 7 || v87 && (v87[26] & 1) != 0 && *((unsigned __int8*)v87 + 10) >= 2u))
        {
            if ((unsigned __int8)v108 == 7)
            {
            LABEL_373:
                sub_4259A4((_DWORD*)thisx, a2, a3, a4);
                return;
            }
            if ((_WORD)v106)
                sub_42455B(thisx, v87);
            goto LABEL_565;
        }
        *(_BYTE*)(thisx + 236) = 0;
        if (*(_DWORD*)(thisx + 428) == 37
            || *(_DWORD*)(thisx + 428) == 169
            || *(_DWORD*)(thisx + 428) == 112
            || *(_DWORD*)(thisx + 428) == 114
            || *(_DWORD*)(thisx + 428) == 88
            || *(_DWORD*)(thisx + 428) == 119 && *(_DWORD*)(thisx + 436) != 5)
        {
            sub_43FFC3((int*)unk_4BDB28, dword_4B9A14, -1, 100, 100, 0);
            ++* (_DWORD*)(thisx + 436);
            if (*(_DWORD*)(thisx + 428) == 169 || *(_DWORD*)(thisx + 428) == 88 || *(_DWORD*)(thisx + 428) == 119)
            {
                *(_DWORD*)(thisx + 360) = 30;
                *(int*)(thisx + 372) /= 2;
                *(int*)(thisx + 376) /= 2;
                *(_DWORD*)(thisx + 424) = *(int*)(thisx + 372) < 0;
                if (*(_DWORD*)(thisx + 436) == 1)
                {
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A20, -1, 100, 100, 0);
                    sub_41261C((_WORD*)thisx, *(unsigned __int16*)(thisx + 242), *(_DWORD*)(thisx + 316), 1);
                }
            }
            else if (*(_DWORD*)(thisx + 428) == 112 || *(_DWORD*)(thisx + 428) == 114)
            {
                *(_DWORD*)(thisx + 360) = 30;
                *(int*)(thisx + 372) /= 2;
                if (*(_DWORD*)(thisx + 436) == 1)
                {
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A20, -1, 100, 100, 0);
                    sub_41261C((_WORD*)thisx, *(unsigned __int16*)(thisx + 242), *(_DWORD*)(thisx + 316), 1);
                }
            }
            else
            {
                *(_DWORD*)(thisx + 360) = 30;
            }
            if (*(_DWORD*)(thisx + 436) == 1)
            {
                *(_DWORD*)(thisx + 336) = -v103 - 1;
                *(_DWORD*)(thisx + 348) = -400;
                *(int*)(thisx + 372) /= 2;
            }
            else if (*(_DWORD*)(thisx + 436) == 2)
            {
                if ((!*(_DWORD*)(thisx + 424) || *(int*)(thisx + 372) >= 0)
                    && (*(_DWORD*)(thisx + 424) || *(int*)(thisx + 372) <= 0))
                {
                    *(_DWORD*)(thisx + 432) = 45;
                }
                else
                {
                    *(_DWORD*)(thisx + 432) = 44;
                }
                *(_DWORD*)(thisx + 444) = 0;
                *(_DWORD*)(thisx + 336) = -v103;
                *(_DWORD*)(thisx + 348) = 0;
                *(_DWORD*)(thisx + 360) = 0;
            }
            goto LABEL_565;
        }
        switch (*(_DWORD*)(thisx + 428))
        {
        case 0x22:
        case 0x4C:
        case 0x11:
        case 0x26:
        case 0x23:
        case 0x1D:
        case 0x21:
        case 0x10:
        case 0x12:
        case 0x13:
        case 0x14:
        case 0x15:
        case 0x17:
        case 0x18:
        case 0x19:
        case 0x16:
        case 0x75:
            sub_43FFC3((int*)unk_4BDB28, dword_4B9A14, -1, 100, 100, 0);
            if ((!*(_DWORD*)(thisx + 424) || *(int*)(thisx + 372) >= 0)
                && (*(_DWORD*)(thisx + 424) || *(int*)(thisx + 372) <= 0))
            {
                *(_DWORD*)(thisx + 432) = 45;
            }
            else
            {
                *(_DWORD*)(thisx + 432) = 44;
            }
            *(_DWORD*)(thisx + 336) = -v103;
            *(_DWORD*)(thisx + 348) = 0;
            *(_DWORD*)(thisx + 360) = 0;
            break;
        case 0x28:
            if (*(int*)(thisx + 436) >= 1)
            {
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A14, -1, 100, 100, 0);
                *(_DWORD*)(thisx + 432) = 46;
            }
        LABEL_498:
            *(_DWORD*)(thisx + 336) = -v103;
            *(_DWORD*)(thisx + 348) = 0;
            *(_DWORD*)(thisx + 360) = 0;
            break;
        case 0x24:
        case 0x27:
        case 0x1E:
            sub_43FFC3((int*)unk_4BDB28, dword_4B9A14, -1, 100, 100, 0);
            *(_DWORD*)(thisx + 432) = 42;
            *(_DWORD*)(thisx + 444) = 0;
            *(_DWORD*)(thisx + 336) = -v103;
            *(_DWORD*)(thisx + 348) = 0;
            *(_DWORD*)(thisx + 360) = 0;
            break;
        case 0x8A:
            *(_DWORD*)(thisx + 336) = -v103;
            if (*(_DWORD*)(thisx + 436))
            {
                *(_DWORD*)(thisx + 432) = 46;
                *(_DWORD*)(thisx + 436) = 0;
                *(_DWORD*)(thisx + 444) = 0;
                *(_DWORD*)(thisx + 348) = 0;
                *(_DWORD*)(thisx + 360) = 0;
            }
            else
            {
                ++* (_DWORD*)(thisx + 436);
                *(_DWORD*)(thisx + 348) = -340;
                *(int*)(thisx + 372) /= 2;
                v15 = *(_DWORD*)(thisx + 316);
                v10 = sub_4261B0((short*)thisx);
                sub_41261C((_WORD*)thisx, v10, v15, 1);
            }
            sub_43FFC3((int*)unk_4BDB28, dword_4B9A14, -1, 100, 100, 0);
            break;
        case 0x88:
        case 0x89:
            *(_DWORD*)(thisx + 336) = -v103;
            if (*(_DWORD*)(thisx + 436))
            {
                if (*(_DWORD*)(thisx + 428) == 136)
                    *(_DWORD*)(thisx + 432) = 44;
                else
                    *(_DWORD*)(thisx + 432) = 45;
                *(_DWORD*)(thisx + 436) = 0;
                *(_DWORD*)(thisx + 444) = 0;
                *(_DWORD*)(thisx + 348) = 0;
                *(_DWORD*)(thisx + 360) = 0;
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A14, -1, 100, 100, 0);
            }
            else
            {
                ++* (_DWORD*)(thisx + 436);
                *(_DWORD*)(thisx + 348) = -300;
                *(int*)(thisx + 372) /= 2;
                v16 = *(_DWORD*)(thisx + 316);
                v11 = sub_4261B0((short*)thisx);
                sub_41261C((_WORD*)thisx, v11, v16, 1);
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A14, -1, 100, 100, 0);
            }
            break;
        case 0x8B:
            if (*(_DWORD*)(thisx + 304))
            {
                SchedulerProxy = Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(thisx + 304));
                if (SchedulerProxy == (struct Concurrency::ISchedulerProxy*)44
                    || SchedulerProxy == (struct Concurrency::ISchedulerProxy*)45
                    || SchedulerProxy == (struct Concurrency::ISchedulerProxy*)46
                    || SchedulerProxy == (struct Concurrency::ISchedulerProxy*)47)
                {
                    *(_DWORD*)(thisx + 432) = 69;
                }
                else
                {
                    *(_DWORD*)(thisx + 432) = 12;
                    *(_DWORD*)(thisx + 304) = 0;
                }
            }
            else
            {
                *(_DWORD*)(thisx + 432) = 12;
            }
            *(_DWORD*)(thisx + 336) = -v103;
            *(_DWORD*)(thisx + 352) = 0;
            *(_DWORD*)(thisx + 356) = 0;
            *(_DWORD*)(thisx + 348) = 0;
            *(_DWORD*)(thisx + 360) = 0;
            break;
        case 0x97:
        case 0x98:
            *(_DWORD*)(thisx + 336) = -v103;
            if (*(_DWORD*)(thisx + 436))
            {
                if (*(_DWORD*)(thisx + 428) == 152)
                    *(_DWORD*)(thisx + 432) = 13;
                else
                    *(_DWORD*)(thisx + 432) = 3;
                *(_DWORD*)(thisx + 436) = 0;
                *(_DWORD*)(thisx + 444) = 0;
                *(_DWORD*)(thisx + 372) = 0;
                *(_DWORD*)(thisx + 376) = 0;
                *(_DWORD*)(thisx + 352) = 0;
                *(_DWORD*)(thisx + 356) = 0;
                *(_DWORD*)(thisx + 348) = 0;
                *(_DWORD*)(thisx + 360) = 0;
            }
            else
            {
                *(_DWORD*)(thisx + 436) = 1;
                *(_DWORD*)(thisx + 348) = -250;
                *(_DWORD*)(thisx + 360) = 30;
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A2C, -1, 100, 100, 0);
            }
            break;
        default:
            if (*(_DWORD*)(thisx + 304) && !sub_4264F0(*(_BYTE**)(thisx + 304)) && *(_DWORD*)(thisx + 428) == 59)
            {
                *(_DWORD*)(thisx + 336) = -v103;
                if (!sub_426170((char*)thisx))
                {
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A20, -1, 100, 100, 0);
                    *(_DWORD*)(thisx + 432) = 46;
                    *(_DWORD*)(thisx + 304) = 0;
                    *(_DWORD*)(thisx + 444) = 0;
                    *(_DWORD*)(thisx + 436) = 0;
                    *(_DWORD*)(thisx + 348) = 0;
                    *(_DWORD*)(thisx + 360) = 0;
                }
                break;
            }
            if (*(_DWORD*)(thisx + 428) == 57 && *(_BYTE*)(thisx + 195) == 1)
            {
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A10, -1, 100, 100, 0);
                *(_DWORD*)(thisx + 392) = 0;
                *(_DWORD*)(thisx + 436) = 1;
                *(_DWORD*)(thisx + 348) = 0;
                *(_DWORD*)(thisx + 360) = 0;
                *(_DWORD*)(thisx + 336) = -v103;
            }
            else if (*(_DWORD*)(thisx + 304) && *(_BYTE*)(thisx + 324) == 1 && *(_DWORD*)(thisx + 428) == 60)
            {
                *(_DWORD*)(thisx + 432) = 44;
                *(_DWORD*)(thisx + 304) = 0;
                *(_DWORD*)(thisx + 336) = -v103;
                *(_DWORD*)(thisx + 348) = 0;
                *(_DWORD*)(thisx + 360) = 0;
            }
            else if (*(_DWORD*)(thisx + 428) == 57 && *(_BYTE*)(thisx + 195) == 2 && !*(_DWORD*)(thisx + 436))
            {
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A10, -1, 100, 100, 0);
                *(_DWORD*)(thisx + 436) = 1;
                *(_DWORD*)(thisx + 348) = -170;
                *(_DWORD*)(thisx + 336) = -v103;
            }
            else if (*(_DWORD*)(thisx + 304)
                && *(_BYTE*)(thisx + 324) == 2
                && *(_DWORD*)(thisx + 428) == 59
                && *(_DWORD*)(thisx + 436) == 3)
            {
                *(_DWORD*)(thisx + 432) = 44;
                *(_DWORD*)(thisx + 304) = 0;
                *(_DWORD*)(thisx + 336) = -v103;
                *(_DWORD*)(thisx + 348) = 0;
                *(_DWORD*)(thisx + 360) = 0;
            }
            else
            {
                if (*(_DWORD*)(thisx + 428) != 58 || *(_BYTE*)(thisx + 195) != 2)
                {
                    if (!*(_DWORD*)(thisx + 304) || *(_BYTE*)(thisx + 324) != 2 || *(_DWORD*)(thisx + 428) != 60)
                    {
                        if (*(_DWORD*)(thisx + 304) && *(_BYTE*)(thisx + 324) == 3 && *(_DWORD*)(thisx + 428) == 59)
                        {
                            *(_DWORD*)(thisx + 336) = -v103;
                            *(_DWORD*)(thisx + 392) = 0;
                        }
                        else
                        {
                            switch (*(_DWORD*)(thisx + 428))
                            {
                            case '=':
                                *(_DWORD*)(thisx + 392) = 0;
                                *(_DWORD*)(thisx + 436) = 1;
                                *(_DWORD*)(thisx + 336) = -v103;
                                *(_DWORD*)(thisx + 348) = 0;
                                *(_DWORD*)(thisx + 360) = 0;
                                break;
                            case 'Z':
                                if (*(_DWORD*)(thisx + 436))
                                {
                                    if (*(_DWORD*)(thisx + 436) == 1)
                                    {
                                        *(_DWORD*)(thisx + 432) = 12;
                                        *(_DWORD*)(thisx + 304) = 0;
                                        *(_DWORD*)(thisx + 444) = 0;
                                        *(_DWORD*)(thisx + 336) = -v103;
                                        *(_DWORD*)(thisx + 352) = 0;
                                        *(_DWORD*)(thisx + 356) = 0;
                                        *(_DWORD*)(thisx + 348) = 0;
                                        *(_DWORD*)(thisx + 360) = 0;
                                    }
                                }
                                else
                                {
                                    ++* (_DWORD*)(thisx + 436);
                                    *(_DWORD*)(thisx + 372) = 150 * ((*(_DWORD*)(thisx + 424) == 0) - *(_DWORD*)(thisx + 424));
                                    *(_DWORD*)(thisx + 348) = -300;
                                    *(_DWORD*)(thisx + 360) = 30;
                                    *(_DWORD*)(thisx + 336) = -v103;
                                    *(_BYTE*)(thisx + 177) = 0;
                                }
                                break;
                            case 'n':
                                if (*(_DWORD*)(thisx + 436))
                                {
                                    if (*(_DWORD*)(thisx + 436) == 1)
                                    {
                                        *(_DWORD*)(thisx + 432) = 44;
                                        *(_DWORD*)(thisx + 304) = 0;
                                        *(_DWORD*)(thisx + 436) = 0;
                                        *(_DWORD*)(thisx + 444) = 0;
                                        *(_DWORD*)(thisx + 340) = 0;
                                        *(_DWORD*)(thisx + 348) = 0;
                                        *(_DWORD*)(thisx + 360) = 0;
                                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A14, -1, 100, 100, 0);
                                    }
                                }
                                else
                                {
                                    ++* (_DWORD*)(thisx + 436);
                                    *(_DWORD*)(thisx + 180) = 0;
                                    *(_BYTE*)(thisx + 177) = 0;
                                    if (*(_DWORD*)(thisx + 304))
                                        *(_DWORD*)(thisx + 424) = sub_425D70(*(_DWORD**)(thisx + 304));
                                    *(_DWORD*)(thisx + 372) = 150 * (*(_DWORD*)(thisx + 424) - (*(_DWORD*)(thisx + 424) == 0));
                                    *(_DWORD*)(thisx + 348) = -300;
                                    *(_DWORD*)(thisx + 360) = 30;
                                    *(_DWORD*)(thisx + 336) = -v103;
                                    sub_41261C((_WORD*)thisx, *(unsigned __int16*)(thisx + 242), *(_DWORD*)(thisx + 304), 1);
                                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A10, -1, 100, 100, 0);
                                }
                                break;
                            default:
                                if (*(_DWORD*)(thisx + 428) == 132
                                    || *(_DWORD*)(thisx + 428) == 133
                                    || *(_BYTE*)(thisx + 195) == 2 && *(_DWORD*)(thisx + 428) == 57
                                    || *(_DWORD*)(thisx + 428) == 51)
                                {
                                    *(_DWORD*)(thisx + 432) = 12;
                                    *(_DWORD*)(thisx + 444) = 0;
                                    *(_DWORD*)(thisx + 336) = -v103;
                                    *(_DWORD*)(thisx + 352) = 0;
                                    *(_DWORD*)(thisx + 356) = 0;
                                    *(_DWORD*)(thisx + 348) = 0;
                                    *(_DWORD*)(thisx + 360) = 0;
                                }
                                else
                                {
                                    switch (*(_DWORD*)(thisx + 428))
                                    {
                                    case 0x37:
                                    case 0x54:
                                    case 0x5B:
                                    case 0x5C:
                                    case 0x5E:
                                    case 0xB2:
                                    case 0xB3:
                                    case 0x61:
                                    case 0x62:
                                    case 0x64:
                                    case 0x78:
                                        *(_DWORD*)(thisx + 336) = -v103;
                                        *(_DWORD*)(thisx + 352) = 0;
                                        *(_DWORD*)(thisx + 356) = 0;
                                        *(_DWORD*)(thisx + 348) = 0;
                                        *(_DWORD*)(thisx + 360) = 0;
                                        *(_DWORD*)(thisx + 392) = 0;
                                        break;
                                    case 0x4D:
                                    case 0x2C:
                                    case 0x2D:
                                    case 0x2E:
                                    case 0x2F:
                                    case 0x4E:
                                    case 0x4F:
                                    case 1:
                                    case 0x63:
                                        *(_DWORD*)(thisx + 336) = -v103;
                                        *(_DWORD*)(thisx + 348) = 0;
                                        *(_DWORD*)(thisx + 360) = 0;
                                        *(_DWORD*)(thisx + 392) = 0;
                                        break;
                                    case 0x68:
                                    case 0x76:
                                        *(_DWORD*)(thisx + 336) = -v103;
                                        *(_DWORD*)(thisx + 348) = 0;
                                        *(_DWORD*)(thisx + 360) = 0;
                                        *(_DWORD*)(thisx + 392) = 0;
                                        if (!*(_DWORD*)(thisx + 304))
                                        {
                                            if (*(_DWORD*)(thisx + 428) == 104)
                                            {
                                                *(_DWORD*)(thisx + 432) = 13;
                                            }
                                            else
                                            {
                                                sub_43FFC3((int*)unk_4BDB28, dword_4B9A14, -1, 100, 100, 0);
                                                *(_DWORD*)(thisx + 432) = 44;
                                            }
                                        }
                                        break;
                                    case 0x55:
                                        *(_DWORD*)(thisx + 336) = -v103;
                                        *(_DWORD*)(thisx + 348) = 0;
                                        *(_DWORD*)(thisx + 360) = 0;
                                        *(_DWORD*)(thisx + 392) = 0;
                                        *(_DWORD*)(thisx + 436) = 1;
                                        break;
                                    case 0xCC:
                                        *(_DWORD*)(thisx + 336) = -v103;
                                        if (*(int*)(thisx + 436) >= 2)
                                        {
                                            *(_DWORD*)(thisx + 432) = 13;
                                            *(_DWORD*)(thisx + 444) = 0;
                                            *(_DWORD*)(thisx + 352) = 0;
                                            *(_DWORD*)(thisx + 356) = 0;
                                            *(_DWORD*)(thisx + 348) = 0;
                                            *(_DWORD*)(thisx + 360) = 0;
                                        }
                                        else
                                        {
                                            *(_DWORD*)(thisx + 444) = 1;
                                            ++* (_DWORD*)(thisx + 436);
                                        }
                                        break;
                                    default:
                                        if (sub_426170((char*)thisx))
                                        {
                                            *(_DWORD*)(thisx + 392) = 0;
                                            *(_DWORD*)(thisx + 336) = -v103;
                                        }
                                        else
                                        {
                                            if (!*(_DWORD*)(thisx + 288))
                                                *(_DWORD*)(thisx + 304) = 0;
                                            *(_DWORD*)(thisx + 432) = 13;
                                            *(_DWORD*)(thisx + 444) = 0;
                                            *(_DWORD*)(thisx + 336) = -v103;
                                            *(_DWORD*)(thisx + 352) = 0;
                                            *(_DWORD*)(thisx + 356) = 0;
                                            *(_DWORD*)(thisx + 348) = 0;
                                            *(_DWORD*)(thisx + 360) = 0;
                                        }
                                        break;
                                    }
                                }
                                break;
                            }
                        }
                        break;
                    }
                    goto LABEL_498;
                }
                *(_DWORD*)(thisx + 432) = 12;
                *(_DWORD*)(thisx + 304) = 0;
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A10, -1, 100, 100, 0);
                *(_DWORD*)(thisx + 436) = 1;
                *(_DWORD*)(thisx + 336) = -v103;
                *(_DWORD*)(thisx + 348) = 0;
                *(_DWORD*)(thisx + 360) = 0;
            }
            break;
        }
    }
LABEL_565:
    if (-*(_DWORD*)(thisx + 336) - v103 < 800 && (!v102 || v102 + *(_DWORD*)(thisx + 336) >= -v103)
        || *(_DWORD*)(thisx + 392))
    {
        if (!*(_DWORD*)(thisx + 392))
        {
            v111 = (Concurrency::details::_UnrealizedChore*)sub_4741F8(
                (int)unk_4B9B10,
                *(_DWORD*)(thisx + 328) / 800,
                *(_DWORD*)(thisx + 332) / 800);
            v46 = sub_4464F6((int*)unk_4B9B10, *(_DWORD*)(thisx + 328) / 800, *(_DWORD*)(thisx + 332) / 800);
            *(_DWORD*)(thisx + 336) = -v103;
            LOBYTE(v45) = 50;
            if (v111)
                LOBYTE(v45) = Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime(v111);
            if (!*(_DWORD*)(thisx + 340)
                || *(_DWORD*)(thisx + 380)
                && (*(int*)(thisx + 380) > 0 && *(_DWORD*)(thisx + 380) < *(_DWORD*)(thisx + 372)
                    || *(int*)(thisx + 380) < 0 && *(_DWORD*)(thisx + 380) > *(_DWORD*)(thisx + 372)))
            {
                *(_DWORD*)(thisx + 372) = (unsigned __int8)v45 * *(_DWORD*)(thisx + 372) / 100;
            }
            if (!*(_DWORD*)(thisx + 344)
                || *(_DWORD*)(thisx + 384)
                && (*(int*)(thisx + 384) > 0 && *(_DWORD*)(thisx + 384) < *(_DWORD*)(thisx + 376)
                    || *(int*)(thisx + 384) < 0 && *(_DWORD*)(thisx + 384) > *(_DWORD*)(thisx + 376)))
            {
                *(_DWORD*)(thisx + 376) = (unsigned __int8)v45 * *(_DWORD*)(thisx + 376) / 100;
            }
            if (*(_DWORD*)(thisx + 352) && *(_DWORD*)(thisx + 428) != 10)
            {
                v44 = *(_DWORD*)(thisx + 352);
                v20 = v44 + *(_DWORD*)(thisx + 372) <= 0 ? (v44 + *(_DWORD*)(thisx + 372) >= 0) - 1 : 1;
                v19 = v44 <= 0 ? (v44 >= 0) - 1 : 1;
                if (v20 == v19)
                {
                    *(_DWORD*)(thisx + 352) = 0;
                    *(_DWORD*)(thisx + 372) = 0;
                }
            }
            if (*(_DWORD*)(thisx + 356) && *(_DWORD*)(thisx + 428) != 10)
            {
                v43 = *(_DWORD*)(thisx + 356);
                v18 = v43 + *(_DWORD*)(thisx + 376) <= 0 ? (v43 + *(_DWORD*)(thisx + 376) >= 0) - 1 : 1;
                v17 = v43 <= 0 ? (v43 >= 0) - 1 : 1;
                if (v18 == v17)
                {
                    *(_DWORD*)(thisx + 356) = 0;
                    *(_DWORD*)(thisx + 376) = 0;
                }
            }
        }
    }
    else
    {
        if (*(_DWORD*)(thisx + 428) == 56)
        {
            if (*(_DWORD*)(thisx + 304))
                sub_417EE0(*(_DWORD*)(thisx + 304));
            *(_DWORD*)(thisx + 304) = 0;
        }
        if (*(_DWORD*)(thisx + 428) == 44
            || *(_DWORD*)(thisx + 428) == 45
            || *(_DWORD*)(thisx + 428) == 46
            || *(_DWORD*)(thisx + 428) == 47
            || *(_DWORD*)(thisx + 428) == 78
            || *(_DWORD*)(thisx + 428) == 79
            || *(_DWORD*)(thisx + 428) == 1
            || *(_DWORD*)(thisx + 428) == 100
            || *(_DWORD*)(thisx + 428) == 104
            || *(_DWORD*)(thisx + 428) == 118)
        {
            *(_DWORD*)(thisx + 360) = 30;
            *(_DWORD*)(thisx + 392) = 1;
        }
        else if (*(_DWORD*)(thisx + 428) == 120)
        {
            if (*(_DWORD*)(thisx + 436))
            {
                if (*(_DWORD*)(thisx + 436) == 1)
                {
                    *(_DWORD*)(thisx + 360) = 30;
                    *(_DWORD*)(thisx + 392) = 1;
                }
            }
            else
            {
                sub_417C83(thisx);
            }
        }
        else if (*(_DWORD*)(thisx + 428) == 55
            || *(_DWORD*)(thisx + 428) == 84
            || *(_DWORD*)(thisx + 428) == 85
            || *(_DWORD*)(thisx + 428) == 99 && *(_DWORD*)(thisx + 304))
        {
            *(_DWORD*)(thisx + 392) = 1;
        }
        else if (*(_DWORD*)(thisx + 428) == 59 || *(_DWORD*)(thisx + 428) == 60 || *(_DWORD*)(thisx + 428) == 115)
        {
            *(_DWORD*)(thisx + 372) = 0;
            *(_DWORD*)(thisx + 348) = 0;
            *(_DWORD*)(thisx + 360) = 30;
        }
        else if (*(_DWORD*)(thisx + 428) == 178 || *(_DWORD*)(thisx + 428) == 179)
        {
            *(_DWORD*)(thisx + 392) = 1;
            *(_DWORD*)(thisx + 360) = 30;
        }
        else
        {
            if (*(_DWORD*)(thisx + 428) == 69 || *(_DWORD*)(thisx + 428) == 70)
            {
                if (*(_DWORD*)(thisx + 304))
                    sub_417EAD((int*)*(_DWORD*)(thisx + 304));
                sub_417E88((int*)thisx);
            }
            if (*(_DWORD*)(thisx + 304) && (*(_DWORD*)(thisx + 428) == 57 || *(_DWORD*)(thisx + 428) == 58))
            {
                sub_417C83(*(_DWORD*)(thisx + 304));
                *(_DWORD*)(thisx + 304) = 0;
            }
            if (*(_DWORD*)(thisx + 304) && !*(_DWORD*)(thisx + 288))
                *(_DWORD*)(thisx + 304) = 0;
            *(_DWORD*)(thisx + 432) = 50;
            ++* (_DWORD*)(thisx + 336);
            *(_DWORD*)(thisx + 352) = 0;
            *(_DWORD*)(thisx + 356) = 0;
            *(_DWORD*)(thisx + 444) = 0;
        }
    }
    *(_DWORD*)(thisx + 348) += *(_DWORD*)(thisx + 360);
LABEL_654:
    if ((*(_DWORD*)(thisx + 428) == 7
        || *(_DWORD*)(thisx + 428) == 8
        || *(_DWORD*)(thisx + 428) == 50
        || *(_DWORD*)(thisx + 428) == 51)
        && *(int*)(thisx + 348) > 0)
    {
        if (*(_DWORD*)(thisx + 392))
        {
            if (!*(_DWORD*)(thisx + 288) && !*(_DWORD*)(thisx + 292))
            {
                v42 = sub_465B44((int*)unk_4B9B10, (Concurrency::details::SchedulerBase*)thisx);
                if (v42)
                {
                    *(_DWORD*)(thisx + 304) = (int)v42;
                    *(_DWORD*)(thisx + 292) = 1;
                    *(_DWORD*)(thisx + 432) = 3;
                    sub_420EF3((int)v42, thisx);
                }
            }
        }
    }
    if (*(_DWORD*)(thisx + 428) != *(_DWORD*)(thisx + 432))
        sub_408F50(thisx, a2, a3, a4, 0);
    v111 = (Concurrency::details::_UnrealizedChore*)sub_4741F8(
        (int)unk_4B9B10,
        *(_DWORD*)(thisx + 328) / 800,
        *(_DWORD*)(thisx + 332) / 800);
    v103 = 100 * sub_446497((int*)unk_4B9B10, *(_DWORD*)(thisx + 328) / 100, *(_DWORD*)(thisx + 332) / 100);
    if (v111)
    {
        if (sub_425C50((char*)v111))
            v103 = 400 * (unsigned __int8)unknown_libname_6((char*)v111);
        v12 = sub_425C30((char*)v111);
        *(_DWORD*)(thisx + 208) = v12 - (-*(_DWORD*)(thisx + 336) - v103) / 100;
        if (*(_DWORD*)(thisx + 392) && v104 <= 0 && *(int*)(thisx + 208) > 0 && unknown_libname_5((char*)v111) == 11)
        {
            sub_43FFC3((int*)unk_4BDB28, dword_4B9AE4, -1, 100, 100, 0);
            sub_442863(v37);
            sub_4641FE((int*)unk_4B9B10, *(_DWORD*)(thisx + 328), *(_DWORD*)(thisx + 332), -v103, (int)v41);
            v13 = sub_446465((char*)unk_4B9B10);
            v37[0] = v13 + v41[0];
            v14 = sub_425C30((char*)v111);
            v37[1] = v41[1] - v14;
            v38 = 20;
            v39 = 0;
            v40 = 0;
            sub_4561A5((char*)unk_4B9B10, (int)v37);
        }
    }
}
 
_DWORD* sub_41714D(_DWORD* thisx, int a2)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[73] = 1;
    thisx[76] = a2;
    return result;
}

 
int sub_417173(int thisx, unsigned __int8 a2)
{
    int v2; // esi
    unsigned __int16 v3; // ax
    int v4; // esi
    int result; // eax
    int v6; // esi
    int v8; // [esp+8h] [ebp-Ch]
    int v9; // [esp+Ch] [ebp-8h]
    _DWORD* v10; // [esp+10h] [ebp-4h]

    v10 = (_DWORD*)sub_446714(unk_4B9B10, a2);
    if (v10 && *(_DWORD*)(thisx + 428) == 44 || *(_DWORD*)(thisx + 428) == 45)
    {
        *(_DWORD*)(thisx + 304) = (_DWORD)v10;
        *(_DWORD*)(thisx + 316) = (_DWORD)v10;
        if (sub_41BA53((int)v10, 0x24u, 0))
        {
            *(_DWORD*)(thisx + 432) = 178;
            *(_DWORD*)(thisx + 424) = sub_425D70(v10);
            v9 = sub_4175B4(*(_DWORD*)(thisx + 304), 1) / 2;
            sub_41EF8A((_WORD*)thisx, v9);
            v2 = sub_4175B4(*(_DWORD*)(thisx + 304), 1);
            v3 = sub_417924(thisx, 3, 1);
            sub_41F169((_WORD*)thisx, (v2 + v3) / 2);
            memset((void*)(thisx + 453), 0, 8u);
            memset((void*)(thisx + 461), 0, 8u);
            *(_BYTE*)(thisx + a2 + 453) = -1;
        }
        else
        {
            *(_DWORD*)(thisx + 432) = 138;
            v8 = sub_4175B4(*(_DWORD*)(thisx + 304), 1) / 10;
            sub_41EF8A((_WORD*)thisx, v8);
            sub_41F169((_WORD*)thisx, *(unsigned __int16*)(thisx + 242));
            *(_BYTE*)(thisx + 248) = 2;
            *(_DWORD*)(thisx + 436) = a2;
        }
    }
    else if (v10 && sub_426070((char*)v10) == *(_BYTE*)(thisx + 193) && sub_420FA1(v10))
    {
        sub_426230((char*)v10);
        *(_DWORD*)(thisx + 432) = 84;
        *(_DWORD*)(thisx + 424) = sub_425D70(v10);
        *(_DWORD*)(thisx + 304) = 0;
    }
    else
    {
        *(_DWORD*)(thisx + 432) = 50;
        *(_DWORD*)(thisx + 304) = 0;
    }
    *(_DWORD*)(thisx + 292) = 0;
    if (*(_DWORD*)(thisx + 432) == 178)
    {
        v4 = sub_425D70(v10);
        *(_DWORD*)(thisx + 372) = 150 * ((__PAIR64__(v4, sub_425D70(v10)) - 1) >> 32);
        *(_DWORD*)(thisx + 340) = 5;
        result = thisx;
        *(_DWORD*)(thisx + 348) = -340;
        *(_DWORD*)(thisx + 360) = 30;
    }
    else
    {
        v6 = sub_425D70(v10);
        *(_DWORD*)(thisx + 372) = 250 * ((__PAIR64__(v6, sub_425D70(v10)) - 1) >> 32);
        *(_DWORD*)(thisx + 348) = -340;
        *(_DWORD*)(thisx + 360) = 25;
        result = thisx;
    }
    *(_DWORD*)(thisx + 436) = 0;
    return result;
}
 
_DWORD* sub_41745B(_DWORD* thisx, unsigned __int8 a2)
{
    _DWORD* result; // eax
    int v3; // esi
    int v5; // [esp+8h] [ebp-4h]

    if (thisx[107] == 44)
    {
        thisx[108] = 136;
    }
    else
    {
        if (thisx[107] != 45)
            return (_DWORD*)sub_417173((int)thisx, a2);
        thisx[108] = 137;
    }
    thisx[73] = 0;
    *((_BYTE*)thisx + a2 + 453) = -1;
    thisx[76] = sub_446714(unk_4B9B10, a2);
    thisx[79] = thisx[76];
    if (thisx[76])
    {
        v5 = sub_4175B4(thisx[76], 1) / 10;
        sub_41EF8A((short*)thisx, v5);
        sub_41F169((short*)thisx, *((unsigned __int16*)thisx + 121));
        v3 = sub_425D70((_DWORD*)thisx[76]);
        thisx[93] = 500 * ((__PAIR64__(v3, sub_425D70((_DWORD*)thisx[76])) - 1) >> 32);
    }
    *((_BYTE*)thisx + 248) = 2;
    result = thisx;
    thisx[87] = 400;
    thisx[90] = 30;
    thisx[109] = 0;
    return result;
}
 
__int16 sub_4175B4(int thisx, int a2)
{
    int v4; // [esp+8h] [ebp-Ch]
    int v5; // [esp+Ch] [ebp-8h]
    unsigned __int16 v6; // [esp+10h] [ebp-4h]

    v6 = *(_WORD*)(thisx + 506);
    if (a2)
    {
        if (sub_41BA53(thisx, 0x82u, 0))
        {
            v5 = 100 * *(unsigned __int16*)(thisx + 214) / *(unsigned __int16*)(thisx + 500);
            if (v5 >= 10)
            {
                if (v5 >= 20)
                {
                    if (v5 >= 30)
                    {
                        if (v5 >= 40)
                        {
                            if (v5 < 50)
                                v6 = 110 * v6 / 100;
                        }
                        else
                        {
                            v6 = 120 * v6 / 100;
                        }
                    }
                    else
                    {
                        v6 = 130 * v6 / 100;
                    }
                }
                else
                {
                    v6 = 140 * v6 / 100;
                }
            }
            else
            {
                v6 = 150 * v6 / 100;
            }
        }
        if (sub_41BA53(thisx, 0x8Cu, 0) && *(_BYTE*)(thisx + 609) == 11)
            v6 += *(_WORD*)(thisx + 496) + 15;
    }
    if (sub_425CD0((_DWORD*)&unk_4B9B10) == 3 && *(_DWORD*)(thisx + 164))
    {
        v4 = v6 * sub_426250((_DWORD*)&unk_4B9B10) / 100;
        if (v4 > 255)
            LOWORD(v4) = 255;
        v6 = v4;
    }
    if (!v6)
        return 1;
    return v6;
}

 
int sub_417763(_WORD* thisx)
{
    int result; // eax

    result = sub_41D61F((_DWORD)thisx);
    thisx[107] = result;
    return result;
}

 
int sub_417780(int thisx)
{
    int result; // eax
    int v2; // [esp+0h] [ebp-Ch]

    result = thisx;
    if (*(_DWORD*)(thisx + 292))
    {
        if (*(_DWORD*)(thisx + 304))
        {
            *(_DWORD*)(thisx + 388) = sub_426270(*(_DWORD**)(thisx + 304));
            *(_DWORD*)(thisx + 328) = sub_426090(*(_DWORD**)(thisx + 304));
            *(_DWORD*)(thisx + 332) = sub_4260B0(*(_DWORD**)(thisx + 304));
            result = sub_4260D0(*(_DWORD**)(thisx + 304)) - 2400;
            *(_DWORD*)(thisx + 336) = result;
        }
    }
    else if (*(_DWORD*)(thisx + 428) == 69)
    {
        result = thisx;
        if (*(_DWORD*)(thisx + 304))
        {
            *(_DWORD*)(thisx + 328) = sub_426090(*(_DWORD**)(thisx + 304));
            *(_DWORD*)(thisx + 332) = sub_4260B0(*(_DWORD**)(thisx + 304));
            *(_BYTE*)(thisx + 223) = sub_426030(*(char**)(thisx + 304)) + 1;
            result = sub_4260D0(*(_DWORD**)(thisx + 304));
            *(_DWORD*)(thisx + 336) = result;
        }
    }
    else if (*(_DWORD*)(thisx + 428) == 56)
    {
        result = thisx;
        if (*(_DWORD*)(thisx + 304))
        {
            v2 = *(_DWORD*)(thisx + 332) - sub_4260B0(*(_DWORD**)(thisx + 304)) <= 0 ? sub_4260B0(*(_DWORD**)(thisx + 304))
                - *(_DWORD*)(thisx + 332) : *(_DWORD*)(thisx + 332) - sub_4260B0(*(_DWORD**)(thisx + 304));
            result = v2;
            if (v2 >= 1)
            {
                result = sub_4260B0(*(_DWORD**)(thisx + 304));
                *(_DWORD*)(thisx + 332) = result;
            }
        }
    }
    return result;
}

 
__int16 sub_417924(int thisx, int a2, int a3)
{
    int v5; // [esp+8h] [ebp-Ch]
    int v6; // [esp+Ch] [ebp-8h]
    unsigned __int16 v7; // [esp+10h] [ebp-4h]

    v7 = *(_WORD*)(thisx + 512);
    if (a3 && sub_41BA53(thisx, 0x8Cu, 0) && *(_BYTE*)(thisx + 609) == 11)
        v7 += *(_WORD*)(thisx + 496) + 10;
    if (sub_41BA53(thisx, 0x83u, 0))
    {
        v6 = 100 * *(unsigned __int16*)(thisx + 214) / *(unsigned __int16*)(thisx + 500);
        if (v6 >= 10)
        {
            if (v6 >= 20)
            {
                if (v6 >= 30)
                {
                    if (v6 >= 40)
                    {
                        if (v6 < 50)
                            v7 = 110 * v7 / 100;
                    }
                    else
                    {
                        v7 = 120 * v7 / 100;
                    }
                }
                else
                {
                    v7 = 130 * v7 / 100;
                }
            }
            else
            {
                v7 = 140 * v7 / 100;
            }
        }
        else
        {
            v7 = 150 * v7 / 100;
        }
    }
    if (*(_DWORD*)(thisx + 428) == 44
        || *(_DWORD*)(thisx + 428) == 45
        || *(_DWORD*)(thisx + 428) == 46
        || *(_DWORD*)(thisx + 428) == 47)
    {
        if (a2 == 148)
        {
            v7 = 125 * v7 / 100;
        }
        else if (a2 == 177)
        {
            v7 *= 2;
        }
        else
        {
            v7 = 175 * v7 / 100;
        }
    }
    if (*(int*)(thisx + 428) >= 31 && *(int*)(thisx + 428) <= 43)
        v7 = 150 * v7 / 100;
    if (*(_DWORD*)(thisx + 428) == 135 || *(_DWORD*)(thisx + 428) == 89)
        v7 = 75 * v7 / 100;
    if (sub_425CD0((_DWORD*)&unk_4B9B10) == 3 && *(_DWORD*)(thisx + 164))
    {
        v5 = v7 * sub_426250((_DWORD*)&unk_4B9B10) / 100;
        if (v5 > 255)
            LOWORD(v5) = 255;
        v7 = v5;
    }
    if (v7)
        return v7;
    else
        return 1;
}

 
unsigned __int8*  sub_417BBB(int thisx, int a2)
{
    unsigned __int8* result; // eax
    unsigned __int16 v3; // ax

    *(_DWORD*)(thisx + 304) = a2;
    *(_DWORD*)(thisx + 296) = 1;
    result = (unsigned __int8*)thisx;
    if (!*(_DWORD*)(thisx + 300))
    {
        v3 = sub_423AC3(a2, 1);
        result = sub_41F1A3((unsigned __int8*)thisx, v3 + 60);
    }
    *(_DWORD*)(thisx + 300) = 1;
    return result;
}

 
void sub_417C15(int thisx, unsigned __int8 a2)
{
    if (!a2)
        a2 = 1;
    sub_41261C((_WORD*)thisx, a2, *(_DWORD*)(thisx + 304), 1);
    if (*(_DWORD*)(thisx + 428) == 44)
    {
        *(_DWORD*)(thisx + 432) = 46;
    }
    else if (*(_DWORD*)(thisx + 428) == 45)
    {
        *(_DWORD*)(thisx + 432) = 47;
    }
}

 
_BYTE* sub_417C83(int thisx)
{
    _BYTE* result; // eax

    result = (_BYTE*)thisx;
    if (*(_DWORD*)(thisx + 428) != 78 && *(_DWORD*)(thisx + 428) != 79)
    {
        if (*(_DWORD*)(thisx + 432) == 59
            || *(_DWORD*)(thisx + 432) == 60
            || *(_DWORD*)(thisx + 432) == 117
            || *(_DWORD*)(thisx + 432) == 120
            || *(_DWORD*)(thisx + 432) == 121
            || *(_DWORD*)(thisx + 432) == 87)
        {
            *(_DWORD*)(thisx + 432) = 76;
        }
        else if (*(_DWORD*)(thisx + 432) != 76)
        {
            if (*(_DWORD*)(thisx + 392))
                *(_DWORD*)(thisx + 432) = 50;
            else
                *(_DWORD*)(thisx + 432) = 3;
        }
        *(_DWORD*)(thisx + 304) = 0;
        *(_DWORD*)(thisx + 372) = 0;
        *(_DWORD*)(thisx + 376) = 0;
        *(_DWORD*)(thisx + 340) = 0;
        *(_DWORD*)(thisx + 344) = 0;
        *(_DWORD*)(thisx + 348) = 0;
        *(_DWORD*)(thisx + 352) = 0;
        *(_DWORD*)(thisx + 356) = 0;
        *(_DWORD*)(thisx + 360) = 0;
        *(_DWORD*)(thisx + 444) = 0;
        return sub_423CF2((_BYTE*)thisx, 0, 0, 0, 0, 0, 0);
    }
    return result;
}

 
_BYTE* sub_417DCC(int thisx)
{
    if (*(_DWORD*)(thisx + 432) == 57 || *(_DWORD*)(thisx + 432) == 58)
        *(_DWORD*)(thisx + 432) = 4;
    *(_DWORD*)(thisx + 304) = 0;
    return sub_423CF2((_BYTE*)thisx, 0, 0, 0, 0, 0, 0);
}

 
_DWORD* sub_417E1D(_DWORD* thisx)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[72] = 0;
    thisx[76] = 0;
    return result;
}

 
int sub_417E42(int thisx)
{
    int result; // eax

    *(_DWORD*)(thisx + 292) = 0;
    *(_DWORD*)(thisx + 304) = 0;
    *(_DWORD*)(thisx + 432) = 50;
    result = thisx;
    *(_BYTE*)(thisx + 470) = 0;
    *(_BYTE*)(thisx + 471) = 1;
    return result;
}

 
_DWORD* sub_417E88(_DWORD* thisx)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[76] = 0;
    thisx[108] = 12;
    return result;
}

 
_DWORD* sub_417EAD(_DWORD* thisx)
{
    _DWORD* result; // eax

    result = thisx;
    if (thisx[74])
    {
        thisx[76] = 0;
        thisx[74] = 0;
    }
    return result;
}

 
int  sub_417EE0(int thisx)
{
    int result; // eax

    *(_DWORD*)(thisx + 304) = 0;
    if (*(_DWORD*)(thisx + 432) == 52 || *(_DWORD*)(thisx + 432) == 53)
        *(_DWORD*)(thisx + 432) = 4;
    sub_423CF2((_BYTE*)thisx, 0, 0, 0, 0, 0, 0);
    *(_DWORD*)(thisx + 372) = 0;
    *(_DWORD*)(thisx + 376) = 0;
    *(_DWORD*)(thisx + 340) = 0;
    *(_DWORD*)(thisx + 344) = 0;
    *(_DWORD*)(thisx + 352) = 0;
    result = thisx;
    *(_DWORD*)(thisx + 356) = 0;
    if (*(_DWORD*)(thisx + 392))
    {
        *(_DWORD*)(thisx + 348) = 0;
        result = thisx;
        *(_DWORD*)(thisx + 360) = 30;
    }
    else
    {
        *(_DWORD*)(thisx + 348) = 0;
        *(_DWORD*)(thisx + 360) = 0;
    }
    return result;
} 
int  sub_417FC1(int thisx)
{
    int result; // eax

    *(_DWORD*)(thisx + 304) = 0;
    *(_DWORD*)(thisx + 340) = 0;
    *(_DWORD*)(thisx + 344) = 0;
    *(_DWORD*)(thisx + 348) = 0;
    *(_DWORD*)(thisx + 352) = 0;
    *(_DWORD*)(thisx + 356) = 0;
    *(_DWORD*)(thisx + 360) = 0;
    *(_DWORD*)(thisx + 372) = 0;
    *(_DWORD*)(thisx + 376) = 0;
    sub_423CF2((_BYTE*)thisx, 0, 0, 0, 0, 0, 0);
    result = thisx;
    if (*(_DWORD*)(thisx + 432) == 54 || *(_DWORD*)(thisx + 432) == 55)
        *(_DWORD*)(thisx + 432) = 75;
    return result;
}

 
_DWORD* sub_41807A(_DWORD* thisx)
{
    thisx[31] = 0;
    thisx[32] = 0;
    thisx[13] = 0;
    thisx[14] = 0;
    thisx[15] = 0;
    *((_BYTE*)thisx + 140) = 100;
    *((_BYTE*)thisx + 141) = 0;
    *((_BYTE*)thisx + 142) = 0;
    *((_BYTE*)thisx + 145) = 0;
    *((_BYTE*)thisx + 144) = 0;
    *((_BYTE*)thisx + 143) = 0;
    *((_BYTE*)thisx + 147) = 0;
    thisx[33] = 0;
    thisx[34] = 0;
    *thisx = 0;
    thisx[1] = 1;
    return thisx;
}

 
void** sub_418130(void** thisx)
{
    void** result; // eax

    if (thisx[13])
        operator delete(thisx[13]);
    thisx[13] = 0;
    if (thisx[14])
        operator delete(thisx[14]);
    result = thisx;
    thisx[14] = 0;
    if (thisx[15])
        operator delete(thisx[15]);
    thisx[15] = 0;
    return result;
}

 
__int16 __fastcall sub_4181B5(int a1)
{
    struct Concurrency::ISchedulerProxy* v1; // eax
    int v2; // edx
    int v3; // ebx
    int v4; // edx
    int v5; // ebx
    int v6; // esi
    int v7; // esi
    int v8; // esi
    int v9; // esi
    int v10; // esi
    int v11; // eax
    int v12; // eax
    int v13; // ebx
    bool v14; // bl
    unsigned int v15; // esi
    int v16; // esi
    int v17; // esi
    unsigned __int16 v18; // ax
    unsigned __int16 v19; // ax
    int v20; // esi
    int v21; // esi
    unsigned __int16 v22; // ax
    unsigned __int16 v23; // ax
    int v24; // ebx
    int v25; // esi
    int v26; // esi
    unsigned __int8 v27; // al
    int v28; // eax
    int v29; // esi
    unsigned __int8 v30; // al
    unsigned __int8 v31; // al
    unsigned __int8 v32; // al
    int v34; // [esp-4h] [ebp-270h]
    int v35; // [esp+8h] [ebp-264h]
    int v36; // [esp+Ch] [ebp-260h]
    int v37; // [esp+10h] [ebp-25Ch]
    int v38; // [esp+14h] [ebp-258h]
    char v39; // [esp+18h] [ebp-254h]
    int v40; // [esp+1Ch] [ebp-250h]
    int v41; // [esp+20h] [ebp-24Ch]
    int v42; // [esp+24h] [ebp-248h]
    int v43; // [esp+28h] [ebp-244h]
    int v44; // [esp+2Ch] [ebp-240h]
    char v45; // [esp+30h] [ebp-23Ch]
    int v46; // [esp+34h] [ebp-238h]
    int v47; // [esp+38h] [ebp-234h]
    char v48; // [esp+3Ch] [ebp-230h]
    int v49; // [esp+40h] [ebp-22Ch]
    int v50; // [esp+44h] [ebp-228h]
    int v51; // [esp+48h] [ebp-224h]
    int v52; // [esp+4Ch] [ebp-220h]
    char v53; // [esp+50h] [ebp-21Ch]
    char v54; // [esp+54h] [ebp-218h]
    int v55; // [esp+58h] [ebp-214h]
    int v56; // [esp+5Ch] [ebp-210h]
    int v57; // [esp+60h] [ebp-20Ch]
    int v58; // [esp+64h] [ebp-208h]
    int v59; // [esp+68h] [ebp-204h]
    int v60; // [esp+6Ch] [ebp-200h]
    int v61; // [esp+70h] [ebp-1FCh]
    char v62; // [esp+74h] [ebp-1F8h]
    int v63; // [esp+78h] [ebp-1F4h]
    char v64; // [esp+7Ch] [ebp-1F0h]
    int v65; // [esp+80h] [ebp-1ECh]
    int v66; // [esp+84h] [ebp-1E8h]
    char v67; // [esp+88h] [ebp-1E4h]
    int v68; // [esp+8Ch] [ebp-1E0h]
    char v69; // [esp+90h] [ebp-1DCh]
    int v70; // [esp+94h] [ebp-1D8h]
    int v71; // [esp+98h] [ebp-1D4h]
    char v72; // [esp+9Ch] [ebp-1D0h]
    int v73; // [esp+A0h] [ebp-1CCh]
    int v74; // [esp+A4h] [ebp-1C8h]
    int v75; // [esp+A8h] [ebp-1C4h]
    char v76; // [esp+ACh] [ebp-1C0h]
    int v77; // [esp+B0h] [ebp-1BCh]
    int v78; // [esp+B4h] [ebp-1B8h]
    int v79; // [esp+B8h] [ebp-1B4h]
    char v80; // [esp+BCh] [ebp-1B0h]
    int v81; // [esp+C0h] [ebp-1ACh]
    int v82; // [esp+C4h] [ebp-1A8h]
    char v83; // [esp+C8h] [ebp-1A4h]
    int v84; // [esp+CCh] [ebp-1A0h]
    int v85; // [esp+D0h] [ebp-19Ch]
    int v86; // [esp+D4h] [ebp-198h]
    int v87; // [esp+D8h] [ebp-194h]
    int v88; // [esp+DCh] [ebp-190h]
    int v89; // [esp+E0h] [ebp-18Ch]
    int v90; // [esp+E4h] [ebp-188h]
    int v91; // [esp+E8h] [ebp-184h]
    int v92; // [esp+ECh] [ebp-180h]
    int v93; // [esp+F0h] [ebp-17Ch]
    char v94; // [esp+F4h] [ebp-178h]
    int v95; // [esp+F8h] [ebp-174h]
    char v96; // [esp+FCh] [ebp-170h]
    char v97; // [esp+100h] [ebp-16Ch]
    int v98; // [esp+104h] [ebp-168h]
    char v99; // [esp+108h] [ebp-164h]
    int v100; // [esp+10Ch] [ebp-160h]
    int v101; // [esp+110h] [ebp-15Ch]
    int v102; // [esp+114h] [ebp-158h]
    int v103; // [esp+118h] [ebp-154h]
    int v104; // [esp+11Ch] [ebp-150h]
    int v105; // [esp+120h] [ebp-14Ch]
    int v106; // [esp+124h] [ebp-148h]
    char v107; // [esp+128h] [ebp-144h]
    char v108; // [esp+12Ch] [ebp-140h]
    char v109; // [esp+130h] [ebp-13Ch]
    char v110; // [esp+134h] [ebp-138h]
    int v111; // [esp+138h] [ebp-134h]
    int v112; // [esp+13Ch] [ebp-130h]
    int v113; // [esp+140h] [ebp-12Ch]
    int v114; // [esp+144h] [ebp-128h]
    int v115; // [esp+148h] [ebp-124h]
    int v117; // [esp+15Ch] [ebp-110h]
    int v118; // [esp+164h] [ebp-108h]
    int v119; // [esp+168h] [ebp-104h]
    int v120; // [esp+16Ch] [ebp-100h]
    int v121; // [esp+180h] [ebp-ECh]
    int v122; // [esp+184h] [ebp-E8h]
    int v123; // [esp+190h] [ebp-DCh]
    int v124; // [esp+194h] [ebp-D8h]
    char v125; // [esp+198h] [ebp-D4h]
    int v126; // [esp+19Ch] [ebp-D0h]
    signed int v127; // [esp+1A0h] [ebp-CCh]
    int v128; // [esp+1A4h] [ebp-C8h]
    int v129; // [esp+1A8h] [ebp-C4h]
    int v130; // [esp+1ACh] [ebp-C0h]
    int v131; // [esp+1B0h] [ebp-BCh]
    int v132; // [esp+1BCh] [ebp-B0h]
    unsigned int v133; // [esp+1C0h] [ebp-ACh]
    int v134; // [esp+1C4h] [ebp-A8h]
    int v135; // [esp+1C4h] [ebp-A8h]
    int v136; // [esp+1C8h] [ebp-A4h]
    _BYTE* v137; // [esp+1CCh] [ebp-A0h]
    int v138; // [esp+1D0h] [ebp-9Ch]
    int v139[2]; // [esp+1D4h] [ebp-98h] BYREF
    int v140; // [esp+1DCh] [ebp-90h]
    int v141; // [esp+1E4h] [ebp-88h]
    int v142; // [esp+1E8h] [ebp-84h]
    int v143; // [esp+1ECh] [ebp-80h]
    int v144; // [esp+1F0h] [ebp-7Ch]
    int v145; // [esp+1F4h] [ebp-78h]
    int k; // [esp+1F8h] [ebp-74h]
    _DWORD* v147; // [esp+1FCh] [ebp-70h]
    unsigned __int8* v148; // [esp+200h] [ebp-6Ch]
    struct Concurrency::ISchedulerProxy* v149; // [esp+204h] [ebp-68h]
    int v150; // [esp+208h] [ebp-64h]
    int v151; // [esp+20Ch] [ebp-60h]
    int v152; // [esp+210h] [ebp-5Ch]
    int v153; // [esp+214h] [ebp-58h]
    _DWORD* v154; // [esp+218h] [ebp-54h]
    _BYTE* v155; // [esp+21Ch] [ebp-50h]
    _DWORD* v156; // [esp+220h] [ebp-4Ch]
    Concurrency::details::SchedulerBase* v157; // [esp+224h] [ebp-48h]
    struct Concurrency::ISchedulerProxy* v158; // [esp+228h] [ebp-44h]
    int j; // [esp+22Ch] [ebp-40h]
    _BYTE* v160; // [esp+230h] [ebp-3Ch]
    int v161; // [esp+234h] [ebp-38h]
    int v162; // [esp+238h] [ebp-34h]
    int v163; // [esp+23Ch] [ebp-30h]
    int v164; // [esp+240h] [ebp-2Ch]
    int v165; // [esp+244h] [ebp-28h]
    int v166; // [esp+248h] [ebp-24h]
    int v167; // [esp+24Ch] [ebp-20h]
    unsigned int v168; // [esp+250h] [ebp-1Ch]
    int i; // [esp+254h] [ebp-18h]
    int v170; // [esp+258h] [ebp-14h]
    struct Concurrency::ISchedulerProxy* SchedulerProxy; // [esp+25Ch] [ebp-10h]
    struct Concurrency::ISchedulerProxy* v172; // [esp+260h] [ebp-Ch]
    int v173; // [esp+264h] [ebp-8h]
    int v174; // [esp+268h] [ebp-4h]

    *(_BYTE*)(a1 + 141) = 0;
    *(_BYTE*)(a1 + 142) = 0;
    *(_DWORD*)(a1 + 8) = 0;
    for (i = 0; i < 4; ++i)
    {
        if (*(char*)(i + a1 + 143) > 0)
            --* (_BYTE*)(i + a1 + 143);
    }
    LOWORD(v1) = a1;
    if (*(_DWORD*)(a1 + 124))
    {
        LOBYTE(v161) = sub_425E70(*(_BYTE**)(a1 + 124));
        SchedulerProxy = Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 124));
        if (SchedulerProxy == (struct Concurrency::ISchedulerProxy*)44
            || SchedulerProxy == (struct Concurrency::ISchedulerProxy*)45
            || SchedulerProxy == (struct Concurrency::ISchedulerProxy*)48)
        {
            *(_BYTE*)(a1 + 141) = rand() % 3 - 1;
            v2 = rand() % 3 - 1;
            LOWORD(v1) = a1;
            *(_BYTE*)(a1 + 142) = v2;
            return (__int16)v1;
        }
        if (sub_425D50(*(_DWORD**)(a1 + 124)))
        {
            v160 = (_BYTE*)sub_426430(*(_DWORD**)(a1 + 124));
            if (!v160
                || (v3 = (unsigned __int8)sub_426070(v160), v3 != (unsigned __int8)sub_426070(*(_BYTE**)(a1 + 124)))
                || !byte_4B99C8)
            {
                *(_BYTE*)(a1 + 147) = 2;
                *(_BYTE*)(a1 + 144) = 1;
                *(_BYTE*)(a1 + 143) = 1;
                *(_BYTE*)(a1 + 148) = 0;
                *(_BYTE*)(a1 + 141) = rand() % 3 - 1;
                v4 = rand() % 3 - 1;
                LOWORD(v1) = a1;
                *(_BYTE*)(a1 + 142) = v4;
                return (__int16)v1;
            }
        }
        if (byte_4B99C8)
        {
            if (*(_DWORD*)a1 == 6 || *(_DWORD*)a1 == 7 || *(_DWORD*)a1 == 8)
            {
                for (j = 0; j < 2; ++j)
                {
                    if (j)
                    {
                        if (j == 1)
                            v157 = *(Concurrency::details::SchedulerBase**)(a1 + 128);
                    }
                    else
                    {
                        v157 = *(Concurrency::details::SchedulerBase**)(a1 + 124);
                    }
                    if (v157)
                        v158 = Concurrency::details::SchedulerBase::GetSchedulerProxy(v157);
                    if (!v157
                        || v158 == (struct Concurrency::ISchedulerProxy*)44
                        || v158 == (struct Concurrency::ISchedulerProxy*)45
                        || v158 == (struct Concurrency::ISchedulerProxy*)46
                        || v158 == (struct Concurrency::ISchedulerProxy*)47
                        || v158 == (struct Concurrency::ISchedulerProxy*)84
                        || v158 == (struct Concurrency::ISchedulerProxy*)85)
                    {
                        *(_DWORD*)(a1 + 132) = 0;
                    }
                }
                if (*(_DWORD*)(a1 + 128))
                {
                    if (sub_41BEA6(*(_DWORD**)(a1 + 128)))
                    {
                        v156 = sub_41F0A9(*(_DWORD**)(a1 + 128));
                        if (unknown_libname_30(v156) != 6 && unknown_libname_30(v156) != 7 && unknown_libname_30(v156) != 8)
                            *(_DWORD*)(a1 + 132) = 0;
                    }
                }
            }
            if (sub_426410(*(_DWORD**)(a1 + 124)))
            {
                v155 = (_BYTE*)sub_426430(*(_DWORD**)(a1 + 124));
                if (v155)
                {
                    if (rand() % 100 < 5)
                    {
                        v5 = (unsigned __int8)sub_426070(v155);
                        if (v5 == (unsigned __int8)sub_426070(*(_BYTE**)(a1 + 124)))
                        {
                            v1 = (struct Concurrency::ISchedulerProxy*)sub_420FA1(*(_DWORD**)(a1 + 124));
                            if (v1)
                            {
                                *(_BYTE*)(a1 + 143) = 1;
                                return (__int16)v1;
                            }
                        }
                    }
                }
            }
            if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 124)) == (struct Concurrency::ISchedulerProxy*)82)
            {
                v154 = (_DWORD*)sub_4262D0(*(_DWORD**)(a1 + 124));
                if (v154)
                {
                    if (sub_41BEA6(v154))
                    {
                        if (rand() % 100 < 5)
                        {
                            if (sub_4262B0(*(_DWORD**)(a1 + 124)))
                            {
                                v1 = (struct Concurrency::ISchedulerProxy*)sub_420FA1(*(_DWORD**)(a1 + 124));
                                if (v1)
                                {
                                    *(_BYTE*)(a1 + 143) = 1;
                                    return (__int16)v1;
                                }
                            }
                        }
                    }
                }
            }
        }
        if ((!(_BYTE)v161 || (unsigned __int8)v161 == 2 || (unsigned __int8)v161 == 3)
            && !sub_426430(*(_DWORD**)(a1 + 124))
            && (sub_4263B0(*(_DWORD**)(a1 + 124))
                || Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 124)) == (struct Concurrency::ISchedulerProxy*)10)
            && !sub_425FF0(*(_DWORD**)(a1 + 124)))
        {
            if (sub_456B0D((unsigned char*)unk_4B9B10, *(_DWORD**)(a1 + 124), 1))
            {
                v1 = Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 124));
                if (v1 == (struct Concurrency::ISchedulerProxy*)10)
                {
                    LOWORD(v1) = a1;
                    *(_BYTE*)(a1 + 145) = 1;
                }
                else
                {
                    *(_BYTE*)(a1 + 143) = 1;
                }
                return (__int16)v1;
            }
            *(_DWORD*)(a1 + 76) = sub_456B0D((unsigned char*)unk_4B9B10, *(_DWORD**)(a1 + 124), 0);
            if (*(_DWORD*)(a1 + 76))
            {
                v6 = *(unsigned __int8*)(a1 + 99);
                if (v6 > rand() % 100)
                {
                    *(_DWORD*)a1 = 4;
                    *(_DWORD*)(a1 + 128) = 0;
                    *(_DWORD*)(a1 + 72) = 0;
                    *(_DWORD*)(a1 + 132) = -1;
                }
            }
        }
        if (*(_DWORD*)(a1 + 128))
        {
            if (unknown_libname_7(*(_DWORD**)(a1 + 128))
                && Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 128)) != (struct Concurrency::ISchedulerProxy*)80)
            {
                if (!*(_DWORD*)a1 && sub_4263D0(*(unsigned char**)(a1 + 128)))
                    *(_DWORD*)a1 = 2;
            }
            else
            {
                *(_DWORD*)(a1 + 128) = 0;
                *(_DWORD*)(a1 + 132) = 0;
            }
        }
        if (*(_DWORD*)a1 == 3 && *(_DWORD*)(a1 + 72))
        {
            v152 = sub_446465((char*)unk_4B9B10);
            v153 = sub_426470(*(_DWORD**)(a1 + 72)) / 100 - v152;
            if (sub_425CD0((_DWORD*)unk_4B9B10) == 3)
                v153 = 0;
            if (v153 < 8 || v153 >= 312 || unknown_libname_12(*(_DWORD**)(a1 + 72)))
                *(_DWORD*)(a1 + 132) = 0;
        }
        if (*(_DWORD*)a1 == 4)
        {
            if (*(_DWORD*)(a1 + 76))
            {
                v150 = sub_446465((char*)unk_4B9B10);
                v151 = unknown_libname_22(*(_DWORD**)(a1 + 76)) - v150;
                if (v151 < 8 || v151 >= 312 || !sub_426290(*(unsigned __int8**)(a1 + 76)))
                    *(_DWORD*)(a1 + 132) = 0;
            }
        }
        if (*(_DWORD*)a1 == 2)
        {
            if (sub_4263D0(*(unsigned char**)(a1 + 124)))
            {
                *(_DWORD*)a1 = 0;
            }
            else if (*(_DWORD*)(a1 + 128))
            {
                v149 = Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 128));
                if (v149 == (struct Concurrency::ISchedulerProxy*)91
                    || v149 == (struct Concurrency::ISchedulerProxy*)92
                    || v149 == (struct Concurrency::ISchedulerProxy*)94
                    || v149 == (struct Concurrency::ISchedulerProxy*)82)
                {
                    *(_DWORD*)a1 = 0;
                }
            }
        }
        if (*(_DWORD*)a1 != 3 && *(_DWORD*)a1 != 4 && !*(_DWORD*)(a1 + 128)
            || *(_DWORD*)a1 == 3 && (sub_425FF0(*(_DWORD**)(a1 + 124)) || !*(_DWORD*)(a1 + 72))
            || *(_DWORD*)a1 == 4 && !*(_DWORD*)(a1 + 76)
            || !*(_DWORD*)(a1 + 132))
        {
            if ((unsigned __int8)v161 != 2
                && (unsigned __int8)v161 != 3
                && byte_4B99C8
                && rand() % 100 < 10
                && sub_4666C5((char*)unk_4B9B10, *(_BYTE**)(a1 + 124)) > 0
                && !sub_425FF0(*(_DWORD**)(a1 + 124))
                && !sub_426410(*(_DWORD**)(a1 + 124))
                && !sub_425D50(*(_DWORD**)(a1 + 124))
                && !sub_426430(*(_DWORD**)(a1 + 124)))
            {
                *(_BYTE*)(a1 + 146) = 1;
                *(_BYTE*)(a1 + rand() % 2 + 143) = 1;
            }
            *(_DWORD*)(a1 + 72) = 0;
            if (!(_BYTE)v161 && !sub_425FF0(*(_DWORD**)(a1 + 124)) && rand() % 100 < *(unsigned __int8*)(a1 + 86))
            {
                *(_DWORD*)a1 = 3;
                *(_DWORD*)(a1 + 72) = (_DWORD)sub_41FE85(a1);
                *(_DWORD*)(a1 + 132) = rand() % 300 + 150;
                if (*(_DWORD*)(a1 + 72))
                {
                    v7 = sub_426090(*(_DWORD**)(a1 + 124));
                    if (v7 - sub_426470(*(_DWORD**)(a1 + 72)) <= 0)
                    {
                        v9 = sub_426090(*(_DWORD**)(a1 + 124));
                        v115 = sub_426470(*(_DWORD**)(a1 + 72)) - v9;
                    }
                    else
                    {
                        v8 = sub_426090(*(_DWORD**)(a1 + 124));
                        v115 = v8 - sub_426470(*(_DWORD**)(a1 + 72));
                    }
                    *(_DWORD*)(a1 + 132) += v115 / 100;
                }
            }
            v148 = sub_41B465((_DWORD*)a1);
            if (!v148)
            {
                LOWORD(v1) = a1;
                *(_DWORD*)(a1 + 128) = 0;
                return (__int16)v1;
            }
            *(_DWORD*)(a1 + 132) = rand() % 300 + 150;
            *(_DWORD*)(a1 + 128) = (_DWORD)v148;
            if (!*(_DWORD*)(a1 + 72))
            {
                if ((_BYTE)v161
                    || sub_4263D0(*(unsigned char**)(a1 + 124))
                    || !sub_4263D0(*(unsigned char**)(a1 + 128)) && rand() % 100 >= 20)
                {
                    *(_DWORD*)a1 = 0;
                }
                else
                {
                    *(_DWORD*)a1 = 2;
                }
            }
        }
        if (*(_DWORD*)(a1 + 128))
        {
            v147 = sub_41F0A9(*(_DWORD**)(a1 + 128));
            if (v147)
            {
                if (unknown_libname_30(v147) == 2 && *(_DWORD*)a1 == 2)
                    *(_DWORD*)a1 = 0;
            }
        }
        if (*(int*)(a1 + 132) > 0)
            --* (_DWORD*)(a1 + 132);
        if (sub_4263D0(*(unsigned char**)(a1 + 124))
            || sub_425FF0(*(_DWORD**)(a1 + 124))
            || rand() % 100 >= 50
            && Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 124)) != (struct Concurrency::ISchedulerProxy*)77
            || !sub_41BB24((_DWORD*)a1))
        {
            *(_DWORD*)(a1 + 136) = 0;
        }
        else
        {
            ++* (_DWORD*)(a1 + 136);
            *(_BYTE*)(a1 + 145) = 1;
        }
        if (*(int*)(a1 + 136) >= 120)
            *(_BYTE*)(a1 + 141) = rand() % 3 - 1;
        if (*(_DWORD*)a1 == 2)
        {
            sub_422573((_DWORD*)a1);
            sub_4227A2((_DWORD*)a1);
        }
        sub_4219B1((_DWORD*)a1);
        v172 = Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 124));
        v163 = *(_DWORD*)(a1 + 24);
        v162 = *(_DWORD*)(a1 + 28);
        v10 = -*(_DWORD*)(a1 + 32);
        v164 = sub_4260D0(*(_DWORD**)(a1 + 124)) + v10;
        v165 = v163 - sub_426090(*(_DWORD**)(a1 + 124));
        v170 = v162 - sub_4260B0(*(_DWORD**)(a1 + 124));
        v168 = Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 124));
        v166 = sub_426390(*(_DWORD**)(a1 + 124));
        if (!*(_DWORD*)a1
            && *(_DWORD*)(a1 + 128)
            && sub_41BEA6(*(_DWORD**)(a1 + 128))
            && Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 128)) == (struct Concurrency::ISchedulerProxy*)200
            || v172 != (struct Concurrency::ISchedulerProxy*)13
            || !*(_BYTE*)(a1 + 94))
        {
            goto LABEL_197;
        }
        for (k = 0; k < 2; ++k)
        {
            if (k)
            {
                v145 = v165;
                v142 = v170;
            }
            else
            {
                v138 = sub_446465((char*)unk_4B9B10);
                v144 = (v163 / 100 - v138 + 32) / 128 - 1;
                v141 = (*(_DWORD*)(a1 + 68) / 2 + v162 / 100) / (3 * *(_DWORD*)(a1 + 68)) - 1;
            }
            sub_42532C(*(_DWORD**)(a1 + 124), *(&v144 + k), *(&v141 + k), k, &v139[2 * k]);
            v139[2 * k] = v163 - v139[2 * k];
            v139[2 * k + 1] = v162 - v139[2 * k + 1];
            if (v139[2 * k] <= 0)
                v114 = -v139[2 * k];
            else
                v114 = v139[2 * k];
            if (v139[2 * k + 1] <= 0)
                v113 = -v139[2 * k + 1];
            else
                v113 = v139[2 * k + 1];
            v139[2 * k] = v113 + v114;
        }
        if (v165 <= 0)
            v112 = -v165;
        else
            v112 = v165;
        if (v170 <= 0)
            v111 = -v170;
        else
            v111 = v170;
        v143 = v111 + v112;
        if (v139[0] < v111 + v112 && v139[0] < v140)
        {
            if (v144 <= 0)
                v110 = (v144 >= 0) - 1;
            else
                v110 = 1;
            *(_BYTE*)(a1 + 141) = v110;
            if (v141 <= 0)
                v109 = (v141 >= 0) - 1;
            else
                v109 = 1;
            *(_BYTE*)(a1 + 142) = v109;
            LOWORD(v1) = a1;
            *(_BYTE*)(a1 + 143) = 1;
            *(_BYTE*)(a1 + 144) = 0;
            *(_BYTE*)(a1 + 145) = 0;
            return (__int16)v1;
        }
        if (v140 >= v143 || v140 >= v139[0])
        {
        LABEL_197:
            if (v165 <= 0)
                v106 = -v165;
            else
                v106 = v165;
            if (v106 > 12800 || (v170 <= 0 ? (v105 = -v170) : (v105 = v170), v105 > 4400))
            {
                if (!sub_425D30(*(_DWORD**)(a1 + 124))
                    && *(_BYTE*)(a1 + 94)
                    && Concurrency::details::SchedulerBase::GetNumberOfBoundContexts(*(Concurrency::details::SchedulerBase**)(a1 + 124))
                    && !(rand() % 10))
                {
                    *(_BYTE*)(a1 + 147) = 1;
                    *(_BYTE*)(a1 + 144) = 1;
                    *(_BYTE*)(a1 + 143) = 1;
                    *(_BYTE*)(a1 + 148) = 0;
                }
            }
            if (!*(_DWORD*)(a1 + 4) || *(_DWORD*)a1 == 6 || *(_DWORD*)a1 == 7 || *(_DWORD*)a1 == 8)
            {
                v165 = 100 * (v165 / 100);
                v170 = 100 * (v170 / 100);
            }
            else
            {
                v163 = *(_DWORD*)(a1 + 36);
                v162 = *(_DWORD*)(a1 + 40);
                v11 = sub_426090(*(_DWORD**)(a1 + 124));
                v165 = 800 * (v163 - v11 / 800);
                v12 = sub_4260B0(*(_DWORD**)(a1 + 124));
                v170 = 800 * (v162 - v12 / 800);
            }
            v164 = 100 * (v164 / 100);
            if (v165 <= 0)
                v104 = -v165;
            else
                v104 = v165;
            if (v170 <= 0)
                v103 = -v170;
            else
                v103 = v170;
            v167 = v103 + v104;
            if (sub_426410(*(_DWORD**)(a1 + 124)))
            {
                v137 = (_BYTE*)sub_426430(*(_DWORD**)(a1 + 124));
                if (!v137
                    || (v13 = (unsigned __int8)sub_426070(v137), v13 != (unsigned __int8)sub_426070(*(_BYTE**)(a1 + 124))))
                {
                    if (sub_41BA53(*(_DWORD*)(a1 + 124), 0x24u, 0))
                        *(_BYTE*)(a1 + 144) = 1;
                    else
                        *(_BYTE*)(a1 + rand() % 2 + 143) = 1;
                }
            }
            if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 124)) == (struct Concurrency::ISchedulerProxy*)52
                || Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 124)) == (struct Concurrency::ISchedulerProxy*)53
                || Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 124)) == (struct Concurrency::ISchedulerProxy*)69)
            {
                if ((unsigned __int8)v161 == 2 || (unsigned __int8)v161 == 3)
                    *(_BYTE*)(a1 + 143) = 1;
                else
                    *(_BYTE*)(a1 + rand() % 2 + 143) = 1;
            }
            if (*(_DWORD*)a1 != 2 && *(_DWORD*)a1 != 6 && *(_DWORD*)a1 != 7 && *(_DWORD*)a1 != 8)
                sub_420119(a1);
            if (*(_DWORD*)a1 != 2 || *(_DWORD*)(a1 + 4))
            {
                if (sub_425D30(*(_DWORD**)(a1 + 124)))
                {
                    if (*(_BYTE*)(a1 + 147))
                    {
                        ++* (_BYTE*)(a1 + 148);
                        if (*(_BYTE*)(a1 + 147) == 1 && *(unsigned __int8*)(a1 + 148) < 3u
                            || *(_BYTE*)(a1 + 147) == 2 && *(unsigned __int8*)(a1 + 148) < 8u)
                        {
                            *(_BYTE*)(a1 + 144) = 1;
                            *(_BYTE*)(a1 + 143) = 1;
                        }
                        else
                        {
                            *(_BYTE*)(a1 + 147) = 0;
                        }
                    }
                    if (*(_DWORD*)(a1 + 4))
                    {
                        if (sub_425D70(*(_DWORD**)(a1 + 124)))
                            *(_BYTE*)(a1 + 141) = 1;
                        else
                            *(_BYTE*)(a1 + 141) = -1;
                    }
                    else if (*(_DWORD*)a1 != 2
                        && *(_DWORD*)a1 != 3
                        && *(_DWORD*)a1 != 6
                        && *(_DWORD*)a1 != 7
                        && *(_DWORD*)a1 != 8)
                    {
                        v57 = v170 <= 0 ? -v170 : v170;
                        if (v57 < 500)
                        {
                            v56 = v165 <= 0 ? -v165 : v165;
                            if (v56 < 6400)
                            {
                                v55 = v164 <= 0 ? -v164 : v164;
                                if (v55 < 3200)
                                {
                                    if (v165 < 0 && sub_425D70(*(_DWORD**)(a1 + 124)))
                                    {
                                        *(_BYTE*)(a1 + 141) = -1;
                                    }
                                    else if (v165 > 0 && !sub_425D70(*(_DWORD**)(a1 + 124)))
                                    {
                                        *(_BYTE*)(a1 + 141) = 1;
                                    }
                                }
                            }
                        }
                    }
                }
                else if (*(_DWORD*)a1 == 6 || *(_DWORD*)a1 == 7 || *(_DWORD*)a1 == 8)
                {
                    if (v165 <= 0)
                        v102 = -v165;
                    else
                        v102 = v165;
                    if (v102 <= 8000 || *(_DWORD*)a1 == 8)
                    {
                        if (v165 <= 0)
                            v101 = -v165;
                        else
                            v101 = v165;
                        if (v101 < 4000 && sub_426350(*(unsigned __int8**)(a1 + 124)))
                        {
                            v14 = sub_425D70(*(_DWORD**)(a1 + 124)) == 0;
                            *(_BYTE*)(a1 + 141) = v14 - sub_425D70(*(_DWORD**)(a1 + 124));
                        }
                        else
                        {
                            if (v165 <= 0)
                                v100 = -v165;
                            else
                                v100 = v165;
                            if (v100 > 1200 && *(_DWORD*)a1 == 7)
                            {
                                if (v165 <= 0)
                                    v99 = (v165 >= 0) - 1;
                                else
                                    v99 = 1;
                                *(_BYTE*)(a1 + 141) = v99;
                            }
                            else
                            {
                                if (v165 <= 0)
                                    v98 = -v165;
                                else
                                    v98 = v165;
                                if (v98 <= 1200 && *(_DWORD*)a1 == 7)
                                {
                                    if (v165)
                                    {
                                        if (v165 <= 0)
                                            v97 = (v165 >= 0) - 1;
                                        else
                                            v97 = 1;
                                        *(_BYTE*)(a1 + 141) = -v97;
                                    }
                                    else
                                    {
                                        *(_BYTE*)(a1 + 141) = 2 * (rand() % 2) - 1;
                                    }
                                }
                                else
                                {
                                    if (v165 <= 0)
                                        v96 = (v165 >= 0) - 1;
                                    else
                                        v96 = 1;
                                    *(_BYTE*)(a1 + 141) = v96;
                                }
                            }
                        }
                    }
                    else
                    {
                        *(_BYTE*)(a1 + 84) = 1;
                    }
                    if (v170 <= 0)
                        v95 = -v170;
                    else
                        v95 = v170;
                    if (v95 > 500)
                    {
                        if (v170 <= 0)
                            v94 = (v170 >= 0) - 1;
                        else
                            v94 = 1;
                        *(_BYTE*)(a1 + 142) = v94;
                    }
                    if (*(_DWORD*)a1 == 6
                        && !sub_425D50(*(_DWORD**)(a1 + 124))
                        && Concurrency::details::SchedulerBase::GetNumberOfBoundContexts(*(Concurrency::details::SchedulerBase**)(a1 + 124)))
                    {
                        v134 = (3 * sub_41D067(*(_DWORD*)(a1 + 124), 0) / 2 + 405) / 15 - 7;
                        v135 = v134 + (v134 < 0 ? 7 : 0);
                        v15 = Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 124)) * v135;
                        v133 = sub_426090(*(_DWORD**)(a1 + 124)) + v15;
                        v16 = sub_426390(*(_DWORD**)(a1 + 124)) * v135;
                        v136 = sub_4260B0(*(_DWORD**)(a1 + 124)) + v16;
                        v93 = (int)(v133 - v163) <= 0 ? v163 - v133 : v133 - v163;
                        if (v93 < 400)
                        {
                            v92 = v136 - v162 <= 0 ? v162 - v136 : v136 - v162;
                            if (v92 <= 500)
                            {
                                if (v165 <= 0)
                                    v91 = -v165;
                                else
                                    v91 = v165;
                                if (v91 < 400)
                                    *(_BYTE*)(a1 + 141) = 0;
                                if (v170 <= 0)
                                    v90 = -v170;
                                else
                                    v90 = v170;
                                if (v90 < 500)
                                    *(_BYTE*)(a1 + 142) = 0;
                                *(_BYTE*)(a1 + 147) = 2;
                                *(_BYTE*)(a1 + 144) = 1;
                                *(_BYTE*)(a1 + 143) = 1;
                                *(_BYTE*)(a1 + 148) = 0;
                            }
                        }
                    }
                }
                else
                {
                    if (*(_DWORD*)(a1 + 4))
                    {
                        v132 = sub_426090(*(_DWORD**)(a1 + 124)) / 800;
                        if (v132 - *(_DWORD*)(a1 + 36) <= 0)
                            v89 = *(_DWORD*)(a1 + 36) - v132;
                        else
                            v89 = v132 - *(_DWORD*)(a1 + 36);
                        if (v89 >= 2
                            && *(unsigned __int16*)(*(_DWORD*)(a1 + 52)
                                + 2 * (*(_DWORD*)(a1 + 64) * *(_DWORD*)(a1 + 40) + *(_DWORD*)(a1 + 36)))
                            - *(unsigned __int16*)(*(_DWORD*)(a1 + 52)
                                + 2 * (*(_DWORD*)(a1 + 64) * (sub_4260B0(*(_DWORD**)(a1 + 124)) / 800) + v132)) == 1)
                        {
                            *(_BYTE*)(a1 + 147) = 2;
                            *(_BYTE*)(a1 + 144) = 1;
                            *(_BYTE*)(a1 + 143) = 1;
                            *(_BYTE*)(a1 + 148) = 0;
                        }
                    }
                    else if (*(_DWORD*)a1 == 3
                        && (v165 <= 0 ? (v88 = -v165) : (v88 = v165),
                            v88 <= 700
                            && (v170 <= 0 ? (v87 = -v170) : (v87 = v170),
                                v87 <= 500 && (v164 <= 0 ? (v86 = -v164) : (v86 = v164), v86 <= 300))))
                    {
                        if (sub_4263B0(*(_DWORD**)(a1 + 124)))
                            *(_BYTE*)(a1 + 143) = 1;
                    }
                    else if (*(_DWORD*)a1 == 3
                        || (v170 <= 0 ? (v85 = -v170) : (v85 = v170),
                            v85 >= 500 || (v165 <= 0 ? (v84 = -v165) : (v84 = v165), v84 >= 400)))
                    {
                        if (*(_DWORD*)a1 == 3
                            || !sub_4263B0(*(_DWORD**)(a1 + 124))
                            || rand() % 99 >= 50
                            || (v170 <= 0 ? (v82 = -v170) : (v82 = v170),
                                v82 >= 500 || (v165 <= 0 ? (v81 = -v165) : (v81 = v165), v81 >= 1600 || v164)))
                        {
                            if (*(_DWORD*)a1 != 3)
                            {
                                v79 = v170 <= 0 ? -v170 : v170;
                                if (v79 < 500)
                                {
                                    v78 = v165 <= 0 ? -v165 : v165;
                                    if (v78 < 2400)
                                    {
                                        v77 = v164 <= 0 ? -v164 : v164;
                                        if (v77 < 1600)
                                        {
                                            if (v165 <= 0)
                                                v76 = (v165 >= 0) - 1;
                                            else
                                                v76 = 1;
                                            *(_BYTE*)(a1 + 141) = v76;
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            if (v165 <= 0)
                                v80 = (v165 >= 0) - 1;
                            else
                                v80 = 1;
                            *(_BYTE*)(a1 + 141) = v80;
                            *(_BYTE*)(a1 + 143) = 1;
                            *(_BYTE*)(a1 + 145) = 1;
                        }
                    }
                    else if (v165)
                    {
                        if (v165 <= 0)
                            v83 = (v165 >= 0) - 1;
                        else
                            v83 = 1;
                        *(_BYTE*)(a1 + 141) = -v83;
                    }
                    else
                    {
                        *(_BYTE*)(a1 + 141) = 2 * (rand() % 2) - 1;
                    }
                    if (!*(_BYTE*)(a1 + 141) && !*(_BYTE*)(a1 + 142))
                    {
                        v17 = 18 * (3 * sub_41CA5F(*(_DWORD*)(a1 + 124), 0) + 20);
                        v129 = v17 * (unsigned __int8)sub_47421B((char*)unk_4B9B10) / 50;
                        if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 124)) == (struct Concurrency::ISchedulerProxy*)10
                            || (*(_DWORD*)a1 == 3
                                || *(_DWORD*)a1 == 4
                                || *(_DWORD*)(a1 + 4)
                                || rand() % 100 >= 10
                                || (v170 <= 0 ? (v75 = -v170) : (v75 = v170), v75 >= 500))
                            && (v165 <= 0 ? (v74 = -v165) : (v74 = v165), v74 <= 8000))
                        {
                            if ((*(_DWORD*)a1 == 3 || *(_DWORD*)(a1 + 4))
                                && Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 124)) == (struct Concurrency::ISchedulerProxy*)10
                                && (v165 <= 0 ? (v73 = -v165) : (v73 = v165), v73 < v129))
                            {
                                if (v165 <= 0)
                                    v72 = (v165 >= 0) - 1;
                                else
                                    v72 = 1;
                                *(_BYTE*)(a1 + 141) = -v72;
                            }
                            else if (*(_DWORD*)a1 == 3
                                && (v165 <= 0 ? (v71 = -v165) : (v71 = v165),
                                    v71 > 800 || (v164 <= 0 ? (v70 = -v164) : (v70 = v164), v70 > 400)))
                            {
                                if (v165 <= 0)
                                    v69 = (v165 >= 0) - 1;
                                else
                                    v69 = 1;
                                *(_BYTE*)(a1 + 141) = v69;
                            }
                            else if (*(_DWORD*)(a1 + 4) || (v165 <= 0 ? (v68 = -v165) : (v68 = v165), v68 > 2400 || v164 < -800))
                            {
                                if (v165 <= 0)
                                    v67 = (v165 >= 0) - 1;
                                else
                                    v67 = 1;
                                *(_BYTE*)(a1 + 141) = v67;
                            }
                        }
                        else
                        {
                            *(_BYTE*)(a1 + 84) = 1;
                        }
                        if (*(_DWORD*)a1 == 3
                            && (v170 <= 0 ? (v66 = -v170) : (v66 = v170),
                                v66 > 400 || (v164 <= 0 ? (v65 = -v164) : (v65 = v164), v65 > 400)))
                        {
                            if (v170 <= 0)
                                v64 = (v170 >= 0) - 1;
                            else
                                v64 = 1;
                            *(_BYTE*)(a1 + 142) = v64;
                        }
                        else if (*(_DWORD*)(a1 + 4) || (v170 <= 0 ? (v63 = -v170) : (v63 = v170), v63 > 500))
                        {
                            if (v170 <= 0)
                                v62 = (v170 >= 0) - 1;
                            else
                                v62 = 1;
                            *(_BYTE*)(a1 + 142) = v62;
                        }
                        v18 = sub_41D067(*(_DWORD*)(a1 + 124), 0);
                        v131 = (int)(12 * v168 * ((3 * v18 / 2 + 405) / 15)) / 10;
                        v19 = sub_41D067(*(_DWORD*)(a1 + 124), 0);
                        v130 = 12 * v166 * ((3 * v19 / 2 + 405) / 15) / 10;
                        if (!*(_DWORD*)(a1 + 4)
                            && !(_BYTE)v161
                            && Concurrency::details::SchedulerBase::GetNumberOfBoundContexts(*(Concurrency::details::SchedulerBase**)(a1 + 124)))
                        {
                            v61 = v130 <= 0 ? (v130 >= 0) - 1 : 1;
                            v60 = v131 <= 0 ? (v131 >= 0) - 1 : 1;
                            if (sub_423F94((_DWORD*)a1, 800 * v60 + v131, 800 * v61 + v130) && !*(_DWORD*)a1)
                            {
                                v59 = v170 <= 0 ? -v170 : v170;
                                if (v59 < 3200)
                                {
                                    v58 = v165 <= 0 ? -v165 : v165;
                                    if (v58 < 8000 && (rand() % 100 < 3 || v164 >= 3200 || sub_425D50(*(_DWORD**)(a1 + 124))))
                                    {
                                        if (v164 < 3200 && rand() % 2)
                                            *(_BYTE*)(a1 + 147) = 1;
                                        else
                                            *(_BYTE*)(a1 + 147) = 2;
                                        *(_BYTE*)(a1 + 144) = 1;
                                        *(_BYTE*)(a1 + 143) = 1;
                                        *(_BYTE*)(a1 + 148) = 0;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (Concurrency::details::SchedulerBase::GetNumberOfBoundContexts(*(Concurrency::details::SchedulerBase**)(a1 + 124)))
            {
                v20 = sub_426090(*(_DWORD**)(a1 + 124));
                v127 = 400 * *(char*)(a1 + 141)
                    + Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 124))
                    + v20;
                v21 = sub_4260B0(*(_DWORD**)(a1 + 124));
                v126 = 400 * *(char*)(a1 + 142) + sub_426390(*(_DWORD**)(a1 + 124)) + v21;
                v128 = -100 * sub_446497((_DWORD*)unk_4B9B10, v127 / 100, v126 / 100);
                if (v128 != -102000)
                {
                    if ((v125 = sub_4464F6((_DWORD*)unk_4B9B10, v127 / 800, v126 / 800),
                        v124 = sub_4260D0(*(_DWORD**)(a1 + 124)) - v128,
                        *(_DWORD*)(a1 + 4))
                        && v124 > 800
                        || v124 >= 800 && v124 <= 3200
                        || v125 == 9
                        || v125 == 14
                        || v125 == 15)
                    {
                        *(_BYTE*)(a1 + 147) = 2;
                        *(_BYTE*)(a1 + 144) = 1;
                        *(_BYTE*)(a1 + 143) = 1;
                        *(_BYTE*)(a1 + 148) = 0;
                    }
                }
            }
            if (Concurrency::details::SchedulerBase::GetNumberOfBoundContexts(*(Concurrency::details::SchedulerBase**)(a1 + 124)))
            {
                if (*(_BYTE*)(a1 + 143) == 1 && *(_BYTE*)(a1 + 144) == 1)
                {
                    v22 = sub_41D067(*(_DWORD*)(a1 + 124), 0);
                    v123 = (int)(12 * v168 * ((3 * v22 / 2 + 405) / 15)) / 10;
                    v23 = sub_41D067(*(_DWORD*)(a1 + 124), 0);
                    if (!sub_4244B5((_DWORD*)a1,(_DWORD)v123, 12 * v166 * ((3 * v23 / 2 + 405) / 15) / 10))
                    {
                        *(_BYTE*)(a1 + 144) = 0;
                        *(_BYTE*)(a1 + 143) = 0;
                    }
                }
            }
            if (*(_DWORD*)(a1 + 128))
            {
                if (!sub_425E70(*(_BYTE**)(a1 + 124))
                    && !*(_BYTE*)(a1 + 85)
                    && Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 128)) == (struct Concurrency::ISchedulerProxy*)91)
                {
                    v24 = (unsigned __int8)sub_426070(*(_BYTE**)(a1 + 124));
                    if (v24 != (unsigned __int8)sub_426070(*(_BYTE**)(a1 + 128)))
                    {
                        if (*(_BYTE*)(a1 + 84))
                        {
                            if (v165 <= 0)
                                v54 = (v165 >= 0) - 1;
                            else
                                v54 = 1;
                            *(_BYTE*)(a1 + 141) = v54;
                            *(_BYTE*)(a1 + 84) = 0;
                        }
                        if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 124)) == (struct Concurrency::ISchedulerProxy*)10)
                        {
                            if ((int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 124)) <= 0)
                                v53 = ((Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 124)) & 0x80000000) == 0)
                                - 1;
                            else
                                v53 = 1;
                            *(_BYTE*)(a1 + 141) = -v53;
                        }
                        if (v165 <= 0)
                            v52 = -v165;
                        else
                            v52 = v165;
                        if (v52 > 3200)
                            *(_BYTE*)(a1 + 142) = 0;
                    }
                }
            }
            if (*(_BYTE*)(a1 + 84))
            {
                if (v165 <= 0)
                    v51 = (v165 >= 0) - 1;
                else
                    v51 = 1;
                v122 = 0;
                if (!*(_DWORD*)a1)
                {
                    if (v170 <= 0)
                        v50 = (v170 >= 0) - 1;
                    else
                        v50 = 1;
                    v122 = v50;
                }
                v25 = 6 * (3 * sub_41CA5F(*(_DWORD*)(a1 + 124), 0) + 20);
                v34 = 800 * v122 + v122 * (v25 * (unsigned __int8)sub_47421B((char*)unk_4B9B10) / 50);
                v26 = 18 * (3 * sub_41CA5F(*(_DWORD*)(a1 + 124), 0) + 20);
                v27 = sub_47421B((char*)unk_4B9B10);
                if (!sub_423F94((_DWORD*)a1, 800 * v51 + v51 * (v26 * v27 / 50), v34))
                    *(_BYTE*)(a1 + 84) = 0;
            }
            if (*(_BYTE*)(a1 + 84))
            {
                if (v165 <= 0)
                    v49 = (v165 >= 0) - 1;
                else
                    v49 = 1;
                v121 = sub_426090(*(_DWORD**)(a1 + 124)) / 100 + 4 * (v49 / 100);
                v28 = sub_4260B0(*(_DWORD**)(a1 + 124));
                if (sub_446497((int*)unk_4B9B10, v121, v28 / 100) >= 1020)
                {
                    *(_BYTE*)(a1 + 84) = 0;
                }
                else
                {
                    if (!v165)
                        *(_BYTE*)(a1 + 84) = 0;
                    if (v165 <= 0)
                        v48 = (v165 >= 0) - 1;
                    else
                        v48 = 1;
                    *(_BYTE*)(a1 + 141) = dword_4B93AC % 2u * v48;
                    if ((unsigned __int8)sub_4263F0(*(char**)(a1 + 124)) == 2)
                        *(_BYTE*)(a1 + 84) = 0;
                }
            }
            if (*(_BYTE*)(a1 + 85) == 1)
            {
                *(_BYTE*)(a1 + 142) = -(dword_4B93AC % 2u);
                if ((unsigned __int8)sub_426310(*(char**)(a1 + 124)) == 2)
                    *(_BYTE*)(a1 + 85) = 0;
            }
            else if (*(_BYTE*)(a1 + 85) == 2)
            {
                *(_BYTE*)(a1 + 142) = dword_4B93AC % 2u;
                if ((unsigned __int8)sub_4262F0(*(char**)(a1 + 124)) == 2)
                    *(_BYTE*)(a1 + 85) = 0;
            }
            if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 124)) == (struct Concurrency::ISchedulerProxy*)10)
            {
                v117 = 0;
                v29 = sub_426090(*(_DWORD**)(a1 + 124)) / 100;
                v120 = (int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 124)) / 100
                    + v29;
                v119 = sub_4260B0(*(_DWORD**)(a1 + 124)) / 100;
                if (sub_446497((int*)unk_4B9B10, v120, v119) == 1020)
                    v117 = 1;
                v118 = sub_41CA5F(*(_DWORD*)(a1 + 124), 0);
                if ((int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 124)) <= 0)
                    v47 = ((Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 124)) & 0x80000000) == 0)
                    - 1;
                else
                    v47 = 1;
                if (sub_426390(*(int**)(a1 + 124)) <= 0)
                    v46 = (sub_426390(*(int**)(a1 + 124)) >= 0) - 1;
                else
                    v46 = 1;
                if (v47 < 0 && *(char*)(a1 + 141) > 0 || v47 > 0 && *(char*)(a1 + 141) < 0)
                {
                    if (v46)
                    {
                        v30 = sub_47421B((char*)unk_4B9B10);
                        if (!sub_423F94((int*)a1, 0, v46 * (6 * (3 * v118 + 20) * v30 / 50)))
                            *(_BYTE*)(a1 + 141) = v47;
                    }
                }
                v31 = sub_47421B((char*)unk_4B9B10);
                if (!sub_423F94((int*)a1, 800 * v47 + v47 * (18 * (3 * v118 + 20) * v31 / 50), 0))
                {
                    v117 = 1;
                    *(_BYTE*)(a1 + 84) = 0;
                }
                if (v46 && !sub_423F94((int*)a1, 0, 800 * v46))
                    *(_BYTE*)(a1 + 142) = 0;
                if (v46)
                {
                    v32 = sub_47421B((char*)unk_4B9B10);
                    if (!sub_423F94((int*)a1, 0, v46 * (6 * (3 * v118 + 20) * v32 / 50)))
                    {
                        *(_BYTE*)(a1 + 143) = 0;
                        *(_BYTE*)(a1 + 144) = 0;
                    }
                }
                if (v117)
                {
                    if ((int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 124)) <= 0)
                        v45 = ((Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 124)) & 0x80000000) == 0)
                        - 1;
                    else
                        v45 = 1;
                    *(_BYTE*)(a1 + 141) = -v45;
                }
            }
            v174 = sub_426090(*(_DWORD**)(a1 + 124)) / 100;
            v173 = sub_4260B0(*(_DWORD**)(a1 + 124)) / 100;
            if (*(_DWORD*)a1 == 3 && v174 == *(_DWORD*)(a1 + 12) && v173 == *(_DWORD*)(a1 + 16))
            {
                v44 = *(__int16*)(a1 + 20) <= 0 ? -*(__int16*)(a1 + 20) : *(__int16*)(a1 + 20);
                if (v44 > 60
                    || (*(__int16*)(a1 + 22) <= 0 ? (v43 = -*(__int16*)(a1 + 22)) : (v43 = *(__int16*)(a1 + 22)), v43 > 60))
                {
                    *(_DWORD*)a1 = 0;
                }
            }
            *(_DWORD*)(a1 + 12) = v174;
            *(_DWORD*)(a1 + 16) = v173;
            if (*(_BYTE*)(a1 + 141) && *(_WORD*)(a1 + 20))
            {
                v42 = *(char*)(a1 + 141) <= 0 ? (*(char*)(a1 + 141) >= 0) - 1 : 1;
                v41 = *(__int16*)(a1 + 20) <= 0 ? (*(__int16*)(a1 + 20) >= 0) - 1 : 1;
                if (v42 != v41)
                {
                    v40 = *(__int16*)(a1 + 20) <= 0 ? -*(__int16*)(a1 + 20) : *(__int16*)(a1 + 20);
                    if (v40 <= 5)
                    {
                        if (*(__int16*)(a1 + 20) <= 0)
                            v39 = (*(__int16*)(a1 + 20) >= 0) - 1;
                        else
                            v39 = 1;
                        *(_BYTE*)(a1 + 141) = v39;
                    }
                }
            }
            if (*(_BYTE*)(a1 + 141)
                && (!*(_WORD*)(a1 + 20)
                    || (*(char*)(a1 + 141) <= 0 ? (v38 = (*(char*)(a1 + 141) >= 0) - 1) : (v38 = 1),
                        *(__int16*)(a1 + 20) <= 0 ? (v37 = (*(__int16*)(a1 + 20) >= 0) - 1) : (v37 = 1),
                        v38 == v37)))
            {
                *(_WORD*)(a1 + 20) += *(char*)(a1 + 141);
            }
            else
            {
                *(_WORD*)(a1 + 20) = *(char*)(a1 + 141);
            }
            if (*(_BYTE*)(a1 + 142)
                && (!*(_WORD*)(a1 + 22)
                    || (*(char*)(a1 + 142) <= 0 ? (v36 = (*(char*)(a1 + 142) >= 0) - 1) : (v36 = 1),
                        *(__int16*)(a1 + 22) <= 0 ? (v35 = (*(__int16*)(a1 + 22) >= 0) - 1) : (v35 = 1),
                        v36 == v35)))
            {
                LOWORD(v1) = *(char*)(a1 + 142) + *(_WORD*)(a1 + 22);
                *(_WORD*)(a1 + 22) = (_WORD)v1;
            }
            else
            {
                LOWORD(v1) = *(char*)(a1 + 142);
                *(_WORD*)(a1 + 22) = (_WORD)v1;
            }
            if (v172 == (struct Concurrency::ISchedulerProxy*)13)
            {
                LOWORD(v1) = *(unsigned __int8*)(a1 + 94);
                if (*(_BYTE*)(a1 + 94))
                {
                    *(_BYTE*)(a1 + 143) = 0;
                    *(_BYTE*)(a1 + 144) = 0;
                }
            }
        }
        else
        {
            if (v145 <= 0)
                v108 = (v145 >= 0) - 1;
            else
                v108 = 1;
            *(_BYTE*)(a1 + 141) = v108;
            if (v142 <= 0)
                v107 = (v142 >= 0) - 1;
            else
                v107 = 1;
            *(_BYTE*)(a1 + 142) = v107;
            *(_BYTE*)(a1 + 143) = 0;
            LOWORD(v1) = a1;
            *(_BYTE*)(a1 + 144) = 1;
            *(_BYTE*)(a1 + 145) = 0;
        }
    }
    return (__int16)v1;
}
 
unsigned __int8* sub_41B465(_DWORD* thisx)
{
    int v2; // esi
    int v4; // [esp+8h] [ebp-1Ch]
    int v5; // [esp+Ch] [ebp-18h]
    int v6; // [esp+Ch] [ebp-18h]
    int v7; // [esp+10h] [ebp-14h]
    unsigned __int8 v8; // [esp+1Ch] [ebp-8h]
    int v9; // [esp+20h] [ebp-4h]

    sub_425EF0((char*)thisx[31]);
    v8 = sub_426070((_BYTE*)thisx[31]);
    v9 = sub_4630A4((unsigned char*)unk_4B9B10) - 1;
    if (v9 <= 0)
        return 0;
    v5 = rand() % v9;
    v4 = -1;
    while (v5 >= 0)
    {
        ++v4;
        while (v4 == v8 || !sub_426490((unsigned __int8*)unk_4B9B10, v4))
            ++v4;
        --v5;
    }
    v2 = rand();
    v6 = v2 % sub_426490((unsigned __int8*)unk_4B9B10, v4);
    v7 = -1;
    while (v6 >= 0)
    {
        ++v7;
        do
        {
            if (sub_4630BF((unsigned __int8*)unk_4B9B10, v4, v7))
                break;
            ++v7;
        } while (v7 < 8);
        --v6;
    }
    if (v7 < 8)
        return sub_463101((unsigned __int8*)unk_4B9B10, v4, v7);
    else
        return 0;
} 
BOOL sub_41B65C(int thisx)
{
    if (!*(_WORD*)(thisx + 214))
        return 0;
    if (*(_DWORD*)(thisx + 296))
        return 0;
    if (*(_DWORD*)(thisx + 428) != 44 && *(_DWORD*)(thisx + 428) != 45)
        return 0;
    if (*(_DWORD*)(thisx + 292))
        return 0;
    return *(_BYTE*)(thisx + 177) == 0;
}

 
_DWORD* sub_41B6CF(_DWORD* thisx, int a2, int a3)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[70] = 0;
    thisx[71] = a3;
    return result;
}

 
int sub_41B6F5(int thisx)
{
    int result; // eax
    int v3; // [esp+4h] [ebp-4h]

    result = thisx;
    if (*(_DWORD*)(thisx + 304))
    {
        v3 = 207;
        if (*(_BYTE*)(thisx + 188) == 1)
        {
            if (rand() % 2)
                *(_DWORD*)(thisx + 432) = 86;
            else
                *(_DWORD*)(thisx + 432) = 57;
        }
        else if ((*(_BYTE*)(thisx + 188) == 2 || *(_BYTE*)(thisx + 188) == 3)
            && (*(_DWORD*)(thisx + 432) == 57 || *(_DWORD*)(thisx + 432) == 58))
        {
            *(_DWORD*)(thisx + 432) = 99;
        }
        if (*(_DWORD*)(thisx + 432) == 99)
        {
            return sub_41B990(*(_DWORD*)(thisx + 304), thisx, 113);
        }
        else if (*(_DWORD*)(thisx + 432) == 102)
        {
            return sub_41B990(*(_DWORD*)(thisx + 304), thisx, 116);
        }
        else if (sub_41BA53(thisx, 0x10u, 0))
        {
            *(_DWORD*)(thisx + 432) = 90;
            return sub_41B990(*(_DWORD*)(thisx + 304), thisx, 110);
        }
        else if (sub_41BA53(thisx, 0x1Bu, 0))
        {
            *(_DWORD*)(thisx + 432) = 93;
            return sub_41B990(*(_DWORD*)(thisx + 304), thisx, 111);
        }
        else if (sub_41BA53(thisx, 0x2Du, 0))
        {
            *(_DWORD*)(thisx + 432) = 101;
            return sub_41B990(*(_DWORD*)(thisx + 304), thisx, 115);
        }
        else if (sub_41BA53(thisx, 0x37u, 0))
        {
            *(_DWORD*)(thisx + 432) = 103;
            return sub_41B990(*(_DWORD*)(thisx + 304), thisx, 117);
        }
        else if (sub_41BA53(thisx, 0x38u, 0))
        {
            *(_DWORD*)(thisx + 432) = 104;
            return sub_41B990(*(_DWORD*)(thisx + 304), thisx, 118);
        }
        else if (sub_41BA53(thisx, 0x39u, 0))
        {
            *(_DWORD*)(thisx + 432) = 105;
            return sub_41B990(*(_DWORD*)(thisx + 304), thisx, 119);
        }
        else if (sub_41BA53(thisx, 0x3Au, 0))
        {
            *(_DWORD*)(thisx + 432) = 106;
            return sub_41B990(*(_DWORD*)(thisx + 304), thisx, 120);
        }
        else if (sub_41BA53(thisx, 0x3Bu, 0))
        {
            *(_DWORD*)(thisx + 432) = 107;
            return sub_41B990(*(_DWORD*)(thisx + 304), thisx, 121);
        }
        else if (sub_41BA53(thisx, 0x47u, 0))
        {
            *(_DWORD*)(thisx + 432) = 108;
            return sub_41B990(*(_DWORD*)(thisx + 304), thisx, 122);
        }
        else if (*(_DWORD*)(thisx + 432) == 86)
        {
            return sub_41B990(*(_DWORD*)(thisx + 304), thisx, 87);
        }
        else if (*(_DWORD*)(thisx + 432) == 57)
        {
            return sub_41B990(*(_DWORD*)(thisx + 304), thisx, 59);
        }
        else
        {
            if (*(_DWORD*)(thisx + 432) == 58)
                v3 = 60;
            return sub_41B990(*(_DWORD*)(thisx + 304), thisx, v3);
        }
    }
    return result;
}

 
int sub_41B990(int thisx, int a2, int a3)
{
    *(_DWORD*)(thisx + 432) = a3;
    *(_DWORD*)(thisx + 304) = a2;
    *(_DWORD*)(thisx + 284) = 0;
    *(_DWORD*)(thisx + 280) = 0;
    *(_DWORD*)(thisx + 444) = 0;
    *(_DWORD*)(thisx + 340) = 0;
    *(_DWORD*)(thisx + 344) = 0;
    *(_DWORD*)(thisx + 352) = 0;
    if (a3 != 113)
    {
        *(_BYTE*)(thisx + 474) = 0;
        *(_BYTE*)(thisx + 475) = 0;
    }
    if (a3 == 116)
        *(_DWORD*)(thisx + 436) = *(_DWORD*)(thisx + 428) != 44;
    return sub_41F6DE((_DWORD*)thisx);
}

 
int sub_41BA53(int thisx, unsigned __int8 a2, int a3)
{
    int i; // [esp+4h] [ebp-4h]

    if (!*(_DWORD*)(thisx + 524) || a3)
    {
        if (*(_BYTE*)(thisx + 195) == 4)
        {
            return a2 <= 0xAu || a2 == 16 || a2 == 23;
        }
        else
        {
            for (i = 0; i < 3; ++i)
            {
                if (a2 == *(unsigned __int8*)(i + thisx + 520))
                    return 1;
            }
            return 0;
        }
    }
    else if (a2 == 38)
    {
        return 0;
    }
    else
    {
        return sub_41BA53(*(_DWORD*)(thisx + 524), a2, 1);
    }
}

 
int sub_41BB24(_DWORD* thisx)
{
    int v2; // [esp+4h] [ebp-74h]
    int v3; // [esp+8h] [ebp-70h]
    int v4; // [esp+Ch] [ebp-6Ch]
    int v5; // [esp+10h] [ebp-68h]
    int v6; // [esp+14h] [ebp-64h]
    BOOL v7; // [esp+18h] [ebp-60h]
    Concurrency::details::UMSFreeVirtualProcessorRoot* v9; // [esp+20h] [ebp-58h]
    int v10; // [esp+24h] [ebp-54h]
    int v11; // [esp+28h] [ebp-50h]
    int v12; // [esp+2Ch] [ebp-4Ch]
    int v13; // [esp+30h] [ebp-48h]
    Concurrency::details::SchedulerBase* v14; // [esp+38h] [ebp-40h]
    int v15; // [esp+3Ch] [ebp-3Ch]
    int v16; // [esp+40h] [ebp-38h]
    int SchedulerProxy; // [esp+48h] [ebp-30h]
    int v18; // [esp+4Ch] [ebp-2Ch]
    int v19; // [esp+50h] [ebp-28h]
    int v20; // [esp+54h] [ebp-24h]
    char v21; // [esp+58h] [ebp-20h]
    int v22; // [esp+5Ch] [ebp-1Ch]
    int v23; // [esp+60h] [ebp-18h]
    int v24; // [esp+64h] [ebp-14h]
    int i; // [esp+68h] [ebp-10h]
    int j; // [esp+68h] [ebp-10h]
    unsigned __int8 v27; // [esp+6Ch] [ebp-Ch]
    char v28; // [esp+74h] [ebp-4h]

    if (!thisx[31])
        return 0;
    v23 = sub_426090((_DWORD*)thisx[31]);
    v22 = sub_4260B0((_DWORD*)thisx[31]);
    v24 = sub_4260D0((_DWORD*)thisx[31]);
    sub_425D70((_DWORD*)thisx[31]);
    v27 = sub_425EF0((_BYTE*)thisx[31]);
    v28 = sub_426070((_BYTE*)thisx[31]);
    for (i = 0; i < 8; ++i)
    {
        if (i == v27)
            continue;
        v14 = (Concurrency::details::SchedulerBase*)sub_446714(unk_4B9B10, i);
        if (!v14 || !unknown_libname_7((_DWORD*)v14) || v28 == sub_426070((char*)v14))
            continue;
        SchedulerProxy = (int)Concurrency::details::SchedulerBase::GetSchedulerProxy(v14);
        v21 = sub_4264D0((char*)v14);
        v16 = 3200;
        v7 = SchedulerProxy == 91 || SchedulerProxy == 162;
        if (v21 == 2 || SchedulerProxy < 123 && !v7)
            continue;
        if (v7)
        {
            if (SchedulerProxy == 91)
            {
                v13 = sub_425ED0((_DWORD*)v14);
                if (v13 > 100)
                    return 1;
                if (v13 < 37)
                    continue;
            }
            v16 = 320000;
        }
        v20 = sub_426090((_DWORD*)v14);
        v19 = sub_4260B0((_DWORD*)v14);
        v18 = sub_425D70((_DWORD*)v14);
        v15 = v23 - v20;
        if (v22 - v19 <= 0)
            v6 = v19 - v22;
        else
            v6 = v22 - v19;
        if (v6 < 100 * (unsigned __int8)sub_4264B0((char*)v14))
        {
            v5 = v15 <= 0 ? v20 - v23 : v23 - v20;
            if (v5 < v16)
            {
                if (v7)
                    return 1;
                if (v18 && v15 >= 0 || !v18 && v15 <= 0)
                    return 1;
            }
        }
    }
    for (j = 0; j < (unsigned __int8)byte_4B999A; ++j)
    {
        v9 = (Concurrency::details::UMSFreeVirtualProcessorRoot*)sub_4655B9(unk_4B9B10, j);
        if (v9 && sub_494209((_DWORD*)v9) && unknown_libname_8((_DWORD*)v9) != thisx[31])
        {
            v10 = v23 - sub_426470((_DWORD*)v9);
            v12 = v22 - sub_426530((_DWORD*)v9);
            v11 = v24 - (_DWORD)Concurrency::details::UMSFreeVirtualProcessorRoot::GetExecutingProxy(v9);
            v4 = v12 <= 0 ? -v12 : v12;
            if (v4 < 100 * (unsigned __int8)sub_4264F0((char*)v9))
            {
                v3 = v10 <= 0 ? -v10 : v10;
                if (v3 < 3200)
                {
                    v2 = v11 <= 0 ? -v11 : v11;
                    if (v2 < 3200)
                        return 1;
                }
            }
        }
    }
    return 0;
} 
BOOL sub_41BE56(_DWORD* thisx)
{
    return thisx[40] && (thisx[107] == 80 || thisx[107] == 78 || thisx[107] == 79);
}

 
int sub_41BEA6(_DWORD* thisx)
{
    return thisx[41];
}

 
int sub_41BEBA(int thisx)
{
    if (*(_DWORD*)(thisx + 428) == 81)
        return 1;
    *(_BYTE*)(thisx + 178) = 0;
    if (*(_DWORD*)(thisx + 392) || !*(_DWORD*)(thisx + 396))
        return 0;
    *(_DWORD*)(thisx + 432) = 81;
    *(_DWORD*)(thisx + 444) = 0;
    return 1;
}

 
_BYTE* sub_41BF1D(int thisx)
{
    *(_DWORD*)(thisx + 424) = 0;
    *(_DWORD*)(thisx + 392) = 0;
    *(_DWORD*)(thisx + 404) = 0;
    *(_DWORD*)(thisx + 396) = 0;
    *(_DWORD*)(thisx + 320) = 0;
    *(_DWORD*)(thisx + 268) = 0;
    *(_DWORD*)(thisx + 180) = 0;
    *(_DWORD*)(thisx + 400) = 0;
    *(_DWORD*)(thisx + 276) = 0;
    *(_DWORD*)(thisx + 288) = 0;
    *(_DWORD*)(thisx + 292) = 0;
    *(_DWORD*)(thisx + 284) = 0;
    *(_DWORD*)(thisx + 280) = 0;
    *(_DWORD*)(thisx + 296) = 0;
    *(_DWORD*)(thisx + 300) = 0;
    *(_BYTE*)(thisx + 592) = 0;
    *(_BYTE*)(thisx + 472) = 0;
    *(_BYTE*)(thisx + 558) = 0;
    *(_BYTE*)(thisx + 250) = 0;
    *(_BYTE*)(thisx + 257) = 0;
    *(_BYTE*)(thisx + 253) = 0;
    *(_BYTE*)(thisx + 248) = 0;
    *(_BYTE*)(thisx + 222) = 0;
    *(_BYTE*)(thisx + 212) = 0;
    *(_BYTE*)(thisx + 220) = 1;
    *(_BYTE*)(thisx + 416) = 0;
    *(_BYTE*)(thisx + 254) = 0;
    *(_BYTE*)(thisx + 223) = 0x80;
    *(_BYTE*)(thisx + 419) = 0;
    *(_BYTE*)(thisx + 260) = 0;
    *(_BYTE*)(thisx + 598) = 0;
    *(_BYTE*)(thisx + 259) = 0;
    *(_BYTE*)(thisx + 474) = 0;
    *(_BYTE*)(thisx + 256) = 0;
    memset((void*)(thisx + 453), 0, 8u);
    *(_BYTE*)(thisx + 249) = 0;
    *(_BYTE*)(thisx + 255) = 0;
    *(_BYTE*)(thisx + 178) = 0;
    *(_BYTE*)(thisx + 475) = 0;
    *(_BYTE*)(thisx + 237) = 0;
    *(_BYTE*)(thisx + 177) = 0;
    *(_BYTE*)(thisx + 471) = 1;
    *(_BYTE*)(thisx + 469) = 1;
    *(_BYTE*)(thisx + 176) = 0;
    *(_BYTE*)(thisx + 251) = 0;
    *(_BYTE*)(thisx + 252) = 0;
    *(_BYTE*)(thisx + 238) = 0;
    *(_BYTE*)(thisx + 236) = 0;
    *(_BYTE*)(thisx + 272) = 0;
    *(_BYTE*)(thisx + 324) = 0;
    *(_BYTE*)(thisx + 258) = 0;
    *(_BYTE*)(thisx + 221) = 0;
    *(_BYTE*)(thisx + 557) = 0;
    *(_BYTE*)(thisx + 556) = 0;
    *(_BYTE*)(thisx + 470) = 0;
    *(_BYTE*)(thisx + 452) = 0;
    *(_BYTE*)(thisx + 476) = 0;
    *(_BYTE*)(thisx + 325) = 0;
    *(_BYTE*)(thisx + 473) = 0;
    memset((void*)(thisx + 461), 0, 8u);
    *(_BYTE*)(thisx + 420) = 0;
    *(_BYTE*)(thisx + 608) = 0;
    *(_BYTE*)(thisx + 593) = 0;
    *(_DWORD*)(thisx + 588) = 0;
    *(_DWORD*)(thisx + 372) = 0;
    *(_DWORD*)(thisx + 376) = 0;
    *(_DWORD*)(thisx + 560) = 0;
    *(_DWORD*)(thisx + 444) = 0;
    *(_DWORD*)(thisx + 364) = 0;
    *(_DWORD*)(thisx + 368) = 0;
    *(_DWORD*)(thisx + 216) = 0;
    *(_DWORD*)(thisx + 448) = 0;
    *(_DWORD*)(thisx + 572) = 0;
    *(_DWORD*)(thisx + 208) = 0;
    *(_DWORD*)(thisx + 360) = 0;
    *(_DWORD*)(thisx + 352) = 0;
    *(_DWORD*)(thisx + 356) = 0;
    *(_DWORD*)(thisx + 568) = 0;
    *(_DWORD*)(thisx + 564) = 0;
    *(_DWORD*)(thisx + 576) = 0;
    *(_DWORD*)(thisx + 580) = 0;
    *(_DWORD*)(thisx + 584) = 0;
    *(_DWORD*)(thisx + 384) = 0;
    *(_DWORD*)(thisx + 380) = 0;
    *(_DWORD*)(thisx + 172) = 0;
    *(_DWORD*)(thisx + 436) = 0;
    *(_DWORD*)(thisx + 440) = 0;
    *(_DWORD*)(thisx + 348) = 0;
    *(_DWORD*)(thisx + 340) = 0;
    *(_DWORD*)(thisx + 344) = 0;
    *(_DWORD*)(thisx + 388) = 0;
    *(_DWORD*)(thisx + 316) = 0;
    *(_DWORD*)(thisx + 4) = 0;
    *(_DWORD*)(thisx + 312) = 0;
    *(_DWORD*)(thisx + 524) = 0;
    *(_DWORD*)(thisx + 304) = 0;
    *(_DWORD*)(thisx + 308) = 0;
    *(_DWORD*)(thisx + 480) = 0;
    memset((void*)(thisx + 244), 0, 4u);
    *(_WORD*)(thisx + 594) = 0;
    *(_WORD*)(thisx + 600) = 0;
    *(_DWORD*)(thisx + 264) = 83;
    *(_WORD*)(thisx + 204) = 0;
    *(_WORD*)(thisx + 596) = 0;
    sub_409273(thisx, 0);
    *(_DWORD*)(thisx + 432) = 0;
    *(_DWORD*)(thisx + 428) = 0;
    return sub_423CF2((_BYTE*)thisx, 0, 0, 0, 0, 0, 0);
}

 
_DWORD* sub_41C432(_DWORD* thisx, int a2, int a3)
{
	int v3; // edx
	_DWORD* result; // eax

	thisx[82] = a2;
	thisx[83] = a3;
	v3 = -100 * sub_446497((int*)unk_4B9B10, a2 / 100, a3 / 100);
	result = thisx;
	thisx[84] = v3;
	return result;
}

 
int sub_41C48F(int thisx, int a2)
{
    _BYTE* v4; // [esp+4h] [ebp-96Ch]
    int v5; // [esp+8h] [ebp-968h]
    unsigned __int8 v6; // [esp+Ch] [ebp-964h]
    unsigned __int16 v7; // [esp+10h] [ebp-960h]
    int i; // [esp+14h] [ebp-95Ch]
    DWORD NumberOfBytesRead; // [esp+18h] [ebp-958h] BYREF
    char v10[1024]; // [esp+1Ch] [ebp-954h] BYREF
    HANDLE hFile; // [esp+41Ch] [ebp-554h]
    int j; // [esp+420h] [ebp-550h]
    _DWORD Buffer[256]; // [esp+424h] [ebp-54Ch] BYREF
    int v14; // [esp+824h] [ebp-14Ch]
    int v15[15]; // [esp+828h] [ebp-148h] BYREF
    CHAR FileName[260]; // [esp+864h] [ebp-10Ch] BYREF
    int v17; // [esp+968h] [ebp-8h]
    int v18; // [esp+96Ch] [ebp-4h]

    if (*(_BYTE*)(thisx + 188))
        return sub_421238(thisx);
    memset(v10, 0, sizeof(v10));
    sub_49DB90(v15);
    if (*(_BYTE*)(thisx + 195) == 4)
    {
        *(_BYTE*)(thisx + 194) = 1;
    }
    else if (a2 < 0)
    {
        if (a2 == -1)
            *(_BYTE*)(thisx + 194) = *(_BYTE*)(thisx + 193) + 1;
    }
    else
    {
        *(_BYTE*)(thisx + 194) = a2;
    }
    wsprintfA(FileName, "Graphic\\%02dpPalette.bin", *(unsigned __int8*)(thisx + 194));
    hFile = CreateFileA(FileName, 0x80000000, 0, 0, 3u, 0x80u, 0);
    if (hFile != (HANDLE)-1)
    {
        for (i = 0; i < 256; ++i)
            ReadFile(hFile, &Buffer[i], 3u, (LPDWORD)&NumberOfBytesRead, 0);
        CloseHandle(hFile);
    }
    v15[11] = (int)v10;
    v17 = sub_41BA53(thisx, 0x26u, 0);
    v18 = 1;
    if (v17)
        v18 = dword_4B93A0;
    v14 = 1;
    for (j = 0; j < v18; ++j)
    {
        if (!v17 || *((__int16*)dword_4B9394 + j) != -1)
        {
            memcpy(v10, Buffer, sizeof(v10));
            if (v17)
                sub_485DFD((int)dword_4B93A4 + 24 * j, (int)v10);
            else
                sub_485DFD((int)dword_4B93A4 + 24 * *(unsigned __int16*)(thisx + 498), (int)v10);
            v15[1] = 0;
            v15[2] = 0;
            v15[3] = -1;
            v15[4] = -1;
            v15[5] = 1;
            v15[9] = 0;
            v15[0] = -1;
            wsprintfA(FileName, "Graphic\\Body%02d.bmp", *(unsigned __int8*)(thisx + 195) + 1);
            if (!sub_49DA45((_DWORD*)unk_4BDC60, FileName, (int)v15))
                return 0;
            if (v14)
            {
                *(_DWORD*)(thisx + 196) = v15[0];
                v14 = 0;
            }
        }
    }
    *(_DWORD*)(*((_DWORD*)dword_4B9360 + *(unsigned __int8*)(thisx + 192)) + 4 * *(unsigned __int16*)(thisx + 498)) = 1;
    if (*(_BYTE*)(thisx + 195) == 4)
    {
        if (*(_DWORD*)(thisx + 168))
        {
            v5 = sub_426590(unk_4B9B10, *(unsigned __int16*)(thisx + 186));
            v6 = sub_426570((char*)v5);
            v7 = (unsigned __int8)sub_426550((char*)v5);
        }
        else
        {
            v4 = (_BYTE*)(36 * *(unsigned __int16*)(thisx + 186) + dword_4B92E0);
            v6 = sub_4016F0(v4);
            v7 = (unsigned __int8)sub_401710(v4);
        }
        *(_DWORD*)(*((_DWORD*)dword_4B9360 + v6) + 4 * v7) = 1;
    }
    return 1;
} 
int sub_41C915(int thisx)
{
    int v2; // [esp+4h] [ebp-8h]
    int v3; // [esp+8h] [ebp-4h]

    if (*(_BYTE*)(thisx + 188))
    {
        if (*(_BYTE*)(thisx + 188) == 1)
        {
            v2 = 0;
        }
        else if (*(_BYTE*)(thisx + 188) == 2 || *(_BYTE*)(thisx + 188) == 3)
        {
            v2 = 1;
        }
        if (*(_BYTE*)(thisx + 212))
        {
            if (*(unsigned __int16*)(thisx + 204) >= (int)(unsigned __int16)word_4B92F8[v2])
                return 0;
            v3 = *(unsigned __int16*)(thisx + 204);
        }
        else
        {
            v3 = *((unsigned __int16*)*(dword_4B9310 + v2) + *(unsigned __int16*)(thisx + 204));
        }
        return 152 * v3 + dword_4B92FC[v2];
    }
    else if (*(_BYTE*)(thisx + 212))
    {
        return 152 * *(unsigned __int16*)(thisx + 204) + dword_4B9328[*(unsigned __int8*)(thisx + 195)];
    }
    else
    {
        return dword_4B9324[0] + 152 * *(unsigned __int16*)(thisx + 204);
    }
}

 
void sub_41CA3D(void* thisxx, _DWORD* a2)
{
    if (a2)
        *a2 = sub_41C915((_DWORD)thisxx);
}

 
unsigned __int16 sub_41CA5F(int thisx, int a2)
{
    unsigned __int16 v4; // [esp+Ch] [ebp-4h]

    if (!*(_WORD*)(thisx + 514))
        *(_WORD*)(thisx + 514) = 1;
    v4 = *(_WORD*)(thisx + 514);
    if (a2 && sub_41BA53(thisx, 0x84u, 0))
        v4 = *(_DWORD*)(thisx + 448) * (unsigned __int16)(__int64)((double)v4 * 1.25) / 180 + (__int64)((double)v4 * 1.25);
    if (sub_41BA53(thisx, 0x8Cu, 0) && *(_BYTE*)(thisx + 609) == 11)
        v4 += *(_WORD*)(thisx + 496) + 10;
    return v4;
}

 
__int16 sub_41CB3B(int thisx, int a2)
{
    int v4; // [esp+8h] [ebp-Ch]
    int v5; // [esp+Ch] [ebp-8h]
    unsigned __int16 v6; // [esp+10h] [ebp-4h]

    v6 = *(_WORD*)(thisx + 502);
    if (a2)
    {
        if (sub_41BA53(thisx, 0x82u, 0))
        {
            v5 = 100 * *(unsigned __int16*)(thisx + 214) / *(unsigned __int16*)(thisx + 500);
            if (v5 >= 10)
            {
                if (v5 >= 20)
                {
                    if (v5 >= 30)
                    {
                        if (v5 >= 40)
                        {
                            if (v5 < 50)
                                v6 = 110 * v6 / 100;
                        }
                        else
                        {
                            v6 = 120 * v6 / 100;
                        }
                    }
                    else
                    {
                        v6 = 130 * v6 / 100;
                    }
                }
                else
                {
                    v6 = 140 * v6 / 100;
                }
            }
            else
            {
                v6 = 150 * v6 / 100;
            }
        }
        if (sub_41BA53(thisx, 0x8Cu, 0) && *(_BYTE*)(thisx + 609) == 11)
            v6 += *(_WORD*)(thisx + 496) + 15;
    }
    if (sub_425CD0((int*)&unk_4B9B10) == 3 && *(_DWORD*)(thisx + 164))
    {
        v4 = v6 * sub_426250((int*)&unk_4B9B10) / 100;
        if (v4 > 255)
            LOWORD(v4) = 255;
        v6 = v4;
    }
    if (v6)
        return v6;
    else
        return 1;
}

 
__int16 sub_41CCEA(int thisx, int a2)
{
    int v4; // [esp+8h] [ebp-Ch]
    int v5; // [esp+Ch] [ebp-8h]
    unsigned __int16 v6; // [esp+10h] [ebp-4h]

    v6 = *(_WORD*)(thisx + 504);
    if (a2)
    {
        if (sub_41BA53(thisx, 0x82u, 0))
        {
            v5 = 100 * *(unsigned __int16*)(thisx + 214) / *(unsigned __int16*)(thisx + 500);
            if (v5 >= 10)
            {
                if (v5 >= 20)
                {
                    if (v5 >= 30)
                    {
                        if (v5 >= 40)
                        {
                            if (v5 < 50)
                                v6 = 110 * v6 / 100;
                        }
                        else
                        {
                            v6 = 120 * v6 / 100;
                        }
                    }
                    else
                    {
                        v6 = 130 * v6 / 100;
                    }
                }
                else
                {
                    v6 = 140 * v6 / 100;
                }
            }
            else
            {
                v6 = 150 * v6 / 100;
            }
        }
        if (sub_41BA53(thisx, 0x8Cu, 0) && *(_BYTE*)(thisx + 609) == 11)
            v6 += *(_WORD*)(thisx + 496) + 15;
    }
    if (sub_425CD0((_DWORD*)&unk_4B9B10) == 3 && *(_DWORD*)(thisx + 164))
    {
        v4 = v6 * sub_426250((_DWORD*)&unk_4B9B10) / 100;
        if (v4 > 255)
            LOWORD(v4) = 255;
        v6 = v4;
    }
    if (v6)
        return v6;
    else
        return 1;
}

 
int sub_41CE99(int thisx)
{
    int v1; // eax
    int v4; // [esp+4h] [ebp-8h] BYREF

    sub_41F6DE((_DWORD*)thisx);
    if (*(_DWORD*)(thisx + 304))
    {
        if (*(_DWORD*)(thisx + 288))
        {
            sub_417E42(*(_DWORD*)(thisx + 304));
            sub_41CE99(*(_DWORD*)(thisx + 304));
            sub_417E1D((_DWORD*)thisx);
        }
        else if (*(_DWORD*)(thisx + 428) == 52 || *(_DWORD*)(thisx + 428) == 53 || *(_DWORD*)(thisx + 428) == 56)
        {
            sub_417FC1((int)*(_DWORD*)(thisx + 304));
            sub_41CE99(*(_DWORD*)(thisx + 304));
            sub_417EE0((int)thisx);
        }
        else if (*(_DWORD*)(thisx + 428) == 54 || *(_DWORD*)(thisx + 428) == 55)
        {
            sub_417EE0((int)*(_DWORD*)(thisx + 304));
            sub_41CE99(*(_DWORD*)(thisx + 304));
            sub_417EE0((int)thisx);
        }
        else
        {
            sub_417DCC((int)*(_DWORD*)(thisx + 304));
            *(_DWORD*)(thisx + 304) = 0;
            sub_423CF2((_BYTE*)thisx, 0, 0, 0, 0, 0, 0);
        }
    }
    *(_DWORD*)(thisx + 432) = 17;
    sub_4097DF((void*)thisx, (int)&v4);
    *(_DWORD*)(thisx + 436) = v4 >= 160;
    v1 = rand() % 4;
    sub_41261C((_WORD*)thisx, v1 + 13, 0, 1);
    *(_DWORD*)(thisx + 444) = 0;
    *(_DWORD*)(thisx + 352) = 0;
    *(_DWORD*)(thisx + 364) = 0;
    *(_BYTE*)(thisx + 176) = 0;
    *(_BYTE*)(thisx + 177) = 0;
    *(_BYTE*)(thisx + 178) = 1;
    return sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A48, -1, 100, 100, 0);
}

 
_int16 sub_41D067(int thisx, int a2)
{
    unsigned __int16 v4; // [esp+8h] [ebp-4h]

    if (!*(_WORD*)(thisx + 516))
        return 1;
    v4 = *(_WORD*)(thisx + 516);
    if (a2)
    {
        if (sub_41BA53(thisx, 0x86u, 0))
            v4 = (__int64)((double)v4 * 1.5);
        if (*(unsigned __int8*)(thisx + 238) > 1u)
            v4 *= 2;
    }
    if (sub_41BA53(thisx, 0x8Cu, 0))
    {
        if (*(_BYTE*)(thisx + 609) == 11)
            v4 += *(_WORD*)(thisx + 496) + 10;
    }
    return v4;
}

 
unsigned __int8* sub_41D3D7(int thisx)
{
    unsigned __int8* result; // eax
    unsigned __int8* v3; // [esp+4h] [ebp-8h]
    unsigned __int8 v4; // [esp+8h] [ebp-4h]

    if (*(_DWORD*)(thisx + 304))
    {
        if (*(_DWORD*)(thisx + 288))
        {
            sub_417E42(*(_DWORD*)(thisx + 304));
            sub_417E1D((_DWORD*)thisx);
        }
        else if (*(_DWORD*)(thisx + 428) == 52 || *(_DWORD*)(thisx + 428) == 53 || *(_DWORD*)(thisx + 428) == 56)
        {
            sub_417FC1(*(_DWORD*)(thisx + 304));
            sub_417EE0(thisx);
        }
        else if (*(_DWORD*)(thisx + 428) == 54 || *(_DWORD*)(thisx + 428) == 55)
        {
            sub_417EE0(*(_DWORD*)(thisx + 304));
            sub_417EE0(thisx);
        }
        else
        {
            *(_DWORD*)(thisx + 304) = 0;
        }
    }
    result = sub_45575F((unsigned __int8*)unk_4B9B10, *(_DWORD*)(thisx + 328) / 800, *(_DWORD*)(thisx + 332) / 800);
    v3 = result;
    if (result)
    {
        v4 = result[13];
        if (!v4)
            v4 = rand() % 2 + 1;
        if (v4 == 1)
        {
            *(_DWORD*)(thisx + 432) = 140;
        }
        else if (v4 == 2)
        {
            *(_DWORD*)(thisx + 432) = 141;
        }
        *(_DWORD*)(thisx + 328) = 100 * *(_DWORD*)v3;
        *(_DWORD*)(thisx + 332) = 100 * *((_DWORD*)v3 + 1);
        *(_DWORD*)(thisx + 336) = 100 * *((_DWORD*)v3 + 2);
        *(_DWORD*)(thisx + 424) = v3[12] == 1;
        *(_BYTE*)(thisx + 176) = 0;
        *(_BYTE*)(thisx + 177) = 0;
        *(_BYTE*)(thisx + 178) = 1;
        *(_DWORD*)(thisx + 372) = 0;
        *(_DWORD*)(thisx + 376) = 0;
        *(_DWORD*)(thisx + 364) = 0;
        *(_DWORD*)(thisx + 368) = 0;
        *(_DWORD*)(thisx + 340) = 0;
        *(_DWORD*)(thisx + 344) = 0;
        *(_DWORD*)(thisx + 348) = 0;
        *(_DWORD*)(thisx + 352) = 0;
        *(_DWORD*)(thisx + 356) = 0;
        result = (unsigned __int8*)thisx;
        *(_DWORD*)(thisx + 360) = 0;
    }
    return result;
} 
int sub_41D61F(int thisx)
{
    int v3; // [esp+8h] [ebp-4h]

    v3 = *(unsigned __int16*)(thisx + 500);
    if (sub_425CD0((_DWORD*)&unk_4B9B10) == 3 && *(_DWORD*)(thisx + 164))
    {
        v3 = sub_426250((_DWORD*)&unk_4B9B10) * v3 / 200;
        if (v3)
        {
            if (v3 > 255)
                return 255;
        }
        else
        {
            return 1;
        }
    }
    return v3;
}

 
int  sub_41D697(int thisx)
{
    int v1; // esi
    int i; // eax
    int v3; // esi
    int v6; // [esp+8h] [ebp-18h]
    char* v7; // [esp+Ch] [ebp-14h]
    int v8; // [esp+10h] [ebp-10h]
    int v9; // [esp+14h] [ebp-Ch]
    int v10; // [esp+18h] [ebp-8h]

    sub_41BF1D(thisx);
    sub_409273(thisx, 1);
    *(_DWORD*)(thisx + 432) = 1;
    *(_DWORD*)(thisx + 428) = 1;
    *(_DWORD*)(thisx + 444) = 0;
    *(_BYTE*)(thisx + 177) = 1;
    *(_BYTE*)(thisx + 178) = 0;
    v7 = sub_426210((char*)unk_4B9B10);
    sub_4897D0(v7);
    v8 = 8 * sub_4261D0(v7);
    v1 = rand() % 303;
    v10 = v1 + sub_446465((char*)unk_4B9B10) + 8;
    v9 = rand() % v8;
    for (i = sub_486633((_DWORD*)v7, v10, v9); ; i = sub_486633((_DWORD*)v7, v10, v9))
    {
        v6 = i;
        if (sub_4773CC(v10 / 8, v9 / 8))
        {
            if (v6 < 1020)
                break;
        }
        v3 = rand() % 303;
        v10 = v3 + sub_446465((char*)unk_4B9B10) + 8;
        v9 = rand() % v8;
    }
    *(_DWORD*)(thisx + 336) = -100 * v6;
    *(_DWORD*)(thisx + 328) = 100 * v10;
    *(_DWORD*)(thisx + 332) = 100 * v9;
    return sub_417763((_WORD*)thisx);
}

 
__int16 sub_41D7FC(unsigned __int16* thisx, int a2)
{
    __int16 result; // ax
    int v3; // [esp+4h] [ebp-4h]

    v3 = a2 + thisx[107];
    if (v3 >= 0)
    {
        if (v3 > 255)
            LOWORD(v3) = 255;
    }
    else
    {
        LOWORD(v3) = 0;
    }
    result = v3;
    thisx[107] = v3;
    return result;
}

 
__int16 sub_41D84A(int thisx)
{
    char* v1; // eax
    int v2; // eax
    char* v3; // eax
    int v6; // [esp+48h] [ebp-10h]
    int j; // [esp+4Ch] [ebp-Ch]
    int i; // [esp+50h] [ebp-8h]
    char* v9; // [esp+54h] [ebp-4h]

    if (*(_DWORD*)(thisx + 168))
    {
        v9 = (char*)sub_426590(unk_4B9B10, *(unsigned __int16*)(thisx + 186));
        v1 = sub_4266D0(v9);
        memcpy((void*)(thisx + 484), v1, 0xBu);
        *(_WORD*)(thisx + 190) = sub_4266F0((short*)v9);
        *(_WORD*)(thisx + 498) = (unsigned __int8)sub_426550(v9);
        *(_BYTE*)(thisx + 192) = sub_426570(v9);
        *(_WORD*)(thisx + 500) = sub_426710((short*)v9);
        *(_WORD*)(thisx + 502) = sub_426730((short*)v9);
        *(_WORD*)(thisx + 504) = sub_426750((short*)v9);
        *(_WORD*)(thisx + 506) = sub_426770((short*)v9);
        *(_WORD*)(thisx + 508) = sub_426790((short*)v9);
        *(_WORD*)(thisx + 510) = sub_4267B0((short*)v9);
        *(_WORD*)(thisx + 512) = sub_4267D0((short*)v9);
        *(_WORD*)(thisx + 514) = sub_4267F0((short*)v9);
        *(_WORD*)(thisx + 516) = sub_426810((short*)v9);
        *(_WORD*)(thisx + 518) = sub_426830((short*)v9);
        for (i = 0; i < 3; ++i)
            *(_BYTE*)(i + thisx + 520) = sub_426850(v9, i);
    }
    else
    {
        LOWORD(v2) = *(_WORD*)(thisx + 186);
        if ((unsigned __int16)v2 >= (int)Size)
            return v2;
        if (*(_BYTE*)(thisx + 188) == 3 || *(_BYTE*)(thisx + 188) == 4)
        {
            *(_WORD*)(thisx + 186) = *(unsigned __int8*)(thisx + 188) + 15;
            if (*(_BYTE*)(thisx + 188) == 3)
                *(_BYTE*)(thisx + 195) = 2;
            else
                *(_BYTE*)(thisx + 195) = 1;
        }
        if (*(_BYTE*)(thisx + 188) == 1 || *(_BYTE*)(thisx + 188) == 2)
        {
            wsprintfA((LPSTR)(thisx + 484), byte_4B01A4);
            *(_WORD*)(thisx + 498) = 0;
            *(_WORD*)(thisx + 500) = 100 * *(unsigned __int8*)(thisx + 188) + 200;
            *(_WORD*)(thisx + 502) = 20 * *(unsigned __int8*)(thisx + 188) + 80;
            *(_WORD*)(thisx + 504) = 20 * *(unsigned __int8*)(thisx + 188) + 80;
            *(_WORD*)(thisx + 506) = 10 * *(unsigned __int8*)(thisx + 188) + 10;
            *(_WORD*)(thisx + 508) = 100;
            *(_WORD*)(thisx + 510) = 100;
            *(_WORD*)(thisx + 512) = 10 * *(unsigned __int8*)(thisx + 188) + 90;
            *(_WORD*)(thisx + 514) = 10 * *(unsigned __int8*)(thisx + 188) + 40;
            *(_WORD*)(thisx + 516) = 50;
            *(_WORD*)(thisx + 518) = 10 * *(unsigned __int8*)(thisx + 188) + 40;
        }
        else
        {
            v3 = unknown_libname_18((char*)(dword_4B92E0 + 36 * *(unsigned __int16*)(thisx + 186)));
            memcpy((void*)(thisx + 484), v3, 0xBu);
            *(_WORD*)(thisx + 498) = (unsigned __int8)sub_401710((_BYTE*)(36 * *(unsigned __int16*)(thisx + 186)
                + dword_4B92E0));
            *(_BYTE*)(thisx + 192) = sub_4016F0((_BYTE*)(36 * *(unsigned __int16*)(thisx + 186) + dword_4B92E0));
            *(_WORD*)(thisx + 500) = (unsigned __int8)sub_4265B0((char*)(36 * *(unsigned __int16*)(thisx + 186) + dword_4B92E0));
            *(_WORD*)(thisx + 502) = (unsigned __int8)sub_426570((char*)dword_4B92E0 + 36 * *(unsigned __int16*)(thisx + 186));
            *(_WORD*)(thisx + 504) = (unsigned __int8)sub_4265D0((char*)(36 * *(unsigned __int16*)(thisx + 186) + dword_4B92E0));
            *(_WORD*)(thisx + 506) = (unsigned __int8)sub_4265F0((char*)dword_4B92E0 + 36 * *(unsigned __int16*)(thisx + 186));
            *(_WORD*)(thisx + 508) = (unsigned __int8)sub_426610((char*)(36 * *(unsigned __int16*)(thisx + 186) + dword_4B92E0));
            *(_WORD*)(thisx + 510) = (unsigned __int8)sub_426550((char*)dword_4B92E0 + 36 * *(unsigned __int16*)(thisx + 186));
            *(_WORD*)(thisx + 512) = (unsigned __int8)sub_426670((char*)(36 * *(unsigned __int16*)(thisx + 186) + dword_4B92E0));
            *(_WORD*)(thisx + 514) = (unsigned __int8)sub_426630((char*)dword_4B92E0 + 36 * *(unsigned __int16*)(thisx + 186));
            *(_WORD*)(thisx + 516) = (unsigned __int8)sub_426650((char*)(36 * *(unsigned __int16*)(thisx + 186) + dword_4B92E0));
            *(_WORD*)(thisx + 518) = (unsigned __int8)sub_426690((char*)dword_4B92E0 + 36 * *(unsigned __int16*)(thisx + 186));
            if (*(_BYTE*)(thisx + 195))
            {
                switch (*(_BYTE*)(thisx + 195))
                {
                case 1:
                    *(_WORD*)(thisx + 502) += 15;
                    break;
                case 2:
                    *(_WORD*)(thisx + 504) += 15;
                    break;
                case 3:
                    *(_WORD*)(thisx + 506) += 15;
                    break;
                }
            }
            else
            {
                *(_WORD*)(thisx + 502) += 5;
                *(_WORD*)(thisx + 504) += 5;
                *(_WORD*)(thisx + 506) += 5;
            }
            if (*(_BYTE*)(thisx + 195) == 4 || *(_BYTE*)(thisx + 188) == 3 || *(_BYTE*)(thisx + 188) == 4)
            {
                *(_WORD*)(thisx + 502) += 20;
                *(_WORD*)(thisx + 504) += 20;
                *(_WORD*)(thisx + 506) += 20;
                *(_WORD*)(thisx + 512) += 10;
            }
        }
        if (!sub_425CD0((_DWORD*)unk_4B9B10))
        {
            *(_WORD*)(thisx + 500) = 8 * *(unsigned __int16*)(thisx + 500) / 10;
            *(_WORD*)(thisx + 518) = 8 * *(unsigned __int16*)(thisx + 518) / 10;
            *(_WORD*)(thisx + 500) = (__int64)((double)*(unsigned __int16*)(thisx + 500)
                + (double)*(unsigned __int16*)(thisx + 496) * 1.2 * 3.0);
            *(_WORD*)(thisx + 502) = (__int64)((double)*(unsigned __int16*)(thisx + 502)
                + (double)*(unsigned __int16*)(thisx + 496) * 1.2);
            *(_WORD*)(thisx + 504) = (__int64)((double)*(unsigned __int16*)(thisx + 504)
                + (double)*(unsigned __int16*)(thisx + 496) * 1.2);
            *(_WORD*)(thisx + 506) = (__int64)((double)*(unsigned __int16*)(thisx + 506)
                + (double)*(unsigned __int16*)(thisx + 496) * 1.2);
            *(_WORD*)(thisx + 508) = (__int64)((double)*(unsigned __int16*)(thisx + 508)
                + (double)*(unsigned __int16*)(thisx + 496) * 1.2);
            *(_WORD*)(thisx + 510) = (__int64)((double)*(unsigned __int16*)(thisx + 510)
                + (double)*(unsigned __int16*)(thisx + 496) * 1.2);
            *(_WORD*)(thisx + 512) = (__int64)((double)*(unsigned __int16*)(thisx + 512)
                + (double)*(unsigned __int16*)(thisx + 496) * 0.9);
            *(_WORD*)(thisx + 514) += *(unsigned __int16*)(thisx + 496) / 10;
            *(_WORD*)(thisx + 516) += *(unsigned __int16*)(thisx + 496) / 10;
            *(_WORD*)(thisx + 518) += *(unsigned __int16*)(thisx + 496) / 10;
            if (*(_BYTE*)(thisx + 188) != 1)
            {
                if (*(_BYTE*)(thisx + 195))
                {
                    switch (*(_BYTE*)(thisx + 195))
                    {
                    case 1:
                        *(_WORD*)(thisx + 502) += *(_WORD*)(thisx + 496);
                        *(_WORD*)(thisx + 518) += *(unsigned __int16*)(thisx + 496) / 20;
                        break;
                    case 2:
                        *(_WORD*)(thisx + 504) += *(_WORD*)(thisx + 496);
                        *(_WORD*)(thisx + 514) += *(unsigned __int16*)(thisx + 496) / 20;
                        break;
                    case 3:
                        *(_WORD*)(thisx + 506) += *(_WORD*)(thisx + 496);
                        *(_WORD*)(thisx + 512) = (__int64)((double)*(unsigned __int16*)(thisx + 512)
                            + (double)*(unsigned __int16*)(thisx + 496) * 0.2);
                        break;
                    case 4:
                        *(_WORD*)(thisx + 502) += *(_WORD*)(thisx + 496);
                        *(_WORD*)(thisx + 504) += *(_WORD*)(thisx + 496);
                        *(_WORD*)(thisx + 506) += *(_WORD*)(thisx + 496);
                        *(_WORD*)(thisx + 508) += *(_WORD*)(thisx + 496);
                        *(_WORD*)(thisx + 510) += *(_WORD*)(thisx + 496);
                        *(_WORD*)(thisx + 512) += *(unsigned __int16*)(thisx + 496) / 2;
                        break;
                    }
                }
                else
                {
                    *(_WORD*)(thisx + 502) += *(unsigned __int16*)(thisx + 496) / 2;
                    *(_WORD*)(thisx + 504) += *(unsigned __int16*)(thisx + 496) / 2;
                    *(_WORD*)(thisx + 506) += *(unsigned __int16*)(thisx + 496) / 2;
                }
            }
        }
        if (*(_BYTE*)(thisx + 188) == 1)
        {
            *(_BYTE*)(thisx + 520) = 0x80;
            *(_BYTE*)(thisx + 521) = 0;
            *(_BYTE*)(thisx + 522) = 0;
        }
        else if (*(_BYTE*)(thisx + 188) == 2)
        {
            *(_BYTE*)(thisx + 520) = -127;
            *(_BYTE*)(thisx + 521) = 0;
            *(_BYTE*)(thisx + 522) = 0;
        }
        else
        {
            for (j = 0; j < 3; ++j)
                *(_BYTE*)(j + thisx + 520) = sub_4266B0((_BYTE*)(dword_4B92E0 + 36 * *(unsigned __int16*)(thisx + 186)), j);
        }
        if (*(unsigned __int8*)(thisx + 188) >= 2u)
            --* (_BYTE*)(thisx + 188);
    }
    if (*(_DWORD*)(thisx + 168))
    {
        v6 = sub_426590(unk_4B9B10, *(unsigned __int16*)(thisx + 186));
        if (v6)
        {
            *(_WORD*)(thisx + 190) = sub_4266F0((short*)v6);
            *(_BYTE*)(thisx + 192) = sub_426570((char*)v6);
        }
    }
    else
    {
        *(_WORD*)(thisx + 190) = sub_475CB0((_WORD*)(dword_4B92E0 + 36 * *(unsigned __int16*)(thisx + 186)));
        *(_BYTE*)(thisx + 192) = sub_4016F0((_BYTE*)(36 * *(unsigned __int16*)(thisx + 186) + dword_4B92E0));
    }
    v2 = *(unsigned __int8*)(thisx + 195);
    if (v2 == 4)
    {
        LOWORD(v2) = thisx;
        *(_WORD*)(thisx + 190) = (*(_BYTE*)(thisx + 184) & 1) + 23;
        *(_BYTE*)(thisx + 192) = 3;
    }
    return v2;
} 
void sub_41E5C9(int thisx, _DWORD* a2)
{
    int v2; // edx
    int v4; // [esp+Ch] [ebp-2Ch]
    int v5; // [esp+18h] [ebp-20h]
    int v6[2]; // [esp+1Ch] [ebp-1Ch] BYREF
    char v7; // [esp+24h] [ebp-14h]
    int v8; // [esp+28h] [ebp-10h]
    int v9; // [esp+2Ch] [ebp-Ch]
    int v10; // [esp+30h] [ebp-8h]
    char v11; // [esp+34h] [ebp-4h]

    if (a2)
    {
        LOBYTE(v10) = sub_426650((char*)a2);
        v11 = 0;
        v5 = 1;
        if (sub_41BA53(thisx, 0x88u, 0))
            v5 = 2;
        ++* (_BYTE*)(thisx + 598);
        switch ((unsigned __int8)v10)
        {
        case 1u:
            sub_41ED81((_WORD*)thisx, 15 * v5);
            v11 = 2;
            break;
        case 2u:
            sub_41EDEC((_WORD*)thisx, 5 * v5);
            v11 = 3;
            break;
        case 3u:
            sub_41ECAB((_WORD*)thisx, 20 * v5);
            sub_41EDEC((_WORD*)thisx, -5 * v5);
            v11 = 4;
            break;
        case 4u:
        LABEL_11:
            sub_41ECAB((_WORD*)thisx, 15 * v5);
            v11 = 5;
            break;
        case 5u:
        LABEL_13:
            sub_41EC40((_WORD*)thisx, 15 * v5);
            v11 = 6;
            break;
        case 6u:
        LABEL_15:
            sub_41ED16((_WORD*)thisx, 15 * v5);
            v11 = 7;
            break;
        case 7u:
            if (rand() % 2)
            {
                sub_41EE57((unsigned __int16*)thisx, -64 * v5);
                v11 = 9;
            }
            else
            {
                sub_41EE57((unsigned __int16*)thisx, v5 << 6);
                v11 = 8;
            }
            break;
        default:
            if ((unsigned __int8)v10 < 8u || (unsigned __int8)v10 > 0xDu)
            {
                switch ((unsigned __int8)v10)
                {
                case 0xEu:
                    v4 = unknown_libname_23(a2);
                    if ((unsigned __int8)v10 == 14 && v4 < 300)
                        sub_41EBBC(thisx, v2, 32, 0);
                    sub_41EE57((unsigned __int16*)thisx, v5 * (255 * (10 * (480 - v4) / 48) / 100));
                    v11 = 8;
                    break;
                case 0xFu:
                    *(_DWORD*)(thisx + 172) = 600 * v5;
                    v11 = 10;
                    break;
                case 0x10u:
                LABEL_31:
                    sub_420D47((_WORD*)thisx, 15 * v5);
                    v11 = 11;
                    break;
                case 0x11u:
                LABEL_33:
                    sub_420DB2((_WORD*)thisx, 15 * v5);
                    v11 = 12;
                    break;
                case 0x12u:
                    sub_41EC40((_WORD*)thisx, 10 * v5);
                    sub_41ECAB((_WORD*)thisx, 10 * v5);
                    sub_41ED16((_WORD*)thisx, 10 * v5);
                    sub_420D47((_WORD*)thisx, 10 * v5);
                    sub_420DB2((_WORD*)thisx, 10 * v5);
                    v11 = 13;
                    break;
                case 0x13u:
                    switch (rand() % (2 * (byte_4B999A != 0) + 3))
                    {
                    case 0:
                        goto LABEL_13;
                    case 1:
                        goto LABEL_11;
                    case 2:
                        goto LABEL_15;
                    case 3:
                        goto LABEL_31;
                    case 4:
                        goto LABEL_33;
                    default:
                        goto LABEL_46;
                    }
                case 0x14u:
                    sub_420E1D((_WORD*)thisx, 10 * v5);
                    v11 = 14;
                    break;
                case 0x15u:
                    sub_4659A5((_DWORD*)unk_4B9B10, (_BYTE*)thisx);
                    break;
                case 0x16u:
                    if (rand() % 2)
                    {
                        sub_41EC40((_WORD*)thisx, -15 * v5);
                        sub_41ECAB((_WORD*)thisx, -15 * v5);
                        sub_41ED16((_WORD*)thisx, -15 * v5);
                        sub_420D47((_WORD*)thisx, -15 * v5);
                        sub_420DB2((_WORD*)thisx, -15 * v5);
                        sub_41ED81((_WORD*)thisx, -15 * v5);
                        sub_41EDEC((_WORD*)thisx, -10 * v5);
                        sub_420E1D((_WORD*)thisx, -10 * v5);
                        sub_420E88((_WORD*)thisx, -10 * v5);
                        v11 = 16;
                    }
                    else
                    {
                        sub_41EC40((_WORD*)thisx, 15 * v5);
                        sub_41ECAB((_WORD*)thisx, 15 * v5);
                        sub_41ED16((_WORD*)thisx, 15 * v5);
                        sub_420D47((_WORD*)thisx, 15 * v5);
                        sub_420DB2((_WORD*)thisx, 15 * v5);
                        sub_41ED81((_WORD*)thisx, 15 * v5);
                        sub_41EDEC((_WORD*)thisx, 10 * v5);
                        sub_420E1D((_WORD*)thisx, 10 * v5);
                        sub_420E88((_WORD*)thisx, 10 * v5);
                        v11 = 15;
                    }
                    break;
                }
            }
            else
            {
                sub_41EE57((unsigned __int16*)thisx, v5 * (255 * (100 * ((unsigned __int8)v10 - 7) / 7) / 100));
                v11 = 8;
            }
            break;
        }
    LABEL_46:
        sub_442863(v6);
        v6[0] = 0;
        v6[1] = -24;
        v9 = thisx;
        v8 = 0;
        v7 = v11;
        sub_4561A5((char*)unk_4B9B10, (int)v6);
        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
        sub_47F14A((char*)a2);
    }
}
 
__int16 __fastcall sub_41EBBC(int a1, int a2, int a3, int a4)
{
    int v4; // eax

    LOWORD(v4) = a1;
    if (a3 + *(unsigned __int16*)(a1 + 500) > 0)
    {
        if (a4 || *(unsigned __int16*)(a1 + 500) >= 0xFFu || (v4 = a3 + *(unsigned __int16*)(a1 + 500), v4 <= 255))
        {
            LOWORD(v4) = a3 + *(_WORD*)(a1 + 500);
            *(_WORD*)(a1 + 500) = v4;
        }
        else
        {
            *(_WORD*)(a1 + 500) = 255;
        }
    }
    else
    {
        *(_WORD*)(a1 + 500) = 1;
    }
    return v4;
}

 
_WORD* sub_41EC40(_WORD* thisx, int a2)
{
    _WORD* result; // eax

    result = thisx;
    if (a2 + (unsigned __int16)thisx[251] > 0)
    {
        result = thisx;
        if (a2 + (unsigned __int16)thisx[251] <= 0xFFFF)
        {
            result = thisx;
            thisx[251] += a2;
        }
        else
        {
            thisx[251] = -1;
        }
    }
    else
    {
        thisx[251] = 1;
    }
    return result;
}

 
_WORD* sub_41ECAB(_WORD* thisx, int a2)
{
    _WORD* result; // eax

    result = thisx;
    if (a2 + (unsigned __int16)thisx[252] > 0)
    {
        result = thisx;
        if (a2 + (unsigned __int16)thisx[252] <= 0xFFFF)
        {
            result = thisx;
            thisx[252] += a2;
        }
        else
        {
            thisx[252] = -1;
        }
    }
    else
    {
        thisx[252] = 1;
    }
    return result;
}

 
_WORD* sub_41ED16(_WORD* thisx, int a2)
{
    _WORD* result; // eax

    result = thisx;
    if (a2 + (unsigned __int16)thisx[253] > 0)
    {
        result = thisx;
        if (a2 + (unsigned __int16)thisx[253] <= 0xFFFF)
        {
            result = thisx;
            thisx[253] += a2;
        }
        else
        {
            thisx[253] = -1;
        }
    }
    else
    {
        thisx[253] = 1;
    }
    return result;
}

 
_WORD* sub_41ED81(_WORD* thisx, int a2)
{
    _WORD* result; // eax

    result = thisx;
    if (a2 + (unsigned __int16)thisx[256] > 0)
    {
        result = thisx;
        if (a2 + (unsigned __int16)thisx[256] <= 0xFFFF)
        {
            result = thisx;
            thisx[256] += a2;
        }
        else
        {
            thisx[256] = -1;
        }
    }
    else
    {
        thisx[256] = 1;
    }
    return result;
}

 
_WORD* sub_41EDEC(_WORD* thisx, int a2)
{
    _WORD* result; // eax

    result = thisx;
    if (a2 + (unsigned __int16)thisx[257] > 0)
    {
        result = thisx;
        if (a2 + (unsigned __int16)thisx[257] <= 0xFFFF)
        {
            result = thisx;
            thisx[257] += a2;
        }
        else
        {
            thisx[257] = -1;
        }
    }
    else
    {
        thisx[257] = 1;
    }
    return result;
}

 
unsigned __int16* sub_41EE57(unsigned __int16* thisx, int a2)
{
    unsigned __int16* result; // eax
    int v3; // [esp+4h] [ebp-4h]

    v3 = a2 + thisx[107];
    if (v3 >= 0)
    {
        if (v3 > thisx[250])
            LOWORD(v3) = thisx[250];
    }
    else
    {
        LOWORD(v3) = 0;
    }
    result = thisx;
    thisx[107] = v3;
    return result;
}

 
int sub_41EEB5(_BYTE* thisx, _DWORD* a2, char a3)
{
    int v4; // [esp+4h] [ebp-8h]
    int v5; // [esp+8h] [ebp-4h]

    if (!a2)
        return 0;
    v5 = 0;
    if (thisx[188])
    {
        if (thisx[188] == 1)
        {
            v4 = 0;
        }
        else if (thisx[188] == 2 || thisx[188] == 3)
        {
            v4 = 1;
        }
        return dword_4B9308[v4] + 12 * (unsigned __int16)sub_401BEF(a2, a3);
    }
    else
    {
        if (thisx[212] == 1)
            v5 = (unsigned __int8)thisx[195] + 1;
        return dword_4B9348[v5] + 12 * (unsigned __int16)sub_401BEF(a2, a3);
    }
}

 
__int16 sub_41EF8A(_WORD* thisx, int a2)
{
    __int16 result; // ax
    int v3; // [esp+4h] [ebp-14h]
    int v4; // [esp+8h] [ebp-10h]
    int i; // [esp+Ch] [ebp-Ch]
    int v6; // [esp+14h] [ebp-4h]

    if (a2 > 0xFFFF)
        a2 = 0xFFFF;
    if (a2 < 0)
        a2 = 0;
    if (a2 > 32)
    {
        v4 = 3200;
        v6 = (a2 - 32) / 8;
        for (i = 0; i < v6 + 1; ++i)
        {
            if (i >= v6)
                v3 = 100 * ((a2 - 32) % 8) / (i + 2);
            else
                v3 = 800 / (i + 2);
            if (!v3)
                v3 = 1;
            v4 += v3;
        }
        thisx[121] = v4 / 100;
        result = (__int16)thisx;
        if (!thisx[121])
            thisx[121] = 1;
    }
    else
    {
        thisx[121] = a2;
        result = thisx[121];
        if (!result)
            thisx[121] = 1;
    }
    return result;
}

 
_DWORD* sub_41F0A9(_DWORD* thisx)
{
    if (thisx[41])
        return thisx + 2;
    else
        return 0;
}

 
void sub_41F0CA(_DWORD* thisx, int a2)
{
    int v2; // ebx

    if (a2)
    {
        v2 = (unsigned __int8)sub_426070((char*)a2);
        if (v2 != (unsigned __int8)sub_426070((char*)thisx[31]))
        {
            if (*thisx == 2)
            {
                thisx[32] = a2;
                *thisx = 0;
                thisx[33] = 600;
            }
            else if (!*thisx && rand() % 99 < 10)
            {
                thisx[32] = a2;
                thisx[33] = 600;
            }
        }
    }
}

 
_WORD* sub_41F169(_WORD* thisx, int a2)
{
    _WORD* result; // eax

    if (a2 >= 0)
    {
        if (a2 > 0xFFFF)
            LOWORD(a2) = -1;
    }
    else
    {
        LOWORD(a2) = 0;
    }
    result = thisx;
    thisx[120] = a2;
    return result;
}

 
unsigned __int8* sub_41F1A3(unsigned __int8* thisx, int a2)
{
    unsigned __int8* result; // eax
    int v3; // [esp+4h] [ebp-4h]

    if (a2 > 0)
    {
        a2 = (100 - 5 * thisx[472]) * a2 / 100;
        if (a2 <= 0)
            a2 = 1;
        if (thisx[472] < 0x14u)
            ++thisx[472];
    }
    v3 = a2 + thisx[470];
    if (v3 >= 0)
    {
        if (v3 > 255)
            LOBYTE(v3) = -1;
    }
    else
    {
        LOBYTE(v3) = 0;
    }
    result = thisx;
    thisx[470] = v3;
    return result;
}

 
int sub_41F24C(int thisx, ISchedulerProxy* a2)
{
    int ExecutingContext; // [esp+4h] [ebp-Ch]
    unsigned int QueueLength; // [esp+8h] [ebp-8h]

    *(_BYTE*)(thisx + 222) = 0;
    *(_DWORD*)(thisx + 480) = (_DWORD)a2;
    sub_49951D((int*)a2);
    QueueLength = Concurrency::details::SchedulerProxy::GetQueueLength(a2);
    ExecutingContext = (int)Concurrency::details::VirtualProcessor::GetExecutingContext((VirtualProcessor*)a2);
    Concurrency::details::VirtualProcessor::GetExecutionResourceId((VirtualProcessor*)a2);
    if (*(_DWORD*)(thisx + 428) != 8)
    {
        if (QueueLength)
        {
            if (*(_DWORD*)(thisx + 392))
            {
                *(_DWORD*)(thisx + 340) += QueueLength;
                *(_DWORD*)(thisx + 348) = 0;
                *(_DWORD*)(thisx + 360) = 30;
            }
            else
            {
                *(_DWORD*)(thisx + 372) = QueueLength;
                *(_DWORD*)(thisx + 352) = (signed int)-QueueLength / 10;
            }
        }
        if (ExecutingContext)
        {
            if (*(_DWORD*)(thisx + 392))
            {
                *(_DWORD*)(thisx + 344) += ExecutingContext;
                *(_DWORD*)(thisx + 348) = 0;
                *(_DWORD*)(thisx + 360) = 30;
            }
            else
            {
                *(_DWORD*)(thisx + 376) = ExecutingContext;
                *(_DWORD*)(thisx + 356) = -ExecutingContext / 10;
            }
        }
    }
    return sub_491639((int)a2, thisx);
}
 
__int16 sub_41F380(int thisx, int a2)
{
    int v4; // [esp+8h] [ebp-Ch]
    int v5; // [esp+Ch] [ebp-8h]
    unsigned __int16 v6; // [esp+10h] [ebp-4h]

    v6 = *(_WORD*)(thisx + 508);
    if (a2)
    {
        if (sub_41BA53(thisx, 0x82u, 0))
        {
            v5 = 100 * *(unsigned __int16*)(thisx + 214) / *(unsigned __int16*)(thisx + 500);
            if (v5 >= 10)
            {
                if (v5 >= 20)
                {
                    if (v5 >= 30)
                    {
                        if (v5 >= 40)
                        {
                            if (v5 < 50)
                                v6 = 110 * v6 / 100;
                        }
                        else
                        {
                            v6 = 120 * v6 / 100;
                        }
                    }
                    else
                    {
                        v6 = 130 * v6 / 100;
                    }
                }
                else
                {
                    v6 = 140 * v6 / 100;
                }
            }
            else
            {
                v6 = 150 * v6 / 100;
            }
        }
        if (sub_41BA53(thisx, 0x8Cu, 0) && *(_BYTE*)(thisx + 609) == 11)
            v6 += *(_WORD*)(thisx + 496) + 15;
    }
    if (sub_425CD0((_DWORD*)&unk_4B9B10) == 3 && *(_DWORD*)(thisx + 164))
    {
        v4 = v6 * sub_426250((_DWORD*)&unk_4B9B10) / 100;
        if (v4 > 255)
            LOWORD(v4) = 255;
        v6 = v4;
    }
    if (v6)
        return v6;
    else
        return 1;
}

 
__int16 sub_41F52F(int thisx, int a2)
{
    int v4; // [esp+8h] [ebp-Ch]
    int v5; // [esp+Ch] [ebp-8h]
    unsigned __int16 v6; // [esp+10h] [ebp-4h]

    v6 = *(_WORD*)(thisx + 510);
    if (a2)
    {
        if (sub_41BA53(thisx, 0x82u, 0))
        {
            v5 = 100 * *(unsigned __int16*)(thisx + 214) / *(unsigned __int16*)(thisx + 500);
            if (v5 >= 10)
            {
                if (v5 >= 20)
                {
                    if (v5 >= 30)
                    {
                        if (v5 >= 40)
                        {
                            if (v5 < 50)
                                v6 = 110 * v6 / 100;
                        }
                        else
                        {
                            v6 = 120 * v6 / 100;
                        }
                    }
                    else
                    {
                        v6 = 130 * v6 / 100;
                    }
                }
                else
                {
                    v6 = 140 * v6 / 100;
                }
            }
            else
            {
                v6 = 150 * v6 / 100;
            }
        }
        if (sub_41BA53(thisx, 0x8Cu, 0) && *(_BYTE*)(thisx + 609) == 11)
            v6 += *(_WORD*)(thisx + 496) + 15;
    }
    if (sub_425CD0((_DWORD*)&unk_4B9B10) == 3 && *(_DWORD*)(thisx + 164))
    {
        v4 = v6 * sub_426250((_DWORD*)&unk_4B9B10) / 100;
        if (v4 > 255)
            LOWORD(v4) = 255;
        v6 = v4;
    }
    if (v6)
        return v6;
    else
        return 1;
}

 
int sub_41F6DE(_DWORD* thisx)
{
    int result; // eax

    result = (int)thisx;
    if (thisx[120])
    {
        result = sub_494979(thisx[120]);
        thisx[120] = 0;
    }
    return result;
}

 
_DWORD* sub_41F712(_DWORD* thisx)
{
    int v1; // esi
    int v2; // esi
    _DWORD* result; // eax
    bool v4; // [esp+4h] [ebp-3Ch]
    bool v5; // [esp+8h] [ebp-38h]
    bool v6; // [esp+Ch] [ebp-34h]
    bool v7; // [esp+10h] [ebp-30h]
    bool v8; // [esp+14h] [ebp-2Ch]
    bool v9; // [esp+18h] [ebp-28h]
    char v11; // [esp+20h] [ebp-20h]
    int v12; // [esp+24h] [ebp-1Ch]
    int v13; // [esp+28h] [ebp-18h]
    int v14; // [esp+2Ch] [ebp-14h]
    int i; // [esp+30h] [ebp-10h]
    int v16; // [esp+34h] [ebp-Ch]
    int v17; // [esp+38h] [ebp-8h]
    int v18; // [esp+3Ch] [ebp-4h]

    thisx[1] = 1;
    *((_BYTE*)thisx + 84) = 0;
    *((_BYTE*)thisx + 86) = 0;
    *((_BYTE*)thisx + 87) = 0;
    *((_BYTE*)thisx + 91) = 0;
    *((_BYTE*)thisx + 92) = 0;
    *((_BYTE*)thisx + 93) = 0;
    *((_BYTE*)thisx + 88) = 0;
    *((_BYTE*)thisx + 89) = 0;
    *((_BYTE*)thisx + 90) = 0;
    *((_BYTE*)thisx + 148) = 0;
    *((_BYTE*)thisx + 147) = 0;
    *((_BYTE*)thisx + 96) = 0;
    *((_BYTE*)thisx + 95) = 0;
    memset(thisx + 25, 0, 0x10u);
    *((_BYTE*)thisx + 85) = 0;
    *((_BYTE*)thisx + 97) = 0;
    *((_BYTE*)thisx + 98) = 0;
    for (i = 0; i < 4; ++i)
        *((_BYTE*)thisx + i + 143) = 0;
    *((_BYTE*)thisx + 141) = 0;
    *((_BYTE*)thisx + 142) = 0;
    thisx[20] = 0;
    thisx[2] = 0;
    thisx[9] = 0;
    thisx[10] = 0;
    thisx[34] = 0;
    thisx[11] = 0;
    thisx[12] = 0;
    thisx[3] = 0;
    thisx[4] = 0;
    thisx[8] = 0;
    thisx[6] = 0;
    thisx[7] = 0;
    thisx[33] = 0;
    *thisx = 0;
    thisx[32] = 0;
    thisx[18] = 0;
    *((_WORD*)thisx + 10) = 0;
    *((_WORD*)thisx + 11) = 0;
    if (sub_41BA53(thisx[31], 0x14u, 0))
    {
        *((_BYTE*)thisx + 89) = 1;
    }
    else if (sub_41BA53(thisx[31], 0x15u, 0))
    {
        *((_BYTE*)thisx + 89) = 2;
    }
    else
    {
        *((_BYTE*)thisx + 89) = 0;
    }
    *((_BYTE*)thisx + 94) = sub_41BA53(thisx[31], 0x48u, 0);
    v9 = sub_41BA53(thisx[31], 4u, 0) || sub_41BA53(thisx[31], 0xFu, 0);
    *((_BYTE*)thisx + 91) = v9;
    v8 = sub_41BA53(thisx[31], 3u, 0) || sub_41BA53(thisx[31], 0xCu, 0);
    *((_BYTE*)thisx + 92) = v8;
    *((_BYTE*)thisx + 90) = sub_41BA53(thisx[31], 0x22u, 0);
    v7 = sub_41BA53(thisx[31], 0x20u, 0) || sub_41BA53(thisx[31], 0x21u, 0);
    *((_BYTE*)thisx + 87) = v7;
    v6 = sub_41BA53(thisx[31], 0x1Du, 0)
        || sub_41BA53(thisx[31], 0x1Fu, 0)
        || sub_41BA53(thisx[31], 0x2Cu, 0)
        || sub_41BA53(thisx[31], 0x31u, 0)
        || sub_41BA53(thisx[31], 0x33u, 0)
        || sub_41BA53(thisx[31], 0x3Du, 0)
        || sub_41BA53(thisx[31], 0x3Fu, 0)
        || sub_41BA53(thisx[31], 0x41u, 0)
        || sub_41BA53(thisx[31], 0x43u, 0)
        || sub_41BA53(thisx[31], 0x45u, 0);
    v5 = sub_41BA53(thisx[31], 0x1Eu, 0)
        || sub_41BA53(thisx[31], 0x32u, 0)
        || sub_41BA53(thisx[31], 0x34u, 0)
        || sub_41BA53(thisx[31], 0x3Cu, 0)
        || sub_41BA53(thisx[31], 0x3Eu, 0)
        || sub_41BA53(thisx[31], 0x40u, 0)
        || sub_41BA53(thisx[31], 0x42u, 0)
        || sub_41BA53(thisx[31], 0x44u, 0)
        || sub_41BA53(thisx[31], 0x45u, 0);
    *((_BYTE*)thisx + 88) = (2 * v5) | v6;
    *((_BYTE*)thisx + 86) = 20;
    if (sub_41BA53(thisx[31], 0x1Cu, 0)
        || *((_BYTE*)thisx + 88)
        || sub_41BA53(thisx[31], 0x20u, 0)
        || sub_41BA53(thisx[31], 0x21u, 0))
    {
        *((_BYTE*)thisx + 86) += 50;
    }
    v1 = (unsigned __int16)sub_41CCEA(thisx[31], 1);
    v18 = (v1 + (unsigned __int16)sub_41CB3B(thisx[31], 1)) / 2;
    v2 = (unsigned __int16)sub_41F380(thisx[31], 1);
    v17 = (v2 + (unsigned __int16)sub_41F52F(thisx[31], 1)) / 2;
    if (v17 - v18 + *((unsigned __int8*)thisx + 86) < 20)
        *((_BYTE*)thisx + 86) += v17 - v18;
    v11 = sub_425E70((char*)thisx[31]);
    if (v11 == 1 || v11 == 2 || v11 == 3 || (unsigned __int8)sub_4264F0((char*)thisx[31]) == 4)
        *((_BYTE*)thisx + 86) = 0;
    v12 = (unsigned __int16)sub_41CB3B(thisx[31], 1);
    v16 = (unsigned __int16)sub_41CCEA(thisx[31], 1);
    if (sub_41BA53(thisx[31], 1u, 0) || sub_41BA53(thisx[31], 0x16u, 0))
        v16 *= 2;
    if (sub_41BA53(thisx[31], 2u, 0) || sub_41BA53(thisx[31], 0x12u, 0))
        v12 *= 2;
    *((_BYTE*)thisx + 95) = 100 * v12 / (v16 + v12);
    *((_BYTE*)thisx + 96) = 100 - *((_BYTE*)thisx + 95);
    *((_BYTE*)thisx + 99) = 50 * sub_41BA53(thisx[31], 0x88u, 0) + 50;
    if (v11 == 1)
    {
        *((_BYTE*)thisx + 95) = 100;
        *((_BYTE*)thisx + 96) = 0;
    }
    v14 = (unsigned __int16)sub_41F380(thisx[31], 1);
    if (!v14)
        v14 = 1;
    v13 = (unsigned __int16)sub_41F52F(thisx[31], 1);
    if (!v13)
        v13 = 1;
    if (sub_41BA53(thisx[31], 0x1Cu, 0) || *((_BYTE*)thisx + 87))
        v14 *= 3;
    if (*((_BYTE*)thisx + 88))
        v13 *= 3;
    *((_BYTE*)thisx + 97) = 100 * v14 / (v13 + v14);
    *((_BYTE*)thisx + 98) = 100 - *((_BYTE*)thisx + 97);
    v4 = sub_4268D0((_DWORD*)thisx[31]) || sub_41BA53(thisx[31], 0x26u, 0);
    result = thisx;
    *((_BYTE*)thisx + 93) = v4;
    return result;
}

 
Concurrency::details::UMSFreeVirtualProcessorRoot* sub_41FE85(int thisx)
{
    int v2; // [esp+0h] [ebp-4Ch]
    int v3; // [esp+4h] [ebp-48h]
    Concurrency::details::UMSFreeVirtualProcessorRoot* v5; // [esp+Ch] [ebp-40h]
    int v6; // [esp+10h] [ebp-3Ch]
    int ExecutingProxy; // [esp+14h] [ebp-38h]
    int v8; // [esp+28h] [ebp-24h]
    int v9; // [esp+2Ch] [ebp-20h]
    int v10; // [esp+30h] [ebp-1Ch]
    int i; // [esp+34h] [ebp-18h]
    int j; // [esp+38h] [ebp-14h]
    int v13; // [esp+3Ch] [ebp-10h]
    int v14; // [esp+44h] [ebp-8h]
    Concurrency::details::UMSFreeVirtualProcessorRoot* v15; // [esp+48h] [ebp-4h]

    v15 = 0;
    v13 = sub_426090(*(_DWORD**)(thisx + 124));
    v9 = sub_4260B0(*(_DWORD**)(thisx + 124));
    v14 = v9 + v13;
    v10 = 100 * sub_446465((char*)unk_4B9B10);
    for (i = 0; i < 3; ++i)
    {
        if (!i)
            i = *(_BYTE*)(thisx + 87) == 0;
        if (i == 1 && !sub_41BA53(*(_DWORD*)(thisx + 124), 0x85u, 0))
            i = 2;
        for (j = 0; j < (unsigned __int8)byte_4B999A; ++j)
        {
            v5 = (Concurrency::details::UMSFreeVirtualProcessorRoot*)sub_4655B9(unk_4B9B10, j);
            if (v5 && (i || sub_494AA9((char*)v5, 1)) && (i != 1 || sub_425CB0((char*)v5) == 12) && !unknown_libname_12((int*)v5))
            {
                v6 = sub_426470((int*)v5);
                v8 = sub_426530((int*)v5);
                if (sub_425CD0((int*)unk_4B9B10) == 3 || v6 >= 0 && v8 >= 0 && v6 >= v10 && v6 <= v10 + 32000)
                {
                    ExecutingProxy = (int)Concurrency::details::UMSFreeVirtualProcessorRoot::GetExecutingProxy(v5);
                    if (ExecutingProxy <= -100 * sub_446497((int*)unk_4B9B10, v6 / 100, v8 / 100))
                    {
                        if (sub_4773CC(v6 / 800, v8 / 800))
                        {
                            if (sub_426470((int*)v5) - v13 <= 0)
                                v3 = v13 - sub_426470((int*)v5);
                            else
                                v3 = sub_426470((int*)v5) - v13;
                            if (sub_426530((int*)v5) - v9 <= 0)
                                v2 = v9 - sub_426530((int*)v5);
                            else
                                v2 = sub_426530((int*)v5) - v9;
                            if (!v15 || v14 > v2 + v3)
                            {
                                v15 = v5;
                                v14 = v2 + v3;
                            }
                        }
                    }
                }
            }
        }
        if (!i && v15)
            break;
    }
    return v15;
}

 
int sub_420119(int thisx)
{
    int result; // eax
    int v2; // eax
    int v3; // et2
    int v4; // edx
    int v6; // eax
    int v7; // et2
    int v8; // esi
    int v9; // esi
    int v10; // esi
    int v11; // edx
    int v12; // edx
    int v13; // eax
    int v14; // et2
    int v15; // eax
    int v16; // et2
    int v17; // eax
    int v18; // et2
    int v19; // eax
    int v20; // et2
    int v21; // eax
    int v22; // et2
    int v23; // eax
    int v24; // et2
    unsigned int v25; // [esp+4h] [ebp-78h]
    int v26; // [esp+8h] [ebp-74h]
    int v27; // [esp+Ch] [ebp-70h]
    int v28; // [esp+10h] [ebp-6Ch]
    int v30; // [esp+24h] [ebp-58h]
    int v31; // [esp+2Ch] [ebp-50h]
    unsigned __int8 v32; // [esp+34h] [ebp-48h]
    _BYTE* v33; // [esp+38h] [ebp-44h]
    int v34; // [esp+3Ch] [ebp-40h]
    char v35; // [esp+40h] [ebp-3Ch]
    int v36; // [esp+44h] [ebp-38h]
    int v37; // [esp+48h] [ebp-34h]
    int v38; // [esp+4Ch] [ebp-30h]
    int v39; // [esp+50h] [ebp-2Ch]
    int v40; // [esp+5Ch] [ebp-20h]
    char v41; // [esp+64h] [ebp-18h]
    int v42; // [esp+70h] [ebp-Ch]
    int SchedulerProxy; // [esp+74h] [ebp-8h]

    v35 = sub_425E70(*(_BYTE**)(thisx + 124));
    v40 = sub_426090(*(_DWORD**)(thisx + 124));
    v39 = sub_4260B0(*(_DWORD**)(thisx + 124));
    result = v40 / 100 - sub_446465((char*)unk_4B9B10);
    if (result > 0 && result < 320)
    {
        if (sub_425FF0(*(_DWORD**)(thisx + 124)))
        {
            v33 = (_BYTE*)sub_426910(*(_DWORD**)(thisx + 124));
            if (*(_BYTE*)(thisx + 87))
            {
                if (sub_494AA9(v33, 1))
                {
                    result = sub_4655EF((_DWORD*)unk_4B9B10, *(_DWORD**)(thisx + 124), 32, 0);
                    if (result)
                    {
                        *(_BYTE*)(thisx + 143) = 1;
                        return result;
                    }
                }
            }
            if (!*(_BYTE*)(thisx + 88) && rand() % 1000 <= *(unsigned __int8*)(thisx + 98))
            {
                result = sub_4655EF((_DWORD*)unk_4B9B10, *(_DWORD**)(thisx + 124), 128, 1);
                if (result)
                {
                    *(_BYTE*)(thisx + 144) = 1;
                    return result;
                }
            }
        }
        else if (rand() % 100 < 5
            && sub_41BA53(*(_DWORD*)(thisx + 124), 0x23u, 0)
            && sub_4655EF((_DWORD*)unk_4B9B10, *(_DWORD**)(thisx + 124), 32, 0))
        {
            *(_BYTE*)(thisx + 85) = 2;
        }
        if (sub_425FF0(*(_DWORD**)(thisx + 124)))
        {
            if (sub_425D30(*(_DWORD**)(thisx + 124)))
            {
                if ((*(_BYTE*)(thisx + 88) & 2) != 0)
                {
                    result = sub_426350(*(unsigned __int8**)(thisx + 124));
                    if (result)
                    {
                        *(_BYTE*)(thisx + 144) = 1;
                        return result;
                    }
                }
            }
            else
            {
                if (rand() % 2)
                {
                    if ((*(_BYTE*)(thisx + 88) & 1) != 0)
                    {
                        result = sub_426350(*(unsigned __int8**)(thisx + 124));
                        if (result)
                        {
                            *(_BYTE*)(thisx + 144) = 1;
                            return result;
                        }
                    }
                }
                if ((*(_BYTE*)(thisx + 88) & 2) != 0
                    && sub_426350(*(unsigned __int8**)(thisx + 124))
                    && Concurrency::details::SchedulerBase::GetNumberOfBoundContexts(*(Concurrency::details::SchedulerBase**)(thisx + 124)))
                {
                    *(_BYTE*)(thisx + 147) = 2;
                    *(_BYTE*)(thisx + 144) = 1;
                    result = thisx;
                    *(_BYTE*)(thisx + 143) = 1;
                    *(_BYTE*)(thisx + 148) = 0;
                    return result;
                }
            }
        }
        SchedulerProxy = (int)Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(thisx + 124));
        v42 = SchedulerProxy;
        if (SchedulerProxy == 188)
            SchedulerProxy = 10;
        if (sub_425D30(*(_DWORD**)(thisx + 124)) || sub_425FF0(*(_DWORD**)(thisx + 124)))
        {
            result = sub_425D30(*(_DWORD**)(thisx + 124));
            if (result)
            {
                result = sub_425FF0(*(_DWORD**)(thisx + 124));
                if (!result)
                {
                    if (SchedulerProxy == 8 && sub_41BA53(*(_DWORD*)(thisx + 124), 7u, 0))
                    {
                        if (sub_426930(*(_DWORD**)(thisx + 124)) >= 0 ? sub_4655EF((_DWORD*)unk_4B9B10, *(_DWORD**)(thisx + 124), 64, 1) : sub_4655EF((_DWORD*)unk_4B9B10, *(_DWORD**)(thisx + 124), 128, 1))
                            *(_BYTE*)(thisx + 142) = 1;
                    }
                    if (sub_41BA53(*(_DWORD*)(thisx + 124), 0x25u, 0)
                        && rand() % 100 < 5
                        && sub_4655EF((_DWORD*)unk_4B9B10, *(_DWORD**)(thisx + 124), 80, 1))
                    {
                        *(_BYTE*)(thisx + 142) = 1;
                        *(_BYTE*)(thisx + 143) = 1;
                    }
                    if (!sub_4268D0(*(_DWORD**)(thisx + 124)) && sub_41BA53(*(_DWORD*)(thisx + 124), 0x26u, 0))
                    {
                        *(_BYTE*)(thisx + 142) = 1;
                        *(_BYTE*)(thisx + 143) = 1;
                        *(_BYTE*)(thisx + 144) = 1;
                    }
                    result = sub_4268D0(*(_DWORD**)(thisx + 124));
                    if (result)
                    {
                        v6 = rand();
                        v7 = v6 % 100;
                        result = v6 / 100;
                        if (v7 < 2)
                        {
                            *(_BYTE*)(thisx + 142) = 1;
                            result = thisx;
                            *(_BYTE*)(thisx + 143) = 1;
                            *(_BYTE*)(thisx + 144) = 1;
                        }
                    }
                }
            }
        }
        else
        {
            if (SchedulerProxy == 13
                && (*(_BYTE*)(thisx + 91) || *(_BYTE*)(thisx + 92))
                && rand() % 100 < 20
                && sub_4655EF((_DWORD*)unk_4B9B10, *(_DWORD**)(thisx + 124), 128, 1))
            {
                if (*(_BYTE*)(thisx + 91) && *(_BYTE*)(thisx + 92))
                {
                    if (rand() % 100 >= *(unsigned __int8*)(thisx + 95))
                        *(_BYTE*)(thisx + 144) = 1;
                    else
                        *(_BYTE*)(thisx + 143) = 1;
                }
                else if (*(_BYTE*)(thisx + 91))
                {
                    *(_BYTE*)(thisx + 143) = 1;
                }
                else
                {
                    *(_BYTE*)(thisx + 144) = 1;
                }
            }
            if (v42 == 10
                && sub_41BA53(*(_DWORD*)(thisx + 124), 0x36u, 0)
                && rand() % 100 < 10
                && sub_4655EF((_DWORD*)unk_4B9B10, *(_DWORD**)(thisx + 124), 128, 1))
            {
                *(_BYTE*)(thisx + 84) = 1;
            }
            if (SchedulerProxy == 10
                && rand() % 100 < 10
                && sub_41BA53(*(_DWORD*)(thisx + 124), 0x19u, 0)
                && sub_457731((_DWORD*)unk_4B9B10, *(_DWORD**)(thisx + 124)))
            {
                *(_BYTE*)(thisx + 84) = 1;
            }
            if (SchedulerProxy != 162 && *(_BYTE*)(thisx + 89) == 1 && !*(_BYTE*)(thisx + 143) && rand() % 100 < 5)
                *(_BYTE*)(thisx + 143) = 20;
            if (SchedulerProxy == 91)
                *(_BYTE*)(thisx + 143) = sub_425ED0(*(_DWORD**)(thisx + 124)) < 37
                || !sub_4655EF((_DWORD*)unk_4B9B10, *(_DWORD**)(thisx + 124), 320, 1);
            v32 = sub_4268F0(*(_BYTE**)(thisx + 124));
            if (v32 < 3u
                && SchedulerProxy != 163
                && *(_BYTE*)(thisx + 89) == 2
                && !*(_BYTE*)(thisx + 143)
                && rand() % 100 < 5)
            {
                *(_BYTE*)(thisx + 143) = 20;
            }
            if (SchedulerProxy == 92)
            {
                if (v32 == 3 || v32 && sub_4655EF((_DWORD*)unk_4B9B10, *(_DWORD**)(thisx + 124), 32, 0))
                {
                    *(_BYTE*)(thisx + 143) = 0;
                    if (v32 == 3)
                        *(_BYTE*)(thisx + 145) = 1;
                }
                else
                {
                    *(_BYTE*)(thisx + 143) = 1;
                }
            }
            result = *(unsigned __int8*)(thisx + 90);
            if (*(_BYTE*)(thisx + 90))
            {
                if (SchedulerProxy == 94 || SchedulerProxy == 176)
                {
                    if (SchedulerProxy == 94)
                    {
                        v31 = sub_425ED0(*(_DWORD**)(thisx + 124));
                        result = *(_DWORD*)(thisx + 80);
                        if (result <= v31)
                            *(_BYTE*)(thisx + 143) = 1;
                    }
                }
                else
                {
                    v2 = rand();
                    v3 = v2 % 100;
                    result = v2 / 100;
                    if (v3 < 3)
                    {
                        result = sub_420CD4();
                        if (result > 0)
                        {
                            *(_BYTE*)(thisx + 85) = 1;
                            v4 = 30 * (rand() % 9);
                            result = thisx;
                            *(_DWORD*)(thisx + 80) = v4 + 60;
                        }
                    }
                }
            }
            if (SchedulerProxy == 15)
            {
                result = sub_41BA53(*(_DWORD*)(thisx + 124), 0x27u, 0);
                if (result)
                {
                    result = thisx;
                    *(_BYTE*)(thisx + 85) = 1;
                }
            }
        }
        if (*(_DWORD*)(thisx + 128))
        {
            v41 = sub_4464D3((int)unk_4B9B10, v40 / 800, v39 / 800);
            v34 = sub_426090(*(_DWORD**)(thisx + 128));
            v36 = sub_4260B0(*(_DWORD**)(thisx + 128));
            if (v40 - v34 <= 0)
                v28 = v34 - v40;
            else
                v28 = v40 - v34;
            if (v39 - v36 <= 0)
                v27 = v36 - v39;
            else
                v27 = v39 - v36;
            v8 = sub_4260D0(*(_DWORD**)(thisx + 124));
            if (v8 - sub_4260D0(*(_DWORD**)(thisx + 128)) <= 0)
            {
                v10 = sub_4260D0(*(_DWORD**)(thisx + 124));
                v26 = sub_4260D0(*(_DWORD**)(thisx + 128)) - v10;
            }
            else
            {
                v9 = sub_4260D0(*(_DWORD**)(thisx + 124));
                v26 = v9 - sub_4260D0(*(_DWORD**)(thisx + 128));
            }
            sub_4260D0(*(_DWORD**)(thisx + 124));
            sub_4260D0(*(_DWORD**)(thisx + 128));
            if (rand() % 100 < 10)
            {
                if (v41)
                {
                    if (!(unsigned __int8)sub_4263F0(*(char**)(thisx + 124))
                        && !sub_425FF0(*(_DWORD**)(thisx + 124))
                        && !sub_425D30(*(_DWORD**)(thisx + 124)))
                    {
                        v30 = sub_425D70(*(_DWORD**)(thisx + 124));
                        if ((v41 & 1) == (v30 == 0) && v28 < 4800 && v27 < 500 && (v30 && v40 < v34 || !v30 && v40 > v34))
                            *(_BYTE*)(thisx + 85) = 2;
                    }
                }
            }
            v37 = 3200;
            v38 = 800;
            result = (unsigned __int8)sub_425E70(*(_BYTE**)(thisx + 124));
            if (result == 1)
            {
                v37 = 4000;
                v38 = 4000;
            }
            if (SchedulerProxy == 10)
            {
                if ((int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(thisx + 124)) <= 0)
                    v25 = -Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(thisx + 124));
                else
                    v25 = Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(thisx + 124));
                result = 10 * v25 + v37;
                v37 = result;
            }
            if (v28 >= 400 && v28 < v37 && v27 < 500 && v26 < v38)
            {
                if (sub_425FF0(*(_DWORD**)(thisx + 124)))
                {
                    v11 = (unsigned __int8)(rand() % 100);
                    result = thisx;
                    if (v11 >= *(unsigned __int8*)(thisx + 97))
                    {
                        result = thisx;
                        *(_BYTE*)(thisx + 144) = 1;
                    }
                    else
                    {
                        *(_BYTE*)(thisx + 143) = 1;
                    }
                }
                else
                {
                    v12 = (unsigned __int8)(rand() % 100);
                    result = thisx;
                    if (v12 >= *(unsigned __int8*)(thisx + 95))
                    {
                        result = thisx;
                        *(_BYTE*)(thisx + 144) = 1;
                    }
                    else
                    {
                        *(_BYTE*)(thisx + 143) = 1;
                    }
                }
            }
            if (v35)
            {
                if (v35 == 2)
                {
                    if (sub_425D30(*(_DWORD**)(thisx + 124)))
                    {
                        v13 = rand();
                        v14 = v13 % 100;
                        result = v13 / 100;
                        if (v14 < 10 && v28 < 3200 && v27 < 800)
                            *(_DWORD*)(thisx + 8) = 3;
                    }
                    else
                    {
                        v15 = rand();
                        v16 = v15 % 100;
                        result = v15 / 100;
                        if (v16 < 10 && v28 < 6400 && v27 < 500)
                        {
                            v17 = rand();
                            v18 = v17 % 3;
                            result = v17 / 3;
                            if (v18)
                            {
                                result = thisx;
                                *(_DWORD*)(thisx + 8) = 1;
                            }
                            else
                            {
                                *(_DWORD*)(thisx + 8) = 2;
                            }
                        }
                    }
                }
                else if (v35 == 3)
                {
                    if (sub_425D30(*(_DWORD**)(thisx + 124)))
                    {
                        v19 = rand();
                        v20 = v19 % 100;
                        result = v19 / 100;
                        if (v20 < 10 && v28 < 3200 && v27 < 800)
                            *(_DWORD*)(thisx + 8) = 3;
                    }
                    else
                    {
                        v21 = rand();
                        v22 = v21 % 100;
                        result = v21 / 100;
                        if (v22 < 10 && v28 < 3200 && v27 < 500)
                        {
                            v23 = rand();
                            v24 = v23 % 3;
                            result = v23 / 3;
                            if (v24)
                            {
                                result = thisx;
                                *(_DWORD*)(thisx + 8) = 1;
                            }
                            else
                            {
                                *(_DWORD*)(thisx + 8) = 2;
                            }
                        }
                    }
                }
            }
        }
    }
    return result;
}

 
int sub_420CD4()
{
    _DWORD* v1; // [esp+4h] [ebp-Ch]
    int i; // [esp+8h] [ebp-8h]
    int v3; // [esp+Ch] [ebp-4h]

    if (!byte_4B999A)
        return 0;
    v3 = 0;
    for (i = 0; i < (unsigned __int8)byte_4B999A; ++i)
    {
        v1 = (_DWORD*)sub_4655B9(unk_4B9B10, i);
        if (v1)
        {
            if (!unknown_libname_12(v1))
                ++v3;
        }
    }
    return v3;
}

 
_WORD* sub_420D47(_WORD* thisx, int a2)
{
    _WORD* result; // eax

    result = thisx;
    if (a2 + (unsigned __int16)thisx[254] > 0)
    {
        result = thisx;
        if (a2 + (unsigned __int16)thisx[254] <= 0xFFFF)
        {
            result = thisx;
            thisx[254] += a2;
        }
        else
        {
            thisx[254] = -1;
        }
    }
    else
    {
        thisx[254] = 1;
    }
    return result;
}

 
WORD* sub_420DB2(_WORD* thisx, int a2)
{
    _WORD* result; // eax

    result = thisx;
    if (a2 + (unsigned __int16)thisx[255] > 0)
    {
        result = thisx;
        if (a2 + (unsigned __int16)thisx[255] <= 0xFFFF)
        {
            result = thisx;
            thisx[255] += a2;
        }
        else
        {
            thisx[255] = -1;
        }
    }
    else
    {
        thisx[255] = 1;
    }
    return result;
}

 
_WORD* sub_420E1D(_WORD* thisx, int a2)
{
    _WORD* result; // eax

    result = thisx;
    if (a2 + (unsigned __int16)thisx[258] > 0)
    {
        result = thisx;
        if (a2 + (unsigned __int16)thisx[258] <= 0xFFFF)
        {
            result = thisx;
            thisx[258] += a2;
        }
        else
        {
            thisx[258] = -1;
        }
    }
    else
    {
        thisx[258] = 1;
    }
    return result;
}

 
_WORD* sub_420E88(_WORD* thisx, int a2)
{
    _WORD* result; // eax

    result = thisx;
    if (a2 + (unsigned __int16)thisx[259] > 0)
    {
        result = thisx;
        if (a2 + (unsigned __int16)thisx[259] <= 0xFFFF)
        {
            result = thisx;
            thisx[259] += a2;
        }
        else
        {
            thisx[259] = -1;
        }
    }
    else
    {
        thisx[259] = 1;
    }
    return result;
}

 
char* sub_420EF3(int thisx, int a2)
{
    char* result; // eax

    *(_DWORD*)(thisx + 304) = a2;
    *(_DWORD*)(thisx + 288) = 1;
    if (*(_DWORD*)(thisx + 428) == 4)
    {
        *(_DWORD*)(thisx + 428) = 3;
        *(_DWORD*)(thisx + 432) = 3;
    }
    result = (char*)(unsigned __int8)byte_4B99C8;
    if (byte_4B99C8)
    {
        result = (char*)(unsigned __int8)sub_426070(*(_BYTE**)(thisx + 304));
        if (result == (char*)*(unsigned __int8*)(thisx + 193))
            return sub_4211F5(thisx);
    }
    return result;
}

 
__int16 sub_420F74(int thisx)
{
    if (*(_DWORD*)(thisx + 524))
        return *(_WORD*)(thisx + 528);
    else
        return *(_WORD*)(thisx + 190);
}

 
int sub_420FA1(_DWORD* thisx)
{
    if (thisx[1])
        return sub_43F0C8((_DWORD*)thisx[1]);
    else
        return 0;
}

 
int sub_420FC4(int thisx, int a2)
{
    int result; // eax

    result = thisx;
    *(_DWORD*)(thisx + 432) = 82;
    *(_BYTE*)(thisx + 272) = 0;
    if (a2)
    {
        *(_DWORD*)(thisx + 320) = 1;
        return sub_420FC4(*(_DWORD*)(thisx + 312), 0);
    }
    else
    {
        *(_DWORD*)(thisx + 320) = 0;
    }
    return result;
}

 
_DWORD* sub_42101A(_DWORD* thisx)
{
    _DWORD* result; // eax

    thisx[108] = 85;
    thisx[80] = 0;
    result = thisx;
    thisx[76] = thisx[78];
    return result;
}

 
int sub_421051(_DWORD* thisx)
{
    int result; // eax

    thisx[78] = 0;
    thisx[76] = 0;
    if (thisx[108] == 82)
        thisx[108] = 3;
    result = sub_41BEA6(thisx);
    if (result)
        thisx[35] = 0;
    return result;
}

 
int sub_4210A8(_BYTE* thisx, char a2)
{
	thisx[556] = a2;
	thisx[557] = 60;
	return sub_43FFC3((int*)unk_4BDB28, dword_4B9AB4, -1, 100, 100, 0);
}

 
_DWORD* __fastcall sub_4210E3(_DWORD* a1, int a2, int a3, unsigned __int8 a4)
{
    _DWORD* result; // eax

    if (a4 == 3)
    {
        a1[33] = 0;
        a1[32] = 0;
        result = a1;
        a1[18] = 0;
    }
    else
    {
        a1[32] = a3;
        result = a1;
        a1[18] = 0;
        if (a4 == 1)
        {
            *a1 = 6;
        }
        else
        {
            result = (_DWORD*)a4;
            if (a4 == 2)
                *a1 = 7;
        }
        a1[33] = 600;
    }
    return result;
}

 
_DWORD* sub_421175(_DWORD* thisx, int a2, int a3, int a4)
{
    _DWORD* result; // eax

    *thisx = a2;
    thisx[33] = a3;
    thisx[32] = a4;
    result = thisx;
    thisx[18] = 0;
    return result;
}

 
BOOL sub_4211AC(_BYTE* thisx)
{
    return (thisx[188] != 1 || rand() % 3 >= 2) && thisx[469] != 0;
}

 
char* sub_4211F5(int thisx)
{
	char* result; // eax

	result = (char*)sub_465E0A((char*)unk_4B9B10, thisx, 5 * (*(unsigned __int8*)(thisx + 325) / 3) + 15);
	*(_DWORD*)(thisx + 4) = (int)result;
	return result;
}

 
int sub_421238(int thisx)
{
    int v3[15]; // [esp+4h] [ebp-3Ch] BYREF

    sub_49DB90(v3);
    v3[1] = 0;
    v3[2] = 0;
    v3[3] = -1;
    v3[4] = -1;
    v3[5] = 1;
    v3[9] = 0;
    v3[0] = -1;
    if (*(_BYTE*)(thisx + 188) == 1)
    {
        if (!sub_49DA45((_DWORD*)unk_4BDC60, aGraphicMisuzuB, (int)v3))
            return 0;
        *(_DWORD*)(thisx + 196) = v3[0];
    }
    else if (*(_BYTE*)(thisx + 188) == 2 || *(_BYTE*)(thisx + 188) == 3)
    {
        if (!sub_49DA45((_DWORD*)unk_4BDC60, aStageSodokuWav, (int)v3))
            return 0;
        *(_DWORD*)(thisx + 196) = v3[0];
        *(_DWORD*)(*((_DWORD*)dword_4B9360 + *(unsigned __int8*)(thisx + 192)) + 4 * *(unsigned __int16*)(thisx + 498)) = 1;
    }
    return 1;
}

 
int sub_42132D(int thisx, int a2, int a3)
{
    int result; // eax

    *(_DWORD*)(thisx + 64) = a2;
    *(_DWORD*)(thisx + 68) = a3;
    if (*(_DWORD*)(thisx + 52))
        operator delete(*(void**)(thisx + 52));
    *(_DWORD*)(thisx + 52) = (_DWORD)operator new(2 * a3 * a2);
    if (*(_DWORD*)(thisx + 56))
        operator delete(*(void**)(thisx + 56));
    *(_DWORD*)(thisx + 56) = (_DWORD)operator new(a3 * a2);
    if (*(_DWORD*)(thisx + 60))
        operator delete(*(void**)(thisx + 60));
    *(_DWORD*)(thisx + 60) = (_DWORD)operator new(2 * a3 * a2);
    sub_4224D9((_DWORD*)thisx);
    sub_422526((_DWORD*)thisx);
    *(_DWORD*)(thisx + 116) = 80;
    result = 8 * a3 / 4;
    *(_DWORD*)(thisx + 120) = result;
    return result;
}

 
LONG sub_42142F(LONG thisx)
{
    LONG result; // eax
    int v3; // [esp+4h] [ebp-8Ch]
    LONG v4; // [esp+8h] [ebp-88h]
    int v5; // [esp+Ch] [ebp-84h]
    int v6; // [esp+18h] [ebp-78h]
    int v7; // [esp+1Ch] [ebp-74h]
    int m; // [esp+24h] [ebp-6Ch]
    int n; // [esp+28h] [ebp-68h]
    char v10; // [esp+2Ch] [ebp-64h]
    int v11; // [esp+30h] [ebp-60h]
    LONG k; // [esp+34h] [ebp-5Ch]
    LONG yTop; // [esp+38h] [ebp-58h]
    LONG yBottom; // [esp+3Ch] [ebp-54h]
    LONG j; // [esp+40h] [ebp-50h]
    LONG xRight; // [esp+44h] [ebp-4Ch]
    LONG xLeft; // [esp+48h] [ebp-48h]
    int v18; // [esp+4Ch] [ebp-44h]
    char* v19; // [esp+50h] [ebp-40h]
    int i; // [esp+54h] [ebp-3Ch]
    int v21; // [esp+64h] [ebp-2Ch]
    int v22; // [esp+64h] [ebp-2Ch]
    int v23; // [esp+6Ch] [ebp-24h]
    int v24; // [esp+70h] [ebp-20h]
    int v25; // [esp+78h] [ebp-18h]
    struct tagRECT rc; // [esp+80h] [ebp-10h] BYREF

    result = thisx;
    if (*(_DWORD*)(thisx + 52) && *(_DWORD*)(thisx + 124))
    {
        memset(*(void**)(thisx + 52), 0, 2 * *(_DWORD*)(thisx + 68) * *(_DWORD*)(thisx + 64));
        if (!sub_425D30(*(_DWORD**)(thisx + 124)))
        {
            *(_DWORD*)(thisx + 44) = sub_426090(*(_DWORD**)(thisx + 124)) / 800;
            *(_DWORD*)(thisx + 48) = sub_4260B0(*(_DWORD**)(thisx + 124)) / 800;
        }
        *(_WORD*)(*(_DWORD*)(thisx + 52) + 2 * (*(_DWORD*)(thisx + 64) * *(_DWORD*)(thisx + 48) + *(_DWORD*)(thisx + 44))) = 1;
        v23 = sub_446465((char*)unk_4B9B10) / 8;
        v21 = sub_426090(*(_DWORD**)(thisx + 124)) / 800 - v23;
        if (sub_425CD0((int*)unk_4B9B10) == 3 && (v21 < 0 || v21 >= 40))
        {
            v22 = v21 - 20;
            if (v22 >= 0)
            {
                if (v22 + 40 >= *(_DWORD*)(thisx + 64))
                    v22 = *(_DWORD*)(thisx + 64) - 40;
            }
            else
            {
                v22 = 0;
            }
            v24 = v22;
            v25 = v22 + 40;
        }
        else
        {
            v24 = v23;
            v25 = v23 + 40;
        }
        rc.right = *(_DWORD*)(thisx + 44);
        rc.left = rc.right;
        rc.bottom = *(_DWORD*)(thisx + 48);
        rc.top = rc.bottom;
        sub_41D067(*(_DWORD*)(thisx + 124), 0);
        sub_41D067(*(_DWORD*)(thisx + 124), 0);
        v19 = sub_426210((char*)unk_4B9B10);
        sub_4224A7((void*)(thisx + 124));
        for (i = 1; ; ++i)
        {
            v18 = 0;
            xLeft = rc.left;
            xRight = rc.right;
            yTop = rc.top;
            yBottom = rc.bottom;
            for (j = rc.top; ; ++j)
            {
                result = j;
                if (j > rc.bottom)
                    break;
                for (k = rc.left; k <= rc.right; ++k)
                {
                    v11 = *(_DWORD*)(thisx + 64) * j + k;
                    if (*(unsigned __int16*)(*(_DWORD*)(thisx + 52) + 2 * v11) == i)
                    {
                        v18 = 1;
                        sub_486633((int*)v19, 8 * k + 4, 8 * j + 4);
                        v10 = 1;
                        for (m = 0; m < 9; ++m)
                        {
                            if (m != 4)
                            {
                                if (m > 0)
                                    v10 *= 2;
                                v7 = m % 3 - 1 + k;
                                v6 = m / 3 - 1 + j;
                                if (v7 >= 0
                                    && v6 >= 0
                                    && v7 < *(_DWORD*)(thisx + 64)
                                    && v6 < *(_DWORD*)(thisx + 68)
                                    && v7 >= v24
                                    && v7 <= v25)
                                {
                                    v5 = *(_DWORD*)(thisx + 64) * v6 + v7;
                                    if (!*(_WORD*)(*(_DWORD*)(thisx + 52) + 2 * v5)
                                        && ((unsigned __int8)v10 & *(_BYTE*)(*(_DWORD*)(thisx + 56) + v11)) != 0)
                                    {
                                        *(_WORD*)(*(_DWORD*)(thisx + 52) + 2 * v5) = i + 1;
                                        if (v7 < xLeft)
                                            xLeft = m % 3 - 1 + k;
                                        if (v7 > xRight)
                                            xRight = m % 3 - 1 + k;
                                        if (v6 < yTop)
                                            yTop = m / 3 - 1 + j;
                                        if (v6 > yBottom)
                                            yBottom = m / 3 - 1 + j;
                                    }
                                }
                            }
                        }
                        for (n = 0; n < 2; ++n)
                        {
                            if (*(_BYTE*)(*(_DWORD*)(thisx + 60) + 2 * v11 + n))
                            {
                                v3 = *(char*)(*(_DWORD*)(thisx + 60) + 2 * v11 + n) + v11;
                                if (!*(_WORD*)(*(_DWORD*)(thisx + 52) + 2 * v3))
                                {
                                    *(_WORD*)(*(_DWORD*)(thisx + 52) + 2 * v3) = i + 1;
                                    v4 = *(char*)(*(_DWORD*)(thisx + 60) + 2 * v11 + n) + k;
                                    if (v4 < xLeft)
                                        xLeft = *(char*)(*(_DWORD*)(thisx + 60) + 2 * v11 + n) + k;
                                    if (v4 > xRight)
                                        xRight = *(char*)(*(_DWORD*)(thisx + 60) + 2 * v11 + n) + k;
                                }
                            }
                        }
                    }
                }
            }
            if (!v18)
                break;
            SetRect(&rc, xLeft, yTop, xRight, yBottom);
        }
    }
    return result;
}

 
int __fastcall sub_4219B1(_DWORD* a1)
{
    int result; // eax
    unsigned __int16 v2; // ax
    int v3; // eax
    int v4; // esi
    int v5; // ecx
    int v6; // [esp-4h] [ebp-104h]
    BOOL v7; // [esp+4h] [ebp-FCh]
    BOOL v8; // [esp+8h] [ebp-F8h]
    BOOL v9; // [esp+Ch] [ebp-F4h]
    BOOL v10; // [esp+10h] [ebp-F0h]
    int v11; // [esp+14h] [ebp-ECh]
    int v12; // [esp+18h] [ebp-E8h]
    int v13; // [esp+1Ch] [ebp-E4h]
    int v14; // [esp+20h] [ebp-E0h]
    BOOL v15; // [esp+24h] [ebp-DCh]
    BOOL v16; // [esp+28h] [ebp-D8h]
    BOOL v17; // [esp+2Ch] [ebp-D4h]
    BOOL v18; // [esp+30h] [ebp-D0h]
    BOOL v19; // [esp+34h] [ebp-CCh]
    BOOL v20; // [esp+38h] [ebp-C8h]
    BOOL v21; // [esp+3Ch] [ebp-C4h]
    BOOL v22; // [esp+40h] [ebp-C0h]
    int v24; // [esp+4Ch] [ebp-B4h]
    int v25; // [esp+50h] [ebp-B0h]
    int v26; // [esp+54h] [ebp-ACh]
    int v27; // [esp+58h] [ebp-A8h]
    int v28; // [esp+60h] [ebp-A0h]
    int v29; // [esp+68h] [ebp-98h]
    int v30; // [esp+6Ch] [ebp-94h]
    int v31; // [esp+70h] [ebp-90h]
    int i; // [esp+78h] [ebp-88h]
    int j; // [esp+78h] [ebp-88h]
    int k; // [esp+78h] [ebp-88h]
    int v35; // [esp+80h] [ebp-80h]
    int v36; // [esp+84h] [ebp-7Ch]
    char* v37; // [esp+88h] [ebp-78h]
    int v38; // [esp+8Ch] [ebp-74h]
    int v39; // [esp+90h] [ebp-70h]
    int v40; // [esp+94h] [ebp-6Ch]
    int v41; // [esp+98h] [ebp-68h]
    int v42; // [esp+9Ch] [ebp-64h]
    int v43; // [esp+A4h] [ebp-5Ch]
    int v44[9]; // [esp+ACh] [ebp-54h]
    int v45; // [esp+D0h] [ebp-30h]
    char v46; // [esp+D4h] [ebp-2Ch]
    char v47[11]; // [esp+D5h] [ebp-2Bh] BYREF
    int v48; // [esp+E0h] [ebp-20h]
    int v49; // [esp+E4h] [ebp-1Ch]
    int v50[2]; // [esp+E8h] [ebp-18h]
    int v51; // [esp+F0h] [ebp-10h]
    int v52; // [esp+F4h] [ebp-Ch]
    int v53; // [esp+F8h] [ebp-8h]
    int v54; // [esp+FCh] [ebp-4h]

    result = (int)a1;
    if (a1[13] && a1[31])
    {
        sub_4223AF((int)a1);
        v2 = sub_41D067(a1[31], 0);
        v43 = (3 * v2 / 2 + 405) * ((3 * v2 / 2 + 405) / 30) / 2;
        v37 = sub_426210((char*)unk_4B9B10);
        v6 = sub_4260B0((_DWORD*)a1[31]) / 100;
        v3 = sub_426090((_DWORD*)a1[31]);
        sub_486633((_DWORD*)v37, v3 / 100, v6);
        sub_42142F((LONG)a1);
        v51 = 100 * sub_446465((char*)unk_4B9B10);
        v49 = sub_426090((_DWORD*)a1[31]) - v51;
        v38 = a1[6] - v51;
        v53 = a1[6] / 800;
        v39 = a1[7] / 800;
        if (*a1 == 2)
            goto LABEL_9;
        if (v53 == a1[9] && v39 == a1[10] && (v4 = -a1[8], v43 > sub_4260D0((_DWORD*)a1[31]) + v4))
            a1[1] = 0;
        else
            LABEL_9:
        a1[1] = v49 >= 0 && v49 < 32000 && v38 >= 0 && v38 < 32000;
        result = (int)a1;
        if (a1[1])
        {
            v40 = *(unsigned __int16*)(a1[13] + 2 * (a1[16] * v39 + v53));
            v41 = -1;
            v45 = 0;
            v42 = a1[6] / 800;
            v54 = a1[7] / 800;
            v52 = a1[11];
            v48 = a1[12];
            result = sub_446497((_DWORD*)unk_4B9B10, a1[6] / 100, a1[7] / 100);
            v46 = 16;
            strcpy(v47, "\b ");
            v47[4] = 4;
            v47[5] = 1;
            v47[6] = 64;
            v47[7] = 2;
            while (1)
            {
                if (v53 == v52)
                {
                    result = v39;
                    if (v39 == v48)
                        break;
                }
                if (v40 == 1)
                    break;
                v45 = 0;
                for (i = 0; i < 9; ++i)
                {
                    v44[i] = 0;
                    if (i != 4)
                    {
                        v22 = i == 1 || i == 3 || i == 6;
                        v21 = !i || i == 2 || i == 5;
                        v29 = v22 - v21;
                        v20 = i == 5 || i == 6 || i == 8;
                        v19 = i == 2 || i == 3 || i == 7;
                        v31 = v29 + v53;
                        v30 = v20 - v19 + v39;
                        if (v29 + v53 >= 0
                            && v30 >= 0
                            && v31 < a1[16]
                            && v30 < a1[17]
                            && *(unsigned __int16*)(a1[13] + 2 * (a1[16] * v30 + v31)) == v40 - 1)
                        {
                            ++v45;
                            v44[i] = 1;
                        }
                    }
                }
                for (j = 0; j < 2; ++j)
                {
                    v50[j] = 0;
                    v5 = a1[15] + 2 * (a1[16] * v39 + v53);
                    v28 = *(char*)(v5 + j);
                    if (*(_BYTE*)(v5 + j) && *(unsigned __int16*)(a1[13] + 2 * (a1[16] * v39 + v28 + v53)) == v40 - 1)
                    {
                        ++v45;
                        v50[j] = v28;
                    }
                }
                v35 = -1;
                v36 = 0;
                sub_446497((_DWORD*)unk_4B9B10, 8 * v53 + 4, 8 * v39 + 4);
                result = a1[16] * v39;
                for (k = 0; k < 11; ++k)
                {
                    if (k != 4)
                    {
                        if ((result = k, v44[k] > 0) && k < 9 || v44[k + 6] && k >= 9)
                        {
                            if (k >= 9)
                            {
                                v25 = v44[k + 6];
                                v24 = 0;
                            }
                            else
                            {
                                v18 = k == 1 || k == 3 || k == 6;
                                v17 = !k || k == 2 || k == 5;
                                v25 = v18 - v17;
                                v16 = k == 5 || k == 6 || k == 8;
                                v15 = k == 2 || k == 3 || k == 7;
                                v24 = v16 - v15;
                            }
                            if ((result = v53 + v25, v27 = v53 + v25, v26 = v39 + v24, k < 9)
                                && (result = k, ((unsigned __int8)v47[k - 1] & *(_BYTE*)(a1[14] + a1[16] * v26 + v27)) != 0)
                                || k >= 9)
                            {
                                v14 = v52 - v27 <= 0 ? v27 - v52 : v52 - v27;
                                v13 = v48 - v26 <= 0 ? v26 - v48 : v48 - v26;
                                v12 = v42 - v27 <= 0 ? v27 - v42 : v42 - v27;
                                v11 = v54 - v26 <= 0 ? v26 - v54 : v54 - v26;
                                result = v11 + v12;
                                if (v35 == -1 || v11 + v12 + v13 + v14 < v36)
                                {
                                    result = k;
                                    v35 = k;
                                    v36 = v11 + v12 + v13 + v14;
                                }
                            }
                        }
                    }
                }
                if (v45 <= 0)
                    break;
                if (v35 != v41 || v35 >= 9)
                {
                    a1[9] = v53;
                    a1[10] = v39;
                    result = 100 * sub_446497((_DWORD*)unk_4B9B10, 8 * a1[9] + 4, 8 * a1[10] + 4);
                    v41 = v35;
                }
                if (v35 < 0 || v35 >= 9)
                {
                    if (v35 >= 9)
                    {
                        result = v35;
                        v53 += v44[v35 + 6];
                    }
                }
                else
                {
                    v10 = v35 == 1 || v35 == 3 || v35 == 6;
                    v9 = !v35 || v35 == 2 || v35 == 5;
                    result = v10 - v9 + v53;
                    v53 = result;
                    v8 = v35 == 5 || v35 == 6 || v35 == 8;
                    v7 = v35 == 2 || v35 == 3 || v35 == 7;
                    v39 += v8 - v7;
                }
                --v40;
            }
        }
    }
    return result;
} 
int __fastcall sub_4223AF(int a1)
{
    int result; // eax

    result = a1;
    if (*(_DWORD*)a1 != 2)
    {
        if (*(_DWORD*)a1 == 3 && *(_DWORD*)(a1 + 72))
        {
            *(_DWORD*)(a1 + 24) = sub_426470(*(_DWORD**)(a1 + 72));
            *(_DWORD*)(a1 + 28) = sub_426530(*(_DWORD**)(a1 + 72));
            result = (int)UMSFreeVirtualProcessorRoot::GetExecutingProxy(*(UMSFreeVirtualProcessorRoot**)(a1 + 72));
            *(_DWORD*)(a1 + 32) = result;
        }
        else if (*(_DWORD*)a1 == 4 && (result = a1, *(_DWORD*)(a1 + 76)))
        {
            *(_DWORD*)(a1 + 24) = 100 * unknown_libname_22(*(_DWORD**)(a1 + 76));
            *(_DWORD*)(a1 + 28) = 100 * unknown_libname_26(*(_DWORD**)(a1 + 76));
            result = 100 * unknown_libname_12(*(_DWORD**)(a1 + 76));
            *(_DWORD*)(a1 + 32) = result;
        }
        else if (*(_DWORD*)(a1 + 128))
        {
            *(_DWORD*)(a1 + 24) = sub_426090(*(_DWORD**)(a1 + 128));
            *(_DWORD*)(a1 + 28) = sub_4260B0(*(_DWORD**)(a1 + 128));
            result = sub_4260D0(*(_DWORD**)(a1 + 128));
            *(_DWORD*)(a1 + 32) = result;
        }
    }
    return result;
}

 
int sub_4224A7(void* thisx)
{
    int v2; // [esp+4h] [ebp-4h]

    v2 = sub_41CA5F((int)thisx, 0) + 5;
    if (v2 < 50)
        return 50;
    return v2;
}

 
int sub_4224D9(_DWORD* thisx)
{
	int v2; // [esp-10h] [ebp-24h] BYREF
	_DWORD* v3; // [esp+0h] [ebp-14h]
	struct tagRECT rc; // [esp+4h] [ebp-10h] BYREF

	v3 = thisx;
	SetRect(&rc, 0, 0, thisx[16], thisx[17]);
	return sub_424C9A(v3, (int)&v2, rc.left, rc.top, rc.right, rc.bottom);
}

 
_DWORD* sub_422526(int* thisx)
{
	struct tagRECT rc; // [esp+4h] [ebp-10h] BYREF

	SetRect(&rc, 0, 0, thisx[16], thisx[17]);
	return sub_425617(thisx, rc.left, rc.top, rc.right, rc.bottom);
}

 
int __fastcall sub_422573(_DWORD* a1)
{
    int result; // eax
    int v2; // eax
    int v3; // [esp+0h] [ebp-44h]
    int v4; // [esp+4h] [ebp-40h]
    unsigned __int8 v6; // [esp+Ch] [ebp-38h]
    int j; // [esp+10h] [ebp-34h]
    SchedulerBase* v8; // [esp+14h] [ebp-30h]
    int v9; // [esp+18h] [ebp-2Ch]
    int v10; // [esp+1Ch] [ebp-28h]
    int v11; // [esp+20h] [ebp-24h]
    int v12; // [esp+24h] [ebp-20h]
    char v13[16]; // [esp+28h] [ebp-1Ch] BYREF
    int v14; // [esp+38h] [ebp-Ch]
    int i; // [esp+3Ch] [ebp-8h]
    int v16; // [esp+40h] [ebp-4h]

    result = (int)a1;
    if (a1[31])
    {
        LOBYTE(v16) = sub_426070((char*)a1[31]);
        memset(a1 + 25, 0, 0x10u);
        v14 = sub_446465((char*)&unk_4B9B10);
        result = (int)memset(v13, 0, sizeof(v13));
        for (i = 0; i < 8; ++i)
        {
            result = sub_446714(unk_4B9B10,i);
            v8 = (SchedulerBase*)result;
            if (result)
            {
                result = unknown_libname_7((_DWORD*)result);
                if (result)
                {
                    result = (unsigned __int8)sub_426070((char*)v8);
                    if (result != (unsigned __int8)v16)
                    {
                        result = (int)SchedulerBase::GetSchedulerProxy(v8);
                        if (result != 80)
                        {
                            v2 = sub_426090((_DWORD*)v8);
                            v11 = v2 / 100 - v14;
                            result = sub_4260B0((_DWORD*)v8) / 100;
                            v9 = result;
                            if (v11 >= 0 && v11 < 320)
                            {
                                v12 = v11 / a1[29];
                                v10 = result / a1[30];
                                result = v12;
                                if (!v13[4 * v10 + v12])
                                {
                                    result = v9 / a1[30];
                                    v13[4 * v10 + v12] = 1;
                                    for (j = 0; j < 16; ++j)
                                    {
                                        if (v12 - j % 4 <= 0)
                                            v4 = j % 4 - v12;
                                        else
                                            v4 = v12 - j % 4;
                                        if (v10 - j / 4 <= 0)
                                            v3 = j / 4 - v10;
                                        else
                                            v3 = v10 - j / 4;
                                        v6 = v4 + v3 + 1;
                                        if (!*((_BYTE*)a1 + j + 100) || *((unsigned __int8*)a1 + j + 100) > (int)v6)
                                            *((_BYTE*)a1 + j + 100) = v6;
                                        result = j + 1;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return result;
}

 
int sub_4227A2(_DWORD* thisx)
{
    int result; // eax
    unsigned int v2; // esi
    int v4; // [esp+8h] [ebp-5Ch]
    int v5; // [esp+Ch] [ebp-58h]
    int v6; // [esp+10h] [ebp-54h]
    int v7; // [esp+14h] [ebp-50h]
    int v8; // [esp+18h] [ebp-4Ch]
    int v9; // [esp+1Ch] [ebp-48h]
    int v10; // [esp+20h] [ebp-44h]
    int v11; // [esp+24h] [ebp-40h]
    int v12; // [esp+28h] [ebp-3Ch]
    int v13; // [esp+2Ch] [ebp-38h]
    int v14; // [esp+34h] [ebp-30h]
    int i; // [esp+44h] [ebp-20h]
    int j; // [esp+44h] [ebp-20h]
    int k; // [esp+44h] [ebp-20h]
    int v18; // [esp+48h] [ebp-1Ch]
    char v19[16]; // [esp+4Ch] [ebp-18h]
    int v20; // [esp+5Ch] [ebp-8h]
    int v21; // [esp+60h] [ebp-4h]

    result = (thisx[6] / 100 - sub_446465((char*)unk_4B9B10)) / thisx[29] + 4 * (thisx[7] / 100 / thisx[30]);
    v21 = result;
    if (result < 0 || v21 >= 16)
    {
        v20 = 0;
        v18 = 0;
    }
    else
    {
        v20 = *((unsigned __int8*)thisx + v21 + 100);
        result = v20;
        v18 = v20;
    }
    v14 = 0;
    for (i = 0; i < 16; ++i)
    {
        result = (int)thisx + i;
        if (v20 < *((unsigned __int8*)thisx + i + 100))
        {
            result = *((unsigned __int8*)thisx + i + 100);
            v20 = result;
        }
    }
    if (v18 != v20)
    {
        for (j = 0; j < 16; ++j)
        {
            if (v20 == *((unsigned __int8*)thisx + j + 100))
                v19[v14++] = j;
        }
        result = thisx[30] / 8;
    LABEL_17:
        if (v14 > 0)
        {
            v9 = rand() % v14--;
            v11 = (unsigned __int8)v19[v9];
            v19[v9] = v19[v14];
            v2 = thisx[29] * (v11 & 0x80000003) + thisx[29] / 2;
            v13 = (int)(v2 + sub_446465((char*)unk_4B9B10)) / 8;
            v12 = (thisx[30] / 2 + thisx[30] * (v11 / 4)) / 8;
            v10 = 0;
            while (1)
            {
                v4 = 4 * v10;
                if (!(4 * v10))
                    v4 = 1;
                v6 = v13;
                v5 = v12 - v10;
                v8 = 1;
                v7 = 1;
                for (k = 0;
                    k < v4
                    && (v6 < 0 || v6 >= thisx[16] || v5 < 0 || v5 >= thisx[17] || !*(_WORD*)(thisx[13] + 2 * (thisx[16] * v5 + v6)));
                    ++k)
                {
                    v6 += v8;
                    v5 += v7;
                    if (v5 == v12)
                        v8 = -v8;
                    if (v6 == v13)
                        v7 = -v7;
                }
                if (k < v4)
                    break;
                if (++v10 > thisx[29] / 8)
                {
                    result = thisx[30] / 8;
                    if (v10 > result)
                        goto LABEL_17;
                }
            }
            thisx[6] = 800 * v6 + 400;
            thisx[7] = 800 * v5 + 400;
            result = sub_446497((int*)unk_4B9B10, thisx[6] / 100, thisx[7] / 100);
            thisx[8] = result;
        }
    }
    return result;
}

 
int  sub_422B03(_DWORD* thisx, int a1, int a2)
{
	int v4; // [esp-10h] [ebp-24h] BYREF
	_DWORD* v5; // [esp+0h] [ebp-14h]
	struct tagRECT rc; // [esp+4h] [ebp-10h] BYREF

	v5 = thisx;
	SetRect(&rc, a1 - 1, a2 - 1, a1 + 2, a2 + 2);
	return sub_424C9A(v5, (int)&v4, rc.left, rc.top, rc.right, rc.bottom);
}

 
int sub_422B5C(int thisx, int a2, int a3, int a4, int a5, __int16 a6, char a7)
{
    int result; // eax

    *(_DWORD*)(thisx + 392) = 1;
    *(_DWORD*)(thisx + 372) = a2 - *(_DWORD*)(thisx + 328);
    *(_DWORD*)(thisx + 376) = a3 - *(_DWORD*)(thisx + 332);
    *(_DWORD*)(thisx + 348) = a4 - *(_DWORD*)(thisx + 336);
    *(_DWORD*)(thisx + 424) = a5;
    *(_BYTE*)(thisx + 212) = 0;
    *(_WORD*)(thisx + 204) = a6;
    result = thisx;
    *(_BYTE*)(thisx + 223) = a7;
    return result;
}

 
char sub_422BE5(int thisx)
{
    if (*(_DWORD*)(thisx + 524))
        return *(_BYTE*)(thisx + 536);
    else
        return *(_BYTE*)(thisx + 192);
}

 
int sub_422C10(const char* thisx, LPSTR a2)
{
    return wsprintfA(a2, "%s", thisx + 484);
}

 
int sub_422C3A(int thisx, HANDLE hFile, int a3)
{
    int v3; // eax
    int i; // [esp+4h] [ebp-178h]
    LPVOID v7[12]; // [esp+8h] [ebp-174h]
    int j; // [esp+38h] [ebp-144h]
    LPVOID lpBuffer[11]; // [esp+3Ch] [ebp-140h]
    int v10; // [esp+68h] [ebp-114h]
    int k; // [esp+6Ch] [ebp-110h]
    __int16 Buffer; // [esp+74h] [ebp-108h] BYREF
    DWORD NumberOfBytesRead; // [esp+78h] [ebp-104h] BYREF

    ReadFile(hFile, (LPVOID)(thisx + 484), 0xBu, (LPDWORD)&NumberOfBytesRead, 0);
    ReadFile(hFile, (LPVOID)(thisx + 190), 2u, (LPDWORD)&NumberOfBytesRead, 0);
    if (dword_4B936C <= *(unsigned __int16*)(thisx + 190))
        *(_WORD*)(thisx + 190) = 0;
    ReadFile(hFile, (LPVOID)(thisx + 192), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    v3 = ReadFile(hFile, &Buffer, 2u, (LPDWORD)&NumberOfBytesRead, 0);
    LOWORD(v3) = Buffer;
    v10 = sub_47C20C(v3);
    if (v10 < 0)
        *(_WORD*)(thisx + 498) = 0;
    else
        *(_WORD*)(thisx + 498) = v10;
    ReadFile(hFile, (LPVOID)(thisx + 195), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    if (a3 > 2)
    {
        v7[0] = (LPVOID)(thisx + 496);
        v7[1] = (LPVOID)(thisx + 500);
        v7[2] = (LPVOID)(thisx + 214);
        v7[3] = (LPVOID)(thisx + 502);
        v7[4] = (LPVOID)(thisx + 504);
        v7[5] = (LPVOID)(thisx + 506);
        v7[6] = (LPVOID)(thisx + 508);
        v7[7] = (LPVOID)(thisx + 510);
        v7[8] = (LPVOID)(thisx + 514);
        v7[9] = (LPVOID)(thisx + 516);
        v7[10] = (LPVOID)(thisx + 518);
        v7[11] = (LPVOID)(thisx + 512);
        for (i = 0; i < 12; ++i)
            ReadFile(hFile, v7[i], 2u, (LPDWORD)&NumberOfBytesRead, 0);
    }
    else
    {
        lpBuffer[0] = (LPVOID)(thisx + 496);
        lpBuffer[1] = (LPVOID)(thisx + 500);
        lpBuffer[2] = (LPVOID)(thisx + 502);
        lpBuffer[3] = (LPVOID)(thisx + 504);
        lpBuffer[4] = (LPVOID)(thisx + 506);
        lpBuffer[5] = (LPVOID)(thisx + 508);
        lpBuffer[6] = (LPVOID)(thisx + 510);
        lpBuffer[7] = (LPVOID)(thisx + 514);
        lpBuffer[8] = (LPVOID)(thisx + 516);
        lpBuffer[9] = (LPVOID)(thisx + 518);
        lpBuffer[10] = (LPVOID)(thisx + 512);
        for (j = 0; j < 11; ++j)
            ReadFile(hFile, lpBuffer[j], 2u, (LPDWORD)&NumberOfBytesRead, 0);
    }
    for (k = 0; k < 3; ++k)
        ReadFile(hFile, (LPVOID)(thisx + k + 520), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    ReadFile(hFile, (LPVOID)(thisx + 193), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    ReadFile(hFile, (LPVOID)(thisx + 194), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    ReadFile(hFile, (LPVOID)(thisx + 186), 2u, (LPDWORD)&NumberOfBytesRead, 0);
    ReadFile(hFile, (LPVOID)(thisx + 188), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    ReadFile(hFile, (LPVOID)(thisx + 168), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    InternalContextBase::UNSAFE_SetVirtualProcessor(
        (InternalContextBase*)thisx,
        (struct VirtualProcessor*)1);
    *(_DWORD*)(thisx + 524) = 0;
    *(_WORD*)(thisx + 528) = *(_WORD*)(thisx + 190);
    *(_BYTE*)(thisx + 536) = *(_BYTE*)(thisx + 192);
    *(_WORD*)(thisx + 530) = *(_WORD*)(thisx + 498);
    *(_WORD*)(thisx + 538) = *(_WORD*)(thisx + 502);
    *(_WORD*)(thisx + 540) = *(_WORD*)(thisx + 504);
    *(_WORD*)(thisx + 542) = *(_WORD*)(thisx + 506);
    *(_WORD*)(thisx + 544) = *(_WORD*)(thisx + 508);
    *(_WORD*)(thisx + 546) = *(_WORD*)(thisx + 510);
    *(_WORD*)(thisx + 548) = *(_WORD*)(thisx + 512);
    *(_WORD*)(thisx + 550) = *(_WORD*)(thisx + 514);
    *(_WORD*)(thisx + 552) = *(_WORD*)(thisx + 516);
    *(_WORD*)(thisx + 554) = *(_WORD*)(thisx + 518);
    return 1;
}

 
int sub_4231E6(unsigned __int16* thisx, HANDLE hFile)
{
    DWORD NumberOfBytesWritten; // [esp+4h] [ebp-140h] BYREF
    int i; // [esp+8h] [ebp-13Ch]
    __int16 Buffer; // [esp+10h] [ebp-134h] BYREF
    LPCVOID lpBuffer[76]; // [esp+14h] [ebp-130h]

    WriteFile(hFile, thisx + 242, 0xBu, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, thisx + 95, 2u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, thisx + 96, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    Buffer = unknown_libname_22((int*)dword_4B93A4 + 24 * thisx[249]);
    WriteFile(hFile, &Buffer, 2u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, (char*)thisx + 195, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    lpBuffer[0] = thisx + 248;
    lpBuffer[1] = thisx + 250;
    lpBuffer[2] = thisx + 107;
    lpBuffer[3] = thisx + 251;
    lpBuffer[4] = thisx + 252;
    lpBuffer[5] = thisx + 253;
    lpBuffer[6] = thisx + 254;
    lpBuffer[7] = thisx + 255;
    lpBuffer[8] = thisx + 257;
    lpBuffer[9] = thisx + 258;
    lpBuffer[10] = thisx + 259;
    lpBuffer[11] = thisx + 256;
    for (i = 0; i < 12; ++i)
        WriteFile(hFile, lpBuffer[i], 2u, (LPDWORD)&NumberOfBytesWritten, 0);
    for (i = 0; i < 3; ++i)
        WriteFile(hFile, (char*)thisx + i + 520, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, (char*)thisx + 193, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, thisx + 97, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, thisx + 93, 2u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, thisx + 94, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, thisx + 84, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    return 1;
}


 
int sub_4234E6(int thisx, int a2)
{
    int result; // eax
    int v3; // [esp+0h] [ebp-28h]
    char v4; // [esp+4h] [ebp-24h]
    int v5; // [esp+8h] [ebp-20h]
    int v6; // [esp+Ch] [ebp-1Ch]
    __int16 v7; // [esp+14h] [ebp-14h]
    int v8; // [esp+18h] [ebp-10h]
    int v9; // [esp+1Ch] [ebp-Ch]
    int v10; // [esp+20h] [ebp-8h]

    v9 = 1000 - ((a2 > 0) - (a2 < 0)) * (50 * *(char*)(thisx + 593) + 2 * *(__int16*)(thisx + 594));
    if (v9 <= 0)
        v9 = 1;
    v10 = v9 * a2 / 100;
    if (!v10)
    {
        if (a2 <= 0)
            v6 = (a2 >= 0) - 1;
        else
            v6 = 1;
        v10 = v6;
    }
    *(_DWORD*)(thisx + 584) += v10;
    v8 = *(_DWORD*)(thisx + 584) / 50;
    if (v8 <= 0)
        v5 = *(_DWORD*)(thisx + 584) / -50;
    else
        v5 = *(_DWORD*)(thisx + 584) / 50;
    if (v5)
    {
        *(_DWORD*)(thisx + 580) += v8;
        *(_DWORD*)(thisx + 588) += v8;
        if (!*(_BYTE*)(thisx + 593))
        {
            *(_DWORD*)(thisx + 580) += a2 / 10;
            *(_DWORD*)(thisx + 588) += a2 / 10;
        }
        if (a2 <= 0)
            v4 = (a2 >= 0) - 1;
        else
            v4 = 1;
        *(_BYTE*)(thisx + 593) += v4;
        *(_WORD*)(thisx + 594) += a2;
        *(int*)(thisx + 584) %= 50;
        *(_BYTE*)(thisx + 592) = 60;
    }
    if (*(char*)(thisx + 593) * *(__int16*)(thisx + 594) <= 0)
        v3 = -(*(char*)(thisx + 593) * *(__int16*)(thisx + 594));
    else
        v3 = *(char*)(thisx + 593) * *(__int16*)(thisx + 594);
    v7 = v3 + 30;
    if (v3 + 30 > 0xFFFF)
        v7 = -1;
    result = thisx;
    *(_WORD*)(thisx + 596) = v7;
    return result;
}

 
int sub_42371C(int thisx)
{
    int v1; // eax
    int v2; // eax
    int v3; // et2
    int v4; // edx
    int result; // eax
    int k; // [esp+4h] [ebp-Ch]
    unsigned __int8 j; // [esp+8h] [ebp-8h]
    int i; // [esp+Ch] [ebp-4h]

    for (i = 0; i < 3; ++i)
    {
        if (*(unsigned __int8*)(i + thisx + 520) == 255)
        {
            v1 = rand();
            v3 = v1 % 73;
            v2 = v1 / 73;
            for (j = v3; ; j = (j + 74) % 73)
            {
                v4 = 1;
                for (k = 0; k < 3; ++k)
                {
                    LOBYTE(v4) = *(_BYTE*)(k + thisx + 520);
                    LOBYTE(v2) = j;
                    if (sub_47744C(v2, v4))
                        break;
                    v2 = k + 1;
                }
                if (k == 3)
                    break;
                v2 = (j + 74) / 73;
            }
            *(_BYTE*)(i + thisx + 520) = j;
        }
    }
    *(_DWORD*)(thisx + 524) = 0;
    *(_WORD*)(thisx + 528) = *(_WORD*)(thisx + 190);
    *(_BYTE*)(thisx + 536) = *(_BYTE*)(thisx + 192);
    *(_WORD*)(thisx + 530) = *(_WORD*)(thisx + 498);
    *(_WORD*)(thisx + 538) = *(_WORD*)(thisx + 502);
    *(_WORD*)(thisx + 540) = *(_WORD*)(thisx + 504);
    *(_WORD*)(thisx + 542) = *(_WORD*)(thisx + 506);
    *(_WORD*)(thisx + 544) = *(_WORD*)(thisx + 508);
    *(_WORD*)(thisx + 546) = *(_WORD*)(thisx + 510);
    *(_WORD*)(thisx + 548) = *(_WORD*)(thisx + 512);
    *(_WORD*)(thisx + 550) = *(_WORD*)(thisx + 514);
    *(_WORD*)(thisx + 552) = *(_WORD*)(thisx + 516);
    result = thisx;
    *(_WORD*)(thisx + 554) = *(_WORD*)(thisx + 518);
    return result;
}

 
int sub_4238DE(int thisx, SchedulerProxy* a2)
{
    int result; // eax

    if (*(_DWORD*)(thisx + 392))
        *(_DWORD*)(thisx + 432) = 50;
    else
        *(_DWORD*)(thisx + 432) = 3;
    sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A1C, -1, 100, 100, 0);
    sub_41F24C(thisx, a2);
    if (*(char*)(thisx + 230) > 0 && *(char*)(thisx + 230) < 5)
        *(_BYTE*)(thisx + 230) = 5;
    if (*(char*)(thisx + 231) > 0 && *(char*)(thisx + 231) < 5)
        *(_BYTE*)(thisx + 231) = 5;
    if (*(char*)(thisx + 233) > 0 && *(char*)(thisx + 233) < 5)
        *(_BYTE*)(thisx + 233) = 5;
    result = *(char*)(thisx + 234);
    if (result > 0 && *(char*)(thisx + 234) < 5)
    {
        result = thisx;
        *(_BYTE*)(thisx + 234) = 5;
    }
    return result;
}

 
int sub_4239D3(int thisx, __int16 a2)
{
    int result; // eax
    int v3; // [esp+4h] [ebp-8h]

    if (*(_BYTE*)(thisx + 188) == 2 || (result = *(unsigned __int8*)(thisx + 188), result == 3))
    {
        v3 = *(__int16*)(thisx + 600) / 100;
        *(_WORD*)(thisx + 600) += a2;
        if (*(__int16*)(thisx + 600) <= 300)
        {
            if (*(__int16*)(thisx + 600) < 0)
                *(_WORD*)(thisx + 600) = 0;
        }
        else
        {
            *(_WORD*)(thisx + 600) = 300;
        }
        result = *(__int16*)(thisx + 600) / 100;
        if (v3 < result)
        {
            if (result >= 3)
                return sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
            else
                return sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9AB4, -1, 100, 100, 0);
        }
    }
    return result;
}

 
__int16 sub_423AC3(int thisx, int a2)
{
    int v4; // [esp+4h] [ebp-Ch]
    int v5; // [esp+8h] [ebp-8h]
    unsigned __int16 v6; // [esp+Ch] [ebp-4h]

    v6 = *(_WORD*)(thisx + 518);
    if (sub_41BA53(thisx, 0x83u, 0))
    {
        v5 = 100 * *(unsigned __int16*)(thisx + 214) / *(unsigned __int16*)(thisx + 500);
        if (v5 >= 10)
        {
            if (v5 >= 20)
            {
                if (v5 >= 30)
                {
                    if (v5 >= 40)
                    {
                        if (v5 < 50)
                            v6 = 110 * v6 / 100;
                    }
                    else
                    {
                        v6 = 120 * v6 / 100;
                    }
                }
                else
                {
                    v6 = 130 * v6 / 100;
                }
            }
            else
            {
                v6 = 140 * v6 / 100;
            }
        }
        else
        {
            v6 = 150 * v6 / 100;
        }
    }
    if (sub_41BA53(thisx, 0x82u, 0))
    {
        v4 = 100 * *(unsigned __int16*)(thisx + 214) / *(unsigned __int16*)(thisx + 500);
        if (v4 >= 10)
        {
            if (v4 >= 20)
            {
                if (v4 >= 30)
                {
                    if (v4 >= 40)
                    {
                        if (v4 < 50)
                            v6 = 110 * v6 / 100;
                    }
                    else
                    {
                        v6 = 120 * v6 / 100;
                    }
                }
                else
                {
                    v6 = 130 * v6 / 100;
                }
            }
            else
            {
                v6 = 140 * v6 / 100;
            }
        }
        else
        {
            v6 = 150 * v6 / 100;
        }
    }
    if (sub_41BA53(thisx, 0x8Cu, 0) && *(_BYTE*)(thisx + 609) == 11)
        v6 += *(_WORD*)(thisx + 496) + 10;
    if (v6)
        return v6;
    else
        return 1;
}

 
_BYTE* sub_423CF2(_BYTE* thisx, char a2, char a3, char a4, char a5, char a6, char a7)
{
	_BYTE* result; // eax

	thisx[602] = a2;
	thisx[603] = a3;
	thisx[604] = a4;
	result = thisx;
	thisx[605] = a5;
	LOBYTE(result) = a6;
	thisx[606] = a6;
	thisx[607] = a7;
	return result;
}

 
char sub_423D47(_DWORD* thisx)
{
    int v1; // ecx
    int v2; // eax
    BOOL v4; // [esp+0h] [ebp-4Ch]
    BOOL v5; // [esp+4h] [ebp-48h]
    BOOL v6; // [esp+8h] [ebp-44h]
    BOOL v7; // [esp+Ch] [ebp-40h]
    int j; // [esp+18h] [ebp-34h]
    int v10; // [esp+1Ch] [ebp-30h]
    int v11; // [esp+20h] [ebp-2Ch]
    int v12; // [esp+2Ch] [ebp-20h]
    int v13; // [esp+30h] [ebp-1Ch]
    char v14; // [esp+34h] [ebp-18h]
    char v15[8]; // [esp+3Ch] [ebp-10h]
    int i; // [esp+44h] [ebp-8h]
    int v17; // [esp+48h] [ebp-4h]

    v15[0] = 1;
    v15[1] = 1;
    v15[2] = 1;
    v15[3] = 1;
    v15[4] = 1;
    v15[5] = 1;
    v15[6] = 1;
    v15[7] = 1;
    v14 = 9;
    for (i = 0; i < 8; ++i)
    {
        v13 = sub_426090((_DWORD*)thisx[31]) / 100;
        v12 = sub_4260B0((_DWORD*)thisx[31]) / 100;
        v11 = v13 / 8;
        v10 = v12 / 8;
        v7 = i == 1 || i == 2 || i == 3;
        v6 = i == 5 || i == 6 || i == 7;
        v5 = i == 3 || i == 4 || i == 5;
        v4 = !i || i == 1 || i == 7;
        for (j = 0; j < 24; ++j)
        {
            v1 = v13 + 2 * (v7 - v6);
            v13 = v1;
            v12 += v5 - v4;
            if (v11 != v1 / 8 || v10 != v12 / 8)
            {
                v11 = v1 / 8;
                v2 = v12 / 8;
                v10 = v12 / 8;
                LOBYTE(v2) = v12 / 8;
                LOBYTE(v1) = v1 / 8;
                if (!sub_4773CC(v1, v2))
                {
                    v15[i] = 0;
                    --v14;
                    break;
                }
            }
        }
    }
    v17 = rand() % v14;
    if (!v17)
        return 0;
    for (i = 0; i < 8; ++i)
    {
        if (v15[i] == 1)
            --v17;
        if (v17 <= 0)
            return i + 1;
    }
    return 0;
}

 
int sub_423F94(_DWORD* thisx, int a2, int a3)
{
    int v3; // eax
    int v4; // ecx
    int v6; // [esp+0h] [ebp-50h]
    int v7; // [esp+4h] [ebp-4Ch]
    int v8; // [esp+8h] [ebp-48h]
    int v9; // [esp+Ch] [ebp-44h]
    int v10; // [esp+10h] [ebp-40h]
    int v11; // [esp+14h] [ebp-3Ch]
    int v13; // [esp+20h] [ebp-30h]
    int v14; // [esp+28h] [ebp-28h]
    int i; // [esp+2Ch] [ebp-24h]
    int v16; // [esp+38h] [ebp-18h]
    int v17; // [esp+3Ch] [ebp-14h]
    int v18; // [esp+40h] [ebp-10h]
    int v19; // [esp+44h] [ebp-Ch]

    v14 = sub_426090((_DWORD*)thisx[31]) / 800;
    v13 = sub_4260B0((_DWORD*)thisx[31]) / 800;
    if (a2 <= 0)
        v11 = -a2;
    else
        v11 = a2;
    if (a3 <= 0)
        v10 = -a3;
    else
        v10 = a3;
    if (a2 <= 0)
        v9 = (a2 >= 0) - 1;
    else
        v9 = 1;
    if (a3 <= 0)
        v8 = (a3 >= 0) - 1;
    else
        v8 = 1;
    if (v14 - (a2 + sub_426090((_DWORD*)thisx[31])) / 800 <= 0)
        v7 = (a2 + sub_426090((_DWORD*)thisx[31])) / 800 - v14;
    else
        v7 = v14 - (a2 + sub_426090((_DWORD*)thisx[31])) / 800;
    if (v13 - (a3 + sub_4260B0((_DWORD*)thisx[31])) / 800 <= 0)
        v6 = (a3 + sub_4260B0((_DWORD*)thisx[31])) / 800 - v13;
    else
        v6 = v13 - (a3 + sub_4260B0((_DWORD*)thisx[31])) / 800;
    v19 = v7;
    v16 = v11;
    if (v11 < v10)
    {
        v19 = v6;
        v16 = v10;
    }
    v18 = 0;
    v17 = 0;
    for (i = 0; i < v19; ++i)
    {
        v18 += v11;
        if (v18 >= v16)
        {
            v14 += v9;
            v18 -= v16;
        }
        v3 = v10 + v17;
        v17 += v10;
        v4 = v17;
        if (v17 >= v16)
        {
            v13 += v8;
            v3 = v17 - v16;
            v17 -= v16;
        }
        if (v14 >= 0)
        {
            v4 = (int)thisx;
            if (v14 >= thisx[16])
            {
                v3 = (int)thisx;
                v4 = thisx[16] - 1;
                v14 = v4;
            }
        }
        else
        {
            v14 = 0;
        }
        if (v13 >= 0)
        {
            v3 = v13;
            if (v13 >= thisx[17])
            {
                v4 = (int)thisx;
                v13 = thisx[17] - 1;
            }
        }
        else
        {
            v13 = 0;
        }
        if (v9)
        {
            v4 = thisx[15] + 2 * (thisx[16] * v13 + v14);
            v3 = (v9 + 1) / 2;
            if (*(_BYTE*)(v4 + v3))
                return 1;
        }
        LOBYTE(v3) = v13;
        LOBYTE(v4) = v14;
        if (!sub_4773CC(v4, v3))
            return 0;
    }
    return 1;
}

 
void* sub_42424D(void* thisx)
{
    return memset(thisx, 0, 4u);
}

 
char sub_424268(_DWORD* thisx)
{
    int v1; // ecx
    int v2; // eax
    BOOL v4; // [esp+0h] [ebp-4Ch]
    BOOL v5; // [esp+4h] [ebp-48h]
    BOOL v6; // [esp+8h] [ebp-44h]
    BOOL v7; // [esp+Ch] [ebp-40h]
    int j; // [esp+18h] [ebp-34h]
    int v10; // [esp+1Ch] [ebp-30h]
    int v11; // [esp+20h] [ebp-2Ch]
    int v12; // [esp+2Ch] [ebp-20h]
    int v13; // [esp+30h] [ebp-1Ch]
    char v14; // [esp+34h] [ebp-18h]
    char v15[8]; // [esp+3Ch] [ebp-10h]
    int i; // [esp+44h] [ebp-8h]
    int v17; // [esp+48h] [ebp-4h]

    v15[0] = 1;
    v15[1] = 1;
    v15[2] = 1;
    v15[3] = 1;
    v15[4] = 1;
    v15[5] = 1;
    v15[6] = 1;
    v15[7] = 1;
    v14 = 9;
    for (i = 0; i < 8; ++i)
    {
        v13 = sub_426090((_DWORD*)thisx[31]) / 100;
        v12 = sub_4260B0((_DWORD*)thisx[31]) / 100;
        v11 = v13 / 8;
        v10 = v12 / 8;
        v7 = i == 1 || i == 2 || i == 3;
        v6 = i == 5 || i == 6 || i == 7;
        v5 = i == 3 || i == 4 || i == 5;
        v4 = !i || i == 1 || i == 7;
        for (j = 0; j < 24; ++j)
        {
            v1 = v13 + 4 * (v7 - v6);
            v13 = v1;
            v12 += v5 - v4;
            if (v11 != v1 / 8 || v10 != v12 / 8)
            {
                v11 = v1 / 8;
                v2 = v12 / 8;
                v10 = v12 / 8;
                LOBYTE(v2) = v12 / 8;
                LOBYTE(v1) = v1 / 8;
                if (!sub_4773CC(v1, v2))
                {
                    v15[i] = 0;
                    --v14;
                    break;
                }
            }
        }
    }
    v17 = rand() % v14;
    if (!v17)
        return 0;
    for (i = 0; i < 8; ++i)
    {
        if (v15[i] == 1)
            --v17;
        if (v17 <= 0)
            return i + 1;
    }
    return 0;
}

 
BOOL sub_4244B5(_DWORD* thisx, int a2, int a3)
{
    int v3; // edx
    int v4; // ecx
    int v7; // [esp+4h] [ebp-8h]
    int v8; // [esp+8h] [ebp-4h]

    v8 = (a2 + sub_426090((_DWORD*)thisx[31])) / 800;
    v7 = (a3 + sub_4260B0((_DWORD*)thisx[31])) / 800;
    if (v8 < 0)
        v8 = 0;
    v3 = (int)thisx;
    if (thisx[16] <= v8)
    {
        v3 = thisx[16] - 1;
        LOBYTE(v8) = v3;
    }
    if (v7 < 0)
        v7 = 0;
    v4 = thisx[17];
    if (v4 <= v7)
    {
        v3 = (int)thisx;
        v7 = thisx[17] - 1;
    }
    LOBYTE(v4) = v7;
    LOBYTE(v3) = v8;
    return sub_4773CC(v3, v4) != 0;
}

 
void sub_42455B(int thisx, __int16* a2)
{
    char* v2; // eax
    int v3; // esi
    int v4; // edi
    int v5; // [esp+Ch] [ebp-50h]
    int v6; // [esp+10h] [ebp-4Ch]
    int v8; // [esp+1Ch] [ebp-40h]
    int v9; // [esp+20h] [ebp-3Ch]
    int v10; // [esp+24h] [ebp-38h]
    int v11; // [esp+28h] [ebp-34h]
    int v12; // [esp+2Ch] [ebp-30h]
    int v13; // [esp+30h] [ebp-2Ch] BYREF
    int v14; // [esp+38h] [ebp-24h]
    int v15; // [esp+3Ch] [ebp-20h]
    int i; // [esp+40h] [ebp-1Ch]
    int v17[6]; // [esp+44h] [ebp-18h]

    v17[0] = thisx + 372;
    v17[1] = thisx + 376;
    v17[2] = thisx + 348;
    v17[3] = thisx + 352;
    v17[4] = thisx + 356;
    v17[5] = thisx + 360;
    if (*((_BYTE*)a2 + 10))
    {
        sub_41F6DE((_DWORD*)thisx);
        if (*(_DWORD*)(thisx + 304))
        {
            if (*(_DWORD*)(thisx + 288))
            {
                sub_417E42(*(_DWORD*)(thisx + 304));
                sub_417E1D((_DWORD*)thisx);
            }
            else if (*(_DWORD*)(thisx + 428) == 52 || *(_DWORD*)(thisx + 428) == 53 || *(_DWORD*)(thisx + 428) == 56)
            {
                sub_417FC1(*(_DWORD*)(thisx + 304));
                sub_417EE0(thisx);
            }
            else if (*(_DWORD*)(thisx + 428) == 54 || *(_DWORD*)(thisx + 428) == 55)
            {
                sub_417EE0(*(_DWORD*)(thisx + 304));
                sub_417FC1(thisx);
            }
            else
            {
                sub_417DCC(*(_DWORD*)(thisx + 304));
                *(_DWORD*)(thisx + 304) = 0;
                sub_423CF2((_BYTE*)thisx, 0, 0, 0, 0, 0, 0);
            }
        }
    }
    v15 = 0;
    v14 = 0;
    for (i = 0; i < 6; ++i)
    {
        v11 = 0;
        switch (*((unsigned __int8*)a2 + i + 11) / 10)
        {
        case 1:
            v11 = 1;
            break;
        case 2:
            sub_4097DF((void*)thisx, (int)&v13);
            if (i && i != 3)
            {
                if (i == 1 || i == 4)
                {
                    v2 = sub_426210((char*)unk_4B9B10);
                    if (*(_DWORD*)(thisx + 332) >= 400 * sub_4261D0(v2))
                        v11 = -1;
                    else
                        v11 = 1;
                }
                else
                {
                    v11 = 1;
                }
            }
            else if (v13 >= 160)
            {
                v11 = -1;
            }
            else
            {
                v11 = 1;
            }
            break;
        case 3:
            if (i && i != 3)
            {
                v11 = 1;
            }
            else if (*(_DWORD*)(thisx + 424))
            {
                v11 = 1;
            }
            else
            {
                v11 = -1;
            }
            break;
        case 4:
            if (*(int*)v17[i] <= 0)
                v6 = (*(_DWORD*)v17[i] >= 0) - 1;
            else
                v6 = 1;
            v11 = v6;
            break;
        default:
            break;
        }
        v12 = v11 * *(_DWORD*)&a2[2 * i + 10];
        v5 = *((unsigned __int8*)a2 + i + 11) % 10;
        switch (v5)
        {
        case 1:
            *(_DWORD*)v17[i] = v12;
            break;
        case 2:
            *(_DWORD*)v17[i] += v12;
            break;
        case 3:
            *(_DWORD*)v17[i] = v12 * *(_DWORD*)v17[i] / 100;
            break;
        }
        if (i)
        {
            if (i == 1)
                v14 = v11;
        }
        else
        {
            v15 = v11;
        }
    }
    if (*((_BYTE*)a2 + 11))
    {
        if ((v10 = v15 * *((_DWORD*)a2 + 11), v10 > 0) && *(_DWORD*)(thisx + 372) > v10
            || v10 < 0 && *(_DWORD*)(thisx + 372) < v10)
        {
            *(_DWORD*)(thisx + 372) = v10;
        }
    }
    if (*((_BYTE*)a2 + 12))
    {
        if ((v9 = v14 * *((_DWORD*)a2 + 12), v9 > 0) && *(_DWORD*)(thisx + 376) > v9
            || v9 < 0 && *(_DWORD*)(thisx + 376) < v9)
        {
            *(_DWORD*)(thisx + 376) = v9;
        }
    }
    switch (*((_BYTE*)a2 + 10))
    {
    case 1:
        *(_DWORD*)(thisx + 432) = 38;
        break;
    case 2:
        *(_DWORD*)(thisx + 432) = 17;
        break;
    case 3:
        *(_DWORD*)(thisx + 432) = 22;
        break;
    case 4:
        *(_DWORD*)(thisx + 432) = 23;
        break;
    case 5:
        *(_DWORD*)(thisx + 432) = 18;
        break;
    case 6:
        *(_DWORD*)(thisx + 432) = 24;
        break;
    case 7:
        *(_DWORD*)(thisx + 432) = 20;
        break;
    case 8:
        *(_DWORD*)(thisx + 432) = 25;
        break;
    case 9:
        *(_DWORD*)(thisx + 432) = 21;
        break;
    case 0xA:
        *(_DWORD*)(thisx + 432) = 19;
        break;
    default:
        break;
    }
    if (*((_BYTE*)a2 + 10))
    {
        *(_DWORD*)(thisx + 392) = 1;
        *(_DWORD*)(thisx + 340) = 0;
        *(_DWORD*)(thisx + 344) = 0;
        *(_DWORD*)(thisx + 380) = 0;
        *(_DWORD*)(thisx + 384) = 0;
        *(_DWORD*)(thisx + 444) = 0;
        *(_BYTE*)(thisx + 176) = 0;
        *(_BYTE*)(thisx + 177) = 0;
        *(_BYTE*)(thisx + 178) = 1;
    }
    else if (!*(_DWORD*)(thisx + 392) && *((_BYTE*)a2 + 13) && *(int*)(thisx + 348) < 0)
    {
        *(_DWORD*)(thisx + 432) = 50;
    }
    if (byte_4B99DF)
    {
        if (!a2[2])
            a2[2] = 1;
        v3 = *a2;
        v4 = a2[1];
        v8 = sub_426970((int*)unk_4B9B10) * v4 / a2[2] + v3;
        if (v8 > 0)
            sub_41261C((_WORD*)thisx, v8, 0, 1);
    }
    sub_4747D2((int*)unk_4B9B10, *((unsigned __int8*)a2 + 6), a2[4]);
    if ((a2[26] & 0xC) != 0)
        sub_451A0A((int*)unk_4B9B10, *(_DWORD*)(thisx + 328) / 800, *(_DWORD*)(thisx + 332) / 800);
} 
int __stdcall sub_424B7E(int a1, int a2)
{
    int result; // eax

    if (a1 == 19)
    {
        *(_DWORD*)(a2 + 20) = 100;
        *(_BYTE*)(a2 + 14) = 11;
        *(_DWORD*)(a2 + 32) = 0;
        *(_BYTE*)(a2 + 13) = 11;
        *(_DWORD*)(a2 + 28) = -800;
    }
    else
    {
        *(_DWORD*)(a2 + 20) = 300;
        *(_BYTE*)(a2 + 14) = 11;
        *(_DWORD*)(a2 + 32) = 0;
        *(_BYTE*)(a2 + 13) = 11;
        *(_DWORD*)(a2 + 28) = -550;
    }
    *(_BYTE*)(a2 + 16) = 11;
    *(_DWORD*)(a2 + 40) = 30;
    *(_BYTE*)(a2 + 6) = 0;
    *(_WORD*)(a2 + 8) = 19;
    result = a1;
    switch (a1)
    {
    case 17:
        result = a2;
        *(_BYTE*)(a2 + 10) = 2;
        break;
    case 18:
        *(_BYTE*)(a2 + 10) = 5;
        break;
    case 19:
        *(_BYTE*)(a2 + 10) = 10;
        break;
    case 20:
        result = a2;
        *(_BYTE*)(a2 + 10) = 7;
        break;
    case 21:
        *(_BYTE*)(a2 + 10) = 9;
        break;
    case 22:
        *(_BYTE*)(a2 + 10) = 3;
        break;
    default:
        return result;
    }
    return result;
}

 
int __fastcall sub_424C9A(_DWORD* a1, int a2, int a3, int a4, int a5, int a6)
{
    int result; // eax
    unsigned __int16 v7; // ax
    int n; // [esp+14h] [ebp-5Ch]
    int v10; // [esp+18h] [ebp-58h]
    int v11; // [esp+1Ch] [ebp-54h]
    int v12; // [esp+20h] [ebp-50h]
    int m; // [esp+24h] [ebp-4Ch]
    int v14; // [esp+28h] [ebp-48h]
    unsigned __int8 v15; // [esp+2Ch] [ebp-44h]
    int k; // [esp+30h] [ebp-40h]
    int i; // [esp+34h] [ebp-3Ch]
    int v18; // [esp+38h] [ebp-38h]
    int Size; // [esp+3Ch] [ebp-34h]
    int v20; // [esp+48h] [ebp-28h]
    char v21[8]; // [esp+50h] [ebp-20h]
    int v22; // [esp+58h] [ebp-18h]
    int j; // [esp+5Ch] [ebp-14h]
    int v24[4]; // [esp+60h] [ebp-10h]

    result = (int)a1;
    if (a1[31] && a1[14])
    {
        v18 = a3;
        if (a3 >= 0)
        {
            result = (int)a1;
            if (a3 >= a1[16])
                return result;
        }
        else
        {
            v18 = 0;
        }
        Size = a5 - a3;
        if (a5 - a3 > a1[16])
            Size = a1[16];
        for (i = a4; i < a6; ++i)
        {
            if (i >= 0)
            {
                if (i >= a1[17])
                    break;
                memset((void*)(a1[16] * i + v18 + a1[14]), 0, Size);
            }
        }
        v7 = sub_41D067(a1[31], 0);
        v20 = (3 * v7 / 2 + 405) * ((3 * v7 / 2 + 405) / 30) / 2;
        v22 = (3 * sub_41D067(a1[31], 0) / 2 + 405) / 15;
        sub_426210((char*)unk_4B9B10);
        result = sub_4224A7((void*)a1[31]) * v22 / 800;
        v21[0] = 2;
        v21[1] = 16;
        v21[2] = 64;
        v21[3] = 8;
        v21[4] = 1;
        v21[5] = 4;
        v21[6] = 32;
        v21[7] = 0x80;
        for (j = a4; ; ++j)
        {
            if (j >= a6)
                return result;
            if (j >= 0 && j < a1[17])
                break;
        LABEL_16:
            result = j + 1;
        }
        for (k = a3; ; ++k)
        {
            if (k >= a5)
                goto LABEL_16;
            if (k >= 0 && k < a1[16])
            {
                v14 = 100 * sub_446497((int*)unk_4B9B10, 8 * k + 4, 8 * j + 4);
                if (sub_4773CC(k, j))
                    break;
            }
        LABEL_22:
            ;
        }
        v15 = 0;
        for (m = 0; ; ++m)
        {
            if (m >= 8)
            {
                *(_BYTE*)(a1[14] + a1[16] * j + k) = v15;
                goto LABEL_22;
            }
            if (m >= 4)
            {
                v11 = k + 2 * (m & 1) - 1;
                v10 = j + 2 * ((m - 4) / 2) - 1;
            }
            else
            {
                v11 = (m == 1) + k - (m == 3);
                v10 = (__PAIR64__((unsigned int)(m == 2) + j, m) - 1) >> 32;
            }
            if (m < 4)
                goto LABEL_60;
            for (n = 0;
                n < 2
                && ((unsigned __int8)v21[2 * (m >= 6) * (n == 0) + (((m & 0x80000001) == 1) + 3 * ((m & 1) == 0)) * (n == 1)] & v15) != 0;
                ++n)
            {
                ;
            }
            if (n >= 2)
            {
            LABEL_60:
                if (v11 >= 0 && v11 < a1[16] && v10 >= 0 && v10 < a1[17])
                {
                    if (sub_4773CC(v11, v10))
                    {
                        v12 = 100 * sub_446497((int*)unk_4B9B10, 8 * v11 + 4, 8 * v10 + 4);
                        if (v12 - v14 <= v20)
                        {
                            if (m < 4)
                            {
                                v24[m] = v14 - v12 <= v20;
                            LABEL_55:
                                v15 |= v21[m];
                                continue;
                            }
                            if (v14 - v12 > v20 || v24[2 * (m >= 6)] && v24[3 * ((m & 0x80000001) == 0) + ((m & 0x80000001) == 1)])
                                goto LABEL_55;
                        }
                    }
                }
            }
        }
    }
    return result;
} 
char* sub_42511B(char* thisx, int a2)
{
    char* result; // eax
    int v3; // [esp+Ch] [ebp-5Ch]
    int v4[7]; // [esp+10h] [ebp-58h]
    int v5[7]; // [esp+2Ch] [ebp-3Ch]
    int v6; // [esp+48h] [ebp-20h]
    int i; // [esp+4Ch] [ebp-1Ch]
    int v8; // [esp+50h] [ebp-18h]
    int v9; // [esp+54h] [ebp-14h]
    int v10; // [esp+58h] [ebp-10h]
    int v11; // [esp+5Ch] [ebp-Ch]
    int v12; // [esp+60h] [ebp-8h]
    int v13; // [esp+64h] [ebp-4h]

    v4[0] = (int)(thisx + 502);
    v4[1] = (int)(thisx + 504);
    v4[2] = (int)(thisx + 506);
    v4[3] = (int)(thisx + 508);
    v4[4] = (int)(thisx + 510);
    v4[5] = (int)(thisx + 512);
    result = thisx + 514;
    v4[6] = (int)(thisx + 514);
    v5[0] = (int)(thisx + 516);
    v5[1] = (int)(thisx + 518);
    v8 = 50;
    v9 = 25;
    v10 = 12;
    v11 = 6;
    v12 = 3;
    v13 = 2;
    v5[2] = 10;
    v5[3] = 5;
    v5[4] = 2;
    v5[5] = 1;
    v5[6] = 1;
    v6 = 1;
    for (i = 0; i < 9; ++i)
    {
        v3 = (v5[a2] + *(&v6 + a2) * *(unsigned __int16*)v4[i] / 100) / (3 * (i >= 5) + 1) + *(unsigned __int16*)v4[i];
        if (v3 > 0xFFFF)
            LOWORD(v3) = -1;
        *(_WORD*)v4[i] = v3;
        result = (char*)(i + 1);
    }
    return result;
}

 
_DWORD* sub_42526D(_DWORD* thisx, int a2)
{
	_DWORD* result; // eax
	int v4[2]; // [esp+4h] [ebp-10h] BYREF
	int v5; // [esp+Ch] [ebp-8h]
	int v6; // [esp+10h] [ebp-4h]

	v6 = thisx[110] % 8 - 1;
	v5 = thisx[110] / 8 - 1;
	sub_42532C(thisx, v6, v5, a2, v4);
	thisx[82] = v4[0];
	thisx[83] = v4[1];
	thisx[84] = -100 * sub_446497((_DWORD*)unk_4B9B10, thisx[82] / 100, thisx[83] / 100) - 4000;
	result = thisx;
	thisx[98] = 1;
	return result;
}

 
int* sub_42532C(_DWORD* thisx, int a2, int a3, int a4, int* a5)
{
    char* v5; // eax
    char* v6; // eax
    int* result; // eax
    int v8; // [esp+0h] [ebp-48h]
    int v9; // [esp+4h] [ebp-44h]
    int v10; // [esp+8h] [ebp-40h]
    int v11; // [esp+Ch] [ebp-3Ch]
    int v13; // [esp+14h] [ebp-34h]
    int v14; // [esp+18h] [ebp-30h]
    int i; // [esp+1Ch] [ebp-2Ch]
    int v16; // [esp+20h] [ebp-28h]
    int v17; // [esp+24h] [ebp-24h]
    int v18; // [esp+28h] [ebp-20h]
    int v19; // [esp+2Ch] [ebp-1Ch]
    int v20; // [esp+2Ch] [ebp-1Ch]
    int v21; // [esp+30h] [ebp-18h]
    int v22; // [esp+30h] [ebp-18h]
    int v23; // [esp+34h] [ebp-14h]
    int v24; // [esp+38h] [ebp-10h]
    int v25; // [esp+3Ch] [ebp-Ch]
    int v26; // [esp+40h] [ebp-8h]
    int v27; // [esp+44h] [ebp-4h]

    v25 = sub_446465((char*)unk_4B9B10);
    v5 = sub_426210((char*)unk_4B9B10);
    v24 = sub_4897D0(v5) / 8;
    v6 = sub_426210((char*)unk_4B9B10);
    v23 = sub_4261D0(v6);
    v21 = 0;
    v19 = 0;
    if (a4)
    {
        if (a4 == 1)
        {
            if (a2 <= 0)
                v9 = (a2 >= 0) - 1;
            else
                v9 = 1;
            v21 = (v9 << 7) + thisx[82] / 100;
            if (a3 <= 0)
                v8 = (a3 >= 0) - 1;
            else
                v8 = 1;
            v19 = 44 * v8 + thisx[83] / 100;
        }
    }
    else
    {
        if (a2 <= 0)
            v11 = (a2 >= 0) - 1;
        else
            v11 = 1;
        v21 = (v11 << 7) + v25 + 160;
        if (a3 <= 0)
            v10 = (a3 >= 0) - 1;
        else
            v10 = 1;
        v19 = 3 * v23 * v10 + 4 * v23;
    }
    v22 = v21 / 8;
    v20 = v19 / 8;
    if (v22 > 0)
    {
        if (v22 >= v24)
            v22 = v24 - 2;
    }
    else
    {
        v22 = 1;
    }
    if (v20 >= 0)
    {
        if (v20 >= v23)
            v20 = v23 - 1;
    }
    else
    {
        v20 = 0;
    }
    v27 = (v25 + 7) / 8;
    v26 = 0;
    while (1)
    {
        v13 = 4 * v26;
        if (!(4 * v26))
            v13 = 1;
        v16 = v22;
        v14 = v20 - v26;
        v18 = 1;
        v17 = 1;
        for (i = 0;
            i < v13
            && (v16 < v27 || v16 >= v27 + 40 || v16 < 1 || v16 >= v24 - 1 || v14 < 0 || v14 >= v23 || !sub_4773CC(v16, v14));
            ++i)
        {
            v16 += v18;
            v14 += v17;
            if (v14 == v20)
                v18 = -v18;
            if (v16 == v22)
                v17 = -v17;
        }
        if (i < v13)
            break;
        if (++v26 > v24 && v26 > v23)
            goto LABEL_47;
    }
    v22 = 800 * v16 + 400;
    v20 = 800 * v14 + 400;
LABEL_47:
    *a5 = v22;
    result = a5;
    a5[1] = v20;
    return result;
}
 
_DWORD* sub_425617(_DWORD* thisx, int a2, int a3, int a4, int a5)
{
    _DWORD* result; // eax
    unsigned __int16 v6; // ax
    int v8; // [esp+8h] [ebp-40h]
    int n; // [esp+Ch] [ebp-3Ch]
    int v10; // [esp+10h] [ebp-38h]
    int v11; // [esp+10h] [ebp-38h]
    int v12; // [esp+14h] [ebp-34h]
    int k; // [esp+18h] [ebp-30h]
    _DWORD* v14; // [esp+24h] [ebp-24h]
    int v15; // [esp+28h] [ebp-20h]
    int v16; // [esp+2Ch] [ebp-1Ch]
    int v17; // [esp+30h] [ebp-18h]
    int v18; // [esp+34h] [ebp-14h]
    int i; // [esp+38h] [ebp-10h]
    int m; // [esp+38h] [ebp-10h]
    int v21; // [esp+3Ch] [ebp-Ch]
    int j; // [esp+40h] [ebp-8h]
    _DWORD* v23; // [esp+44h] [ebp-4h]

    result = thisx;
    if (thisx[31] && thisx[15])
    {
        v6 = sub_41D067(thisx[31], 0);
        v15 = (3 * v6 / 2 + 405) * ((3 * v6 / 2 + 405) / 30) / 2;
        v21 = (3 * sub_41D067(thisx[31], 0) / 2 + 405) / 15;
        sub_426210((char*)unk_4B9B10);
        v18 = 2 * sub_4224A7((void*)thisx[31]) * v21 / 800;
        v23 = (_DWORD*)(a2 - v18);
        v16 = v18 + a4;
        v14 = (_DWORD*)a3;
        v17 = a5;
        if (a2 - v18 < 0)
            v23 = 0;
        if (v16 > thisx[16])
            v16 = thisx[16];
        if (a3 < 0)
            v14 = 0;
        if (a5 > thisx[17])
            v17 = thisx[17];
        for (i = (int)v14; i < v17; ++i)
            memset((void*)(thisx[15] + 2 * ((_DWORD)v23 + thisx[16] * i)), 0, 2 * (v16 - (_DWORD)v23));
        result = v14;
        for (j = (int)v14; j < v17; ++j)
        {
            result = v23;
            for (k = (int)v23; k < v16; ++k)
            {
                v12 = 100 * sub_446497((int*)unk_4B9B10, 8 * k + 4, 8 * j + 4);
                result = (_DWORD*)sub_4773CC(k, j);
                if (result)
                {
                    for (m = 0; m < 2; ++m)
                    {
                        if (!*(_BYTE*)(thisx[15] + 2 * (thisx[16] * j + k) + m))
                        {
                            v10 = k + 2 * m - 1;
                            if (v10 >= 0
                                && v10 < thisx[16]
                                && ((16 * (m == 0) + 8 * (m == 1)) & *(unsigned __int8*)(thisx[14] + thisx[16] * j + v10)) == 0)
                            {
                                for (n = 0; n < v18; ++n)
                                {
                                    v10 = v10 + 2 * m - 1;
                                    if (v10 < 0)
                                        break;
                                    if (v10 >= thisx[16])
                                        break;
                                    v8 = 100 * sub_446497((int*)unk_4B9B10, 8 * v10 + 4, 8 * j + 4);
                                    if (v8 - v12 > v15)
                                        break;
                                    if (v12 - v8 <= v15 && sub_4773CC(v10, j))
                                    {
                                        v11 = v10 - k;
                                        if (v11 <= 127 && v11 >= -127)
                                        {
                                            *(_BYTE*)(thisx[15] + 2 * (thisx[16] * j + k) + m) = v11;
                                            *(_BYTE*)(thisx[15] + 2 * (thisx[16] * j + v11 + k) + 1 - m) = -(char)v11;
                                        }
                                        break;
                                    }
                                }
                            }
                        }
                        result = (_DWORD*)(m + 1);
                    }
                }
            }
        }
    }
    return result;
} 
void sub_4259A4(_DWORD* thisx, double a2, double a3, double a4)
{
    int v4; // esi
    int i; // eax
    int v6; // esi
    int v8; // [esp+8h] [ebp-18h]
    char* v9; // [esp+Ch] [ebp-14h]
    int v10; // [esp+10h] [ebp-10h]
    int v11; // [esp+14h] [ebp-Ch]
    int v12; // [esp+18h] [ebp-8h]

    if (byte_4B99E0)
    {
        if (byte_4B99E0 == 2)
        {
            thisx[145] -= 5;
            thisx[147] -= 5;
        }
        v9 = sub_426210((char*)unk_4B9B10);
        sub_4897D0(v9);
        v10 = 8 * sub_4261D0(v9);
        v4 = rand() % 303;
        v12 = v4 + sub_446465((char*)unk_4B9B10) + 8;
        v11 = rand() % v10;
        for (i = sub_486633((int*)v9, v12, v11); ; i = sub_486633((int*)v9, v12, v11))
        {
            v8 = i;
            if (sub_4773CC(v12 / 8, v11 / 8))
            {
                if (v8 < 1020)
                    break;
            }
            v6 = rand() % 303;
            v12 = v6 + sub_446465((char*)unk_4B9B10) + 8;
            v11 = rand() % v10;
        }
        thisx[84] = -100 * v8 - 17600;
        thisx[82] = 100 * v12;
        thisx[83] = 100 * v11;
    }
    else
    {
        thisx[108] = 80;
        sub_409273((int)thisx, thisx[108]);
        thisx[111] = 1;
        thisx[98] = 1;
        sub_4097FE((int)thisx, a2, a3, a4);
    }
}
Concurrency::details::VirtualProcessorRoot* sub_425B40(
    Concurrency::details::VirtualProcessorRoot* thisx,
    char a2)
{
    //Concurrency::details::VirtualProcessorRoot::~VirtualProcessorRoot(thisx);
    Concurrency::details::VirtualProcessorRoot::_VirtualProcessorRoot(thisx);
    if ((a2 & 1) != 0)
        operator delete(thisx);
    return thisx;
}
 
char sub_425B70(_BYTE* thisx)
{
    return thisx[10];
}

 
_DWORD* sub_425B90(char* thisx, _DWORD* a2, int a3, int a4)
{
    char* v4; // edx

    v4 = &thisx[32 * a3 + 16 + 16 * a4];
    *a2 = *(_DWORD*)v4;
    a2[1] = *((_DWORD*)v4 + 1);
    a2[2] = *((_DWORD*)v4 + 2);
    a2[3] = *((_DWORD*)v4 + 3);
    return a2;
}

 
_DWORD* sub_425BD0(char* thisx, _DWORD* a2, int a3, int a4)
{
    char* v4; // edx

    v4 = &thisx[32 * a3 + 80 + 16 * a4];
    *a2 = *(_DWORD*)v4;
    a2[1] = *((_DWORD*)v4 + 1);
    a2[2] = *((_DWORD*)v4 + 2);
    a2[3] = *((_DWORD*)v4 + 3);
    return a2;
}

 
char sub_425C10(_BYTE* thisx)
{
    return thisx[7];
}

 
char sub_425C30(_BYTE* thisx)
{
    return thisx[14];
}

 
BOOL sub_425C50(_BYTE* thisx)
{
    return (thisx[15] & 1) != 0;
}

 
int sub_425C70(_BYTE* thisx)
{
    return (thisx[15] & 6) >> 1;
}

 
BOOL sub_425C90(_BYTE* thisx)
{
    return (thisx[15] & 8) != 0;
}

 
char sub_425CB0(_BYTE* thisx)
{
    return thisx[72];
}

 
int sub_425CD0(_DWORD* thisx)
{
    return thisx[29];
}


 
_DWORD* sub_425D10(_DWORD* thisx, int a2)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[78] = a2;
    return result;
}

 
int sub_425D30(_DWORD* thisx)
{
    return thisx[98];
}

 
int sub_425D50(_DWORD* thisx)
{
    return thisx[73];
}

 
int sub_425D70(_DWORD* thisx)
{
    return thisx[106];
}

 
char sub_425D90(_BYTE* thisx)
{
    return thisx[269];
}

 
char sub_425DB0(_BYTE* thisx)
{
    return thisx[270];
}

 
char sub_425DD0(_BYTE* thisx, int a2)
{
    return thisx[a2 + 271];
}

 
int sub_425DF0(int thisx, int a2)
{
	return sub_425E10((void*)(thisx + 13400), a2);
}

 
int sub_425E10(void* thisx, int a2)
{
    return (int)thisx + 276 * a2 + 12;
}

 
BOOL sub_425E30(int thisx)
{
    return *(_BYTE*)(thisx + 558) || *(_DWORD*)(thisx + 560);
}

 
char sub_425E70(_BYTE* thisx)
{
    return thisx[188];
}

 
int sub_425E90(unsigned __int8* thisx)
{
    return thisx[471];
}

 
char sub_425EB0(_BYTE* thisx)
{
    return thisx[470];
}

 
int sub_425ED0(_DWORD* thisx)
{
    return thisx[111];
}

 
char sub_425EF0(_BYTE* thisx)
{
    return thisx[184];
}



 
int sub_425F30(_DWORD* thisx)
{
    return thisx[108];
}

 
char sub_425F50(_BYTE* thisx)
{
    return thisx[6];
}


 
char sub_425F90(_BYTE* thisx)
{
    return thisx[5];
}


 
char sub_425FD0(_BYTE* thisx)
{
    return thisx[9];
}

 
BOOL sub_425FF0(_DWORD* thisx)
{
    return thisx[120] != 0;
}

 
int sub_426010(_DWORD* thisx)
{
    return thisx[109];
}

 
char sub_426030(_BYTE* thisx)
{
    return thisx[223];
}

 
_DWORD* sub_426050(_DWORD* thisx, int a2)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[108] = a2;
    return result;
}

 
char sub_426070(_BYTE* thisx)
{
    return thisx[193];
}

 
int sub_426090(_DWORD* thisx)
{
    return thisx[82];
}

 
int sub_4260B0(_DWORD* thisx)
{
    return thisx[83];
}

 
int sub_4260D0(_DWORD* thisx)
{
    return thisx[84];
}


__int16 sub_4260F0(_WORD *thisx)
{
  return thisx[3];
} 
__int16 sub_426110(_WORD* thisx)
{
	return thisx[5];
} 
__int16  sub_426130(_WORD* thisx)
{
	return thisx[6];
} 
char sub_426150(_BYTE* thisx)
{
    return thisx[17];
}

 
int sub_426170(_BYTE* thisx)
{
    return thisx[606] & 1 | thisx[604] & 1 | thisx[602] & 1;
}

 
__int16 sub_4261B0(_WORD* thisx)
{
    return thisx[120];
}

 
int sub_4261D0(char* thisx)
{
    return (unsigned __int8)sub_4261F0(thisx + 4);
}
 
char sub_4261F0(_BYTE* thisx)
{
    return thisx[13];
}

 
char* sub_426210(char* thisx)
{
    return thisx + 128;
}

 
_BYTE* sub_426230(_BYTE* thisx)
{
    _BYTE* result; // eax

    result = thisx;
    ++thisx[325];
    return result;
}

 
int sub_426250(_DWORD* thisx)
{
    return thisx[2850];
}

 
int sub_426270(_DWORD* thisx)
{
    return thisx[97];
}

 
BOOL sub_426290(unsigned __int8* thisx)
{
    return thisx[28] != 0;
}

 
int sub_4262B0(_DWORD* thisx)
{
    return thisx[80];
}

 
int sub_4262D0(_DWORD* thisx)
{
    return thisx[78];
}

 
char sub_4262F0(_BYTE* thisx)
{
    return thisx[419];
}

 
char sub_426310(_BYTE* thisx)
{
    return thisx[420];
}

 
BOOL sub_426350(unsigned __int8* thisx)
{
    return thisx[237] != 0;
}


 
int sub_426390(_DWORD* thisx)
{
    return thisx[94];
}

 
int sub_4263B0(_DWORD* thisx)
{
    return thisx[99];
}

 
BOOL sub_4263D0(unsigned __int8* thisx)
{
    return thisx[177] != 0;
}

 
char sub_4263F0(_BYTE* thisx)
{
    return thisx[416];
}

 
int sub_426410(_DWORD* thisx)
{
    return thisx[72];
}

 
int sub_426430(_DWORD* thisx)
{
    return thisx[76];
}

 
int sub_426470(_DWORD* thisx)
{
    return thisx[24];
}

 
int sub_426490(unsigned __int8* thisx, int a2)
{
    return thisx[a2 + 13092];
}

 
char sub_4264B0(_BYTE* thisx)
{
    return thisx[250];
}

 
char sub_4264D0(_BYTE* thisx)
{
    return thisx[257];
}

 
char sub_4264F0(_BYTE* thisx)
{
    return thisx[195];
}


 
int sub_426530(_DWORD* thisx)
{
    return thisx[25];
}

 
char sub_426550(_BYTE* thisx)
{
    return thisx[26];
}

 
char sub_426570(_BYTE* thisx)
{
    return thisx[22];
}

 
int sub_426590(void* thisx, int a2)
{
    return (int)thisx + 76 * a2 + 11816;
}

 
char sub_4265B0(_BYTE* thisx)
{
    return thisx[21];
}

 
char sub_4265D0(_BYTE* thisx)
{
    return thisx[23];
}

 
char sub_4265F0(_BYTE* thisx)
{
    return thisx[24];
}

 
char sub_426610(_BYTE* thisx)
{
    return thisx[25];
}

 
char sub_426630(_BYTE* thisx)
{
    return thisx[27];
}

 
char sub_426650(_BYTE* thisx)
{
    return thisx[28];
}

 
char sub_426670(_BYTE* thisx)
{
    return thisx[30];
}

 
char sub_426690(_BYTE* thisx)
{
    return thisx[31];
}

 
char sub_4266B0(_BYTE* thisx, int a2)
{
    return thisx[a2 + 32];
}

 
char* sub_4266D0(char* thisx)
{
    return thisx + 2;
}

 
__int16 sub_4266F0(_WORD* thisx)
{
    return thisx[10];
}

 
__int16 sub_426710(_WORD* thisx)
{
    return thisx[14];
}

 
__int16 sub_426730(_WORD* thisx)
{
    return thisx[15];
}

 
__int16 sub_426750(_WORD* thisx)
{
    return thisx[16];
}

 
__int16 sub_426770(_WORD* thisx)
{
    return thisx[17];
}

 
__int16 sub_426790(_WORD* thisx)
{
    return thisx[18];
}

 
__int16 sub_4267B0(_WORD* thisx)
{
    return thisx[19];
}

 
__int16 sub_4267D0(_WORD* thisx)
{
    return thisx[20];
}

 
__int16 sub_4267F0(_WORD* thisx)
{
    return thisx[21];
}

 
__int16 sub_426810(_WORD* thisx)
{
    return thisx[22];
}

 
__int16 sub_426830(_WORD* thisx)
{
    return thisx[23];
}

 
char sub_426850(_BYTE* thisx, unsigned __int8 a2)
{
    return thisx[a2 + 68];
}


 
int sub_4268D0(_DWORD* thisx)
{
    return thisx[131];
}

 
char sub_4268F0(_BYTE* thisx)
{
    return thisx[476];
}

 
int sub_426910(_DWORD* thisx)
{
    return thisx[120];
}

 
int sub_426930(_DWORD* thisx)
{
    return thisx[87];
}
/*
void InternalContextBase::UNSAFE_SetVirtualProcessor(
    InternalContextBase* thisx,
    struct VirtualProcessor* a2)
{
    *((_DWORD*)thisx + 40) = a2;
}
*/

 
int sub_426970(_DWORD* thisx)
{
    return thisx[627];
}

 
void sub_426990(int a1, double a2, double a3, double a4)
{
    unsigned __int16 v4; // ax
    int v5; // esi
    int v6; // edi
    unsigned __int16 v7; // ax
    unsigned __int16 v8; // ax
    int v9; // esi
    int v10; // edi
    unsigned __int16 v11; // ax
    double v12; // st4
    double v13; // st4
    unsigned __int16 v14; // ax
    double v15; // st4
    double v16; // st4
    double v17; // st4
    double v18; // st4
    double v19; // st4
    int v20; // esi
    int v21; // edi
    int v22; // edi
    unsigned __int16 v23; // ax
    int v24; // esi
    int v25; // edi
    int v26; // edi
    unsigned __int16 v27; // ax
    int v28; // esi
    int v29; // edi
    unsigned __int16 v30; // ax
    int v31; // esi
    int v32; // edi
    unsigned __int16 v33; // ax
    int v34; // esi
    int v35; // edi
    unsigned __int16 v36; // ax
    double v37; // st4
    int v38; // esi
    double v39; // st4
    int v40; // esi
    double v41; // st4
    int v42; // esi
    int v43; // esi
    unsigned __int16 v44; // ax
    int v45; // esi
    int v46; // esi
    unsigned __int16 v47; // ax
    int v48; // esi
    int v49; // eax
    unsigned __int16 v50; // ax
    int v51; // esi
    int v52; // esi
    unsigned __int16 v53; // ax
    unsigned __int16 v54; // ax
    unsigned __int16 v55; // ax
    unsigned __int16 v56; // ax
    unsigned __int16 v57; // ax
    int v58; // esi
    int v59; // esi
    unsigned __int16 v60; // ax
    int v61; // esi
    int v62; // esi
    int v63; // esi
    unsigned __int16 v64; // ax
    int v65; // esi
    int v66; // esi
    int v67; // esi
    double v68; // st7
    double v69; // st7
    int v70; // esi
    int v71; // edi
    unsigned __int16 v72; // ax
    unsigned __int16 v73; // ax
    int v74; // esi
    int v75; // esi
    int v76; // edi
    unsigned __int16 v77; // ax
    int v78; // esi
    unsigned __int16 v79; // ax
    int v80; // esi
    int v81; // edi
    unsigned __int16 v82; // ax
    unsigned __int16 v83; // ax
    int v84; // esi
    unsigned __int16 v85; // ax
    unsigned __int16 v86; // ax
    unsigned __int16 v87; // ax
    int v88; // esi
    int v89; // edi
    unsigned __int16 v90; // ax
    int v91; // esi
    int v92; // edi
    unsigned __int16 v93; // ax
    int v94; // esi
    int v95; // edi
    unsigned __int16 v96; // ax
    int v97; // esi
    int v98; // edi
    unsigned __int16 v99; // ax
    int v100; // esi
    int v101; // edi
    int v102; // esi
    unsigned __int16 v103; // ax
    int v104; // esi
    double v105; // st4
    int v106; // esi
    double v107; // st4
    int v108; // esi
    double v109; // st4
    int v110; // esi
    double v111; // st4
    int v112; // esi
    double v113; // st4
    int v114; // esi
    int v115; // edi
    unsigned __int16 v116; // ax
    int v117; // esi
    int v118; // edi
    unsigned __int16 v119; // ax
    char v120; // al
    int v121; // esi
    int v122; // edi
    int v123; // esi
    int v124; // esi
    int v125; // esi
    double v126; // st4
    int v127; // esi
    int v128; // edi
    unsigned __int16 v129; // ax
    unsigned __int16 v130; // ax
    int v131; // esi
    double v132; // st4
    unsigned __int16 v133; // ax
    unsigned __int16 v134; // ax
    double v135; // st4
    unsigned __int16 v136; // ax
    int v137; // esi
    int v138; // esi
    unsigned __int16 v139; // ax
    int v140; // esi
    int v141; // edi
    unsigned __int16 v142; // ax
    int v143; // esi
    int v144; // edi
    unsigned __int16 v145; // ax
    int v146; // esi
    double v147; // st4
    int v148; // esi
    int v149; // edi
    unsigned __int16 v150; // ax
    int v151; // esi
    int v152; // edi
    unsigned __int16 v153; // ax
    int v154; // esi
    int v155; // esi
    int v156; // esi
    unsigned __int16 v157; // ax
    int v158; // esi
    int v159; // esi
    unsigned __int16 v160; // ax
    int v161; // esi
    int v162; // esi
    unsigned __int16 v163; // ax
    int v164; // esi
    int v165; // esi
    unsigned __int16 v166; // ax
    int v167; // eax
    int v168; // esi
    int v169; // edi
    int v170; // edi
    unsigned __int16 v171; // ax
    int v172; // esi
    int v173; // edi
    unsigned __int16 v174; // ax
    unsigned __int16 v175; // ax
    int v176; // eax
    unsigned __int16 v177; // ax
    int v178; // esi
    int v179; // edi
    unsigned __int16 v180; // ax
    unsigned __int16 v181; // ax
    unsigned __int16 v182; // ax
    unsigned __int16 v183; // ax
    unsigned __int16 v184; // ax
    unsigned __int16 v185; // ax
    int v186; // esi
    unsigned __int16 v187; // ax
    unsigned __int16 v188; // ax
    int v189; // esi
    int v190; // edi
    unsigned __int16 v191; // ax
    int v192; // esi
    unsigned __int16 v193; // ax
    unsigned __int16 v194; // ax
    unsigned __int16 v195; // ax
    unsigned __int16 v196; // ax
    unsigned __int16 v197; // ax
    unsigned __int16 v198; // ax
    int v199; // esi
    int v200; // esi
    double v201; // st4
    int v202; // esi
    unsigned __int16 v203; // ax
    int v204; // esi
    int v205; // esi
    int v206; // esi
    unsigned __int16 v207; // ax
    int v208; // eax
    int v209; // esi
    int v210; // esi
    unsigned __int16 v211; // ax
    int v212; // esi
    double v213; // st4
    int v214; // esi
    double v215; // st4
    int v216; // esi
    double v217; // st4
    int v218; // esi
    double v219; // st4
    int v220; // esi
    double v221; // st4
    int v222; // [esp+4h] [ebp-3F8h]
    int v223; // [esp+4h] [ebp-3F8h]
    int v224; // [esp+4h] [ebp-3F8h]
    int v225; // [esp+8h] [ebp-3F4h]
    int v226; // [esp+8h] [ebp-3F4h]
    int v227; // [esp+8h] [ebp-3F4h]
    double v228; // [esp+1Ch] [ebp-3E0h]
    double v229; // [esp+2Ch] [ebp-3D0h]
    double v230; // [esp+3Ch] [ebp-3C0h]
    double v231; // [esp+4Ch] [ebp-3B0h]
    double v232; // [esp+5Ch] [ebp-3A0h]
    int v233; // [esp+68h] [ebp-394h]
    int v234; // [esp+6Ch] [ebp-390h]
    BOOL v235; // [esp+70h] [ebp-38Ch]
    BOOL v236; // [esp+74h] [ebp-388h]
    int v237; // [esp+78h] [ebp-384h]
    int v238; // [esp+7Ch] [ebp-380h]
    int v239; // [esp+80h] [ebp-37Ch]
    int v240; // [esp+84h] [ebp-378h]
    int v241; // [esp+88h] [ebp-374h]
    double v242; // [esp+90h] [ebp-36Ch]
    double v243; // [esp+9Ch] [ebp-360h]
    int v244; // [esp+A8h] [ebp-354h]
    int v245; // [esp+ACh] [ebp-350h]
    int v246; // [esp+B0h] [ebp-34Ch]
    int v247; // [esp+B8h] [ebp-344h]
    double v248; // [esp+C0h] [ebp-33Ch]
    double v249; // [esp+D4h] [ebp-328h]
    double v250; // [esp+E4h] [ebp-318h]
    double v251; // [esp+F4h] [ebp-308h]
    double v252; // [esp+104h] [ebp-2F8h]
    double v253; // [esp+114h] [ebp-2E8h]
    double v254; // [esp+124h] [ebp-2D8h]
    double v255; // [esp+134h] [ebp-2C8h]
    int v256; // [esp+144h] [ebp-2B8h]
    int v257; // [esp+148h] [ebp-2B4h]
    int v258; // [esp+14Ch] [ebp-2B0h]
    int v259; // [esp+150h] [ebp-2ACh]
    int v260; // [esp+154h] [ebp-2A8h]
    int v261; // [esp+158h] [ebp-2A4h]
    int v262; // [esp+15Ch] [ebp-2A0h]
    int v263; // [esp+160h] [ebp-29Ch]
    int v264; // [esp+164h] [ebp-298h]
    int v265; // [esp+168h] [ebp-294h]
    int v266; // [esp+16Ch] [ebp-290h]
    int v267; // [esp+170h] [ebp-28Ch]
    int v268; // [esp+174h] [ebp-288h]
    int v269; // [esp+178h] [ebp-284h]
    bool v270; // [esp+17Ch] [ebp-280h]
    int v271; // [esp+180h] [ebp-27Ch]
    int v272; // [esp+184h] [ebp-278h]
    int v273; // [esp+188h] [ebp-274h]
    int v274; // [esp+18Ch] [ebp-270h]
    int v275; // [esp+190h] [ebp-26Ch]
    int v276; // [esp+194h] [ebp-268h]
    int v277; // [esp+198h] [ebp-264h]
    int v278; // [esp+19Ch] [ebp-260h]
    int v279; // [esp+1A0h] [ebp-25Ch]
    int v280; // [esp+1A4h] [ebp-258h]
    int v281; // [esp+1A8h] [ebp-254h]
    int v282; // [esp+1ACh] [ebp-250h]
    double v283; // [esp+1B4h] [ebp-248h]
    double v284; // [esp+1C4h] [ebp-238h]
    int v286; // [esp+1F8h] [ebp-204h]
    int v287; // [esp+1FCh] [ebp-200h]
    int v288; // [esp+200h] [ebp-1FCh]
    int v289; // [esp+208h] [ebp-1F4h]
    int v290[2]; // [esp+20Ch] [ebp-1F0h] BYREF
    char v291; // [esp+214h] [ebp-1E8h]
    int v292; // [esp+218h] [ebp-1E4h]
    int v293; // [esp+21Ch] [ebp-1E0h]
    int v294[3]; // [esp+220h] [ebp-1DCh] BYREF
    int v295; // [esp+22Ch] [ebp-1D0h]
    int v296; // [esp+230h] [ebp-1CCh]
    int v297; // [esp+234h] [ebp-1C8h]
    int v298; // [esp+238h] [ebp-1C4h]
    __int16 v299; // [esp+23Ch] [ebp-1C0h]
    int v300; // [esp+240h] [ebp-1BCh]
    int v301; // [esp+244h] [ebp-1B8h]
    int v302; // [esp+248h] [ebp-1B4h]
    int v303; // [esp+24Ch] [ebp-1B0h]
    int v304; // [esp+250h] [ebp-1ACh]
    __int16 v305; // [esp+254h] [ebp-1A8h]
    char v306; // [esp+258h] [ebp-1A4h]
    int v307; // [esp+25Ch] [ebp-1A0h]
    int v308; // [esp+260h] [ebp-19Ch]
    int v309; // [esp+264h] [ebp-198h]
    int v310; // [esp+268h] [ebp-194h]
    int v311; // [esp+26Ch] [ebp-190h]
    int v312; // [esp+270h] [ebp-18Ch]
    int v313; // [esp+274h] [ebp-188h]
    int v314; // [esp+278h] [ebp-184h]
    int v315; // [esp+27Ch] [ebp-180h]
    int v316; // [esp+280h] [ebp-17Ch]
    struct Concurrency::ISchedulerProxy* SchedulerProxy; // [esp+284h] [ebp-178h]
    int v318; // [esp+288h] [ebp-174h]
    int v319; // [esp+28Ch] [ebp-170h]
    int v320; // [esp+290h] [ebp-16Ch]
    int v321[2]; // [esp+294h] [ebp-168h] BYREF
    char v322; // [esp+29Ch] [ebp-160h]
    int v323; // [esp+2A0h] [ebp-15Ch]
    int v324; // [esp+2A4h] [ebp-158h]
    int v325; // [esp+2A8h] [ebp-154h]
    int v326; // [esp+2ACh] [ebp-150h]
    int v327; // [esp+2B0h] [ebp-14Ch]
    int v328; // [esp+2B4h] [ebp-148h]
    int v329; // [esp+2B8h] [ebp-144h]
    int v330; // [esp+2BCh] [ebp-140h]
    int v331; // [esp+2C0h] [ebp-13Ch]
    int v332; // [esp+2C4h] [ebp-138h]
    int v333; // [esp+2C8h] [ebp-134h]
    int v334; // [esp+2CCh] [ebp-130h]
    int v335; // [esp+2D0h] [ebp-12Ch]
    int v336; // [esp+2D4h] [ebp-128h]
    int v337; // [esp+2D8h] [ebp-124h]
    int v338; // [esp+2DCh] [ebp-120h]
    int v339; // [esp+2E0h] [ebp-11Ch]
    int v340; // [esp+2E4h] [ebp-118h]
    int v341; // [esp+2E8h] [ebp-114h]
    int v342; // [esp+2ECh] [ebp-110h] BYREF
    int v343; // [esp+2F0h] [ebp-10Ch]
    char v344; // [esp+2F4h] [ebp-108h]
    int v345; // [esp+2F8h] [ebp-104h]
    int v346; // [esp+2FCh] [ebp-100h]
    int v347; // [esp+300h] [ebp-FCh]
    int v348; // [esp+304h] [ebp-F8h]
    int v349[2]; // [esp+308h] [ebp-F4h] BYREF
    char v350; // [esp+310h] [ebp-ECh]
    int v351; // [esp+314h] [ebp-E8h]
    int v352; // [esp+318h] [ebp-E4h]
    int v353; // [esp+31Ch] [ebp-E0h]
    int v354; // [esp+320h] [ebp-DCh]
    int v355; // [esp+324h] [ebp-D8h]
    int v356; // [esp+328h] [ebp-D4h]
    int v357; // [esp+32Ch] [ebp-D0h]
    int v358; // [esp+330h] [ebp-CCh]
    int v359; // [esp+334h] [ebp-C8h]
    int v360; // [esp+338h] [ebp-C4h]
    int v361; // [esp+33Ch] [ebp-C0h]
    int v362; // [esp+340h] [ebp-BCh]
    int v363; // [esp+344h] [ebp-B8h]
    int v364; // [esp+348h] [ebp-B4h]
    int v365; // [esp+34Ch] [ebp-B0h]
    double X; // [esp+350h] [ebp-ACh]
    int v367; // [esp+358h] [ebp-A4h]
    int v368; // [esp+35Ch] [ebp-A0h]
    int v369; // [esp+360h] [ebp-9Ch]
    int v370; // [esp+364h] [ebp-98h]
    int v371; // [esp+368h] [ebp-94h]
    int v372; // [esp+36Ch] [ebp-90h]
    char* v373; // [esp+370h] [ebp-8Ch]
    int v374; // [esp+374h] [ebp-88h]
    int v375; // [esp+378h] [ebp-84h]
    int v376; // [esp+37Ch] [ebp-80h]
    int v377; // [esp+380h] [ebp-7Ch]
    int v378; // [esp+384h] [ebp-78h]
    int v379; // [esp+388h] [ebp-74h]
    int v380; // [esp+38Ch] [ebp-70h]
    int v381; // [esp+390h] [ebp-6Ch]
    int v382; // [esp+394h] [ebp-68h]
    int v383; // [esp+398h] [ebp-64h]
    int v384; // [esp+39Ch] [ebp-60h]
    int v385; // [esp+3A0h] [ebp-5Ch]
    char* v386; // [esp+3A4h] [ebp-58h]
    int v387; // [esp+3A8h] [ebp-54h]
    int v388; // [esp+3ACh] [ebp-50h]
    int v389; // [esp+3B0h] [ebp-4Ch]
    int v390; // [esp+3B4h] [ebp-48h]
    int v391; // [esp+3B8h] [ebp-44h]
    int v392; // [esp+3BCh] [ebp-40h]
    int v393; // [esp+3C0h] [ebp-3Ch]
    int v394; // [esp+3C4h] [ebp-38h]
    int v395; // [esp+3C8h] [ebp-34h]
    int v396; // [esp+3CCh] [ebp-30h]
    int v397; // [esp+3D0h] [ebp-2Ch]
    int v398; // [esp+3D4h] [ebp-28h]
    int i; // [esp+3D8h] [ebp-24h]
    char* v400; // [esp+3DCh] [ebp-20h]
    int v401; // [esp+3E0h] [ebp-1Ch]
    int v402; // [esp+3E4h] [ebp-18h]
    char* v403; // [esp+3E8h] [ebp-14h]
    int v404; // [esp+3ECh] [ebp-10h]
    int v405; // [esp+3F0h] [ebp-Ch]
    int v406; // [esp+3F4h] [ebp-8h]
    int v407; // [esp+3F8h] [ebp-4h]

    switch (*(_DWORD*)(a1 + 428))
    {
    case 0x7C:
    case 0x80:
        if (*(_DWORD*)(a1 + 444) == 1)
        {
            if (*(_DWORD*)(a1 + 428) == 124)
            {
                v4 = sub_41CB3B(a1, 1);
                sub_41F169((_WORD*)a1, v4);
            }
            else
            {
                v5 = sub_41CB3B(a1, 1);
                v6 = sub_41CB3B(a1, 1);
                v7 = sub_41D067(a1, 1);
                sub_41F169((_WORD*)a1, v6 * v7 / 200 + v5);
            }
            *(_BYTE*)(a1 + 248) = 0;
            *(_BYTE*)(a1 + 213) = -1;
            memset((void*)(a1 + 453), 0, 8u);
            memset((void*)(a1 + 461), 0, 8u);
            *(_BYTE*)(a1 + 257) = 1;
            if (!*(_DWORD*)(a1 + 392))
            {
                if (*(char*)(a1 + 224) < 0 && *(_DWORD*)(a1 + 424))
                {
                    *(_DWORD*)(a1 + 424) = 0;
                }
                else if (*(char*)(a1 + 224) > 0 && !*(_DWORD*)(a1 + 424))
                {
                    *(_DWORD*)(a1 + 424) = 1;
                }
            }
            if (*(_BYTE*)(a1 + 188) == 1)
                *(_BYTE*)(a1 + 256) = 6;
            if (*(_DWORD*)(a1 + 392))
            {
                if (*(unsigned __int8*)(a1 + 238) <= 1u && sub_41BA53(a1, 0x86u, 0))
                    *(_DWORD*)(a1 + 400) = 1;
            }
            else
            {
                *(_DWORD*)(a1 + 400) = 1;
                *(_DWORD*)(a1 + 408) = 1;
            }
        }
        if (*(_DWORD*)(a1 + 444) == 5)
        {
            *(_DWORD*)(a1 + 400) = 0;
            *(_DWORD*)(a1 + 408) = 0;
        }
        if (*(_BYTE*)(a1 + 188) == 1)
        {
            *(_BYTE*)(a1 + 212) = 1;
            if (*(int*)(a1 + 444) >= 4)
            {
                if (*(int*)(a1 + 444) >= 8)
                {
                    if (*(int*)(a1 + 444) >= 12)
                    {
                        if (*(int*)(a1 + 444) >= 16)
                        {
                            *(_WORD*)(a1 + 204) = 3;
                        }
                        else
                        {
                            *(_BYTE*)(a1 + 257) = 2;
                            *(_WORD*)(a1 + 204) = 4;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 5;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 4;
                }
            }
            else
            {
                *(_WORD*)(a1 + 204) = 3;
            }
            if (*(_DWORD*)(a1 + 444) == 4)
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A24, -1, 100, 100, 0);
            if (*(int*)(a1 + 444) >= 20)
                *(_DWORD*)(a1 + 432) = 3;
        }
        else if (*(_BYTE*)(a1 + 188) == 2 || *(_BYTE*)(a1 + 188) == 3)
        {
            *(_BYTE*)(a1 + 212) = 1;
            if (*(int*)(a1 + 444) >= 4)
            {
                if (*(int*)(a1 + 444) >= 8)
                {
                    if (*(int*)(a1 + 444) >= 14)
                    {
                        *(_BYTE*)(a1 + 257) = 2;
                        *(_WORD*)(a1 + 204) = 0;
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 8;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 7;
                }
            }
            else
            {
                *(_WORD*)(a1 + 204) = 6;
            }
            if (*(_DWORD*)(a1 + 444) == 4)
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
            if (*(_DWORD*)(a1 + 444) == 12)
                *(_DWORD*)(a1 + 404) = 1;
            if (*(int*)(a1 + 444) >= 18)
            {
                if (*(_DWORD*)(a1 + 392))
                    *(_DWORD*)(a1 + 432) = 50;
                else
                    *(_DWORD*)(a1 + 432) = 4;
            }
        }
        else
        {
            *(_BYTE*)(a1 + 212) = 1;
            if (*(_BYTE*)(a1 + 195))
            {
                switch (*(_BYTE*)(a1 + 195))
                {
                case 1:
                    if (*(int*)(a1 + 444) >= 4)
                    {
                        if (*(int*)(a1 + 444) >= 8)
                        {
                            if (*(int*)(a1 + 444) >= 12)
                            {
                                *(_BYTE*)(a1 + 257) = 2;
                                *(_WORD*)(a1 + 204) = 0;
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 1;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 0;
                        }
                    }
                    else
                    {
                        *(_BYTE*)(a1 + 212) = 0;
                        *(_WORD*)(a1 + 204) = 4;
                    }
                    if (*(_DWORD*)(a1 + 444) == 12)
                        *(_DWORD*)(a1 + 404) = 1;
                    if (*(_DWORD*)(a1 + 444) == 7)
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                    if (*(int*)(a1 + 444) > 16)
                    {
                        if (*(_DWORD*)(a1 + 392))
                            *(_DWORD*)(a1 + 432) = 50;
                        else
                            *(_DWORD*)(a1 + 432) = 4;
                    }
                    break;
                case 2:
                    if (*(int*)(a1 + 444) >= 4)
                    {
                        if (*(int*)(a1 + 444) >= 8)
                        {
                            if (*(int*)(a1 + 444) >= 12)
                            {
                                if (*(int*)(a1 + 444) >= 16)
                                {
                                    *(_WORD*)(a1 + 204) = 0;
                                }
                                else
                                {
                                    *(_BYTE*)(a1 + 257) = 2;
                                    *(_WORD*)(a1 + 204) = 1;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 2;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 1;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 0;
                    }
                    if (*(_DWORD*)(a1 + 444) == 16)
                        *(_DWORD*)(a1 + 404) = 1;
                    if (*(_DWORD*)(a1 + 444) == 7)
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                    if (*(int*)(a1 + 444) >= 20)
                    {
                        if (*(_DWORD*)(a1 + 392))
                            *(_DWORD*)(a1 + 432) = 50;
                        else
                            *(_DWORD*)(a1 + 432) = 4;
                    }
                    break;
                case 3:
                    if (*(int*)(a1 + 444) >= 4)
                    {
                        if (*(int*)(a1 + 444) >= 8)
                        {
                            if (*(int*)(a1 + 444) >= 12)
                            {
                                if (*(int*)(a1 + 444) >= 16)
                                {
                                    *(_WORD*)(a1 + 204) = 0;
                                }
                                else
                                {
                                    *(_BYTE*)(a1 + 257) = 2;
                                    *(_WORD*)(a1 + 204) = 1;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 2;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 1;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 0;
                    }
                    if (*(_DWORD*)(a1 + 444) == 16)
                        *(_DWORD*)(a1 + 404) = 1;
                    if (*(_DWORD*)(a1 + 444) == 7)
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                    if (*(int*)(a1 + 444) >= 20)
                    {
                        if (*(_DWORD*)(a1 + 392))
                            *(_DWORD*)(a1 + 432) = 50;
                        else
                            *(_DWORD*)(a1 + 432) = 4;
                    }
                    break;
                case 4:
                    if (*(int*)(a1 + 444) >= 4)
                    {
                        if (*(int*)(a1 + 444) >= 8)
                        {
                            if (*(int*)(a1 + 444) >= 12)
                            {
                                *(_WORD*)(a1 + 204) = 3;
                            }
                            else
                            {
                                *(_BYTE*)(a1 + 257) = 2;
                                *(_WORD*)(a1 + 204) = 2;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 1;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 0;
                    }
                    if (*(_DWORD*)(a1 + 444) == 8)
                        *(_DWORD*)(a1 + 404) = 1;
                    if (*(_DWORD*)(a1 + 444) == 2)
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                    if (*(int*)(a1 + 444) >= 16)
                    {
                        if (*(_DWORD*)(a1 + 392))
                            *(_DWORD*)(a1 + 432) = 50;
                        else
                            *(_DWORD*)(a1 + 432) = 4;
                    }
                    break;
                }
            }
            else
            {
                if (*(int*)(a1 + 444) >= 4)
                {
                    if (*(int*)(a1 + 444) >= 8)
                    {
                        if (*(int*)(a1 + 444) >= 12)
                        {
                            *(_BYTE*)(a1 + 257) = 2;
                            *(_WORD*)(a1 + 204) = 2;
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 3;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 2;
                    }
                }
                else
                {
                    *(_BYTE*)(a1 + 212) = 0;
                    *(_WORD*)(a1 + 204) = 4;
                }
                if (*(_DWORD*)(a1 + 444) == 14)
                    *(_DWORD*)(a1 + 404) = 1;
                if (*(_DWORD*)(a1 + 444) == 7)
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                if (*(int*)(a1 + 444) > 16)
                {
                    if (*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 432) = 50;
                    else
                        *(_DWORD*)(a1 + 432) = 4;
                }
            }
        }
        return;
    case 0x7B:
    case 0x7F:
        *(_BYTE*)(a1 + 248) = 0;
        *(_BYTE*)(a1 + 212) = 1;
        *(_BYTE*)(a1 + 213) = -1;
        if (*(_DWORD*)(a1 + 444) == 1)
        {
            if (*(_DWORD*)(a1 + 392))
            {
                v9 = sub_41CCEA(a1, 1);
                v10 = sub_41CCEA(a1, 1);
                v11 = sub_41D067(a1, 1);
                sub_41F169((_WORD*)a1, v10 * v11 / 200 + v9);
            }
            else
            {
                v8 = sub_41CCEA(a1, 1);
                sub_41F169((_WORD*)a1, v8);
            }
            memset((void*)(a1 + 453), 0, 8u);
            memset((void*)(a1 + 461), 0, 8u);
            *(_BYTE*)(a1 + 257) = 1;
            if (!*(_DWORD*)(a1 + 392))
            {
                if (*(char*)(a1 + 224) < 0 && *(_DWORD*)(a1 + 424))
                {
                    *(_DWORD*)(a1 + 424) = 0;
                }
                else if (*(char*)(a1 + 224) > 0 && !*(_DWORD*)(a1 + 424))
                {
                    *(_DWORD*)(a1 + 424) = 1;
                }
            }
            if (!*(_DWORD*)(a1 + 392) || *(unsigned __int8*)(a1 + 238) <= 1u && sub_41BA53(a1, 0x86u, 0))
                *(_DWORD*)(a1 + 400) = 1;
        }
        if (*(_DWORD*)(a1 + 444) == 5)
            *(_DWORD*)(a1 + 400) = 0;
        if (*(_BYTE*)(a1 + 188) == 2 || *(_BYTE*)(a1 + 188) == 3)
        {
            *(_BYTE*)(a1 + 212) = 1;
            if (*(int*)(a1 + 444) >= 4)
            {
                if (*(int*)(a1 + 444) >= 8)
                {
                    if (*(int*)(a1 + 444) >= 14)
                    {
                        *(_BYTE*)(a1 + 257) = 2;
                        *(_WORD*)(a1 + 204) = 0;
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 11;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 10;
                }
            }
            else
            {
                *(_WORD*)(a1 + 204) = 9;
            }
            if (*(_DWORD*)(a1 + 444) == 4)
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
            if (*(_DWORD*)(a1 + 444) == 12)
                *(_DWORD*)(a1 + 404) = 1;
            if (*(int*)(a1 + 444) >= 18)
            {
                if (*(_DWORD*)(a1 + 392))
                    *(_DWORD*)(a1 + 432) = 50;
                else
                    *(_DWORD*)(a1 + 432) = 4;
            }
        }
        else if (*(_BYTE*)(a1 + 195))
        {
            switch (*(_BYTE*)(a1 + 195))
            {
            case 1:
                if (*(int*)(a1 + 444) >= 5)
                {
                    if (*(int*)(a1 + 444) >= 10)
                    {
                        *(_BYTE*)(a1 + 257) = 2;
                        *(_WORD*)(a1 + 204) = 2;
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 3;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 2;
                }
                if (*(_DWORD*)(a1 + 444) == 14)
                    *(_DWORD*)(a1 + 404) = 1;
                if (*(_DWORD*)(a1 + 444) == 5)
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                if (*(int*)(a1 + 444) > 15)
                {
                    if (*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 432) = 50;
                    else
                        *(_DWORD*)(a1 + 432) = 4;
                }
                break;
            case 2:
                if (*(int*)(a1 + 444) >= 4)
                {
                    if (*(int*)(a1 + 444) >= 12)
                    {
                        if (*(int*)(a1 + 444) >= 16)
                        {
                            *(_WORD*)(a1 + 204) = 0;
                        }
                        else
                        {
                            *(_BYTE*)(a1 + 257) = 2;
                            *(_WORD*)(a1 + 204) = 3;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 4;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 3;
                }
                if (*(_DWORD*)(a1 + 444) == 12)
                    *(_DWORD*)(a1 + 404) = 1;
                if (*(_DWORD*)(a1 + 444) == 4)
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                if (*(int*)(a1 + 444) >= 20)
                {
                    if (*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 432) = 50;
                    else
                        *(_DWORD*)(a1 + 432) = 4;
                }
                break;
            case 3:
                if (*(int*)(a1 + 444) >= 4)
                {
                    if (*(int*)(a1 + 444) >= 12)
                    {
                        if (*(int*)(a1 + 444) >= 16)
                        {
                            if (*(int*)(a1 + 444) >= 20)
                                *(_WORD*)(a1 + 204) = 0;
                            else
                                *(_WORD*)(a1 + 204) = 5;
                        }
                        else
                        {
                            *(_BYTE*)(a1 + 257) = 2;
                            *(_WORD*)(a1 + 204) = 3;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 4;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 3;
                }
                if (*(_DWORD*)(a1 + 444) == 20)
                    *(_DWORD*)(a1 + 404) = 1;
                if (*(_DWORD*)(a1 + 444) == 4)
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                if (*(int*)(a1 + 444) >= 24)
                {
                    if (*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 432) = 50;
                    else
                        *(_DWORD*)(a1 + 432) = 4;
                }
                break;
            case 4:
                if (*(int*)(a1 + 444) >= 4)
                {
                    if (*(int*)(a1 + 444) >= 8)
                    {
                        if (*(int*)(a1 + 444) >= 12)
                        {
                            *(_WORD*)(a1 + 204) = 3;
                        }
                        else
                        {
                            *(_BYTE*)(a1 + 257) = 2;
                            *(_WORD*)(a1 + 204) = 4;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 5;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 4;
                }
                if (*(_DWORD*)(a1 + 444) == 7)
                    *(_DWORD*)(a1 + 404) = 1;
                if (*(_DWORD*)(a1 + 444) == 2)
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                if (*(int*)(a1 + 444) >= 16)
                {
                    if (*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 432) = 50;
                    else
                        *(_DWORD*)(a1 + 432) = 4;
                }
                break;
            }
        }
        else
        {
            if (*(int*)(a1 + 444) >= 5)
            {
                if (*(int*)(a1 + 444) >= 10)
                {
                    *(_BYTE*)(a1 + 257) = 2;
                    *(_WORD*)(a1 + 204) = 0;
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 1;
                }
            }
            else
            {
                *(_WORD*)(a1 + 204) = 0;
            }
            if (*(_DWORD*)(a1 + 444) == 12)
                *(_DWORD*)(a1 + 404) = 1;
            if (*(_DWORD*)(a1 + 444) == 5)
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
            if (*(int*)(a1 + 444) > 15)
            {
                if (*(_DWORD*)(a1 + 392))
                    *(_DWORD*)(a1 + 432) = 50;
                else
                    *(_DWORD*)(a1 + 432) = 4;
            }
        }
        return;
    case 0x86:
        *(_BYTE*)(a1 + 248) = 1;
        *(_BYTE*)(a1 + 212) = 1;
        *(_BYTE*)(a1 + 213) = -1;
        if (*(_DWORD*)(a1 + 444) == 1)
        {
            memset((void*)(a1 + 453), 0, 8u);
            memset((void*)(a1 + 461), 0, 8u);
            *(_BYTE*)(a1 + 257) = 1;
        }
        if (*(_BYTE*)(a1 + 188) == 1)
        {
            if (*(int*)(a1 + 444) >= 5)
            {
                if (*(int*)(a1 + 444) >= 10)
                {
                    if (*(int*)(a1 + 444) >= 15)
                        *(_WORD*)(a1 + 204) = 9;
                    else
                        *(_WORD*)(a1 + 204) = 8;
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 7;
                }
            }
            else
            {
                *(_WORD*)(a1 + 204) = 6;
            }
            if (*(_DWORD*)(a1 + 444) == 4)
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A24, -1, 100, 100, 0);
            if (*(int*)(a1 + 444) >= 20)
                *(_DWORD*)(a1 + 432) = 3;
        }
        else if (*(_BYTE*)(a1 + 188) == 2 || *(_BYTE*)(a1 + 188) == 3)
        {
            if (*(_DWORD*)(a1 + 436))
            {
                v13 = (double)sub_41CCEA(a1, 1) * 1.5;
                sub_41F169((_WORD*)a1, (__int64)v13);
                if (*(int*)(a1 + 444) >= 10)
                {
                    if (*(int*)(a1 + 444) >= 14)
                    {
                        if (*(int*)(a1 + 444) >= 18)
                        {
                            if (*(int*)(a1 + 444) < 26)
                            {
                                *(_BYTE*)(a1 + 257) = 2;
                                *(_WORD*)(a1 + 204) = 19;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 18;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 17;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 12;
                }
                if (*(_DWORD*)(a1 + 444) == 10)
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                if (*(int*)(a1 + 444) >= 26)
                    *(_DWORD*)(a1 + 432) = 3;
            }
            else
            {
                v12 = (double)sub_41CB3B(a1, 1) * 1.5;
                sub_41F169((_WORD*)a1, (__int64)v12);
                if (*(int*)(a1 + 444) >= 10)
                {
                    if (*(int*)(a1 + 444) >= 14)
                    {
                        if (*(int*)(a1 + 444) >= 18)
                        {
                            if (*(int*)(a1 + 444) >= 26)
                            {
                                *(_WORD*)(a1 + 204) = 16;
                            }
                            else
                            {
                                *(_BYTE*)(a1 + 257) = 2;
                                *(_WORD*)(a1 + 204) = 15;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 14;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 13;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 12;
                }
                if (*(_DWORD*)(a1 + 444) == 10)
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                if (*(int*)(a1 + 444) >= 30)
                    *(_DWORD*)(a1 + 432) = 3;
            }
        }
        else if (*(_DWORD*)(a1 + 480))
        {
            if (*(_DWORD*)(a1 + 444) == 1)
            {
                v407 = (__int64)((double)sub_41CB3B(a1, 1) * 1.5);
                v14 = sub_43E620((short*)*(_DWORD*)(a1 + 480));
                sub_41F169((_WORD*)a1, (v407 * v14 / 100 + 50) / 2);
            }
            *(_BYTE*)(a1 + 212) = 0;
            if (*(int*)(a1 + 444) >= 4)
            {
                if (*(int*)(a1 + 444) >= 8)
                {
                    if (*(int*)(a1 + 444) >= 12)
                    {
                        if (*(int*)(a1 + 444) >= 20)
                        {
                            if (*(int*)(a1 + 444) >= 24)
                            {
                                *(_WORD*)(a1 + 204) = 208;
                            }
                            else
                            {
                                *(_BYTE*)(a1 + 251) = 0;
                                *(_WORD*)(a1 + 204) = 209;
                            }
                        }
                        else
                        {
                            *(_BYTE*)(a1 + 257) = 2;
                            *(_WORD*)(a1 + 204) = 211;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 210;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 209;
                }
            }
            else
            {
                *(_WORD*)(a1 + 204) = 208;
            }
            if (*(int*)(a1 + 444) >= 28)
                *(_DWORD*)(a1 + 432) = 3;
        }
        else if (*(_BYTE*)(a1 + 195))
        {
            switch (*(_BYTE*)(a1 + 195))
            {
            case 1:
                v16 = (double)sub_41CB3B(a1, 1) * 1.5;
                sub_41F169((_WORD*)a1, (__int64)v16);
                if (*(int*)(a1 + 444) >= 4)
                {
                    if (*(int*)(a1 + 444) >= 8)
                    {
                        if (*(int*)(a1 + 444) >= 10)
                        {
                            if (*(int*)(a1 + 444) >= 21)
                            {
                                *(_WORD*)(a1 + 204) = 29;
                            }
                            else
                            {
                                *(_BYTE*)(a1 + 257) = 2;
                                *(_WORD*)(a1 + 204) = 7;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 6;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 5;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 4;
                }
                if (*(int*)(a1 + 444) > 24)
                    *(_DWORD*)(a1 + 432) = 4;
                break;
            case 2:
                v17 = (double)sub_41CCEA(a1, 1) * 1.5;
                sub_41F169((_WORD*)a1, (__int64)v17);
                if (*(int*)(a1 + 444) >= 4)
                {
                    if (*(int*)(a1 + 444) >= 8)
                    {
                        if (*(int*)(a1 + 444) >= 12)
                        {
                            if (*(int*)(a1 + 444) >= 16)
                            {
                                if (*(int*)(a1 + 444) >= 20)
                                {
                                    if (*(int*)(a1 + 444) >= 24)
                                    {
                                        if (*(int*)(a1 + 444) >= 28)
                                        {
                                            if (*(int*)(a1 + 444) >= 32)
                                            {
                                                *(_WORD*)(a1 + 204) = 0;
                                            }
                                            else
                                            {
                                                *(_BYTE*)(a1 + 212) = 0;
                                                *(_WORD*)(a1 + 204) = 3;
                                            }
                                        }
                                        else
                                        {
                                            *(_WORD*)(a1 + 204) = 11;
                                        }
                                    }
                                    else
                                    {
                                        *(_BYTE*)(a1 + 257) = 2;
                                        *(_WORD*)(a1 + 204) = 10;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 9;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 8;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 7;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 6;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 5;
                }
                if (*(int*)(a1 + 444) >= 36)
                    *(_DWORD*)(a1 + 432) = 4;
                break;
            case 3:
                v18 = (double)sub_41CCEA(a1, 1) * 1.5;
                sub_41F169((_WORD*)a1, (__int64)v18);
                if (*(int*)(a1 + 444) >= 4)
                {
                    if (*(int*)(a1 + 444) >= 8)
                    {
                        if (*(int*)(a1 + 444) >= 12)
                        {
                            if (*(int*)(a1 + 444) >= 16)
                            {
                                if (*(int*)(a1 + 444) >= 20)
                                {
                                    if (*(int*)(a1 + 444) >= 24)
                                        *(_WORD*)(a1 + 204) = 0;
                                    else
                                        *(_WORD*)(a1 + 204) = 6;
                                }
                                else
                                {
                                    *(_BYTE*)(a1 + 257) = 2;
                                    *(_WORD*)(a1 + 204) = 3;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 9;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 8;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 7;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 6;
                }
                if (*(int*)(a1 + 444) >= 28)
                    *(_DWORD*)(a1 + 432) = 4;
                break;
            case 4:
                v19 = (double)sub_41CB3B(a1, 1) * 1.5;
                sub_41F169((_WORD*)a1, (__int64)v19);
                if (*(int*)(a1 + 444) >= 4)
                {
                    if (*(int*)(a1 + 444) >= 8)
                    {
                        if (*(int*)(a1 + 444) >= 12)
                        {
                            if (*(int*)(a1 + 444) >= 16)
                            {
                                if (*(int*)(a1 + 444) >= 26)
                                {
                                    if (*(int*)(a1 + 444) >= 30)
                                        *(_WORD*)(a1 + 204) = *(int*)(a1 + 444) >= 34 ? 6 : 7;
                                    else
                                        *(_WORD*)(a1 + 204) = 11;
                                }
                                else
                                {
                                    *(_BYTE*)(a1 + 257) = 2;
                                    *(_WORD*)(a1 + 204) = 10;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 9;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 8;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 7;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 6;
                }
                if (*(int*)(a1 + 444) >= 38)
                    *(_DWORD*)(a1 + 432) = 4;
                break;
            }
        }
        else
        {
            v15 = (double)sub_41CB3B(a1, 1) * 1.5;
            sub_41F169((_WORD*)a1, (__int64)v15);
            if (*(int*)(a1 + 444) >= 4)
            {
                if (*(int*)(a1 + 444) >= 8)
                {
                    if (*(int*)(a1 + 444) >= 20)
                    {
                        *(_WORD*)(a1 + 204) = 4;
                    }
                    else
                    {
                        *(_BYTE*)(a1 + 257) = 2;
                        *(_WORD*)(a1 + 204) = 6;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 5;
                }
            }
            else
            {
                *(_WORD*)(a1 + 204) = 4;
            }
            if (*(int*)(a1 + 444) > 24)
                *(_DWORD*)(a1 + 432) = 4;
        }
        return;
    case 0x81:
        v20 = sub_41CCEA(a1, 1);
        v21 = sub_41CCEA(a1, 1);
        v22 = sub_41CA5F(a1, 1) * v21;
        v23 = sub_41D067(a1, 1);
        sub_41F169((_WORD*)a1, v22 * v23 / 10000 + v20);
        *(_BYTE*)(a1 + 248) = 2;
        *(_BYTE*)(a1 + 212) = 1;
        *(_BYTE*)(a1 + 213) = -1;
        if (*(_DWORD*)(a1 + 444) == 1)
        {
            memset((void*)(a1 + 453), 0, 8u);
            memset((void*)(a1 + 461), 0, 8u);
            *(_BYTE*)(a1 + 257) = 1;
            if (*(unsigned __int8*)(a1 + 238) <= 1u)
            {
                if (sub_41BA53(a1, 0x86u, 0))
                    *(_DWORD*)(a1 + 400) = 1;
            }
        }
        if (*(_DWORD*)(a1 + 444) == 5)
            *(_DWORD*)(a1 + 400) = 0;
        if (*(_BYTE*)(a1 + 188) == 2 || *(_BYTE*)(a1 + 188) == 3)
        {
            *(_WORD*)(a1 + 204) = 20;
        }
        else if (*(_BYTE*)(a1 + 195))
        {
            switch (*(_BYTE*)(a1 + 195))
            {
            case 1:
                *(_WORD*)(a1 + 204) = 3;
                break;
            case 2:
                *(_WORD*)(a1 + 204) = 16;
                break;
            case 3:
                *(_WORD*)(a1 + 204) = 31;
                break;
            case 4:
                *(_WORD*)(a1 + 204) = 12;
                break;
            }
        }
        else
        {
            *(_WORD*)(a1 + 204) = 7;
        }
        if (*(_DWORD*)(a1 + 444) == 1)
            sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
        return;
    case 0x82:
        v24 = sub_41CB3B(a1, 1);
        v25 = sub_41CB3B(a1, 1);
        v26 = sub_41CA5F(a1, 1) * v25;
        v27 = sub_41D067(a1, 1);
        sub_41F169((_WORD*)a1, v26 * v27 / 10000 + v24);
        *(_BYTE*)(a1 + 248) = 2;
        *(_BYTE*)(a1 + 212) = 1;
        *(_BYTE*)(a1 + 213) = -1;
        if (*(_DWORD*)(a1 + 444) == 1)
        {
            memset((void*)(a1 + 453), 0, 8u);
            memset((void*)(a1 + 461), 0, 8u);
            *(_BYTE*)(a1 + 257) = 1;
            if (*(unsigned __int8*)(a1 + 238) <= 1u)
            {
                if (sub_41BA53(a1, 0x86u, 0))
                    *(_DWORD*)(a1 + 400) = 1;
            }
        }
        if (*(_DWORD*)(a1 + 444) == 5)
            *(_DWORD*)(a1 + 400) = 0;
        if (*(_BYTE*)(a1 + 188) == 2 || *(_BYTE*)(a1 + 188) == 3)
        {
            *(_WORD*)(a1 + 204) = 8;
        }
        else if (*(_BYTE*)(a1 + 195))
        {
            switch (*(_BYTE*)(a1 + 195))
            {
            case 1:
                *(_WORD*)(a1 + 204) = 28;
                break;
            case 2:
                if (*(int*)(a1 + 444) >= 4)
                    *(_WORD*)(a1 + 204) = 2;
                else
                    *(_WORD*)(a1 + 204) = 1;
                break;
            case 3:
                *(_WORD*)(a1 + 204) = 2;
                break;
            case 4:
                *(_WORD*)(a1 + 204) = 1;
                break;
            }
        }
        else
        {
            *(_WORD*)(a1 + 204) = 8;
        }
        if (*(_DWORD*)(a1 + 444) == 1)
            sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
        return;
    case 0x7D:
        *(_BYTE*)(a1 + 212) = 1;
        if (*(_DWORD*)(a1 + 444) == 1)
        {
            memset((void*)(a1 + 453), 0, 8u);
            memset((void*)(a1 + 461), 0, 8u);
            v28 = sub_41CCEA(a1, 1);
            v29 = sub_41CCEA(a1, 1);
            v30 = sub_41CA5F(a1, 1);
            sub_41F169((_WORD*)a1, v29 * v30 / 200 + v28);
            *(_BYTE*)(a1 + 248) = 3;
            *(_BYTE*)(a1 + 257) = 1;
            *(_BYTE*)(a1 + 213) = -1;
            if (*(_BYTE*)(a1 + 188) == 2 || *(_BYTE*)(a1 + 188) == 3)
            {
                *(_BYTE*)(a1 + 248) = 0;
                *(_DWORD*)(a1 + 352) *= 2;
                *(_DWORD*)(a1 + 356) *= 2;
            }
        }
        if (*(_BYTE*)(a1 + 188) == 2 || *(_BYTE*)(a1 + 188) == 3)
        {
            *(_BYTE*)(a1 + 212) = 1;
            if (*(int*)(a1 + 444) >= 4)
            {
                if (*(int*)(a1 + 444) >= 8)
                {
                    if (*(int*)(a1 + 444) >= 14)
                    {
                        *(_BYTE*)(a1 + 257) = 2;
                        *(_WORD*)(a1 + 204) = 0;
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 11;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 10;
                }
            }
            else
            {
                *(_WORD*)(a1 + 204) = 9;
            }
            if (*(_DWORD*)(a1 + 444) == 4)
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
            if (*(_DWORD*)(a1 + 444) == 12)
                *(_DWORD*)(a1 + 404) = 1;
            if (*(int*)(a1 + 444) >= 18)
                *(_DWORD*)(a1 + 432) = 4;
        }
        else if (*(_BYTE*)(a1 + 195))
        {
            switch (*(_BYTE*)(a1 + 195))
            {
            case 1:
                *(_WORD*)(a1 + 204) = 3;
                if (*(_DWORD*)(a1 + 444) == 1)
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A18, -1, 100, 100, 0);
                if (*(int*)(a1 + 444) > 30)
                    *(_DWORD*)(a1 + 432) = 4;
                break;
            case 2:
                if (*(int*)(a1 + 444) >= 4)
                    *(_WORD*)(a1 + 204) = 15;
                else
                    *(_WORD*)(a1 + 204) = 14;
                if (*(_DWORD*)(a1 + 444) == 1)
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A18, -1, 100, 100, 0);
                if (*(int*)(a1 + 444) > 30)
                    *(_DWORD*)(a1 + 432) = 4;
                break;
            case 3:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                    *(_DWORD*)(a1 + 436) = 0;
                    *(_DWORD*)(a1 + 352) = 0;
                    *(_DWORD*)(a1 + 356) = 0;
                    *(_DWORD*)(a1 + 348) = -400;
                    *(_DWORD*)(a1 + 360) = 30;
                    *(_DWORD*)(a1 + 392) = 1;
                    *(_DWORD*)(a1 + 400) = 0;
                    if ((unsigned __int8)++ * (_BYTE*)(a1 + 238) <= 1u)
                    {
                        if (sub_41BA53(a1, 0x86u, 0))
                            *(_DWORD*)(a1 + 400) = 1;
                    }
                }
                if (*(_DWORD*)(a1 + 436))
                {
                    if (*(_DWORD*)(a1 + 444) - *(_DWORD*)(a1 + 436) >= 8)
                        *(_WORD*)(a1 + 204) = 35;
                    else
                        *(_WORD*)(a1 + 204) = 34;
                }
                else if (*(int*)(a1 + 444) >= 5)
                {
                    *(_BYTE*)(a1 + 212) = 1;
                    *(_WORD*)(a1 + 204) = 33;
                }
                else
                {
                    *(_BYTE*)(a1 + 212) = 1;
                    *(_WORD*)(a1 + 204) = 32;
                }
                break;
            case 4:
                *(_WORD*)(a1 + 204) = 13;
                if (*(_DWORD*)(a1 + 444) == 1)
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A18, -1, 100, 100, 0);
                if (*(int*)(a1 + 444) > 30)
                {
                    *(_DWORD*)(a1 + 432) = 4;
                    *(_DWORD*)(a1 + 444) = 0;
                }
                break;
            }
        }
        else
        {
            *(_WORD*)(a1 + 204) = 9;
            if (*(_DWORD*)(a1 + 444) == 1)
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A18, -1, 100, 100, 0);
            if (*(int*)(a1 + 444) > 30)
            {
                *(_DWORD*)(a1 + 432) = 4;
                *(_DWORD*)(a1 + 444) = 0;
            }
        }
        return;
    case 0x7E:
        *(_BYTE*)(a1 + 212) = 1;
        *(_BYTE*)(a1 + 213) = -1;
        if (*(_DWORD*)(a1 + 444) == 1)
        {
            memset((void*)(a1 + 453), 0, 8u);
            memset((void*)(a1 + 461), 0, 8u);
            *(_BYTE*)(a1 + 257) = 1;
            if (*(_BYTE*)(a1 + 195) == 1)
            {
                v31 = sub_41CB3B(a1, 1);
                v32 = sub_41CB3B(a1, 1);
                v33 = sub_41CA5F(a1, 1);
                sub_41F169((_WORD*)a1, (v31 + v32 * v33 / 200) / 2);
            }
            else
            {
                v34 = sub_41CB3B(a1, 1);
                v35 = sub_41CB3B(a1, 1);
                v36 = sub_41CA5F(a1, 1);
                sub_41F169((_WORD*)a1, v35 * v36 / 200 + v34);
            }
            *(_BYTE*)(a1 + 248) = 3;
            if (*(_BYTE*)(a1 + 188) == 2 || *(_BYTE*)(a1 + 188) == 3)
            {
                *(_BYTE*)(a1 + 248) = 0;
                *(_DWORD*)(a1 + 352) *= 2;
                *(_DWORD*)(a1 + 356) *= 2;
            }
        }
        if (*(_BYTE*)(a1 + 188) == 1)
        {
            if (*(int*)(a1 + 444) >= 30)
            {
                if (*(int*)(a1 + 444) >= 38)
                {
                    *(_WORD*)(a1 + 204) = 3;
                }
                else
                {
                    *(_BYTE*)(a1 + 257) = 2;
                    *(_WORD*)(a1 + 204) = 4;
                }
            }
            else
            {
                *(_WORD*)(a1 + 204) = 61;
            }
            if (*(_DWORD*)(a1 + 444) == 1)
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A18, -1, 100, 100, 0);
            if (*(int*)(a1 + 444) > 45)
            {
                *(_DWORD*)(a1 + 432) = 3;
                *(_DWORD*)(a1 + 444) = 0;
            }
        }
        else if (*(_BYTE*)(a1 + 188) == 2 || *(_BYTE*)(a1 + 188) == 3)
        {
            *(_BYTE*)(a1 + 212) = 1;
            if (*(int*)(a1 + 444) >= 4)
            {
                if (*(int*)(a1 + 444) >= 8)
                {
                    if (*(int*)(a1 + 444) >= 14)
                    {
                        *(_BYTE*)(a1 + 257) = 2;
                        *(_WORD*)(a1 + 204) = 0;
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 8;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 7;
                }
            }
            else
            {
                *(_WORD*)(a1 + 204) = 6;
            }
            if (*(_DWORD*)(a1 + 444) == 4)
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
            if (*(_DWORD*)(a1 + 444) == 12)
                *(_DWORD*)(a1 + 404) = 1;
            if (*(int*)(a1 + 444) >= 18)
                *(_DWORD*)(a1 + 432) = 4;
        }
        else if (*(_BYTE*)(a1 + 195))
        {
            switch (*(_BYTE*)(a1 + 195))
            {
            case 1:
                if (*(int*)(a1 + 444) >= 10)
                    *(_WORD*)(a1 + 204) = 9;
                else
                    *(_WORD*)(a1 + 204) = 8;
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A18, -1, 100, 100, 0);
                }
                else if (*(_DWORD*)(a1 + 444) == 10)
                {
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                }
                if (*(int*)(a1 + 444) > 30)
                {
                    *(_DWORD*)(a1 + 432) = 4;
                    *(_DWORD*)(a1 + 444) = 0;
                }
                break;
            case 2:
                if (*(int*)(a1 + 444) >= 4)
                    *(_WORD*)(a1 + 204) = 13;
                else
                    *(_WORD*)(a1 + 204) = 12;
                if (*(_DWORD*)(a1 + 444) == 1)
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A18, -1, 100, 100, 0);
                if (*(int*)(a1 + 444) > 30)
                    *(_DWORD*)(a1 + 432) = 4;
                break;
            case 3:
                *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 5 % 4 + 10;
                if (*(int*)(a1 + 444) >= 26)
                {
                    *(_BYTE*)(a1 + 212) = 0;
                    *(_WORD*)(a1 + 204) = 6;
                }
                if (*(_DWORD*)(a1 + 444) == 1)
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A18, -1, 100, 100, 0);
                if (*(int*)(a1 + 444) > 30)
                    *(_DWORD*)(a1 + 432) = 4;
                break;
            case 4:
                *(_WORD*)(a1 + 204) = 13;
                if (*(_DWORD*)(a1 + 444) == 1)
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A18, -1, 100, 100, 0);
                if (*(int*)(a1 + 444) > 30)
                {
                    *(_DWORD*)(a1 + 432) = 4;
                    *(_DWORD*)(a1 + 444) = 0;
                }
                break;
            }
        }
        else
        {
            *(_WORD*)(a1 + 204) = 10;
            if (*(_DWORD*)(a1 + 444) == 1)
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A18, -1, 100, 100, 0);
            if (*(int*)(a1 + 444) > 30)
            {
                *(_DWORD*)(a1 + 432) = 4;
                *(_DWORD*)(a1 + 444) = 0;
            }
        }
        return;
    case 0x83:
        v37 = (double)sub_41CB3B(a1, 1) * 1.5;
        sub_41F169((_WORD*)a1, (__int64)v37);
        *(_BYTE*)(a1 + 248) = 1;
        *(_BYTE*)(a1 + 212) = 0;
        *(_WORD*)(a1 + 204) = 54;
        *(_BYTE*)(a1 + 213) = -1;
        if (*(_DWORD*)(a1 + 444) == 1)
        {
            memset((void*)(a1 + 453), 0, 8u);
            memset((void*)(a1 + 461), 0, 8u);
            *(_BYTE*)(a1 + 257) = 1;
            sub_43FFC3((int*)unk_4BDB28, dword_4B9A18, -1, 100, 100, 0);
        }
        if (*(int*)(a1 + 444) > 30)
        {
            *(_DWORD*)(a1 + 432) = 4;
            *(_DWORD*)(a1 + 444) = 0;
        }
        return;
    case 0x85:
        if (*(_DWORD*)(a1 + 444) == 1)
        {
            v284 = (double)sub_41CB3B(a1, 1) * 1.2;
            v38 = sub_41CB3B(a1, 1);
            v39 = (double)(v38 * sub_41D067(a1, 1) / 200) + v284;
            sub_41F169((_WORD*)a1, (__int64)v39);
            *(_BYTE*)(a1 + 248) = 0;
            *(_BYTE*)(a1 + 213) = -1;
            memset((void*)(a1 + 453), 0, 8u);
            memset((void*)(a1 + 461), 0, 8u);
            *(_BYTE*)(a1 + 257) = 1;
            *(_DWORD*)(a1 + 372) = 0;
            *(_DWORD*)(a1 + 376) = 0;
            *(_DWORD*)(a1 + 340) = 0;
            *(_DWORD*)(a1 + 352) = 0;
            *(_DWORD*)(a1 + 344) = 0;
            *(_DWORD*)(a1 + 348) = -420;
            *(_DWORD*)(a1 + 360) = 30;
            sub_43FFC3((int*)unk_4BDB28, dword_4B9A04, -1, 100, 100, 0);
        }
        *(_BYTE*)(a1 + 212) = 0;
        if (*(int*)(a1 + 348) >= 0)
            *(_WORD*)(a1 + 204) = 54;
        else
            *(_WORD*)(a1 + 204) = 25;
        return;
    case 0x84:
    case 0x8B:
        if (*(_DWORD*)(a1 + 444) == 1)
        {
            v283 = (double)sub_41CCEA(a1, 1) * 1.2;
            v40 = sub_41CCEA(a1, 1);
            v41 = (double)(v40 * sub_41D067(a1, 1) / 200) + v283;
            sub_41F169((_WORD*)a1, (__int64)v41);
            *(_BYTE*)(a1 + 248) = 0;
            *(_BYTE*)(a1 + 257) = 1;
            *(_BYTE*)(a1 + 213) = -1;
            memset((void*)(a1 + 453), 0, 8u);
            memset((void*)(a1 + 461), 0, 8u);
            *(_DWORD*)(a1 + 372) = 0;
            *(_DWORD*)(a1 + 376) = 0;
            *(_DWORD*)(a1 + 340) = 0;
            *(_DWORD*)(a1 + 352) = 0;
            *(_DWORD*)(a1 + 344) = 0;
            *(_DWORD*)(a1 + 348) = -420;
            *(_DWORD*)(a1 + 360) = 30;
            sub_43FFC3((int*)unk_4BDB28, dword_4B9A04, -1, 100, 100, 0);
        }
        *(_BYTE*)(a1 + 212) = 0;
        if (*(int*)(a1 + 348) >= 0)
            *(_WORD*)(a1 + 204) = 55;
        else
            *(_WORD*)(a1 + 204) = 25;
        return;
    case 0x8E:
        if (*(_DWORD*)(a1 + 480))
        {
            LOBYTE(v406) = sub_425CB0(*(_BYTE**)(a1 + 480));
            *(_BYTE*)(a1 + 212) = 0;
            if (*(_DWORD*)(a1 + 444) == 1)
            {
                memset((void*)(a1 + 453), 0, 8u);
                memset((void*)(a1 + 461), 0, 8u);
                if ((unsigned __int8)v406 == 1)
                {
                    v405 = sub_41CB3B(a1, 1);
                    if (*(_BYTE*)(a1 + 237))
                    {
                        v42 = sub_41CB3B(a1, 1);
                        v405 += v42 * sub_41CA5F(a1, 1) / 250;
                    }
                    if (*(_DWORD*)(a1 + 392))
                    {
                        v43 = sub_41CB3B(a1, 1);
                        v405 += v43 * sub_41D067(a1, 1) / 250;
                    }
                    v44 = sub_43E620((short*)*(_DWORD*)(a1 + 480));
                    sub_41F169((_WORD*)a1, (v405 * v44 / 100 + 50) / 2);
                }
                else
                {
                    v404 = sub_41F380(a1, 1);
                    if (*(_BYTE*)(a1 + 237))
                    {
                        v45 = sub_41F380(a1, 1);
                        v404 += v45 * sub_41CA5F(a1, 1) / 250;
                    }
                    if (*(_DWORD*)(a1 + 392))
                    {
                        v46 = sub_41F380(a1, 1);
                        v404 += v46 * sub_41D067(a1, 1) / 250;
                    }
                    v47 = sub_43E620((short*)*(_DWORD*)(a1 + 480));
                    sub_41F169((_WORD*)a1, v404 * v47 / 100 + 50);
                }
                *(_BYTE*)(a1 + 248) = 0;
                *(_BYTE*)(a1 + 257) = 1;
                *(_BYTE*)(a1 + 213) = -1;
                if (!*(_DWORD*)(a1 + 392) || *(unsigned __int8*)(a1 + 238) <= 1u && sub_41BA53(a1, 0x86u, 0))
                    *(_DWORD*)(a1 + 400) = 1;
            }
            if (*(_DWORD*)(a1 + 444) == 5)
                *(_DWORD*)(a1 + 400) = 0;
            if (sub_494AA9(*(_BYTE**)(a1 + 480), 0))
            {
                if (*(int*)(a1 + 444) >= 6)
                {
                    if (*(int*)(a1 + 444) >= 11)
                    {
                        if (*(int*)(a1 + 444) >= 15)
                        {
                            *(_BYTE*)(a1 + 257) = 2;
                            *(_WORD*)(a1 + 204) = 142;
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 141;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 140;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 135;
                }
                if (*(_DWORD*)(a1 + 444) == 6)
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                if (*(int*)(a1 + 444) > 25)
                {
                    if (*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 432) = 50;
                    else
                        *(_DWORD*)(a1 + 432) = 3;
                }
            }
            else if ((unsigned __int8)v406 == 7)
            {
                if (*(int*)(a1 + 444) >= 4)
                {
                    if (*(int*)(a1 + 444) >= 7)
                    {
                        if (*(int*)(a1 + 444) >= 10)
                        {
                            *(_BYTE*)(a1 + 257) = 2;
                            *(_WORD*)(a1 + 204) = 132;
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 131;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 130;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 129;
                }
                if (*(_DWORD*)(a1 + 444) == 4)
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                if (*(int*)(a1 + 444) > 14)
                {
                    if (*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 432) = 50;
                    else
                        *(_DWORD*)(a1 + 432) = 3;
                }
            }
            else if ((unsigned __int8)v406 == 1)
            {
                if (*(int*)(a1 + 444) >= 3)
                {
                    if (*(int*)(a1 + 444) >= 6)
                    {
                        if (*(int*)(a1 + 444) >= 9)
                        {
                            if (*(int*)(a1 + 444) >= 12)
                            {
                                *(_WORD*)(a1 + 204) = 194;
                            }
                            else
                            {
                                *(_BYTE*)(a1 + 257) = 2;
                                *(_WORD*)(a1 + 204) = 195;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 196;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 195;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 194;
                }
                if (*(_DWORD*)(a1 + 444) == 4)
                {
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                }
                else if (*(_DWORD*)(a1 + 444) == 12)
                {
                    *(_DWORD*)(a1 + 404) = 1;
                }
                if (*(int*)(a1 + 444) > 16)
                {
                    if (*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 432) = 50;
                    else
                        *(_DWORD*)(a1 + 432) = 3;
                }
            }
            else
            {
                if (*(int*)(a1 + 444) >= 5)
                {
                    if (*(int*)(a1 + 444) >= 9)
                    {
                        if (*(int*)(a1 + 444) >= 13)
                        {
                            *(_BYTE*)(a1 + 257) = 2;
                            *(_WORD*)(a1 + 204) = 132;
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 131;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 130;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 129;
                }
                if (*(_DWORD*)(a1 + 444) == 5)
                {
                    if ((unsigned __int8)v406 == 5)
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A88, -1, 100, 100, 0);
                    else
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                }
                if (*(int*)(a1 + 444) > 21)
                {
                    if (*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 432) = 50;
                    else
                        *(_DWORD*)(a1 + 432) = 3;
                }
            }
        }
        else if (*(_DWORD*)(a1 + 392))
        {
            *(_DWORD*)(a1 + 432) = 50;
        }
        else
        {
            *(_DWORD*)(a1 + 432) = 3;
        }
        return;
    case 0x8F:
    case 0xAB:
    case 0xAC:
    case 0xAD:
    case 0xB4:
    case 0xB7:
    case 0xB8:
    case 0xB9:
    case 0xBA:
    case 0xBD:
    case 0xBE:
    case 0xBF:
    case 0xC0:
    case 0xC1:
    case 0xC2:
    case 0xC3:
    case 0xC4:
    case 0xC5:
    case 0xC6:
        *(_BYTE*)(a1 + 212) = 0;
        if (*(_DWORD*)(a1 + 444) == 1)
        {
            memset((void*)(a1 + 453), 0, 8u);
            memset((void*)(a1 + 461), 0, 8u);
            if (*(_DWORD*)(a1 + 480))
            {
                *(_DWORD*)(a1 + 436) = (unsigned __int8)sub_425CB0(*(_BYTE**)(a1 + 480));
                v48 = (unsigned __int16)sub_43E620((short*)*(_DWORD*)(a1 + 480));
                *(_WORD*)(a1 + 240) = v48 * sub_41F380(a1, 1) / 100;
            }
            *(_BYTE*)(a1 + 248) = 0;
            *(_BYTE*)(a1 + 213) = -1;
            if (!*(_DWORD*)(a1 + 392) || *(unsigned __int8*)(a1 + 238) <= 1u && sub_41BA53(a1, 0x86u, 0))
                *(_DWORD*)(a1 + 400) = 1;
        }
        v49 = a1;
        if (*(_DWORD*)(a1 + 444) == 5)
            *(_DWORD*)(a1 + 400) = 0;
        LOBYTE(v49) = *(_BYTE*)(a1 + 436);
        if (sub_4771C5(0, v49))
        {
            if (*(int*)(a1 + 444) >= 5)
            {
                if (*(int*)(a1 + 444) >= 9)
                {
                    if (*(int*)(a1 + 444) >= 13)
                    {
                        *(_BYTE*)(a1 + 257) = 2;
                        *(_WORD*)(a1 + 204) = 144;
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 143;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 140;
                }
            }
            else
            {
                *(_WORD*)(a1 + 204) = 135;
            }
            if (*(_DWORD*)(a1 + 444) == 5)
            {
                if (*(_DWORD*)(a1 + 428) == 143)
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                else
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A70, -1, 100, 100, 0);
            }
            if (*(_DWORD*)(a1 + 444) == 9)
            {
                if (*(_DWORD*)(a1 + 480))
                {
                    sub_4914CC(*(_DWORD*)(a1 + 480), a3, a2, a4);
                    if (*(_DWORD*)(a1 + 480))
                    {
                        v225 = *(_DWORD*)(a1 + 392);
                        v222 = *(unsigned __int8*)(a1 + 237);
                        v50 = sub_41F52F(a1, 1);
                        sub_4917E7(*(_DWORD*)(a1 + 480), a4, v50, v222, v225, 0);
                        *(_DWORD*)(a1 + 480) = 0;
                    }
                }
            }
            if (*(int*)(a1 + 444) > 21)
            {
                if (*(_DWORD*)(a1 + 392))
                    *(_DWORD*)(a1 + 432) = 50;
                else
                    *(_DWORD*)(a1 + 432) = 3;
            }
        }
        else if (*(_DWORD*)(a1 + 436) == 12)
        {
            if (*(_DWORD*)(a1 + 444) == 1)
            {
                *(_DWORD*)(a1 + 440) = -1;
                if (sub_41BA53(a1, 0x85u, 0))
                {
                    if (((v403 = 0, !*(_DWORD*)(a1 + 424)) || *(char*)(a1 + 224) <= 0)
                        && (*(_DWORD*)(a1 + 424) || *(char*)(a1 + 224) >= 0))
                    {
                        if (*(char*)(a1 + 225) >= 0)
                            v403 = *(char*)(a1 + 225) <= 0 ? (char*)sub_4682D3((char*)unk_4B9B10, (_DWORD*)a1, 0) : (char*)sub_4682D3(
                                (char*)unk_4B9B10,
                                (_DWORD*)a1,
                                3);
                        else
                            v403 = (char*)sub_4682D3((char*)unk_4B9B10, (_DWORD*)a1, 1);
                    }
                    else
                    {
                        v403 = (char*)sub_4682D3((char*)unk_4B9B10, (_DWORD*)a1, 2);
                    }
                    if (v403)
                    {
                        v51 = sub_426090((int*)v403);
                        v401 = v51 - sub_426090((_DWORD*)a1);
                        v52 = sub_4260B0((int*)v403);
                        v402 = v52 - sub_4260B0((_DWORD*)a1);
                        if (v401 <= 0)
                            v282 = -v401;
                        else
                            v282 = v401;
                        if (v402 <= 0)
                            v281 = -v402;
                        else
                            v281 = v402;
                        if (v282 < 2 * v281)
                        {
                            if (v402 >= 0)
                            {
                                if (v402 > 0)
                                    *(_DWORD*)(a1 + 440) = 3;
                            }
                            else
                            {
                                *(_DWORD*)(a1 + 440) = 1;
                            }
                        }
                        else
                        {
                            *(_DWORD*)(a1 + 440) = 2;
                        }
                    }
                }
            }
            if (*(int*)(a1 + 444) >= 4)
            {
                if (*(int*)(a1 + 444) >= 7)
                {
                    if (*(int*)(a1 + 444) >= 10)
                    {
                        if (*(int*)(a1 + 444) >= 13)
                        {
                            *(_BYTE*)(a1 + 257) = 2;
                            if (*(_DWORD*)(a1 + 440) == 1)
                            {
                                *(_WORD*)(a1 + 204) = 231;
                            }
                            else if (*(_DWORD*)(a1 + 440) == 3)
                            {
                                *(_WORD*)(a1 + 204) = 233;
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 227;
                            }
                        }
                        else if (*(_DWORD*)(a1 + 440) == 1)
                        {
                            *(_WORD*)(a1 + 204) = 231;
                        }
                        else if (*(_DWORD*)(a1 + 440) == 3)
                        {
                            *(_WORD*)(a1 + 204) = 233;
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 226;
                        }
                    }
                    else if (*(_DWORD*)(a1 + 440) == 1)
                    {
                        *(_WORD*)(a1 + 204) = 230;
                    }
                    else if (*(_DWORD*)(a1 + 440) == 3)
                    {
                        *(_WORD*)(a1 + 204) = 232;
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 225;
                    }
                }
                else if (*(_DWORD*)(a1 + 440) == 1)
                {
                    *(_WORD*)(a1 + 204) = 229;
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 224;
                }
            }
            else if (*(_DWORD*)(a1 + 440) == 1)
            {
                *(_WORD*)(a1 + 204) = 228;
            }
            else
            {
                *(_WORD*)(a1 + 204) = 223;
            }
            if (*(_DWORD*)(a1 + 444) == 7)
            {
                if (*(_DWORD*)(a1 + 428) == 143)
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9AD0, -1, 100, 100, 0);
                else
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A70, -1, 100, 100, 0);
            }
            else if (*(_DWORD*)(a1 + 444) == 10)
            {
                if (*(_DWORD*)(a1 + 480))
                {
                    sub_4914CC(*(_DWORD*)(a1 + 480), a3, a2, a4);
                    if (*(_DWORD*)(a1 + 480))
                    {
                        v400 = 0;
                        if (sub_41BA53(a1, 0x85u, 0) && *(int*)(a1 + 440) >= 0)
                            v400 = (char*)sub_4682D3((char*)unk_4B9B10, (_DWORD*)a1, *(_BYTE*)(a1 + 440));
                        v226 = *(_DWORD*)(a1 + 392);
                        v223 = *(unsigned __int8*)(a1 + 237);
                        v53 = sub_41F52F(a1, 1);
                        sub_4917E7(*(_DWORD*)(a1 + 480), a4, v53, v223, v226, (int*)v400);
                        *(_DWORD*)(a1 + 480) = 0;
                    }
                }
            }
            if (*(int*)(a1 + 444) > 24)
            {
                if (*(_DWORD*)(a1 + 392))
                    *(_DWORD*)(a1 + 432) = 50;
                else
                    *(_DWORD*)(a1 + 432) = 3;
            }
        }
        else
        {
            if (*(int*)(a1 + 444) >= 5)
            {
                if (*(int*)(a1 + 444) >= 9)
                {
                    if (*(int*)(a1 + 444) >= 13)
                    {
                        *(_BYTE*)(a1 + 257) = 2;
                        *(_WORD*)(a1 + 204) = 134;
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 133;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 130;
                }
            }
            else
            {
                *(_WORD*)(a1 + 204) = 129;
            }
            if (*(_DWORD*)(a1 + 444) == 5)
            {
                if (*(_DWORD*)(a1 + 428) == 143)
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                else
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A70, -1, 100, 100, 0);
            }
            if (*(_DWORD*)(a1 + 444) == 9)
            {
                if (*(_DWORD*)(a1 + 480))
                {
                    sub_4914CC(*(_DWORD*)(a1 + 480), a3, a2, a4);
                    if (*(_DWORD*)(a1 + 480))
                    {
                        v227 = *(_DWORD*)(a1 + 392);
                        v224 = *(unsigned __int8*)(a1 + 237);
                        v54 = sub_41F52F(a1, 1);
                        sub_4917E7(*(_DWORD*)(a1 + 480), a4, v54, v224, v227, 0);
                        *(_DWORD*)(a1 + 480) = 0;
                    }
                }
            }
            if (*(int*)(a1 + 444) > 21)
            {
                if (*(_DWORD*)(a1 + 392))
                    *(_DWORD*)(a1 + 432) = 50;
                else
                    *(_DWORD*)(a1 + 432) = 3;
            }
        }
        return;
    case 0x87:
    case 0x59:
        *(_DWORD*)(a1 + 372) = 180 * (*(_DWORD*)(a1 + 424) - (*(_DWORD*)(a1 + 424) == 0));
        sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
        *(_DWORD*)(a1 + 304) = 0;
        if (*(_DWORD*)(a1 + 428) == 135 && *(_DWORD*)(a1 + 444) == 1)
        {
            memset((void*)(a1 + 453), 0, 8u);
            memset((void*)(a1 + 461), 0, 8u);
            *(_BYTE*)(a1 + 257) = 1;
            sub_41F169((_WORD*)a1, 10);
            *(_BYTE*)(a1 + 248) = 2;
            *(_BYTE*)(a1 + 253) = 1;
        }
        *(_BYTE*)(a1 + 212) = 0;
        if (*(_DWORD*)(a1 + 444) / 10 % 2)
        {
            if (*(_DWORD*)(a1 + 428) == 135)
                *(_WORD*)(a1 + 204) = 37;
            else
                *(_WORD*)(a1 + 204) = 38;
        }
        else
        {
            *(_WORD*)(a1 + 204) = 36;
        }
        if (*(int*)(a1 + 444) > 240 && *(_DWORD*)(a1 + 428) == 135
            || *(int*)(a1 + 444) > 120 && *(_DWORD*)(a1 + 428) == 89)
        {
            *(_DWORD*)(a1 + 432) = 42;
            *(_DWORD*)(a1 + 444) = 0;
            *(_DWORD*)(a1 + 436) = *(_DWORD*)(a1 + 424);
        }
        return;
    case 0x8A:
        if (*(_DWORD*)(a1 + 444) == 1)
        {
            memset((void*)(a1 + 453), 0, 8u);
            memset((void*)(a1 + 461), 0, 8u);
            *(_BYTE*)(a1 + *(_DWORD*)(a1 + 436) + 453) = -1;
            sub_41F1A3((unsigned __int8*)a1, -30);
            *(_BYTE*)(a1 + 248) = 2;
            *(_BYTE*)(a1 + 253) = 1;
            *(_DWORD*)(a1 + 304) = 0;
        }
        else if (*(_DWORD*)(a1 + 444) == 8)
        {
            *(_BYTE*)(a1 + *(_DWORD*)(a1 + 436) + 453) = 0;
        }
        *(_BYTE*)(a1 + 212) = 0;
        *(_WORD*)(a1 + 204) = 49;
        return;
    case 0x88:
    case 0x89:
        *(_BYTE*)(a1 + 212) = 0;
        if (*(_DWORD*)(a1 + 444) == 1)
        {
            for (i = 0; i < 8; ++i)
            {
                if (*(_DWORD*)(a1 + 304) && (unsigned __int8)sub_425EF0(*(_BYTE**)(a1 + 304)) == i)
                    *(_BYTE*)(i + a1 + 453) = -1;
                else
                    *(_BYTE*)(i + a1 + 453) = 0;
            }
            *(_DWORD*)(a1 + 304) = 0;
            *(_BYTE*)(a1 + 253) = 1;
            sub_41F1A3((unsigned __int8*)a1, -30);
        }
        if (*(_DWORD*)(a1 + 428) == 136)
        {
            if (*(_DWORD*)(a1 + 436))
                *(_WORD*)(a1 + 204) = 17;
            else
                *(_WORD*)(a1 + 204) = 50;
        }
        else if (*(_DWORD*)(a1 + 436))
        {
            *(_WORD*)(a1 + 204) = 28;
        }
        else
        {
            *(_WORD*)(a1 + 204) = 51;
        }
        return;
    case 0x8C:
        if (*(_DWORD*)(a1 + 444) == 1)
        {
            memset((void*)(a1 + 453), 0, 8u);
            memset((void*)(a1 + 461), 0, 8u);
            *(_BYTE*)(a1 + 257) = 1;
            *(_DWORD*)(a1 + 372) = 450 * (*(_DWORD*)(a1 + 424) - (*(_DWORD*)(a1 + 424) == 0));
            *(_DWORD*)(a1 + 352) = 0;
            *(_DWORD*)(a1 + 344) = 0;
            *(_DWORD*)(a1 + 356) = 0;
            *(_DWORD*)(a1 + 376) = 0;
            *(_DWORD*)(a1 + 348) = -350;
            *(_DWORD*)(a1 + 360) = 30;
            sub_41F169((_WORD*)a1, 16);
            *(_BYTE*)(a1 + 248) = 1;
            *(_BYTE*)(a1 + 253) = 1;
            *(_BYTE*)(a1 + 255) = 0;
            *(_BYTE*)(a1 + 254) = 2;
            *(_BYTE*)(a1 + 213) = -1;
            sub_43FFC3((int*)unk_4BDB28, dword_4B9A4C, -1, 100, 100, 0);
        }
        *(_BYTE*)(a1 + 212) = 0;
        *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 4 % 4 + 234;
        return;
    case 0x8D:
        if (*(_DWORD*)(a1 + 444) == 1)
        {
            memset((void*)(a1 + 453), 0, 8u);
            memset((void*)(a1 + 461), 0, 8u);
            *(_BYTE*)(a1 + 257) = 1;
            *(_DWORD*)(a1 + 372) = 600 * (*(_DWORD*)(a1 + 424) - (*(_DWORD*)(a1 + 424) == 0));
            *(_DWORD*)(a1 + 352) = -*(_DWORD*)(a1 + 372) / 90;
            *(_DWORD*)(a1 + 344) = 0;
            *(_DWORD*)(a1 + 356) = 0;
            *(_DWORD*)(a1 + 348) = 0;
            *(_DWORD*)(a1 + 360) = 0;
            sub_41F169((_WORD*)a1, 16);
            *(_BYTE*)(a1 + 248) = 1;
            *(_BYTE*)(a1 + 253) = 1;
            *(_BYTE*)(a1 + 255) = 0;
            *(_BYTE*)(a1 + 254) = 2;
            *(_BYTE*)(a1 + 213) = -1;
            sub_43FFC3((int*)unk_4BDB28, dword_4B9A4C, -1, 100, 100, 0);
        }
        *(_BYTE*)(a1 + 212) = 0;
        *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 4 % 4 + 234;
        if (*(_DWORD*)(a1 + 444) == 40)
        {
            *(_DWORD*)(a1 + 432) = 12;
            *(_DWORD*)(a1 + 352) = 0;
        }
        return;
    case 0x54:
        if (*(_DWORD*)(a1 + 444) != 1)
        {
        LABEL_897:
            *(_BYTE*)(a1 + 212) = 0;
            *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 4 % 4 + 169;
            if (!((*(_DWORD*)(a1 + 444) - 1) % 6))
                *(_DWORD*)(a1 + 436) = sub_43FFC3((int*)unk_4BDB28, dword_4B9A44, *(_DWORD*)(a1 + 436), 100, 100, 0);
            if (*(int*)(a1 + 444) >= 300
                || !*(_DWORD*)(a1 + 312)
                || Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 312)) == (struct Concurrency::ISchedulerProxy*)80)
            {
                if (*(_DWORD*)(a1 + 392))
                    *(_DWORD*)(a1 + 432) = 51;
                else
                    *(_DWORD*)(a1 + 432) = 12;
            }
            else
            {
                v395 = sub_426090(*(_DWORD**)(a1 + 312)) - *(_DWORD*)(a1 + 328);
                v397 = sub_4260B0(*(_DWORD**)(a1 + 312)) - *(_DWORD*)(a1 + 332);
                v396 = sub_4260D0(*(_DWORD**)(a1 + 312)) - *(_DWORD*)(a1 + 336) - 400;
                v398 = 0;
                if (v395 <= 0)
                    v280 = -v395;
                else
                    v280 = v395;
                if (v397 <= 0)
                    v279 = -v397;
                else
                    v279 = v397;
                if (v280 <= v279)
                {
                    if (v397 <= 0)
                        v274 = -v397;
                    else
                        v274 = v397;
                    if (v274 >= 60)
                    {
                        if (v397 <= 0)
                            v273 = (v397 >= 0) - 1;
                        else
                            v273 = 1;
                        *(_DWORD*)(a1 + 376) = 60 * v273;
                    }
                    else
                    {
                        *(_DWORD*)(a1 + 376) = v397;
                    }
                    if (v397)
                    {
                        if (*(int*)(a1 + 376) <= 0)
                            v272 = -*(_DWORD*)(a1 + 376);
                        else
                            v272 = *(_DWORD*)(a1 + 376);
                        if (v397 <= 0)
                            v271 = -v397;
                        else
                            v271 = v397;
                        v398 = 1000 * v272 / v271;
                    }
                    *(_DWORD*)(a1 + 372) = v398 * v395 / 1000;
                }
                else
                {
                    if (v395 <= 0)
                        v278 = -v395;
                    else
                        v278 = v395;
                    if (v278 >= 300)
                    {
                        if (v395 <= 0)
                            v277 = (v395 >= 0) - 1;
                        else
                            v277 = 1;
                        *(_DWORD*)(a1 + 372) = 300 * v277;
                    }
                    else
                    {
                        *(_DWORD*)(a1 + 372) = v395;
                    }
                    if (v395)
                    {
                        if (*(int*)(a1 + 372) <= 0)
                            v276 = -*(_DWORD*)(a1 + 372);
                        else
                            v276 = *(_DWORD*)(a1 + 372);
                        if (v395 <= 0)
                            v275 = -v395;
                        else
                            v275 = v395;
                        v398 = 1000 * v276 / v275;
                    }
                    *(_DWORD*)(a1 + 376) = v398 * v397 / 1000;
                }
                if (*(int*)(a1 + 444) >= 6)
                {
                    *(_DWORD*)(a1 + 348) = v398 * v396 / 1000;
                    if (!*(_DWORD*)(a1 + 348))
                        *(_DWORD*)(a1 + 348) = v396;
                    if (*(int*)(a1 + 348) < 0)
                        *(_DWORD*)(a1 + 392) = 1;
                }
            }
            return;
        }
        *(_DWORD*)(a1 + 372) = 0;
        *(_DWORD*)(a1 + 376) = 0;
        *(_DWORD*)(a1 + 340) = 0;
        *(_DWORD*)(a1 + 344) = 0;
        *(_DWORD*)(a1 + 348) = 400;
        *(_DWORD*)(a1 + 352) = 0;
        *(_DWORD*)(a1 + 356) = 0;
        *(_DWORD*)(a1 + 360) = 0;
        *(_DWORD*)(a1 + 392) = 1;
        *(_BYTE*)(a1 + 248) = 1;
        *(_BYTE*)(a1 + 253) = 2;
        *(_BYTE*)(a1 + 213) = -1;
        *(_BYTE*)(a1 + 255) = 0;
        if (*(_BYTE*)(a1 + 195))
        {
            switch (*(_BYTE*)(a1 + 195))
            {
            case 1:
                v55 = sub_41CB3B(a1, 1);
                sub_41F169((_WORD*)a1, 3 * v55);
            LABEL_896:
                memset((void*)(a1 + 453), 0, 8u);
                memset((void*)(a1 + 461), 0, 8u);
                *(_DWORD*)(a1 + 312) = sub_466127((char*)unk_4B9B10, (_BYTE*)a1, a1 + 453);
                *(_DWORD*)(a1 + 436) = -1;
                ++* (_BYTE*)(a1 + 325);
                goto LABEL_897;
            case 2:
                v56 = sub_41CCEA(a1, 1);
                sub_41F169((_WORD*)a1, 3 * v56);
                goto LABEL_896;
            case 3:
                v57 = sub_4175B4(a1, 1);
                sub_41F169((_WORD*)a1, 3 * v57);
                goto LABEL_896;
            }
            if (*(_BYTE*)(a1 + 195) != 4)
                goto LABEL_896;
        }
        v58 = sub_41CB3B(a1, 1);
        v59 = sub_41CCEA(a1, 1) + v58;
        v60 = sub_4175B4(a1, 1);
        sub_41F169((_WORD*)a1, v60 + v59);
        goto LABEL_896;
    case 0x55:
        if (*(_DWORD*)(a1 + 444) == 1)
        {
            *(_BYTE*)(a1 + 177) = 1;
            *(_DWORD*)(a1 + 328) += 700 * (*(_DWORD*)(a1 + 424) - (*(_DWORD*)(a1 + 424) == 0));
            if (*(_DWORD*)(a1 + 320))
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A18, -1, 100, 100, 0);
            *(_DWORD*)(a1 + 436) = 0;
            ++* (_BYTE*)(a1 + 325);
        }
        v394 = (*(_DWORD*)(a1 + 444) - 1) / 4 % 6;
        if (*(int*)(a1 + 444) <= 60)
        {
            if (!*(_DWORD*)(a1 + 320))
                v394 = (v394 + 3) % 6;
            *(_BYTE*)(a1 + 212) = 0;
            if (v394 && v394 != 3)
                *(_WORD*)(a1 + 204) = 173;
            else
                *(_WORD*)(a1 + 204) = 29;
            v270 = v394 == 4 || v394 == 5;
            *(_BYTE*)(a1 + 176) = v270;
            *(_DWORD*)(a1 + 372) = 0;
            if (!((*(_DWORD*)(a1 + 444) - 1) % 4))
            {
                switch (v394)
                {
                case 1:
                case 4:
                    *(_DWORD*)(a1 + 372) = 700 * (*(_DWORD*)(a1 + 424) - (*(_DWORD*)(a1 + 424) == 0));
                    break;
                case 2:
                case 5:
                    *(_DWORD*)(a1 + 424) = *(_DWORD*)(a1 + 424) == 0;
                    *(_DWORD*)(a1 + 372) = 0;
                    break;
                case 0:
                case 3:
                    *(_DWORD*)(a1 + 372) = 700 * ((*(_DWORD*)(a1 + 424) == 0) - *(_DWORD*)(a1 + 424));
                    break;
                }
            }
            return;
        }
        if (*(_DWORD*)(a1 + 444) != 61)
            goto LABEL_1004;
        if (!*(_DWORD*)(a1 + 304))
            goto LABEL_1004;
        *(_DWORD*)(a1 + 348) = -1200;
        *(_DWORD*)(a1 + 360) = 30;
        *(_DWORD*)(a1 + 392) = 1;
        if (!*(_DWORD*)(a1 + 320))
            goto LABEL_1004;
        if (*(_BYTE*)(a1 + 195))
        {
            switch (*(_BYTE*)(a1 + 195))
            {
            case 1:
                sub_43FFC3((int*)unk_4BDB28, dword_4B9AB0, -1, 100, 100, 0);
                *(_BYTE*)(a1 + 248) = 10;
                *(_BYTE*)(a1 + 213) = -1;
                break;
            case 2:
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A60, -1, 100, 100, 0);
                *(_BYTE*)(a1 + 248) = 7;
                *(_BYTE*)(a1 + 213) = -1;
                break;
            case 3:
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A44, -1, 100, 100, 0);
                *(_BYTE*)(a1 + 248) = 8;
                *(_BYTE*)(a1 + 213) = -1;
                break;
            case 4:
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A44, -1, 100, 100, 0);
                *(_BYTE*)(a1 + 248) = 9;
                *(_BYTE*)(a1 + 213) = -1;
                break;
            }
        }
        else
        {
            sub_43FFC3((int*)unk_4BDB28, dword_4B9AAC, -1, 100, 100, 0);
            *(_BYTE*)(a1 + 248) = 6;
            *(_BYTE*)(a1 + 213) = -1;
        }
        *(_BYTE*)(a1 + 255) = 0;
        *(_BYTE*)(a1 + 254) = 1;
        v61 = sub_41CB3B(*(_DWORD*)(a1 + 304), 1);
        v391 = (v61 + sub_41CB3B(a1, 1)) / 2;
        v62 = sub_41CCEA(*(_DWORD*)(a1 + 304), 1);
        v393 = (v62 + sub_41CCEA(a1, 1)) / 2;
        v63 = sub_4175B4(*(_DWORD*)(a1 + 304), 1);
        v392 = (v63 + sub_4175B4(a1, 1)) / 2;
        if (*(_BYTE*)(a1 + 195))
        {
            switch (*(_BYTE*)(a1 + 195))
            {
            case 1:
                sub_41F169((_WORD*)a1, 3 * v391);
            LABEL_1003:
                memset((void*)(a1 + 453), 0, 8u);
                memset((void*)(a1 + 461), 0, 8u);
                *(_DWORD*)(a1 + 312) = sub_466127((char*)unk_4B9B10, (_BYTE*)a1, a1 + 453);
            LABEL_1004:
                if (*(_DWORD*)(a1 + 312)
                    && *(_DWORD*)(a1 + 304)
                    && *(int*)(a1 + 444) < 300
                    && Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) == (struct Concurrency::ISchedulerProxy*)85)
                {
                    if (*(_DWORD*)(a1 + 320))
                    {
                        if (sub_4263D0(*(unsigned __int8**)(a1 + 312)) || sub_41BE56(*(_DWORD**)(a1 + 312)))
                            *(_DWORD*)(a1 + 312) = sub_466127((char*)unk_4B9B10, (_BYTE*)a1, a1 + 453);
                        if (!((*(_DWORD*)(a1 + 444) - 1) % 4) && (v394 == 2 || v394 == 5))
                            *(_DWORD*)(a1 + 424) = *(_DWORD*)(a1 + 424) == 0;
                        *(_BYTE*)(a1 + 212) = 1;
                        if (*(_BYTE*)(a1 + 195))
                        {
                            switch (*(_BYTE*)(a1 + 195))
                            {
                            case 1:
                                if (v394 % 3)
                                    *(_WORD*)(a1 + 204) = 19;
                                else
                                    *(_WORD*)(a1 + 204) = 18;
                                break;
                            case 2:
                                if (v394 % 3)
                                    *(_WORD*)(a1 + 204) = 19;
                                else
                                    *(_WORD*)(a1 + 204) = 18;
                                break;
                            case 3:
                                if (v394 % 3)
                                    *(_WORD*)(a1 + 204) = 21;
                                else
                                    *(_WORD*)(a1 + 204) = 20;
                                break;
                            case 4:
                                if (v394 % 3)
                                {
                                    if (v394 % 3 == 1)
                                        *(_WORD*)(a1 + 204) = 15;
                                    else
                                        *(_WORD*)(a1 + 204) = 16;
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 14;
                                }
                                break;
                            }
                        }
                        else if (v394 % 3)
                        {
                            *(_WORD*)(a1 + 204) = 15;
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 14;
                        }
                        if (*(_DWORD*)(a1 + 312))
                        {
                            v387 = sub_426090(*(_DWORD**)(a1 + 312)) - *(_DWORD*)(a1 + 328);
                            v389 = sub_4260B0(*(_DWORD**)(a1 + 312)) - *(_DWORD*)(a1 + 332);
                            v388 = sub_4260D0(*(_DWORD**)(a1 + 312)) - *(_DWORD*)(a1 + 336) - 400;
                            v390 = 0;
                            if (v387 <= 0)
                                v269 = -v387;
                            else
                                v269 = v387;
                            if (v389 <= 0)
                                v268 = -v389;
                            else
                                v268 = v389;
                            if (v269 <= v268)
                            {
                                if (v389 <= 0)
                                    v263 = -v389;
                                else
                                    v263 = v389;
                                if (v263 >= 60)
                                {
                                    if (v389 <= 0)
                                        v262 = (v389 >= 0) - 1;
                                    else
                                        v262 = 1;
                                    *(_DWORD*)(a1 + 376) = 60 * v262;
                                }
                                else
                                {
                                    *(_DWORD*)(a1 + 376) = v389;
                                }
                                if (v389)
                                {
                                    if (*(int*)(a1 + 376) <= 0)
                                        v261 = -*(_DWORD*)(a1 + 376);
                                    else
                                        v261 = *(_DWORD*)(a1 + 376);
                                    if (v389 <= 0)
                                        v260 = -v389;
                                    else
                                        v260 = v389;
                                    v390 = 1000 * v261 / v260;
                                }
                                *(_DWORD*)(a1 + 372) = v390 * v387 / 1000;
                            }
                            else
                            {
                                if (v387 <= 0)
                                    v267 = -v387;
                                else
                                    v267 = v387;
                                if (v267 >= 150)
                                {
                                    if (v387 <= 0)
                                        v266 = (v387 >= 0) - 1;
                                    else
                                        v266 = 1;
                                    *(_DWORD*)(a1 + 372) = 150 * v266;
                                }
                                else
                                {
                                    *(_DWORD*)(a1 + 372) = v387;
                                }
                                if (v387)
                                {
                                    if (*(int*)(a1 + 372) <= 0)
                                        v265 = -*(_DWORD*)(a1 + 372);
                                    else
                                        v265 = *(_DWORD*)(a1 + 372);
                                    if (v387 <= 0)
                                        v264 = -v387;
                                    else
                                        v264 = v387;
                                    v390 = 1000 * v265 / v264;
                                }
                                *(_DWORD*)(a1 + 376) = v390 * v389 / 1000;
                            }
                            if (*(int*)(a1 + 436) > 0)
                            {
                                *(_DWORD*)(a1 + 348) = v390 * v388 / 1000;
                                if (*(int*)(a1 + 348) < 0)
                                    *(_DWORD*)(a1 + 392) = 1;
                            }
                        }
                    }
                    else
                    {
                        *(_BYTE*)(a1 + 176) = 1;
                        *(_DWORD*)(a1 + 328) = sub_426090(*(_DWORD**)(a1 + 304));
                        *(_DWORD*)(a1 + 332) = sub_4260B0(*(_DWORD**)(a1 + 304));
                        *(_DWORD*)(a1 + 336) = sub_4260D0(*(_DWORD**)(a1 + 304));
                    }
                }
                else
                {
                    *(_DWORD*)(a1 + 348) = 0;
                    *(_BYTE*)(a1 + 176) = 0;
                    *(_BYTE*)(a1 + 177) = 0;
                    *(_DWORD*)(a1 + 304) = 0;
                    if (*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 432) = 51;
                    else
                        *(_DWORD*)(a1 + 432) = 12;
                }
                return;
            case 2:
                sub_41F169((_WORD*)a1, 3 * v393);
                goto LABEL_1003;
            case 3:
                sub_41F169((_WORD*)a1, 3 * v392);
                goto LABEL_1003;
            }
            if (*(_BYTE*)(a1 + 195) != 4)
                goto LABEL_1003;
        }
        sub_41F169((_WORD*)a1, v392 + v393 + v391);
        goto LABEL_1003;
    }
    if (*(_DWORD*)(a1 + 428) != 86)
    {
        switch (*(_DWORD*)(a1 + 428))
        {
        case 0x57:
            *(_DWORD*)(a1 + 392) = 1;
            if (*(int*)(a1 + 444) >= 2
                && (!*(_DWORD*)(a1 + 304)
                    || Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) != (struct Concurrency::ISchedulerProxy*)86))
            {
                if (*(_DWORD*)(a1 + 392))
                    *(_DWORD*)(a1 + 432) = 50;
                else
                    *(_DWORD*)(a1 + 432) = 3;
                *(_DWORD*)(a1 + 304) = 0;
                *(_DWORD*)(a1 + 372) = 0;
                *(_DWORD*)(a1 + 376) = 0;
                *(_DWORD*)(a1 + 340) = 0;
                *(_DWORD*)(a1 + 344) = 0;
                *(_DWORD*)(a1 + 348) = 0;
            }
            return;
        case 0x58:
            if (*(_DWORD*)(a1 + 444) == 1)
            {
                *(_DWORD*)(a1 + 304) = 0;
                *(_DWORD*)(a1 + 392) = 1;
                sub_41F169((_WORD*)a1, *(unsigned __int16*)(a1 + 242));
                *(_BYTE*)(a1 + 248) = 0;
                *(_BYTE*)(a1 + 253) = 1;
                *(_BYTE*)(a1 + 254) = 2;
                *(_BYTE*)(a1 + 255) = 0;
                *(_DWORD*)(a1 + 436) = 0;
                memset((void*)(a1 + 453), 0, 8u);
                memset((void*)(a1 + 461), 0, 8u);
            }
            *(_BYTE*)(a1 + 212) = 0;
            *(_WORD*)(a1 + 204) = 214;
            return;
        case 0x90:
            if (*(_DWORD*)(a1 + 444) == 1)
            {
                if (*(_DWORD*)(a1 + 392))
                {
                    v70 = 50 * sub_41CCEA(a1, 1) / 100;
                    v71 = sub_41CCEA(a1, 1);
                    v72 = sub_41D067(a1, 1);
                    sub_41F169((_WORD*)a1, v71 * v72 / 200 + v70);
                }
                else
                {
                    v73 = sub_41CCEA(a1, 1);
                    sub_41F169((_WORD*)a1, 50 * v73 / 100);
                }
                *(_BYTE*)(a1 + 257) = 1;
                *(_BYTE*)(a1 + 248) = -1;
                *(_BYTE*)(a1 + 212) = 1;
                *(_BYTE*)(a1 + 213) = -1;
                if (!*(_DWORD*)(a1 + 392) || *(unsigned __int8*)(a1 + 238) <= 1u && sub_41BA53(a1, 0x86u, 0))
                    *(_DWORD*)(a1 + 400) = 1;
            }
            if (*(_DWORD*)(a1 + 444) == 5)
                *(_DWORD*)(a1 + 400) = 0;
            if (*(_BYTE*)(a1 + 195))
            {
                switch (*(_BYTE*)(a1 + 195))
                {
                case 1:
                    if (!(*(_DWORD*)(a1 + 444) % 4))
                    {
                        memset((void*)(a1 + 453), 0, 8u);
                        memset((void*)(a1 + 461), 0, 8u);
                    }
                    if (*(int*)(a1 + 444) >= 4)
                    {
                        if (*(int*)(a1 + 444) >= 8)
                        {
                            if (*(int*)(a1 + 444) >= 12)
                            {
                                if (*(int*)(a1 + 444) >= 16)
                                {
                                    if (*(int*)(a1 + 444) >= 20)
                                    {
                                        if (*(int*)(a1 + 444) >= 24)
                                        {
                                            *(_BYTE*)(a1 + 257) = 2;
                                            *(_WORD*)(a1 + 204) = 2;
                                        }
                                        else
                                        {
                                            *(_BYTE*)(a1 + 248) = 0;
                                            *(_WORD*)(a1 + 204) = 3;
                                        }
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 2;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 3;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 2;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 3;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 2;
                    }
                    if (*(_DWORD*)(a1 + 444) == 4 || *(_DWORD*)(a1 + 444) == 12 || *(_DWORD*)(a1 + 444) == 20)
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                    if (*(int*)(a1 + 444) > 28)
                    {
                        if (*(_DWORD*)(a1 + 392))
                            *(_DWORD*)(a1 + 432) = 50;
                        else
                            *(_DWORD*)(a1 + 432) = 4;
                    }
                    break;
                case 2:
                    if (*(_DWORD*)(a1 + 444) == 4 || *(_DWORD*)(a1 + 444) == 11 || *(_DWORD*)(a1 + 444) == 18)
                    {
                        memset((void*)(a1 + 453), 0, 8u);
                        memset((void*)(a1 + 461), 0, 8u);
                    }
                    if (*(int*)(a1 + 444) >= 4)
                    {
                        if (*(int*)(a1 + 444) >= 7)
                        {
                            if (*(int*)(a1 + 444) >= 11)
                            {
                                if (*(int*)(a1 + 444) >= 14)
                                {
                                    if (*(int*)(a1 + 444) >= 18)
                                    {
                                        if (*(int*)(a1 + 444) >= 21)
                                        {
                                            *(_BYTE*)(a1 + 257) = 2;
                                            *(_WORD*)(a1 + 204) = 3;
                                        }
                                        else
                                        {
                                            *(_BYTE*)(a1 + 248) = 0;
                                            *(_WORD*)(a1 + 204) = 4;
                                        }
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 3;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 4;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 3;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 4;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 3;
                    }
                    if (*(_DWORD*)(a1 + 444) == 4 || *(_DWORD*)(a1 + 444) == 11 || *(_DWORD*)(a1 + 444) == 18)
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                    if (*(int*)(a1 + 444) > 25)
                    {
                        if (*(_DWORD*)(a1 + 392))
                            *(_DWORD*)(a1 + 432) = 50;
                        else
                            *(_DWORD*)(a1 + 432) = 4;
                    }
                    break;
                case 3:
                    if (!(*(_DWORD*)(a1 + 444) % 4))
                    {
                        memset((void*)(a1 + 453), 0, 8u);
                        memset((void*)(a1 + 461), 0, 8u);
                    }
                    if (*(int*)(a1 + 444) >= 4)
                    {
                        if (*(int*)(a1 + 444) >= 8)
                        {
                            if (*(int*)(a1 + 444) >= 12)
                            {
                                if (*(int*)(a1 + 444) >= 16)
                                {
                                    if (*(int*)(a1 + 444) >= 20)
                                    {
                                        if (*(int*)(a1 + 444) >= 24)
                                        {
                                            *(_BYTE*)(a1 + 257) = 2;
                                            *(_WORD*)(a1 + 204) = 3;
                                        }
                                        else
                                        {
                                            *(_BYTE*)(a1 + 248) = 0;
                                            *(_WORD*)(a1 + 204) = 4;
                                        }
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 3;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 4;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 3;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 4;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 3;
                    }
                    if (*(_DWORD*)(a1 + 444) == 4 || *(_DWORD*)(a1 + 444) == 12 || *(_DWORD*)(a1 + 444) == 20)
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                    if (*(int*)(a1 + 444) > 28)
                    {
                        if (*(_DWORD*)(a1 + 392))
                            *(_DWORD*)(a1 + 432) = 50;
                        else
                            *(_DWORD*)(a1 + 432) = 4;
                    }
                    break;
                case 4:
                    if (*(_DWORD*)(a1 + 444) == 4 || *(_DWORD*)(a1 + 444) == 10 || *(_DWORD*)(a1 + 444) == 14)
                    {
                        memset((void*)(a1 + 453), 0, 8u);
                        memset((void*)(a1 + 461), 0, 8u);
                    }
                    if (*(int*)(a1 + 444) >= 4)
                    {
                        if (*(int*)(a1 + 444) >= 7)
                        {
                            if (*(int*)(a1 + 444) >= 10)
                            {
                                if (*(int*)(a1 + 444) >= 13)
                                {
                                    if (*(int*)(a1 + 444) >= 14)
                                    {
                                        if (*(int*)(a1 + 444) >= 17)
                                        {
                                            *(_BYTE*)(a1 + 257) = 2;
                                            *(_WORD*)(a1 + 204) = 4;
                                        }
                                        else
                                        {
                                            *(_BYTE*)(a1 + 248) = 0;
                                            *(_WORD*)(a1 + 204) = 5;
                                        }
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 4;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 5;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 4;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 5;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 4;
                    }
                    if (*(_DWORD*)(a1 + 444) == 1 || *(_DWORD*)(a1 + 444) == 7 || *(_DWORD*)(a1 + 444) == 13)
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                    if (*(int*)(a1 + 444) > 20)
                    {
                        if (*(_DWORD*)(a1 + 392))
                            *(_DWORD*)(a1 + 432) = 50;
                        else
                            *(_DWORD*)(a1 + 432) = 4;
                    }
                    break;
                }
            }
            else
            {
                if (!(*(_DWORD*)(a1 + 444) % 4))
                {
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                }
                if (*(int*)(a1 + 444) >= 4)
                {
                    if (*(int*)(a1 + 444) >= 8)
                    {
                        if (*(int*)(a1 + 444) >= 12)
                        {
                            if (*(int*)(a1 + 444) >= 16)
                            {
                                if (*(int*)(a1 + 444) >= 20)
                                {
                                    if (*(int*)(a1 + 444) >= 24)
                                    {
                                        *(_BYTE*)(a1 + 257) = 2;
                                        *(_WORD*)(a1 + 204) = 0;
                                    }
                                    else
                                    {
                                        *(_BYTE*)(a1 + 248) = 0;
                                        *(_WORD*)(a1 + 204) = 1;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 0;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 1;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 0;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 1;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 0;
                }
                if (*(_DWORD*)(a1 + 444) == 4 || *(_DWORD*)(a1 + 444) == 12 || *(_DWORD*)(a1 + 444) == 20)
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                if (*(int*)(a1 + 444) > 28)
                {
                    if (*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 432) = 50;
                    else
                        *(_DWORD*)(a1 + 432) = 4;
                }
            }
            return;
        case 0x91:
            if (*(_DWORD*)(a1 + 444) == 1)
            {
                if (*(_DWORD*)(a1 + 480))
                {
                    if (*(_DWORD*)(a1 + 392))
                    {
                        v74 = sub_41CB3B(a1, 1);
                        v75 = v74 * (unsigned __int16)sub_43E620((short*)*(_DWORD*)(a1 + 480)) / 200;
                        v76 = sub_41CB3B(a1, 1);
                        v77 = sub_41D067(a1, 1);
                        sub_41F169((_WORD*)a1, v76 * v77 / 200 + v75);
                    }
                    else
                    {
                        v78 = sub_41CB3B(a1, 1);
                        v79 = sub_43E620((short*)*(_DWORD*)(a1 + 480));
                        sub_41F169((_WORD*)a1, v78 * v79 / 200);
                    }
                }
                else if (*(_DWORD*)(a1 + 392))
                {
                    v80 = 50 * sub_41CB3B(a1, 1) / 100;
                    v81 = sub_41CB3B(a1, 1);
                    v82 = sub_41D067(a1, 1);
                    sub_41F169((_WORD*)a1, v81 * v82 / 200 + v80);
                }
                else
                {
                    v83 = sub_41CB3B(a1, 1);
                    sub_41F169((_WORD*)a1, 50 * v83 / 100);
                }
                *(_BYTE*)(a1 + 257) = 1;
                *(_BYTE*)(a1 + 248) = -1;
                *(_BYTE*)(a1 + 212) = 1;
                *(_BYTE*)(a1 + 213) = -1;
                if (!*(_DWORD*)(a1 + 392) || *(unsigned __int8*)(a1 + 238) <= 1u && sub_41BA53(a1, 0x86u, 0))
                {
                    *(_DWORD*)(a1 + 400) = 1;
                    if (*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 408) = 1;
                }
            }
            if (*(_DWORD*)(a1 + 444) == 5)
            {
                *(_DWORD*)(a1 + 400) = 0;
                *(_DWORD*)(a1 + 408) = 0;
            }
            if (!*(_DWORD*)(a1 + 480))
            {
                if (*(_BYTE*)(a1 + 195))
                {
                    switch (*(_BYTE*)(a1 + 195))
                    {
                    case 1:
                        if (*(_DWORD*)(a1 + 444) == 4 || *(_DWORD*)(a1 + 444) == 11 || *(_DWORD*)(a1 + 444) == 18)
                        {
                            memset((void*)(a1 + 453), 0, 8u);
                            memset((void*)(a1 + 461), 0, 8u);
                        }
                        if (*(int*)(a1 + 444) >= 4)
                        {
                            if (*(int*)(a1 + 444) >= 7)
                            {
                                if (*(int*)(a1 + 444) >= 11)
                                {
                                    if (*(int*)(a1 + 444) >= 14)
                                    {
                                        if (*(int*)(a1 + 444) >= 18)
                                        {
                                            if (*(int*)(a1 + 444) >= 21)
                                            {
                                                *(_BYTE*)(a1 + 257) = 2;
                                                *(_WORD*)(a1 + 204) = 0;
                                            }
                                            else
                                            {
                                                *(_BYTE*)(a1 + 248) = 0;
                                                *(_WORD*)(a1 + 204) = 1;
                                            }
                                        }
                                        else
                                        {
                                            *(_WORD*)(a1 + 204) = 0;
                                        }
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 1;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 0;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 1;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 0;
                        }
                        if (*(_DWORD*)(a1 + 444) == 4 || *(_DWORD*)(a1 + 444) == 11 || *(_DWORD*)(a1 + 444) == 18)
                            sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                        if (*(int*)(a1 + 444) > 24)
                        {
                            if (*(_DWORD*)(a1 + 392))
                                *(_DWORD*)(a1 + 432) = 50;
                            else
                                *(_DWORD*)(a1 + 432) = 4;
                        }
                        break;
                    case 2:
                        if (!(*(_DWORD*)(a1 + 444) % 4))
                        {
                            memset((void*)(a1 + 453), 0, 8u);
                            memset((void*)(a1 + 461), 0, 8u);
                        }
                        if (*(int*)(a1 + 444) >= 4)
                        {
                            if (*(int*)(a1 + 444) >= 8)
                            {
                                if (*(int*)(a1 + 444) >= 12)
                                {
                                    if (*(int*)(a1 + 444) >= 16)
                                    {
                                        if (*(int*)(a1 + 444) >= 20)
                                        {
                                            if (*(int*)(a1 + 444) >= 24)
                                            {
                                                *(_BYTE*)(a1 + 257) = 2;
                                                *(_WORD*)(a1 + 204) = 1;
                                            }
                                            else
                                            {
                                                *(_BYTE*)(a1 + 248) = 0;
                                                *(_WORD*)(a1 + 204) = 2;
                                            }
                                        }
                                        else
                                        {
                                            *(_WORD*)(a1 + 204) = 1;
                                        }
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 2;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 1;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 2;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 1;
                        }
                        if (*(_DWORD*)(a1 + 444) == 4 || *(_DWORD*)(a1 + 444) == 12 || *(_DWORD*)(a1 + 444) == 20)
                            sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                        if (*(int*)(a1 + 444) > 28)
                        {
                            if (*(_DWORD*)(a1 + 392))
                                *(_DWORD*)(a1 + 432) = 50;
                            else
                                *(_DWORD*)(a1 + 432) = 4;
                        }
                        break;
                    case 3:
                        if (!(*(_DWORD*)(a1 + 444) % 4))
                        {
                            memset((void*)(a1 + 453), 0, 8u);
                            memset((void*)(a1 + 461), 0, 8u);
                        }
                        if (*(int*)(a1 + 444) >= 4)
                        {
                            if (*(int*)(a1 + 444) >= 8)
                            {
                                if (*(int*)(a1 + 444) >= 12)
                                {
                                    if (*(int*)(a1 + 444) >= 16)
                                    {
                                        if (*(int*)(a1 + 444) >= 20)
                                        {
                                            if (*(int*)(a1 + 444) >= 24)
                                            {
                                                *(_BYTE*)(a1 + 257) = 2;
                                                *(_WORD*)(a1 + 204) = 1;
                                            }
                                            else
                                            {
                                                *(_BYTE*)(a1 + 248) = 0;
                                                *(_WORD*)(a1 + 204) = 2;
                                            }
                                        }
                                        else
                                        {
                                            *(_WORD*)(a1 + 204) = 1;
                                        }
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 2;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 1;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 2;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 1;
                        }
                        if (*(_DWORD*)(a1 + 444) == 4 || *(_DWORD*)(a1 + 444) == 12 || *(_DWORD*)(a1 + 444) == 20)
                            sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                        if (*(int*)(a1 + 444) > 28)
                        {
                            if (*(_DWORD*)(a1 + 392))
                                *(_DWORD*)(a1 + 432) = 50;
                            else
                                *(_DWORD*)(a1 + 432) = 4;
                        }
                        break;
                    case 4:
                        if (*(_DWORD*)(a1 + 444) == 4 || *(_DWORD*)(a1 + 444) == 10 || *(_DWORD*)(a1 + 444) == 16)
                        {
                            memset((void*)(a1 + 453), 0, 8u);
                            memset((void*)(a1 + 461), 0, 8u);
                        }
                        if (*(int*)(a1 + 444) >= 4)
                        {
                            if (*(int*)(a1 + 444) >= 7)
                            {
                                if (*(int*)(a1 + 444) >= 10)
                                {
                                    if (*(int*)(a1 + 444) >= 13)
                                    {
                                        if (*(int*)(a1 + 444) >= 16)
                                        {
                                            if (*(int*)(a1 + 444) >= 19)
                                            {
                                                *(_BYTE*)(a1 + 257) = 2;
                                                *(_WORD*)(a1 + 204) = 2;
                                            }
                                            else
                                            {
                                                *(_BYTE*)(a1 + 248) = 0;
                                                *(_WORD*)(a1 + 204) = 1;
                                            }
                                        }
                                        else
                                        {
                                            *(_WORD*)(a1 + 204) = 2;
                                        }
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 1;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 2;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 1;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 2;
                        }
                        if (*(_DWORD*)(a1 + 444) == 4 || *(_DWORD*)(a1 + 444) == 10 || *(_DWORD*)(a1 + 444) == 16)
                            sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                        if (*(int*)(a1 + 444) >= 22)
                        {
                            if (*(_DWORD*)(a1 + 392))
                                *(_DWORD*)(a1 + 432) = 50;
                            else
                                *(_DWORD*)(a1 + 432) = 4;
                        }
                        break;
                    }
                }
                else
                {
                    if (!(*(_DWORD*)(a1 + 444) % 4))
                    {
                        memset((void*)(a1 + 453), 0, 8u);
                        memset((void*)(a1 + 461), 0, 8u);
                    }
                    if (*(int*)(a1 + 444) >= 4)
                    {
                        if (*(int*)(a1 + 444) >= 8)
                        {
                            if (*(int*)(a1 + 444) >= 12)
                            {
                                if (*(int*)(a1 + 444) >= 16)
                                {
                                    if (*(int*)(a1 + 444) >= 20)
                                    {
                                        if (*(int*)(a1 + 444) >= 24)
                                        {
                                            *(_BYTE*)(a1 + 257) = 2;
                                            *(_WORD*)(a1 + 204) = 2;
                                        }
                                        else
                                        {
                                            *(_BYTE*)(a1 + 248) = 0;
                                            *(_WORD*)(a1 + 204) = 3;
                                        }
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 2;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 3;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 2;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 3;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 2;
                    }
                    if (*(_DWORD*)(a1 + 444) == 4 || *(_DWORD*)(a1 + 444) == 12 || *(_DWORD*)(a1 + 444) == 20)
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                    if (*(int*)(a1 + 444) > 28)
                    {
                        if (*(_DWORD*)(a1 + 392))
                            *(_DWORD*)(a1 + 432) = 50;
                        else
                            *(_DWORD*)(a1 + 432) = 4;
                    }
                }
                return;
            }
            if (!((*(_DWORD*)(a1 + 444) - 4) % 6))
            {
                memset((void*)(a1 + 453), 0, 8u);
                memset((void*)(a1 + 461), 0, 8u);
            }
            *(_BYTE*)(a1 + 212) = 0;
            if (*(int*)(a1 + 444) >= 2)
            {
                if (*(int*)(a1 + 444) >= 4)
                {
                    if (*(int*)(a1 + 444) >= 7)
                    {
                        if (*(int*)(a1 + 444) >= 10)
                        {
                            if (*(int*)(a1 + 444) >= 13)
                            {
                                if (*(int*)(a1 + 444) >= 16)
                                {
                                    if (*(int*)(a1 + 444) >= 19)
                                    {
                                        if (*(int*)(a1 + 444) >= 22)
                                        {
                                            *(_WORD*)(a1 + 204) = 194;
                                        }
                                        else
                                        {
                                            *(_BYTE*)(a1 + 257) = 2;
                                            *(_WORD*)(a1 + 204) = 195;
                                        }
                                    }
                                    else
                                    {
                                        *(_BYTE*)(a1 + 248) = 0;
                                        *(_WORD*)(a1 + 204) = 196;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 195;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 196;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 195;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 196;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 195;
                }
            }
            else
            {
                *(_WORD*)(a1 + 204) = 194;
            }
            if (*(int*)(a1 + 444) >= 19 || (*(_DWORD*)(a1 + 444) - 2) % 6)
            {
                if (*(int*)(a1 + 444) > 25)
                {
                    if (*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 432) = 50;
                    else
                        *(_DWORD*)(a1 + 432) = 3;
                }
                return;
            }
            break;
        default:
            switch (*(_DWORD*)(a1 + 428))
            {
            case 0x92:
                v84 = sub_41CCEA(a1, 1);
                v85 = sub_41CCEA(a1, 1);
                sub_41F169((_WORD*)a1, v85 / 10 + v84);
                *(_BYTE*)(a1 + 248) = 1;
                *(_BYTE*)(a1 + 212) = 0;
                *(_WORD*)(a1 + 204) = 62;
                *(_BYTE*)(a1 + 213) = -1;
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_DWORD*)(a1 + 436) = 0;
                    *(_DWORD*)(a1 + 372) = 0;
                    *(_DWORD*)(a1 + 340) = 500 * (*(_DWORD*)(a1 + 424) - (*(_DWORD*)(a1 + 424) == 0));
                    *(_DWORD*)(a1 + 352) = 0;
                    *(_DWORD*)(a1 + 348) = -220;
                    *(_DWORD*)(a1 + 360) = 20;
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    *(_BYTE*)(a1 + 257) = 1;
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A18, -1, 100, 100, 0);
                }
                return;
            case 0x93:
                v86 = sub_41CB3B(a1, 1);
                sub_41F169((_WORD*)a1, v86);
                *(_BYTE*)(a1 + 248) = 1;
                *(_BYTE*)(a1 + 212) = 0;
                *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 6 % 4 + 63;
                *(_BYTE*)(a1 + 213) = -1;
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    *(_BYTE*)(a1 + 257) = 1;
                    *(_DWORD*)(a1 + 436) = 0;
                    *(_DWORD*)(a1 + 372) = 0;
                    *(_DWORD*)(a1 + 340) = 450 * (*(_DWORD*)(a1 + 424) - (*(_DWORD*)(a1 + 424) == 0));
                    *(_DWORD*)(a1 + 352) = 0;
                    *(_DWORD*)(a1 + 348) = -300;
                    *(_DWORD*)(a1 + 360) = 20;
                    *(_WORD*)(a1 + 244) = -60;
                    *(_BYTE*)(a1 + 452) = 12;
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A18, -1, 100, 100, 0);
                }
                return;
            case 0x94:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_DWORD*)(a1 + 436) = 0;
                    *(_DWORD*)(a1 + 340) = 0;
                    *(_DWORD*)(a1 + 344) = 0;
                    *(_DWORD*)(a1 + 348) = 0;
                    *(_DWORD*)(a1 + 352) = 0;
                    *(_DWORD*)(a1 + 360) = 0;
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    *(_BYTE*)(a1 + 257) = 1;
                    v87 = sub_41CCEA(a1, 1);
                    sub_41F169((_WORD*)a1, v87);
                    *(_BYTE*)(a1 + 248) = -1;
                    *(_BYTE*)(a1 + 213) = -1;
                    *(_BYTE*)(a1 + 212) = 0;
                    *(_DWORD*)(a1 + 400) = 1;
                }
                if (*(_DWORD*)(a1 + 444) == 5)
                    *(_DWORD*)(a1 + 400) = 0;
                *(_WORD*)(a1 + 204) = 6 * (*(_DWORD*)(a1 + 444) / 4 % 2) + 55;
                if (!(*(_DWORD*)(a1 + 444) % 8))
                {
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    *(_DWORD*)(a1 + 424) = *(_DWORD*)(a1 + 424) == 0;
                }
                if (*(int*)(a1 + 444) >= 40)
                    *(_DWORD*)(a1 + 432) = 3;
                return;
            case 0x95:
                v363 = (__int64)((double)(*(_DWORD*)(a1 + 444) - 1) * 1.3);
                v88 = sub_41CB3B(a1, 1);
                v89 = sub_41CB3B(a1, 1);
                v90 = sub_41D067(a1, 1);
                sub_41F169((_WORD*)a1, (v363 + 75) * (v89 * v90 / 100 + v88) / 100);
                *(_BYTE*)(a1 + 248) = 1;
                *(_BYTE*)(a1 + 212) = 0;
                *(_WORD*)(a1 + 204) = (*(_DWORD*)(a1 + 444) - 1) / 6 % 4 + 63;
                *(_BYTE*)(a1 + 213) = -1;
                if (!((*(_DWORD*)(a1 + 444) - 1) % 12))
                {
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                }
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_DWORD*)(a1 + 436) = 0;
                    *(_DWORD*)(a1 + 344) = 0;
                    *(_DWORD*)(a1 + 360) = 20;
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    *(_BYTE*)(a1 + 257) = 1;
                }
                return;
            case 0x96:
                *(_BYTE*)(a1 + 248) = 1;
                *(_BYTE*)(a1 + 213) = -1;
                *(_BYTE*)(a1 + 257) = 1;
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    v91 = (int)sub_41CCEA(a1, 1) >> 1;
                    v92 = sub_41CCEA(a1, 1);
                    v93 = sub_41D067(a1, 1);
                    sub_41F169((_WORD*)a1, v92 * v93 / 200 + v91);
                    *(_DWORD*)(a1 + 436) = 0;
                    *(_DWORD*)(a1 + 348) -= 700;
                    *(_DWORD*)(a1 + 360) = 70;
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A18, -1, 100, 100, 0);
                }
                else if (*(_DWORD*)(a1 + 444) == 12)
                {
                    v94 = 9 * sub_41CCEA(a1, 1) / 10;
                    v95 = sub_41CCEA(a1, 1);
                    v96 = sub_41D067(a1, 1);
                    sub_41F169((_WORD*)a1, v95 * v96 / 200 + v94);
                    *(_DWORD*)(a1 + 372) = 700 * (*(_DWORD*)(a1 + 424) - (*(_DWORD*)(a1 + 424) == 0));
                    *(_DWORD*)(a1 + 348) = 800;
                    *(_DWORD*)(a1 + 360) = 0;
                    *(_WORD*)(a1 + 244) = 30;
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                }
                if (*(int*)(a1 + 444) >= 12)
                {
                    *(_BYTE*)(a1 + 212) = 1;
                    if (*(_BYTE*)(a1 + 195))
                    {
                        switch (*(_BYTE*)(a1 + 195))
                        {
                        case 1:
                            *(_WORD*)(a1 + 204) = 3;
                            break;
                        case 2:
                            *(_WORD*)(a1 + 204) = 16;
                            break;
                        case 3:
                            *(_WORD*)(a1 + 204) = 4;
                            break;
                        case 4:
                            *(_WORD*)(a1 + 204) = 12;
                            break;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 7;
                    }
                }
                else
                {
                    if (!(*(_DWORD*)(a1 + 444) % 4))
                    {
                        memset((void*)(a1 + 453), 0, 8u);
                        memset((void*)(a1 + 461), 0, 8u);
                    }
                    *(_BYTE*)(a1 + 212) = 0;
                    *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 3 % 4 + 63;
                }
                return;
            case 0x97:
                v97 = sub_41CCEA(a1, 1);
                v98 = sub_41CCEA(a1, 1);
                v99 = sub_41D067(a1, 1);
                sub_41F169((_WORD*)a1, v98 * v99 / 200 + v97);
                *(_BYTE*)(a1 + 248) = 1;
                *(_BYTE*)(a1 + 213) = -1;
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    *(_BYTE*)(a1 + 257) = 1;
                    *(_BYTE*)(a1 + 250) = 10;
                    *(_DWORD*)(a1 + 436) = 0;
                    *(_WORD*)(a1 + 244) = 30;
                }
                *(_BYTE*)(a1 + 212) = 0;
                if (*(_DWORD*)(a1 + 436))
                {
                    *(_BYTE*)(a1 + 257) = 2;
                    *(_WORD*)(a1 + 204) = 6;
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 67;
                }
                return;
            case 0x98:
                v100 = sub_41CB3B(a1, 1);
                v101 = sub_41CB3B(a1, 1);
                v102 = v101 * sub_41D067(a1, 1) / 100 + v100;
                v103 = sub_41CB3B(a1, 1);
                sub_41F169((_WORD*)a1, v103 / 5 + v102);
                *(_BYTE*)(a1 + 248) = 17;
                *(_BYTE*)(a1 + 213) = -1;
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    *(_BYTE*)(a1 + 257) = 1;
                    *(_DWORD*)(a1 + 436) = 0;
                    *(_WORD*)(a1 + 244) = 90;
                }
                *(_BYTE*)(a1 + 212) = 0;
                if (*(_DWORD*)(a1 + 436))
                {
                    *(_BYTE*)(a1 + 257) = 2;
                    *(_WORD*)(a1 + 204) = 6;
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 54;
                }
                return;
            case 0x9A:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_DWORD*)(a1 + 436) = 0;
                    *(_DWORD*)(a1 + 372) = 0;
                    *(_DWORD*)(a1 + 376) = 0;
                    *(_DWORD*)(a1 + 340) = 0;
                    *(_DWORD*)(a1 + 344) = 0;
                    *(_DWORD*)(a1 + 352) = 0;
                    *(_DWORD*)(a1 + 348) = -100;
                    *(_DWORD*)(a1 + 360) = 5;
                    *(_BYTE*)(a1 + 250) = 12;
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    *(_BYTE*)(a1 + 257) = 1;
                    *(_BYTE*)(a1 + 212) = 0;
                    *(_BYTE*)(a1 + 248) = 1;
                    v255 = (double)sub_41CCEA(a1, 1) * 1.25;
                    v104 = sub_41CCEA(a1, 1);
                    v105 = (double)(v104 * sub_41D067(a1, 1) / 200) + v255;
                    sub_41F169((_WORD*)a1, (__int64)v105);
                    *(_BYTE*)(a1 + 213) = -1;
                    if (*(_BYTE*)(a1 + 188) == 2 || *(_BYTE*)(a1 + 188) == 3)
                    {
                        *(_BYTE*)(a1 + 452) = 8;
                        *(_BYTE*)(a1 + 248) = 12;
                        sub_4239D3(a1, 5);
                        v254 = (double)sub_41CCEA(a1, 1) * 1.25;
                        v106 = sub_41CCEA(a1, 1);
                        v107 = ((double)(v106 * sub_41D067(a1, 1) / 200) + v254) / 3.0;
                        sub_41F169((_WORD*)a1, (__int64)v107);
                    }
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A38, -1, 100, 100, 0);
                    if (*(unsigned __int8*)(a1 + 238) <= 1u && sub_41BA53(a1, 0x86u, 0))
                        *(_DWORD*)(a1 + 400) = 1;
                }
                if (*(_DWORD*)(a1 + 444) == 5)
                    *(_DWORD*)(a1 + 400) = 0;
                if (*(_BYTE*)(a1 + 188) == 2 || *(_BYTE*)(a1 + 188) == 3)
                {
                    *(_BYTE*)(a1 + 212) = 1;
                    if (*(int*)(a1 + 444) >= 40)
                    {
                        *(_BYTE*)(a1 + 257) = 2;
                        *(_DWORD*)(a1 + 360) = 30;
                        *(_WORD*)(a1 + 204) = 4;
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 4 % 4 + 68;
                    }
                }
                else if (*(int*)(a1 + 444) >= 40)
                {
                    *(_BYTE*)(a1 + 257) = 2;
                    *(_DWORD*)(a1 + 360) = 30;
                    *(_WORD*)(a1 + 204) = 5;
                }
                else
                {
                    *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 4 % 4 + 78;
                }
                return;
            case 0x9B:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_BYTE*)(a1 + 212) = 0;
                    *(_BYTE*)(a1 + 248) = 3;
                    v253 = (double)sub_41CCEA(a1, 1) * 1.5;
                    v108 = sub_41CCEA(a1, 1);
                    v109 = (double)(v108 * sub_41D067(a1, 1) / 200) + v253;
                    sub_41F169((_WORD*)a1, (__int64)v109);
                    *(_BYTE*)(a1 + 213) = -1;
                    *(_DWORD*)(a1 + 380) = 0;
                    *(_DWORD*)(a1 + 372) = 0;
                    *(_DWORD*)(a1 + 376) = 0;
                    *(_DWORD*)(a1 + 340) = 350 * (*(_DWORD*)(a1 + 424) - (*(_DWORD*)(a1 + 424) == 0));
                    *(_DWORD*)(a1 + 344) = 0;
                    *(_DWORD*)(a1 + 352) = 0;
                    *(_DWORD*)(a1 + 348) = -420;
                    *(_DWORD*)(a1 + 360) = 30;
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    *(_BYTE*)(a1 + 257) = 1;
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A3C, -1, 100, 100, 0);
                    if (*(_BYTE*)(a1 + 188) == 2 || *(_BYTE*)(a1 + 188) == 3)
                    {
                        v252 = (double)sub_41CCEA(a1, 1) * 1.5;
                        v110 = sub_41CCEA(a1, 1);
                        v111 = ((double)(v110 * sub_41D067(a1, 1) / 200) + v252) / 2.0;
                        sub_41F169((_WORD*)a1, (__int64)v111);
                        *(_DWORD*)(a1 + 340) *= 2;
                        *(_DWORD*)(a1 + 352) = -*(_DWORD*)(a1 + 340) / 20;
                        *(_BYTE*)(a1 + 212) = 1;
                        *(_BYTE*)(a1 + 452) = 5;
                        sub_4239D3(a1, 5);
                    }
                }
                if (*(_BYTE*)(a1 + 188) == 2 || *(_BYTE*)(a1 + 188) == 3)
                {
                    if (*(_DWORD*)(a1 + 444) == 20)
                    {
                        *(_DWORD*)(a1 + 352) = 0;
                        *(int*)(a1 + 340) /= 2;
                    }
                    if (*(int*)(a1 + 444) >= 3)
                    {
                        if (*(int*)(a1 + 444) >= 21)
                            *(_WORD*)(a1 + 204) = 4;
                        else
                            *(_WORD*)(a1 + 204) = 73;
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 72;
                    }
                }
                else if (*(int*)(a1 + 444) >= 5)
                {
                    *(_WORD*)(a1 + 204) = 83;
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 82;
                }
                return;
            case 0x9C:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_DWORD*)(a1 + 380) = 0;
                    *(_DWORD*)(a1 + 372) = 0;
                    *(_DWORD*)(a1 + 376) = 0;
                    *(_DWORD*)(a1 + 340) = 50 * (*(_DWORD*)(a1 + 424) - (*(_DWORD*)(a1 + 424) == 0));
                    *(_DWORD*)(a1 + 344) = 0;
                    *(_DWORD*)(a1 + 352) = 0;
                    *(_DWORD*)(a1 + 348) = -280;
                    *(_DWORD*)(a1 + 360) = 30;
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    *(_BYTE*)(a1 + 257) = 1;
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A40, -1, 100, 100, 0);
                    *(_BYTE*)(a1 + 212) = 0;
                    *(_BYTE*)(a1 + 248) = 5;
                    v251 = (double)sub_41CB3B(a1, 1) * 1.5;
                    v112 = sub_41CB3B(a1, 1);
                    v113 = (double)(v112 * sub_41D067(a1, 1) / 200) + v251;
                    sub_41F169((_WORD*)a1, (__int64)v113);
                    *(_BYTE*)(a1 + 213) = -1;
                    if (*(_BYTE*)(a1 + 188) == 2 || *(_BYTE*)(a1 + 188) == 3)
                    {
                        *(_DWORD*)(a1 + 348) = -500;
                        *(_DWORD*)(a1 + 340) *= 4;
                        *(_DWORD*)(a1 + 352) = -*(_DWORD*)(a1 + 340) / 16;
                        *(_BYTE*)(a1 + 452) = 10;
                        *(_BYTE*)(a1 + 212) = 1;
                        sub_4239D3(a1, 5);
                    }
                }
                if (*(_BYTE*)(a1 + 188) == 2 || *(_BYTE*)(a1 + 188) == 3)
                {
                    if (*(int*)(a1 + 444) >= 2)
                    {
                        if (*(int*)(a1 + 444) >= 4)
                        {
                            if (*(int*)(a1 + 444) >= 6)
                            {
                                if (*(int*)(a1 + 444) >= 16)
                                {
                                    if (*(int*)(a1 + 444) >= 19)
                                    {
                                        if (*(int*)(a1 + 444) >= 22)
                                        {
                                            if (*(int*)(a1 + 444) >= 25)
                                            {
                                                if (*(int*)(a1 + 444) >= 28)
                                                    *(_WORD*)(a1 + 204) = 4;
                                                else
                                                    *(_WORD*)(a1 + 204) = 105;
                                            }
                                            else
                                            {
                                                *(_WORD*)(a1 + 204) = 100;
                                            }
                                        }
                                        else
                                        {
                                            *(_WORD*)(a1 + 204) = 99;
                                        }
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 104;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 102;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 89;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 88;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 87;
                    }
                    if (*(_DWORD*)(a1 + 444) == 16)
                    {
                        *(_DWORD*)(a1 + 372) = 0;
                        *(_DWORD*)(a1 + 340) = 0;
                        *(_DWORD*)(a1 + 352) = 0;
                    }
                }
                else if (*(int*)(a1 + 444) >= 5)
                {
                    if (*(int*)(a1 + 444) >= 9)
                        *(_WORD*)(a1 + 204) = 86;
                    else
                        *(_WORD*)(a1 + 204) = 85;
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 84;
                }
                return;
            case 0x9D:
                *(_BYTE*)(a1 + 212) = 0;
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_DWORD*)(a1 + 348) = -100;
                    *(_DWORD*)(a1 + 360) = 10;
                    *(_BYTE*)(a1 + 248) = 0;
                    *(_BYTE*)(a1 + 257) = 1;
                    v114 = (int)sub_41CCEA(a1, 1) >> 1;
                    v115 = sub_41CCEA(a1, 1);
                    v116 = sub_41D067(a1, 1);
                    sub_41F169((_WORD*)a1, v115 * v116 / 200 + v114);
                    if (*(_BYTE*)(a1 + 236) == 3)
                    {
                        v117 = (unsigned __int16)sub_4261B0((short*)a1);
                        v118 = sub_41CCEA(a1, 1);
                        v119 = sub_41CA5F(a1, 1);
                        sub_41F169((_WORD*)a1, v118 * v119 / 200 + v117);
                    }
                    *(_BYTE*)(a1 + 213) = -1;
                    if (*(unsigned __int8*)(a1 + 238) <= 1u && sub_41BA53(a1, 0x86u, 0))
                        *(_DWORD*)(a1 + 400) = 1;
                }
                if (*(_DWORD*)(a1 + 444) == 5)
                    *(_DWORD*)(a1 + 400) = 0;
                v120 = (*(_DWORD*)(a1 + 444) - 1) / 3 % 4;
                LOBYTE(v362) = v120;
                if (v120)
                {
                    switch ((unsigned __int8)v362)
                    {
                    case 1u:
                        *(_WORD*)(a1 + 204) = 87;
                        break;
                    case 2u:
                        *(_WORD*)(a1 + 204) = 88;
                        break;
                    case 3u:
                        *(_WORD*)(a1 + 204) = 80;
                        break;
                    }
                }
                else
                {
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A24, -1, 100, 100, 0);
                    *(_WORD*)(a1 + 204) = 0;
                }
                if (!((*(_DWORD*)(a1 + 444) - 1) % 3))
                {
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                }
                if (*(int*)(a1 + 444) >= 30)
                {
                    *(_DWORD*)(a1 + 432) = 50;
                    *(_DWORD*)(a1 + 360) = 30;
                }
                return;
            case 0x9E:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_DWORD*)(a1 + 372) = 0;
                    *(_DWORD*)(a1 + 376) = 0;
                    *(_DWORD*)(a1 + 340) = 460 * (*(_DWORD*)(a1 + 424) - (*(_DWORD*)(a1 + 424) == 0));
                    *(_DWORD*)(a1 + 344) = 0;
                    *(_DWORD*)(a1 + 352) = 0;
                    *(_DWORD*)(a1 + 348) = -350;
                    *(_DWORD*)(a1 + 360) = 30;
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    *(_BYTE*)(a1 + 257) = 1;
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A3C, -1, 100, 100, 0);
                    *(_BYTE*)(a1 + 248) = 3;
                    v121 = sub_41CB3B(a1, 1);
                    v122 = sub_41CB3B(a1, 1);
                    v123 = v122 * sub_41D067(a1, 1) / 100 + v121;
                    v361 = sub_41CB3B(a1, 1) / 5 + v123;
                    if (*(_DWORD*)(a1 + 480))
                    {
                        v124 = (unsigned __int16)sub_43E620((short*)*(_DWORD*)(a1 + 480));
                        v361 += v124 * sub_41F380(a1, 1) / 250;
                    }
                    sub_41F169((_WORD*)a1, v361);
                    *(_BYTE*)(a1 + 213) = -1;
                }
                *(_BYTE*)(a1 + 212) = 0;
                if (*(int*)(a1 + 444) >= 6)
                    *(_WORD*)(a1 + 204) = 89;
                else
                    *(_WORD*)(a1 + 204) = 6;
                return;
            case 0x5A:
                *(_BYTE*)(a1 + 212) = 0;
                *(_BYTE*)(a1 + 213) = -1;
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    v359 = 0;
                    v360 = sub_4175B4(a1, 1);
                    if (*(_BYTE*)(a1 + 195))
                    {
                        switch (*(_BYTE*)(a1 + 195))
                        {
                        case 1:
                            v359 = 40 * v360 / 100;
                            break;
                        case 2:
                            v359 = 35 * v360 / 100;
                            break;
                        case 3:
                            v359 = 50 * v360 / 100;
                            break;
                        case 4:
                            v359 = 55 * v360 / 100;
                            break;
                        }
                    }
                    else
                    {
                        v359 = 45 * v360 / 100;
                    }
                    v359 += 10;
                    if (*(_BYTE*)(a1 + 258) == 1)
                    {
                        v359 = 12 * v359 / 10;
                    }
                    else if (*(_BYTE*)(a1 + 258) == 2)
                    {
                        v359 /= 2;
                    }
                    if (!v359)
                        v359 = 1;
                    if (*(_DWORD*)(a1 + 304))
                        sub_41EF8A(*(_WORD**)(a1 + 304), v359);
                    *(_DWORD*)(a1 + 372) = 0;
                    *(_DWORD*)(a1 + 376) = 0;
                    *(_DWORD*)(a1 + 340) = 0;
                    *(_DWORD*)(a1 + 352) = 0;
                    *(_DWORD*)(a1 + 344) = 0;
                    *(_DWORD*)(a1 + 356) = 0;
                    *(_DWORD*)(a1 + 348) = -1200;
                    *(_DWORD*)(a1 + 360) = 30;
                    *(_DWORD*)(a1 + 436) = 0;
                    *(_BYTE*)(a1 + 177) = 1;
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A44, -1, 100, 100, 0);
                }
                if (*(_DWORD*)(a1 + 436))
                {
                    *(_WORD*)(a1 + 204) = 25;
                    *(_DWORD*)(a1 + 304) = 0;
                }
                else if (*(int*)(a1 + 444) <= 1
                    || !*(_DWORD*)(a1 + 304)
                    || Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) == (struct Concurrency::ISchedulerProxy*)110)
                {
                    *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 4 % 5 + 90;
                }
                else
                {
                    *(_DWORD*)(a1 + 432) = 50;
                    *(_BYTE*)(a1 + 177) = 0;
                    *(_DWORD*)(a1 + 304) = 0;
                }
                return;
            case 0x6E:
                *(_BYTE*)(a1 + 212) = 0;
                *(_WORD*)(a1 + 204) = 33;
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_DWORD*)(a1 + 372) = 0;
                    *(_DWORD*)(a1 + 376) = 0;
                    *(_DWORD*)(a1 + 340) = 0;
                    *(_DWORD*)(a1 + 352) = 0;
                    *(_DWORD*)(a1 + 344) = 0;
                    *(_DWORD*)(a1 + 356) = 0;
                    *(_DWORD*)(a1 + 348) = -1200;
                    *(_DWORD*)(a1 + 360) = 30;
                    *(_DWORD*)(a1 + 436) = 0;
                    *(_BYTE*)(a1 + 177) = 1;
                    sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                }
                if (*(_DWORD*)(a1 + 304))
                {
                    if (*(_DWORD*)(a1 + 436))
                    {
                        *(_WORD*)(a1 + 204) = 17;
                    }
                    else
                    {
                        v358 = sub_426090(*(_DWORD**)(a1 + 304));
                        v357 = sub_4260B0(*(_DWORD**)(a1 + 304));
                        v356 = *(_DWORD*)(a1 + 444) / 4 % 5;
                        if (v356)
                        {
                            switch (v356)
                            {
                            case 1:
                                *(_DWORD*)(a1 + 424) = sub_425D70(*(_DWORD**)(a1 + 304)) == 0;
                                *(_BYTE*)(a1 + 223) = sub_426030(*(_BYTE**)(a1 + 304)) + 1;
                                break;
                            case 2:
                                *(_DWORD*)(a1 + 424) = sub_425D70(*(_DWORD**)(a1 + 304));
                                *(_BYTE*)(a1 + 223) = sub_426030(*(_BYTE**)(a1 + 304)) + 1;
                                break;
                            case 3:
                                *(_DWORD*)(a1 + 424) = sub_425D70(*(_DWORD**)(a1 + 304));
                                *(_BYTE*)(a1 + 223) = sub_426030(*(_BYTE**)(a1 + 304)) - 1;
                                if (*(_DWORD*)(a1 + 424))
                                    v358 -= 800;
                                else
                                    v358 += 800;
                                break;
                            case 4:
                                *(_BYTE*)(a1 + 223) = sub_426030(*(_BYTE**)(a1 + 304)) - 1;
                                break;
                            }
                        }
                        else
                        {
                            *(_DWORD*)(a1 + 424) = sub_425D70(*(_DWORD**)(a1 + 304)) == 0;
                            *(_BYTE*)(a1 + 223) = sub_426030(*(_BYTE**)(a1 + 304)) - 1;
                            if (*(_DWORD*)(a1 + 424))
                                v358 -= 800;
                            else
                                v358 += 800;
                        }
                        *(_DWORD*)(a1 + 372) = v358 - *(_DWORD*)(a1 + 328);
                    }
                }
                else
                {
                    *(_BYTE*)(a1 + 177) = 0;
                    *(_DWORD*)(a1 + 372) = 0;
                    sub_417C83(a1);
                }
                return;
            case 0x9F:
                *(_BYTE*)(a1 + 212) = 0;
                *(_BYTE*)(a1 + 213) = 24;
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_BYTE*)(a1 + 248) = 2;
                    *(_BYTE*)(a1 + 257) = 1;
                    v250 = (double)sub_41CB3B(a1, 1) * 1.7;
                    v125 = sub_41CB3B(a1, 1);
                    v126 = (double)(v125 * sub_41D067(a1, 1) / 100) + v250;
                    sub_41F169((_WORD*)a1, (__int64)v126);
                    if (*(_BYTE*)(a1 + 236) == 3)
                    {
                        v127 = (unsigned __int16)sub_4261B0((short*)a1);
                        v128 = sub_41CB3B(a1, 1);
                        v129 = sub_41CA5F(a1, 1);
                        sub_41F169((_WORD*)a1, v128 * v129 / 100 + v127);
                        *(_BYTE*)(a1 + 248) = 3;
                    }
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A3C, -1, 100, 100, 0);
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    if (*(unsigned __int8*)(a1 + 238) <= 1u && sub_41BA53(a1, 0x86u, 0))
                        *(_DWORD*)(a1 + 400) = 1;
                }
                if (*(_DWORD*)(a1 + 444) == 5)
                    *(_DWORD*)(a1 + 400) = 0;
                if (*(int*)(a1 + 444) >= 9)
                    *(_WORD*)(a1 + 204) = 96;
                else
                    *(_WORD*)(a1 + 204) = 95;
                return;
            case 0xA0:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_BYTE*)(a1 + 248) = -1;
                    *(_BYTE*)(a1 + 257) = 1;
                    v130 = sub_41CB3B(a1, 1);
                    sub_41F169((_WORD*)a1, v130 / 3);
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    *(_WORD*)(a1 + 244) = -120;
                    *(_BYTE*)(a1 + 213) = 24;
                    if (!*(_DWORD*)(a1 + 392) || *(unsigned __int8*)(a1 + 238) <= 1u && sub_41BA53(a1, 0x86u, 0))
                    {
                        *(_DWORD*)(a1 + 400) = 1;
                        if (!*(_DWORD*)(a1 + 392))
                            *(_DWORD*)(a1 + 408) = 1;
                    }
                }
                if (*(_DWORD*)(a1 + 444) == 5)
                {
                    *(_DWORD*)(a1 + 400) = 0;
                    *(_DWORD*)(a1 + 408) = 0;
                }
                *(_BYTE*)(a1 + 212) = 0;
                *(_WORD*)(a1 + 204) = (*(_DWORD*)(a1 + 444) - 1) / 2 % 2 + 97;
                if ((*(_DWORD*)(a1 + 444) - 1) % 4)
                {
                    if ((*(_DWORD*)(a1 + 444) - 1) % 4 == 3)
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                }
                else
                {
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                }
                if (*(_DWORD*)(a1 + 444) == 13)
                {
                    if (*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 432) = 50;
                    else
                        *(_DWORD*)(a1 + 432) = 3;
                }
                return;
            case 0xA1:
                *(_BYTE*)(a1 + 212) = 0;
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_BYTE*)(a1 + 248) = 2;
                    *(_BYTE*)(a1 + 257) = 1;
                    *(_BYTE*)(a1 + 250) = 10;
                    v249 = (double)sub_41CB3B(a1, 1) * 1.5;
                    v131 = sub_41CB3B(a1, 1);
                    v132 = (double)(v131 * sub_41D067(a1, 1) / 100) + v249;
                    sub_41F169((_WORD*)a1, (__int64)v132);
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A3C, -1, 100, 100, 0);
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    *(_WORD*)(a1 + 244) = 120;
                    *(_BYTE*)(a1 + 213) = 24;
                    if (*(unsigned __int8*)(a1 + 238) <= 1u)
                    {
                        if (sub_41BA53(a1, 0x86u, 0))
                            *(_DWORD*)(a1 + 400) = 1;
                    }
                }
                if (*(_DWORD*)(a1 + 444) == 5)
                    *(_DWORD*)(a1 + 400) = 0;
                if (*(int*)(a1 + 444) >= 7)
                    *(_WORD*)(a1 + 204) = 98;
                else
                    *(_WORD*)(a1 + 204) = 97;
                return;
            case 0x5B:
                *(_BYTE*)(a1 + 212) = 0;
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A50, -1, 100, 100, 0);
                    *(_BYTE*)(a1 + 213) = 5;
                    *(_DWORD*)(a1 + 412) = 1;
                    if (!*(_DWORD*)(a1 + 392) || *(unsigned __int8*)(a1 + 238) <= 1u && sub_41BA53(a1, 0x86u, 0))
                        *(_DWORD*)(a1 + 400) = 1;
                }
                if (*(_DWORD*)(a1 + 444) == 5)
                    *(_DWORD*)(a1 + 400) = 0;
                *(_WORD*)(a1 + 204) = 99;
                switch (*(_DWORD*)(a1 + 444))
                {
                case '%':
                    *(_BYTE*)(a1 + 248) = 2;
                    v133 = sub_41CB3B(a1, 1);
                    sub_41F169((_WORD*)a1, v133);
                    break;
                case 'K':
                    *(_BYTE*)(a1 + 248) = 3;
                    *(_BYTE*)(a1 + 250) = 7;
                    v134 = sub_41CB3B(a1, 1);
                    sub_41F169((_WORD*)a1, 2 * v134);
                    break;
                case 'q':
                    *(_BYTE*)(a1 + 248) = 1;
                    *(_BYTE*)(a1 + 250) = 10;
                    v135 = (double)sub_41CB3B(a1, 1) * 2.5;
                    sub_41F169((_WORD*)a1, (__int64)v135);
                    break;
                }
                v355 = *(_DWORD*)(a1 + 444) % 38;
                if (v355 <= 12 && !(v355 % 2))
                {
                    v354 = 0;
                    v353 = 0;
                    if (v355)
                    {
                        switch (v355)
                        {
                        case 2:
                            v354 = -11;
                            v353 = -27;
                            break;
                        case 6:
                            v354 = -13;
                            v353 = -20;
                            break;
                        case 8:
                            v354 = -11;
                            v353 = -13;
                            break;
                        }
                    }
                    else
                    {
                        v354 = -6;
                        v353 = -32;
                    }
                    if (v354 && v353)
                    {
                        if (*(_DWORD*)(a1 + 424))
                            v354 = -v354;
                        sub_442863(v349);
                        v349[0] = v354;
                        v349[1] = v353;
                        v350 = 1;
                        v351 = *(_DWORD*)(a1 + 424);
                        v352 = a1;
                        sub_4561A5((char*)unk_4B9B10, (int)v349);
                    }
                }
                if (*(char*)(a1 + 230) > 0)
                {
                    if (*(int*)(a1 + 444) >= 113)
                        *(_DWORD*)(a1 + 432) = 162;
                }
                else if (*(int*)(a1 + 444) <= 36)
                {
                    if (*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 432) = 50;
                    else
                        *(_DWORD*)(a1 + 432) = 4;
                }
                else
                {
                    *(_DWORD*)(a1 + 432) = 162;
                }
                return;
            case 0xA2:
                *(_DWORD*)(a1 + 412) = 1;
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_WORD*)(a1 + 244) = -120;
                    *(_BYTE*)(a1 + 257) = 1;
                    if (*(_BYTE*)(a1 + 248) == 1)
                        *(_BYTE*)(a1 + 249) = 1;
                }
                if (*(_BYTE*)(a1 + 248) == 1 && *(_BYTE*)(a1 + 195) == 1)
                {
                    *(_BYTE*)(a1 + 212) = 1;
                    if (*(int*)(a1 + 444) >= 4)
                    {
                        if (*(int*)(a1 + 444) >= 8)
                        {
                            if (*(int*)(a1 + 444) >= 10)
                            {
                                if (*(int*)(a1 + 444) >= 21)
                                {
                                    *(_WORD*)(a1 + 204) = 8;
                                }
                                else
                                {
                                    *(_BYTE*)(a1 + 257) = 2;
                                    *(_WORD*)(a1 + 204) = 7;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 6;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 5;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 4;
                    }
                    if (*(int*)(a1 + 444) > 24)
                        *(_DWORD*)(a1 + 432) = 4;
                    if (*(_DWORD*)(a1 + 444) == 4)
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                }
                else
                {
                    *(_BYTE*)(a1 + 212) = 0;
                    if (*(int*)(a1 + 444) >= 4)
                    {
                        if (*(int*)(a1 + 444) >= 8)
                        {
                            if (*(int*)(a1 + 444) >= 24)
                            {
                                *(_BYTE*)(a1 + 257) = 2;
                                *(_WORD*)(a1 + 204) = 103;
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 167;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 166;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 100;
                    }
                    if (*(_DWORD*)(a1 + 444) == 4)
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                    if (*(int*)(a1 + 444) >= 28)
                        *(_DWORD*)(a1 + 432) = 4;
                }
                return;
            case 0x5C:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_DWORD*)(a1 + 412) = 1;
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A54, -1, 100, 100, 0);
                    if (!*(_DWORD*)(a1 + 392) || *(unsigned __int8*)(a1 + 238) <= 1u && sub_41BA53(a1, 0x86u, 0))
                        *(_DWORD*)(a1 + 400) = 1;
                }
                if (*(_DWORD*)(a1 + 444) == 5)
                    *(_DWORD*)(a1 + 400) = 0;
                *(_BYTE*)(a1 + 212) = 0;
                *(_WORD*)(a1 + 204) = 100;
                if (*(unsigned __int8*)(a1 + 476) < 5u && *(int*)(a1 + 444) >= 31 && !((*(_DWORD*)(a1 + 444) - 1) % 30))
                    ++* (_BYTE*)(a1 + 476);
                if (*(unsigned __int8*)(a1 + 476) < 5u && !((*(_DWORD*)(a1 + 444) - 1) % 5))
                {
                    v341 = (*(_DWORD*)(a1 + 444) - 1) % 30 / 6;
                    sub_442863(&v342);
                    v344 = 1;
                    v345 = *(_DWORD*)(a1 + 424);
                    v346 = a1;
                    v348 = 0;
                    v347 = 0;
                    if (v341)
                    {
                        switch (v341)
                        {
                        case 1:
                            v348 = -7;
                            v347 = -26;
                            break;
                        case 2:
                            v348 = -6;
                            v347 = -25;
                            break;
                        case 3:
                            v348 = -5;
                            v347 = -25;
                            break;
                        case 4:
                            v348 = -4;
                            v347 = -24;
                            break;
                        case 5:
                            v348 = -3;
                            v347 = -24;
                            break;
                        }
                    }
                    else
                    {
                        v348 = -8;
                        v347 = -26;
                    }
                    if (*(_DWORD*)(a1 + 424))
                        v348 = -v348;
                    v342 = v348;
                    v343 = v347;
                    sub_4561A5((char*)unk_4B9B10, (int)&v342);
                    if (v341)
                    {
                        switch (v341)
                        {
                        case 1:
                            v347 = -15;
                            break;
                        case 2:
                            v347 = -16;
                            break;
                        case 3:
                            v347 = -16;
                            break;
                        case 4:
                            v347 = -17;
                            break;
                        case 5:
                            v347 = -17;
                            break;
                        }
                    }
                    else
                    {
                        v347 = -15;
                    }
                    v342 = v348;
                    v343 = v347;
                    sub_4561A5((char*)unk_4B9B10, (int)&v342);
                }
                if (*(char*)(a1 + 230) <= 0)
                {
                    if (*(_BYTE*)(a1 + 476))
                    {
                        *(_DWORD*)(a1 + 432) = 163;
                    }
                    else if (*(_DWORD*)(a1 + 392))
                    {
                        *(_DWORD*)(a1 + 432) = 50;
                    }
                    else
                    {
                        *(_DWORD*)(a1 + 432) = 4;
                    }
                }
                if (*(char*)(a1 + 232) > 0 && *(char*)(a1 + 232) < 5)
                {
                    if (*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 432) = 50;
                    else
                        *(_DWORD*)(a1 + 432) = 77;
                }
                return;
            case 0xA3:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_BYTE*)(a1 + 248) = 1;
                    *(_BYTE*)(a1 + 257) = 1;
                    *(_BYTE*)(a1 + 250) = 10;
                    v136 = sub_41CB3B(a1, 1);
                    sub_41F169(
                        (_WORD*)a1,
                        (6 * *(unsigned __int8*)(a1 + 476) + 10) * v136 / 10 + 2 * *(unsigned __int8*)(a1 + 476));
                    if (*(_BYTE*)(a1 + 476) == 5)
                        *(_BYTE*)(a1 + 255) = 0;
                    *(_BYTE*)(a1 + 476) = 0;
                    *(_WORD*)(a1 + 244) = 60;
                    *(_DWORD*)(a1 + 412) = 1;
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A58, -1, 100, 100, 0);
                }
                *(_BYTE*)(a1 + 212) = 0;
                if (*(int*)(a1 + 444) >= 5)
                {
                    if (*(int*)(a1 + 444) >= 25)
                    {
                        *(_BYTE*)(a1 + 257) = 2;
                        *(_WORD*)(a1 + 204) = 103;
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 102;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 101;
                }
                if (*(int*)(a1 + 444) >= 33)
                {
                    if (*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 432) = 50;
                    else
                        *(_DWORD*)(a1 + 432) = 4;
                }
                return;
            case 0xA4:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_BYTE*)(a1 + 248) = 2;
                    *(_BYTE*)(a1 + 257) = 1;
                    *(_BYTE*)(a1 + 250) = 6;
                    v137 = sub_41CB3B(a1, 1);
                    v138 = sub_41CCEA(a1, 1) + v137;
                    v139 = sub_417924(a1, 3, 1);
                    sub_41F169((_WORD*)a1, 3 * (v139 + v138) / 5);
                    if (*(_DWORD*)(a1 + 392))
                    {
                        v140 = (unsigned __int16)sub_4261B0((short*)a1);
                        v141 = (unsigned __int16)sub_4261B0((short*)a1);
                        v142 = sub_41D067(a1, 1);
                        sub_41F169((_WORD*)a1, v141 * v142 / 200 + v140);
                    }
                    if (*(_BYTE*)(a1 + 237) || *(_BYTE*)(a1 + 236) == 3 && *(_DWORD*)(a1 + 392))
                    {
                        *(_BYTE*)(a1 + 248) = 3;
                        v143 = (unsigned __int16)sub_4261B0((short*)a1);
                        v144 = (unsigned __int16)sub_4261B0((short*)a1);
                        v145 = sub_41CA5F(a1, 1);
                        sub_41F169((_WORD*)a1, v144 * v145 / 200 + v143);
                    }
                    *(_BYTE*)(a1 + 213) = -1;
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    if (!*(_DWORD*)(a1 + 392) || *(unsigned __int8*)(a1 + 238) <= 1u && sub_41BA53(a1, 0x86u, 0))
                        *(_DWORD*)(a1 + 400) = 1;
                }
                if (*(_DWORD*)(a1 + 444) == 5)
                    *(_DWORD*)(a1 + 400) = 0;
                *(_BYTE*)(a1 + 212) = 0;
                if (*(int*)(a1 + 444) >= 4)
                {
                    if (*(int*)(a1 + 444) >= 8)
                        *(_WORD*)(a1 + 204) = 106;
                    else
                        *(_WORD*)(a1 + 204) = 105;
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 104;
                }
                if (*(_DWORD*)(a1 + 444) == 8)
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                if (*(int*)(a1 + 444) >= 28)
                {
                    if (*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 432) = 50;
                    else
                        *(_DWORD*)(a1 + 432) = 4;
                }
                return;
            case 0xA5:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_BYTE*)(a1 + 212) = 0;
                    *(_DWORD*)(a1 + 424) = *(_DWORD*)(a1 + 424) == 0;
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    *(_BYTE*)(a1 + 257) = 1;
                    *(_BYTE*)(a1 + 248) = 3;
                    *(_BYTE*)(a1 + 250) = 9;
                    v248 = (double)sub_41CB3B(a1, 1) * 1.4;
                    v146 = sub_41CB3B(a1, 1);
                    v147 = (double)(v146 * sub_41CA5F(a1, 1) / 200) + v248;
                    sub_41F169((_WORD*)a1, (__int64)v147);
                    if (*(_DWORD*)(a1 + 392))
                    {
                        v148 = (unsigned __int16)sub_4261B0((short*)a1);
                        v149 = sub_41CB3B(a1, 1);
                        v150 = sub_41D067(a1, 1);
                        sub_41F169((_WORD*)a1, v149 * v150 / 100 + v148);
                    }
                    *(_BYTE*)(a1 + 213) = -1;
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A60, -1, 100, 100, 0);
                }
                if (*(_BYTE*)(a1 + 195) == 4)
                {
                    *(_BYTE*)(a1 + 212) = 1;
                    if (*(int*)(a1 + 444) >= 5)
                    {
                        if (*(int*)(a1 + 444) >= 11)
                        {
                            if (*(int*)(a1 + 444) >= 15)
                            {
                                if (*(int*)(a1 + 444) >= 21)
                                {
                                    if (*(int*)(a1 + 444) >= 25)
                                    {
                                        if (*(int*)(a1 + 444) >= 31)
                                            *(_WORD*)(a1 + 204) = 17;
                                        else
                                            *(_WORD*)(a1 + 204) = 18;
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 17;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 19;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 17;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 18;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 17;
                    }
                }
                else if (*(int*)(a1 + 444) >= 5)
                {
                    if (*(int*)(a1 + 444) >= 11)
                    {
                        if (*(int*)(a1 + 444) >= 15)
                        {
                            if (*(int*)(a1 + 444) >= 21)
                            {
                                if (*(int*)(a1 + 444) >= 25)
                                {
                                    if (*(int*)(a1 + 444) >= 31)
                                        *(_WORD*)(a1 + 204) = 107;
                                    else
                                        *(_WORD*)(a1 + 204) = 108;
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 107;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 109;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 107;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 108;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 107;
                }
                if ((*(_DWORD*)(a1 + 444) - 1) % 10 == 6)
                    *(_DWORD*)(a1 + 424) = *(_DWORD*)(a1 + 424) == 0;
                if (*(_DWORD*)(a1 + 444) == 35)
                {
                    if (*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 432) = 50;
                    else
                        *(_DWORD*)(a1 + 432) = 4;
                }
                return;
            case 0xA6:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_BYTE*)(a1 + 212) = 0;
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    *(_BYTE*)(a1 + 248) = -1;
                    *(_BYTE*)(a1 + 257) = 1;
                    v151 = sub_41CB3B(a1, 1) / 3;
                    v152 = sub_41CB3B(a1, 1);
                    v153 = sub_41CA5F(a1, 1);
                    sub_41F169((_WORD*)a1, v152 * v153 / 200 + v151);
                    *(_BYTE*)(a1 + 213) = 26;
                    *(_DWORD*)(a1 + 400) = 1;
                }
                v340 = (*(_DWORD*)(a1 + 444) - 1) / 2 % 7;
                *(_WORD*)(a1 + 204) = v340 + 110;
                if (*(_DWORD*)(a1 + 444) == 2
                    || *(_DWORD*)(a1 + 444) == 8
                    || *(_DWORD*)(a1 + 444) == 16
                    || *(_DWORD*)(a1 + 444) == 22)
                {
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                    if (*(_DWORD*)(a1 + 444) == 22)
                        *(_BYTE*)(a1 + 248) = 2;
                }
                if (*(_DWORD*)(a1 + 444) == 14)
                    *(_DWORD*)(a1 + 424) = *(_DWORD*)(a1 + 424) == 0;
                if (*(_DWORD*)(a1 + 444) == 26)
                {
                    *(_DWORD*)(a1 + 424) = *(_DWORD*)(a1 + 424) == 0;
                    *(_DWORD*)(a1 + 432) = 4;
                }
                return;
            case 0xA7:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_BYTE*)(a1 + 212) = 0;
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    *(_BYTE*)(a1 + 248) = 1;
                    *(_BYTE*)(a1 + 257) = 1;
                    v154 = 6 * (sub_41CA5F(a1, 0) - 80);
                    v339 = *(unsigned __int16*)(a1 + 496) + sub_41CA5F(a1, 1) / 3 + v154;
                    if (v339 <= 0)
                        v339 = 1;
                    sub_41F169((_WORD*)a1, v339);
                    *(_BYTE*)(a1 + 213) = -1;
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A68, -1, 100, 100, 0);
                    if (*(_DWORD*)(a1 + 308))
                    {
                        v337 = 50 * ((*(_DWORD*)(a1 + 424) == 0) - *(_DWORD*)(a1 + 424)) + sub_426090(*(_DWORD**)(a1 + 308));
                        v336 = sub_4260B0(*(_DWORD**)(a1 + 308));
                        *(_DWORD*)(a1 + 372) = v337 - *(_DWORD*)(a1 + 328);
                        *(_DWORD*)(a1 + 376) = v336 - *(_DWORD*)(a1 + 332);
                        *(_DWORD*)(a1 + 340) = 0;
                        *(_DWORD*)(a1 + 344) = 0;
                        v338 = -100 * sub_446497((int*)unk_4B9B10, v337 / 100, v336 / 100);
                        if (v338 >= *(_DWORD*)(a1 + 336))
                        {
                            if (v338 > *(_DWORD*)(a1 + 336))
                                *(_DWORD*)(a1 + 348) = v338 - *(_DWORD*)(a1 + 336);
                        }
                        else
                        {
                            *(_DWORD*)(a1 + 348) = 0;
                            *(_DWORD*)(a1 + 336) = v338;
                        }
                    }
                }
                else if (*(_DWORD*)(a1 + 444) == 2)
                {
                    if (*(int*)(a1 + 372) <= 0)
                        v247 = (*(_DWORD*)(a1 + 372) >= 0) - 1;
                    else
                        v247 = 1;
                    *(_DWORD*)(a1 + 372) = 100 * v247;
                    *(_DWORD*)(a1 + 376) = 0;
                    *(_DWORD*)(a1 + 348) = 0;
                }
                if (*(int*)(a1 + 444) >= 4)
                {
                    if (*(int*)(a1 + 444) >= 26)
                    {
                        *(_BYTE*)(a1 + 257) = 2;
                        *(_WORD*)(a1 + 204) = 82;
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 117;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 168;
                }
                if (*(_DWORD*)(a1 + 444) == 30)
                    *(_DWORD*)(a1 + 432) = 4;
                return;
            case 0xA8:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_BYTE*)(a1 + 212) = 0;
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    *(_BYTE*)(a1 + 257) = 1;
                    *(_BYTE*)(a1 + 248) = -1;
                    sub_41F169((_WORD*)a1, 1);
                    *(_BYTE*)(a1 + 213) = -1;
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A6C, -1, 100, 100, 0);
                }
                *(_WORD*)(a1 + 204) = (*(_DWORD*)(a1 + 444) - 1) / 4 % 3 + 118;
                if (*(_DWORD*)(a1 + 444) == 12)
                    *(_DWORD*)(a1 + 424) = *(_DWORD*)(a1 + 424) == 0;
                if (!((*(_DWORD*)(a1 + 444) - 1) % 4))
                {
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                }
                if (*(_DWORD*)(a1 + 444) == 24)
                {
                    *(_DWORD*)(a1 + 424) = *(_DWORD*)(a1 + 424) == 0;
                    *(_DWORD*)(a1 + 432) = 77;
                }
                return;
            case 0x5D:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_BYTE*)(a1 + 212) = 0;
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    *(_DWORD*)(a1 + 372) = 0;
                    *(_DWORD*)(a1 + 376) = 0;
                    *(_DWORD*)(a1 + 340) = 0;
                    *(_DWORD*)(a1 + 344) = 0;
                    *(_DWORD*)(a1 + 352) = 0;
                    *(_DWORD*)(a1 + 356) = 0;
                    *(_DWORD*)(a1 + 436) = 0;
                    v335 = 0;
                    if (*(_BYTE*)(a1 + 195))
                    {
                        switch (*(_BYTE*)(a1 + 195))
                        {
                        case 1:
                            v335 = 25 * sub_4175B4(a1, 1) / 200;
                            break;
                        case 2:
                            v335 = 20 * sub_4175B4(a1, 1) / 200;
                            break;
                        case 3:
                            v335 = 35 * sub_4175B4(a1, 1) / 200;
                            break;
                        }
                    }
                    else
                    {
                        v335 = 30 * sub_4175B4(a1, 1) / 200;
                    }
                    v335 = sub_41CB3B(a1, 1) / 3 + 10;
                    if (*(_BYTE*)(a1 + 258) == 1)
                    {
                        v335 = 12 * v335 / 10;
                    }
                    else if (*(_BYTE*)(a1 + 258) == 2)
                    {
                        v335 /= 2;
                    }
                    if (!v335)
                        v335 = 1;
                    if (*(_DWORD*)(a1 + 304))
                        sub_41EF8A(*(_WORD**)(a1 + 304), v335);
                }
                if (*(int*)(a1 + 444) > 1
                    && *(_DWORD*)(a1 + 304)
                    && Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) != (struct Concurrency::ISchedulerProxy*)111)
                {
                    *(_DWORD*)(a1 + 304) = 0;
                }
                if (*(int*)(a1 + 444) >= 6)
                {
                    if (*(int*)(a1 + 444) >= 12)
                    {
                        if (*(int*)(a1 + 444) >= 16)
                        {
                            if (*(int*)(a1 + 444) >= 28)
                            {
                                if (*(int*)(a1 + 444) >= 36)
                                {
                                    if (*(int*)(a1 + 444) >= 40)
                                    {
                                        if (*(int*)(a1 + 444) >= 44)
                                        {
                                            if (*(int*)(a1 + 444) >= 48)
                                                *(_WORD*)(a1 + 204) = 25;
                                            else
                                                *(_WORD*)(a1 + 204) = 20;
                                        }
                                        else
                                        {
                                            *(_WORD*)(a1 + 204) = 23;
                                        }
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 122;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 121;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 25;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 6;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 121;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 31;
                }
                if (*(_DWORD*)(a1 + 444) == 16)
                {
                    *(_DWORD*)(a1 + 348) = -700;
                    *(_DWORD*)(a1 + 360) = 30;
                    *(_DWORD*)(a1 + 392) = 1;
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A04, -1, 100, 100, 0);
                }
                else if (*(_DWORD*)(a1 + 444) == 36)
                {
                    *(_DWORD*)(a1 + 436) = 1;
                    *(_DWORD*)(a1 + 304) = 0;
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A70, -1, 100, 100, 0);
                }
                if (*(int*)(a1 + 444) < 36 && !*(_DWORD*)(a1 + 304))
                {
                    if (*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 432) = 50;
                    else
                        *(_DWORD*)(a1 + 432) = 4;
                }
                return;
            case 0x6F:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_BYTE*)(a1 + 212) = 0;
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    *(_DWORD*)(a1 + 372) = 0;
                    *(_DWORD*)(a1 + 376) = 0;
                    *(_DWORD*)(a1 + 340) = 0;
                    *(_DWORD*)(a1 + 344) = 0;
                    *(_DWORD*)(a1 + 352) = 0;
                    *(_DWORD*)(a1 + 356) = 0;
                    *(_DWORD*)(a1 + 392) = 1;
                    sub_423CF2((_BYTE*)a1, 1, -16, 1, 0, 0, 0);
                }
                if (*(int*)(a1 + 444) >= 6)
                {
                    *(_WORD*)(a1 + 204) = (*(_DWORD*)(a1 + 444) - 6) / 4 % 4 + 20;
                    if (*(_DWORD*)(a1 + 304))
                    {
                        if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) == (struct Concurrency::ISchedulerProxy*)93
                            && sub_426010(*(_DWORD**)(a1 + 304)) == 1)
                        {
                            *(_DWORD*)(a1 + 432) = 169;
                            sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                        }
                        if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) != (struct Concurrency::ISchedulerProxy*)93)
                        {
                            sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                            *(_DWORD*)(a1 + 304) = 0;
                        }
                    }
                    else
                    {
                        sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 16;
                }
                if (*(_DWORD*)(a1 + 444) == 6)
                {
                    *(_DWORD*)(a1 + 348) = -700;
                    *(_DWORD*)(a1 + 360) = 30;
                    *(_DWORD*)(a1 + 392) = 1;
                }
                return;
            case 0xA9:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_BYTE*)(a1 + 212) = 0;
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    *(_BYTE*)(a1 + 248) = 1;
                    *(_BYTE*)(a1 + 257) = 1;
                    *(_BYTE*)(a1 + 253) = 1;
                    *(_BYTE*)(a1 + 213) = 5;
                    sub_41F169((_WORD*)a1, *(unsigned __int16*)(a1 + 242));
                    *(_BYTE*)(a1 + 254) = 1;
                    *(_BYTE*)(a1 + 250) = 10;
                    *(_DWORD*)(a1 + 424) = 0;
                    *(_DWORD*)(a1 + 372) = -700;
                    *(_DWORD*)(a1 + 376) = 0;
                    *(_DWORD*)(a1 + 340) = 0;
                    *(_DWORD*)(a1 + 344) = 0;
                    *(_DWORD*)(a1 + 348) = 700;
                    *(_DWORD*)(a1 + 352) = 0;
                    *(_DWORD*)(a1 + 356) = 0;
                    *(_DWORD*)(a1 + 360) = 0;
                    *(_DWORD*)(a1 + 436) = 0;
                    *(_DWORD*)(a1 + 392) = 1;
                    *(_DWORD*)(a1 + 316) = *(_DWORD*)(a1 + 304);
                    if (*(_DWORD*)(a1 + 304))
                    {
                        *(_BYTE*)(a1 + (unsigned __int8)sub_425EF0(*(_BYTE**)(a1 + 304)) + 453) = -1;
                        if (sub_425D70(*(_DWORD**)(a1 + 304))
                            && Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) == (struct Concurrency::ISchedulerProxy*)93
                            || !sub_425D70(*(_DWORD**)(a1 + 304))
                            && Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) == (struct Concurrency::ISchedulerProxy*)108)
                        {
                            *(_DWORD*)(a1 + 372) = -*(_DWORD*)(a1 + 372);
                            *(_DWORD*)(a1 + 424) = 1;
                        }
                        *(_DWORD*)(a1 + 304) = 0;
                    }
                }
                if (*(_DWORD*)(a1 + 436))
                {
                    if (*(_DWORD*)(a1 + 436) == 1)
                        *(_WORD*)(a1 + 204) = 17;
                }
                else
                {
                    if (!(*(_DWORD*)(a1 + 444) % 3))
                        ++* (_WORD*)(a1 + 242);
                    sub_41F169((_WORD*)a1, *(unsigned __int16*)(a1 + 240) + 1);
                    *(_WORD*)(a1 + 204) = 123;
                }
                return;
            case 0xAA:
                LOBYTE(v334) = sub_425CB0(*(_BYTE**)(a1 + 480));
                *(_BYTE*)(a1 + 212) = 0;
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    v333 = sub_41F380(a1, 1);
                    if (*(_BYTE*)(a1 + 237))
                    {
                        v155 = sub_41F380(a1, 1);
                        v333 += v155 * sub_41CA5F(a1, 1) / 250;
                    }
                    if (*(_DWORD*)(a1 + 392))
                    {
                        v156 = sub_41F380(a1, 1);
                        v333 += v156 * sub_41D067(a1, 1) / 250;
                    }
                    v157 = sub_43E620((short*)*(_DWORD*)(a1 + 480));
                    sub_41F169((_WORD*)a1, (v333 * v157 / 100 + 50) / 2);
                    *(_BYTE*)(a1 + 248) = -1;
                    *(_BYTE*)(a1 + 257) = 1;
                    *(_BYTE*)(a1 + 213) = -1;
                    if (!*(_DWORD*)(a1 + 392) || *(unsigned __int8*)(a1 + 238) <= 1u && sub_41BA53(a1, 0x86u, 0))
                        *(_DWORD*)(a1 + 400) = 1;
                }
                if (*(_DWORD*)(a1 + 444) == 5)
                    *(_DWORD*)(a1 + 400) = 0;
                v332 = (*(_DWORD*)(a1 + 444) - 1) / 3 % 2;
                if (sub_494AA9(*(_BYTE**)(a1 + 480), 0))
                    *(_WORD*)(a1 + 204) = v332 + 140;
                else
                    *(_WORD*)(a1 + 204) = v332 + 130;
                if (*(int*)(a1 + 444) >= 18)
                {
                    *(_BYTE*)(a1 + 257) = 2;
                    if (sub_494AA9(*(_BYTE**)(a1 + 480), 0))
                        *(_WORD*)(a1 + 204) = 142;
                    else
                        *(_WORD*)(a1 + 204) = 132;
                }
                if (*(int*)(a1 + 444) < 18 && !((*(_DWORD*)(a1 + 444) - 1) % 6))
                {
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    if ((unsigned __int8)v334 == 5)
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A88, -1, 100, 100, 0);
                    else
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                }
                if (*(int*)(a1 + 444) >= 24)
                {
                    if (*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 432) = 50;
                    else
                        *(_DWORD*)(a1 + 432) = 3;
                }
                return;
            case 0xAE:
                *(_BYTE*)(a1 + 212) = 0;
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    v330 = sub_41F380(a1, 1);
                    if (*(_BYTE*)(a1 + 237))
                    {
                        v158 = sub_41F380(a1, 1);
                        v330 += v158 * sub_41CA5F(a1, 1) / 250;
                    }
                    if (*(_DWORD*)(a1 + 392))
                    {
                        v159 = sub_41F380(a1, 1);
                        v330 += v159 * sub_41D067(a1, 1) / 250;
                    }
                    v160 = sub_43E620((short*)*(_DWORD*)(a1 + 480));
                    sub_41F169((_WORD*)a1, v330 * v160 / 100 + 50);
                    *(_BYTE*)(a1 + 248) = 0;
                    *(_BYTE*)(a1 + 257) = 1;
                    *(_BYTE*)(a1 + 213) = -1;
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A90, -1, 100, 100, 0);
                    if (!*(_DWORD*)(a1 + 392) || *(unsigned __int8*)(a1 + 238) <= 1u && sub_41BA53(a1, 0x86u, 0))
                        *(_DWORD*)(a1 + 400) = 1;
                }
                if (*(_DWORD*)(a1 + 444) == 5)
                    *(_DWORD*)(a1 + 400) = 0;
                v331 = (*(_DWORD*)(a1 + 444) - 1) / 2 % 6;
                switch (v331)
                {
                case 0:
                case 3:
                    *(_WORD*)(a1 + 204) = 145;
                    break;
                case 1:
                case 2:
                    *(_WORD*)(a1 + 204) = 146;
                    break;
                default:
                    *(_WORD*)(a1 + 204) = 147;
                    break;
                }
                if (*(int*)(a1 + 444) > 1 && !((*(_DWORD*)(a1 + 444) + 1) % 6))
                    *(_DWORD*)(a1 + 424) = *(_DWORD*)(a1 + 424) == 0;
                if (*(int*)(a1 + 444) >= 24)
                {
                    if (*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 432) = 50;
                    else
                        *(_DWORD*)(a1 + 432) = 3;
                }
                return;
            case 0xAF:
                *(_BYTE*)(a1 + 212) = 0;
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    v329 = sub_41F380(a1, 1);
                    if (*(_BYTE*)(a1 + 237))
                    {
                        v161 = sub_41F380(a1, 1);
                        v329 += v161 * sub_41CA5F(a1, 1) / 250;
                    }
                    if (*(_DWORD*)(a1 + 392))
                    {
                        v162 = sub_41F380(a1, 1);
                        v329 += v162 * sub_41D067(a1, 1) / 250;
                    }
                    v163 = sub_43E620((short*)*(_DWORD*)(a1 + 480));
                    sub_41F169((_WORD*)a1, (v329 * v163 / 100 + 50) / 3);
                    *(_BYTE*)(a1 + 248) = 0;
                    *(_BYTE*)(a1 + 257) = 1;
                    *(_BYTE*)(a1 + 213) = -1;
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A94, -1, 100, 100, 0);
                    if (!*(_DWORD*)(a1 + 392) || *(unsigned __int8*)(a1 + 238) <= 1u && sub_41BA53(a1, 0x86u, 0))
                        *(_DWORD*)(a1 + 400) = 1;
                }
                if (*(_DWORD*)(a1 + 444) == 5)
                    *(_DWORD*)(a1 + 400) = 0;
                *(_WORD*)(a1 + 204) = (*(_DWORD*)(a1 + 444) - 1) / 2 % 6 + 148;
                if (!((*(_DWORD*)(a1 + 444) - 1) % 5))
                {
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                }
                if (*(int*)(a1 + 444) >= 24)
                {
                    if (*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 432) = 50;
                    else
                        *(_DWORD*)(a1 + 432) = 3;
                }
                return;
            case 0x5E:
                *(_BYTE*)(a1 + 212) = 0;
                *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) % 2 + 154;
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    sub_464C06((char*)unk_4B9B10, 0, a1);
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A98, -1, 100, 100, 0);
                }
                return;
            case 0xB0:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    sub_464C06((char*)unk_4B9B10, 1, a1);
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A9C, -1, 100, 100, 0);
                }
                *(_BYTE*)(a1 + 212) = 0;
                if (*(int*)(a1 + 444) >= 5)
                {
                    if (*(int*)(a1 + 444) >= 9)
                    {
                        if (*(int*)(a1 + 444) >= 13)
                            *(_WORD*)(a1 + 204) = 134;
                        else
                            *(_WORD*)(a1 + 204) = 133;
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 130;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 129;
                }
                if (*(int*)(a1 + 444) > 21)
                {
                    if (*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 432) = 50;
                    else
                        *(_DWORD*)(a1 + 432) = 3;
                }
                return;
            case 0xB1:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_BYTE*)(a1 + 212) = 0;
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    *(_BYTE*)(a1 + 257) = 1;
                    *(_BYTE*)(a1 + 248) = -1;
                    v327 = sub_417924(a1, 3, 1);
                    if (*(_BYTE*)(a1 + 237))
                    {
                        v164 = sub_417924(a1, 3, 1);
                        v327 += v164 * sub_41CA5F(a1, 1) / 300;
                    }
                    if (*(_DWORD*)(a1 + 392))
                    {
                        v165 = sub_417924(a1, 3, 1);
                        v327 += v165 * sub_41D067(a1, 1) / 300;
                    }
                    sub_41F169((_WORD*)a1, v327);
                    *(_BYTE*)(a1 + 213) = -1;
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9AA0, -1, 100, 100, 0);
                }
                v328 = (*(_DWORD*)(a1 + 444) - 1) / 2 % 6;
                if (v328 >= 3)
                    *(_WORD*)(a1 + 204) = 161 - (v328 - 3);
                else
                    *(_WORD*)(a1 + 204) = v328 + 159;
                if (!((*(_DWORD*)(a1 + 444) - 1) % 6))
                    *(_DWORD*)(a1 + 424) = *(_DWORD*)(a1 + 424) == 0;
                if (!((*(_DWORD*)(a1 + 444) - 1) % 6))
                {
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                }
                if (*(_DWORD*)(a1 + 444) == 36)
                {
                    if (*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 432) = 50;
                    else
                        *(_DWORD*)(a1 + 432) = 3;
                }
                return;
            case 0xB2:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_DWORD*)(a1 + 304) = 0;
                    *(_BYTE*)(a1 + 212) = 0;
                    *(_BYTE*)(a1 + 257) = 1;
                    *(_BYTE*)(a1 + 253) = 1;
                    *(_BYTE*)(a1 + 248) = -1;
                    *(_BYTE*)(a1 + 213) = -1;
                }
                if (!*(_DWORD*)(a1 + 392))
                    *(_DWORD*)(a1 + 340) = 4 * (*(_DWORD*)(a1 + 424) - (*(_DWORD*)(a1 + 424) == 0));
                *(_WORD*)(a1 + 204) = (*(_DWORD*)(a1 + 444) - 1) / 4 % 2 + 162;
                if (*(int*)(a1 + 444) > 8 && !(*(_DWORD*)(a1 + 444) % 8))
                {
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                }
                return;
            case 0xB3:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_BYTE*)(a1 + 212) = 0;
                    *(_BYTE*)(a1 + 257) = 1;
                    *(_BYTE*)(a1 + 248) = -1;
                    v166 = sub_417924(a1, 3, 1);
                    sub_41F169((_WORD*)a1, v166);
                    *(_BYTE*)(a1 + 213) = -1;
                }
                if (!*(_DWORD*)(a1 + 392))
                    *(_DWORD*)(a1 + 400) = 1;
                *(_DWORD*)(a1 + 340) = 4 * (*(_DWORD*)(a1 + 424) - (*(_DWORD*)(a1 + 424) == 0));
                if (*(_DWORD*)(a1 + 372))
                {
                    v246 = *(int*)(a1 + 372) <= 0 ? (*(_DWORD*)(a1 + 372) >= 0) - 1 : 1;
                    v245 = *(int*)(a1 + 340) <= 0 ? (*(_DWORD*)(a1 + 340) >= 0) - 1 : 1;
                    if (v246 != v245)
                        *(_DWORD*)(a1 + 372) = 9 * *(_DWORD*)(a1 + 372) / 10;
                }
                *(_WORD*)(a1 + 204) = (*(_DWORD*)(a1 + 444) - 1) / 4 % 2 + 164;
                if (*(int*)(a1 + 444) > 8 && !(*(_DWORD*)(a1 + 444) % 8))
                {
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                }
                return;
            case 0x5F:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    if (*(_DWORD*)(a1 + 524))
                        *(_DWORD*)(a1 + 524) = 0;
                    else
                        *(_DWORD*)(a1 + 524) = sub_46588C((char*)unk_4B9B10, (_BYTE*)a1);
                    if (*(_DWORD*)(a1 + 524))
                    {
                        if (sub_4264F0(*(_BYTE**)(a1 + 524)) == 4)
                        {
                            LOWORD(v326) = sub_43E600(*(_WORD**)(a1 + 524));
                            if (Concurrency::details::SchedulerProxy::GetNumBorrowedCores(*(Concurrency::details::SchedulerProxy**)(a1 + 524)))
                            {
                                v325 = sub_426590(unk_4B9B10, (unsigned __int16)v326);
                                if (v325)
                                {
                                    *(_WORD*)(a1 + 190) = sub_4266F0((short*)v325);
                                    *(_BYTE*)(a1 + 192) = sub_426570((char*)v325);
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 190) = sub_475CB0((_WORD*)(36 * (unsigned __int16)v326 + dword_4B92E0));
                                *(_BYTE*)(a1 + 192) = sub_4016F0((_BYTE*)(36 * (unsigned __int16)v326 + dword_4B92E0));
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 190) = sub_420F74(*(_DWORD*)(a1 + 524));
                            *(_BYTE*)(a1 + 192) = sub_422BE5(*(_DWORD*)(a1 + 524));
                        }
                        *(_WORD*)(a1 + 498) = sub_43E5A0((short*)*(_DWORD*)(a1 + 524));
                        *(_DWORD*)(a1 + 200) = sub_43E5C0((int*)*(_DWORD*)(a1 + 524));
                        *(_WORD*)(a1 + 502) = sub_41CB3B(*(_DWORD*)(a1 + 524), 1);
                        *(_WORD*)(a1 + 504) = sub_41CCEA(*(_DWORD*)(a1 + 524), 1);
                        *(_WORD*)(a1 + 506) = sub_4175B4(*(_DWORD*)(a1 + 524), 1);
                        *(_WORD*)(a1 + 508) = sub_41F380(*(_DWORD*)(a1 + 524), 1);
                        *(_WORD*)(a1 + 510) = sub_41F52F(*(_DWORD*)(a1 + 524), 1);
                        *(_WORD*)(a1 + 512) = sub_417924(*(_DWORD*)(a1 + 524), 3, 1);
                        *(_WORD*)(a1 + 514) = sub_41CA5F(*(_DWORD*)(a1 + 524), 0);
                        *(_WORD*)(a1 + 516) = sub_41D067(*(_DWORD*)(a1 + 524), 0);
                        *(_WORD*)(a1 + 518) = sub_423AC3(*(_DWORD*)(a1 + 524), 0);
                    }
                    else
                    {
                        *(_WORD*)(a1 + 190) = *(_WORD*)(a1 + 528);
                        *(_BYTE*)(a1 + 192) = *(_BYTE*)(a1 + 536);
                        *(_WORD*)(a1 + 498) = *(_WORD*)(a1 + 530);
                        *(_DWORD*)(a1 + 200) = *(_DWORD*)(a1 + 532);
                        *(_WORD*)(a1 + 502) = *(_WORD*)(a1 + 538);
                        *(_WORD*)(a1 + 504) = *(_WORD*)(a1 + 540);
                        *(_WORD*)(a1 + 506) = *(_WORD*)(a1 + 542);
                        *(_WORD*)(a1 + 508) = *(_WORD*)(a1 + 544);
                        *(_WORD*)(a1 + 510) = *(_WORD*)(a1 + 546);
                        *(_WORD*)(a1 + 512) = *(_WORD*)(a1 + 548);
                        *(_WORD*)(a1 + 514) = *(_WORD*)(a1 + 550);
                        *(_WORD*)(a1 + 516) = *(_WORD*)(a1 + 552);
                        *(_WORD*)(a1 + 518) = *(_WORD*)(a1 + 554);
                    }
                    sub_41F712((_DWORD*)(a1 + 8));
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9AA4, -1, 100, 100, 0);
                }
                if (*(int*)(a1 + 444) >= 8)
                {
                    if (*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 432) = 50;
                    else
                        *(_DWORD*)(a1 + 432) = 3;
                }
                return;
            case 0x60:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    sub_442863(v321);
                    v321[0] = 8;
                    v321[1] = -6;
                    v324 = a1;
                    v323 = *(_DWORD*)(a1 + 424);
                    v322 = 17;
                    sub_4561A5((char*)unk_4B9B10, (int)v321);
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                }
                if (*(_DWORD*)(a1 + 444) == 15)
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9AA8, -1, 100, 100, 0);
                if (*(_DWORD*)(a1 + 444) == 60)
                {
                    v167 = sub_41D61F(a1);
                    sub_41F169((_WORD*)a1, 7 * v167 / 20);
                    *(_BYTE*)(a1 + 248) = 2;
                    *(_BYTE*)(a1 + 249) = 1;
                    *(_BYTE*)(a1 + 253) = 1;
                    *(_BYTE*)(a1 + 255) = 0;
                    *(_BYTE*)(a1 + 254) = 2;
                }
                if (*(int*)(a1 + 444) >= 60 && *(int*)(a1 + 444) <= 61
                    || *(int*)(a1 + 444) >= 62 && *(int*)(a1 + 444) < 65 && *(_DWORD*)(a1 + 444) % 2 == 1)
                {
                    sub_465986((char*)unk_4B9B10);
                }
                if (*(int*)(a1 + 444) >= 75)
                    *(_DWORD*)(a1 + 432) = 3;
                return;
            case 0x61:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_BYTE*)(a1 + 248) = 0;
                    *(_BYTE*)(a1 + 253) = 0;
                    *(_BYTE*)(a1 + 213) = 5;
                    *(_BYTE*)(a1 + 257) = 0;
                    *(_BYTE*)(a1 + 249) = 0;
                    *(_WORD*)(a1 + 244) = 0;
                    *(_BYTE*)(a1 + 255) = 0;
                    *(_BYTE*)(a1 + 256) = 0;
                    *(_DWORD*)(a1 + 264) = 112;
                    if (*(_DWORD*)(a1 + 392))
                    {
                        v168 = sub_41CB3B(a1, 1);
                        v169 = sub_41CB3B(a1, 1);
                        v170 = sub_41CA5F(a1, 1) * v169;
                        v171 = sub_41D067(a1, 1);
                        sub_41F169((_WORD*)a1, v170 * v171 / 10000 + v168);
                        *(_BYTE*)(a1 + 248) = 2;
                    }
                    else
                    {
                        v172 = sub_41CB3B(a1, 1);
                        v173 = sub_41CB3B(a1, 1);
                        v174 = sub_41CA5F(a1, 1);
                        sub_41F169((_WORD*)a1, v173 * v174 / 200 + v172);
                        *(_BYTE*)(a1 + 248) = 3;
                    }
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    if (!*(_DWORD*)(a1 + 392) || *(unsigned __int8*)(a1 + 238) <= 1u && sub_41BA53(a1, 0x86u, 0))
                        *(_DWORD*)(a1 + 400) = 1;
                }
                if (*(_DWORD*)(a1 + 444) == 5)
                    *(_DWORD*)(a1 + 400) = 0;
                *(_BYTE*)(a1 + 212) = 1;
                if (*(_BYTE*)(a1 + 195))
                {
                    switch (*(_BYTE*)(a1 + 195))
                    {
                    case 1:
                        if (*(int*)(a1 + 444) >= 4)
                        {
                            *(_WORD*)(a1 + 204) = *(int*)(a1 + 444) >= 8 && *(int*)(a1 + 444) < 12;
                        }
                        else
                        {
                            *(_BYTE*)(a1 + 212) = 0;
                            *(_WORD*)(a1 + 204) = 4;
                        }
                        if (*(_DWORD*)(a1 + 444) == 7)
                            sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                        if (*(int*)(a1 + 444) > 16 && !*(_DWORD*)(a1 + 392))
                            *(_DWORD*)(a1 + 432) = 4;
                        break;
                    case 2:
                        if (*(int*)(a1 + 444) >= 4)
                        {
                            if (*(int*)(a1 + 444) >= 8)
                            {
                                if (*(int*)(a1 + 444) >= 12)
                                    *(_WORD*)(a1 + 204) = *(int*)(a1 + 444) < 16;
                                else
                                    *(_WORD*)(a1 + 204) = 2;
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 1;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 0;
                        }
                        if (*(_DWORD*)(a1 + 444) == 7)
                            sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                        if (*(int*)(a1 + 444) >= 20 && !*(_DWORD*)(a1 + 392))
                            *(_DWORD*)(a1 + 432) = 4;
                        break;
                    case 3:
                        if (*(int*)(a1 + 444) >= 4)
                        {
                            if (*(int*)(a1 + 444) >= 8)
                            {
                                if (*(int*)(a1 + 444) >= 12)
                                    *(_WORD*)(a1 + 204) = *(int*)(a1 + 444) < 16;
                                else
                                    *(_WORD*)(a1 + 204) = 2;
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 1;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 0;
                        }
                        if (*(_DWORD*)(a1 + 444) == 7)
                            sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                        if (*(int*)(a1 + 444) >= 20 && !*(_DWORD*)(a1 + 392))
                            *(_DWORD*)(a1 + 432) = 4;
                        break;
                    case 4:
                        if (*(int*)(a1 + 444) >= 4)
                        {
                            if (*(int*)(a1 + 444) >= 8)
                            {
                                if (*(int*)(a1 + 444) >= 12)
                                    *(_WORD*)(a1 + 204) = 3;
                                else
                                    *(_WORD*)(a1 + 204) = 2;
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 1;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 0;
                        }
                        if (*(_DWORD*)(a1 + 444) == 2)
                            sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                        if (*(int*)(a1 + 444) >= 16 && !*(_DWORD*)(a1 + 392))
                            *(_DWORD*)(a1 + 432) = 4;
                        break;
                    }
                }
                else
                {
                    if (*(int*)(a1 + 444) >= 4)
                    {
                        if (*(int*)(a1 + 444) >= 8)
                        {
                            if (*(int*)(a1 + 444) >= 12)
                                *(_WORD*)(a1 + 204) = 2;
                            else
                                *(_WORD*)(a1 + 204) = 3;
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 2;
                        }
                    }
                    else
                    {
                        *(_BYTE*)(a1 + 212) = 0;
                        *(_WORD*)(a1 + 204) = 4;
                    }
                    if (*(_DWORD*)(a1 + 444) == 7)
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                    if (*(int*)(a1 + 444) > 16 && !*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 432) = 4;
                }
                return;
            case 0x62:
                if (*(_DWORD*)(a1 + 444) == 1)
                    *(_DWORD*)(a1 + 424) = *(_DWORD*)(a1 + 424) == 0;
                *(_BYTE*)(a1 + 212) = 0;
                if (*(int*)(a1 + 444) >= 4)
                {
                    if (*(int*)(a1 + 444) >= 8)
                    {
                        if (*(int*)(a1 + 444) >= 12)
                            *(_WORD*)(a1 + 204) = 134;
                        else
                            *(_WORD*)(a1 + 204) = 133;
                    }
                    else
                    {
                        *(_DWORD*)(a1 + 304) = 0;
                        *(_WORD*)(a1 + 204) = 130;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 129;
                }
                if (*(int*)(a1 + 444) > 24 && !*(_DWORD*)(a1 + 392))
                    *(_DWORD*)(a1 + 432) = 4;
                return;
            case 0x70:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_DWORD*)(a1 + 372) = 0;
                    *(_DWORD*)(a1 + 376) = 0;
                    *(_DWORD*)(a1 + 340) = 0;
                    *(_DWORD*)(a1 + 344) = 0;
                    *(_DWORD*)(a1 + 348) = 0;
                    *(_DWORD*)(a1 + 352) = 0;
                    *(_DWORD*)(a1 + 356) = 0;
                    *(_DWORD*)(a1 + 360) = 0;
                    if (*(_BYTE*)(a1 + 469))
                        --* (_BYTE*)(a1 + 469);
                }
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_DWORD*)(a1 + 392) = 1;
                    *(_DWORD*)(a1 + 436) = 2 * (*(_DWORD*)(a1 + 436) == 0) - 1;
                    *(_DWORD*)(a1 + 372) = 400 * *(_DWORD*)(a1 + 436);
                    *(_DWORD*)(a1 + 436) = 0;
                    *(_DWORD*)(a1 + 348) = -550;
                    *(_DWORD*)(a1 + 360) = 30;
                    *(_BYTE*)(a1 + 248) = 2;
                    *(_BYTE*)(a1 + 250) = 10;
                    *(_BYTE*)(a1 + 253) = 1;
                    *(_BYTE*)(a1 + 213) = -1;
                    *(_BYTE*)(a1 + 257) = 0;
                    *(_BYTE*)(a1 + 249) = 0;
                    *(_WORD*)(a1 + 244) = 0;
                    *(_BYTE*)(a1 + 254) = 1;
                    *(_BYTE*)(a1 + 255) = 0;
                    *(_BYTE*)(a1 + 177) = 1;
                    sub_41F169((_WORD*)a1, *(unsigned __int16*)(a1 + 242));
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    *(_BYTE*)(a1 + *(_DWORD*)(a1 + 440) + 453) = -1;
                    *(_DWORD*)(a1 + 316) = *(_DWORD*)(a1 + 304);
                }
                else if (*(_DWORD*)(a1 + 444) == 8)
                {
                    *(_DWORD*)(a1 + 304) = 0;
                    if (*(int*)(a1 + 372) <= 0)
                        v244 = (*(_DWORD*)(a1 + 372) >= 0) - 1;
                    else
                        v244 = 1;
                    *(_DWORD*)(a1 + 372) = 700 * v244;
                    *(_DWORD*)(a1 + 348) = -100;
                    *(_DWORD*)(a1 + 360) = 30;
                }
                if (*(int*)(a1 + 444) > 1
                    && *(int*)(a1 + 444) < 8
                    && (!*(_DWORD*)(a1 + 304)
                        || Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) != (struct Concurrency::ISchedulerProxy*)98))
                {
                    *(_BYTE*)(a1 + 177) = 0;
                    *(_BYTE*)(a1 + 469) = 1;
                    *(_DWORD*)(a1 + 372) = 0;
                    *(_DWORD*)(a1 + 340) = 0;
                    *(_DWORD*)(a1 + 348) = 0;
                    *(_DWORD*)(a1 + 360) = 30;
                    *(_DWORD*)(a1 + 432) = 76;
                }
                *(_BYTE*)(a1 + 212) = 0;
                if (*(_DWORD*)(a1 + 436))
                {
                    *(_BYTE*)(a1 + 177) = 0;
                    if ((*(int*)(a1 + 372) <= 0 || !*(_DWORD*)(a1 + 424))
                        && (*(int*)(a1 + 372) >= 0 || *(_DWORD*)(a1 + 424)))
                    {
                        *(_WORD*)(a1 + 204) = 17;
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 28;
                    }
                }
                else if (*(int*)(a1 + 444) >= 3)
                {
                    if (*(int*)(a1 + 444) >= 6)
                    {
                        *(_WORD*)(a1 + 204) = 49;
                    }
                    else if ((*(int*)(a1 + 372) <= 0 || !*(_DWORD*)(a1 + 424))
                        && (*(int*)(a1 + 372) >= 0 || *(_DWORD*)(a1 + 424)))
                    {
                        *(_WORD*)(a1 + 204) = 17;
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 28;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 13;
                }
                return;
            case 0x63:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_DWORD*)(a1 + 392) = 1;
                    *(_DWORD*)(a1 + 372) = 0;
                    *(_DWORD*)(a1 + 376) = 0;
                    *(_DWORD*)(a1 + 340) = 0;
                    *(_DWORD*)(a1 + 344) = 0;
                    *(_DWORD*)(a1 + 348) = 0;
                    *(_DWORD*)(a1 + 352) = 0;
                    *(_DWORD*)(a1 + 356) = 0;
                    *(_DWORD*)(a1 + 360) = 0;
                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A1C, -1, 100, 100, 0);
                }
                *(_BYTE*)(a1 + 212) = 0;
                if (*(_BYTE*)(a1 + 188) == 2 || *(_BYTE*)(a1 + 188) == 3)
                {
                    *(_BYTE*)(a1 + 212) = 1;
                    if (*(int*)(a1 + 444) >= 6)
                    {
                        if (*(int*)(a1 + 444) >= 12)
                        {
                            if (*(int*)(a1 + 444) >= 18)
                            {
                                if (*(int*)(a1 + 444) >= 24)
                                {
                                    if (*(int*)(a1 + 444) >= 29)
                                    {
                                        if (*(int*)(a1 + 444) >= 34)
                                        {
                                            if (*(int*)(a1 + 444) >= 35)
                                            {
                                                if (*(_DWORD*)(a1 + 392))
                                                {
                                                    *(_DWORD*)(a1 + 360) = 30;
                                                    *(_WORD*)(a1 + 204) = 4;
                                                }
                                                else
                                                {
                                                    *(_DWORD*)(a1 + 432) = 13;
                                                }
                                            }
                                            else
                                            {
                                                *(_WORD*)(a1 + 204) = 28;
                                            }
                                        }
                                        else
                                        {
                                            *(_WORD*)(a1 + 204) = 31;
                                        }
                                    }
                                    else
                                    {
                                        *(_DWORD*)(a1 + 372) = 50 * (*(_DWORD*)(a1 + 424) - (*(_DWORD*)(a1 + 424) == 0));
                                        *(_DWORD*)(a1 + 376) = 0;
                                        *(_DWORD*)(a1 + 348) = 0;
                                        *(_WORD*)(a1 + 204) = 79;
                                    }
                                }
                                else
                                {
                                    v319 = -1600;
                                    v320 = -100;
                                    *(_WORD*)(a1 + 204) = 77;
                                }
                            }
                            else
                            {
                                v319 = -1200;
                                v320 = -2400;
                                *(_WORD*)(a1 + 204) = 76;
                            }
                        }
                        else
                        {
                            v319 = 0;
                            v320 = -3000;
                            *(_WORD*)(a1 + 204) = 75;
                        }
                    }
                    else
                    {
                        v319 = 1200;
                        v320 = -2400;
                        *(_WORD*)(a1 + 204) = 74;
                    }
                    if (*(int*)(a1 + 444) < 28)
                    {
                        *(_DWORD*)(a1 + 372) = 0;
                        *(_DWORD*)(a1 + 348) = 0;
                    }
                    if (*(int*)(a1 + 444) < 18
                        && *(_DWORD*)(a1 + 304)
                        && Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) == (struct Concurrency::ISchedulerProxy*)113)
                    {
                        if (*(_DWORD*)(a1 + 424))
                            v319 = -v319;
                        *(_DWORD*)(a1 + 372) = v319 + sub_426090(*(_DWORD**)(a1 + 304)) - *(_DWORD*)(a1 + 328);
                        *(_DWORD*)(a1 + 376) = sub_4260B0(*(_DWORD**)(a1 + 304)) - *(_DWORD*)(a1 + 332);
                        *(_DWORD*)(a1 + 348) = v320 + sub_4260D0(*(_DWORD**)(a1 + 304)) - *(_DWORD*)(a1 + 336);
                    }
                    else if (*(_DWORD*)(a1 + 444) == 18)
                    {
                        *(_DWORD*)(a1 + 372) = 600 * (*(_DWORD*)(a1 + 424) - (*(_DWORD*)(a1 + 424) == 0));
                        *(_DWORD*)(a1 + 348) = 1600;
                    }
                    else if (*(_DWORD*)(a1 + 444) == 28)
                    {
                        *(_DWORD*)(a1 + 304) = 0;
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A24, -1, 100, 100, 0);
                    }
                    if (*(int*)(a1 + 444) > 1
                        && *(int*)(a1 + 444) < 18
                        && (!*(_DWORD*)(a1 + 304)
                            || Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) != (struct Concurrency::ISchedulerProxy*)113))
                    {
                        *(_DWORD*)(a1 + 304) = 0;
                        *(_DWORD*)(a1 + 432) = 50;
                    }
                }
                else
                {
                    if (*(int*)(a1 + 444) >= 9)
                    {
                        if (*(int*)(a1 + 444) >= 17)
                        {
                            if (*(int*)(a1 + 444) >= 25)
                            {
                                if (*(int*)(a1 + 444) >= 33)
                                {
                                    if (*(int*)(a1 + 444) >= 37)
                                    {
                                        if (*(int*)(a1 + 444) >= 41)
                                        {
                                            if (*(int*)(a1 + 444) >= 42)
                                            {
                                                if (*(_DWORD*)(a1 + 392))
                                                {
                                                    *(_DWORD*)(a1 + 360) = 30;
                                                    *(_WORD*)(a1 + 204) = 25;
                                                }
                                                else
                                                {
                                                    *(_DWORD*)(a1 + 432) = 13;
                                                }
                                            }
                                            else
                                            {
                                                *(_WORD*)(a1 + 204) = 20;
                                            }
                                        }
                                        else
                                        {
                                            *(_WORD*)(a1 + 204) = 23;
                                        }
                                    }
                                    else
                                    {
                                        *(_DWORD*)(a1 + 372) = 50 * (*(_DWORD*)(a1 + 424) - (*(_DWORD*)(a1 + 424) == 0));
                                        *(_DWORD*)(a1 + 376) = 0;
                                        *(_DWORD*)(a1 + 348) = 0;
                                        *(_WORD*)(a1 + 204) = 122;
                                    }
                                }
                                else
                                {
                                    v319 = -1600;
                                    v320 = -100;
                                    *(_WORD*)(a1 + 204) = 184;
                                }
                            }
                            else
                            {
                                v319 = -1200;
                                v320 = -2400;
                                *(_WORD*)(a1 + 204) = 183;
                            }
                        }
                        else
                        {
                            v319 = 0;
                            v320 = -3000;
                            *(_WORD*)(a1 + 204) = 182;
                        }
                    }
                    else
                    {
                        v319 = 1200;
                        v320 = -2400;
                        *(_WORD*)(a1 + 204) = 181;
                    }
                    if (*(int*)(a1 + 444) < 36)
                    {
                        *(_DWORD*)(a1 + 372) = 0;
                        *(_DWORD*)(a1 + 348) = 0;
                    }
                    if (*(int*)(a1 + 444) < 25
                        && *(_DWORD*)(a1 + 304)
                        && Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) == (struct Concurrency::ISchedulerProxy*)113)
                    {
                        if (*(_DWORD*)(a1 + 424))
                            v319 = -v319;
                        *(_DWORD*)(a1 + 372) = v319 + sub_426090(*(_DWORD**)(a1 + 304)) - *(_DWORD*)(a1 + 328);
                        *(_DWORD*)(a1 + 376) = sub_4260B0(*(_DWORD**)(a1 + 304)) - *(_DWORD*)(a1 + 332);
                        *(_DWORD*)(a1 + 348) = v320 + sub_4260D0(*(_DWORD**)(a1 + 304)) - *(_DWORD*)(a1 + 336);
                    }
                    else if (*(_DWORD*)(a1 + 444) == 25)
                    {
                        *(_DWORD*)(a1 + 372) = 600 * (*(_DWORD*)(a1 + 424) - (*(_DWORD*)(a1 + 424) == 0));
                        *(_DWORD*)(a1 + 348) = 1600;
                    }
                    else if (*(_DWORD*)(a1 + 444) == 36)
                    {
                        *(_DWORD*)(a1 + 304) = 0;
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A24, -1, 100, 100, 0);
                    }
                    if (*(int*)(a1 + 444) > 1
                        && *(int*)(a1 + 444) < 25
                        && (!*(_DWORD*)(a1 + 304)
                            || Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) != (struct Concurrency::ISchedulerProxy*)113))
                    {
                        *(_DWORD*)(a1 + 304) = 0;
                        *(_DWORD*)(a1 + 432) = 50;
                    }
                }
                return;
            case 0x71:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_DWORD*)(a1 + 392) = 1;
                    *(_DWORD*)(a1 + 372) = 0;
                    *(_DWORD*)(a1 + 376) = 0;
                    *(_DWORD*)(a1 + 340) = 0;
                    *(_DWORD*)(a1 + 344) = 0;
                    *(_DWORD*)(a1 + 348) = 0;
                    *(_DWORD*)(a1 + 352) = 0;
                    *(_DWORD*)(a1 + 356) = 0;
                    *(_DWORD*)(a1 + 360) = 0;
                    if (*(_DWORD*)(a1 + 304))
                        *(_DWORD*)(a1 + 440) = (unsigned __int8)sub_425E70(*(_BYTE**)(a1 + 304));
                    memset((void*)(a1 + 453), 0, 8u);
                    memset((void*)(a1 + 461), 0, 8u);
                    sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                }
                else if (*(_DWORD*)(a1 + 444) == 2 && *(_DWORD*)(a1 + 304))
                {
                    v175 = sub_4175B4(*(_DWORD*)(a1 + 304), 1);
                    sub_41EF8A((_WORD*)a1, 60 * v175 / 100);
                    sub_41F169((_WORD*)a1, *(unsigned __int16*)(a1 + 242));
                    *(_BYTE*)(a1 + (unsigned __int8)sub_425EF0(*(_BYTE**)(a1 + 304)) + 453) = -1;
                }
                *(_BYTE*)(a1 + 212) = 0;
                if (*(_DWORD*)(a1 + 440) == 2 || *(_DWORD*)(a1 + 440) == 3)
                {
                    if (*(int*)(a1 + 444) >= 6)
                    {
                        if (*(int*)(a1 + 444) >= 18)
                        {
                            if (*(int*)(a1 + 444) < 20)
                                *(_WORD*)(a1 + 204) = 19;
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 13;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 15;
                    }
                    *(_DWORD*)(a1 + 348) = 0;
                    if (*(_DWORD*)(a1 + 444) == 18)
                    {
                        *(_DWORD*)(a1 + 424) = *(_DWORD*)(a1 + 424) == 0;
                        *(_DWORD*)(a1 + 348) = -3200;
                        *(_DWORD*)(a1 + 392) = 1;
                    }
                    else if (*(_DWORD*)(a1 + 444) == 24)
                    {
                        *(_DWORD*)(a1 + 432) = 114;
                    }
                    if (!*(_DWORD*)(a1 + 304)
                        || *(int*)(a1 + 444) > 2
                        && Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) != (struct Concurrency::ISchedulerProxy*)99)
                    {
                        *(_DWORD*)(a1 + 304) = 0;
                        *(_DWORD*)(a1 + 432) = 76;
                    }
                }
                else
                {
                    if (*(int*)(a1 + 444) >= 9)
                    {
                        if (*(int*)(a1 + 444) >= 25)
                        {
                            if (*(int*)(a1 + 444) < 29)
                                *(_WORD*)(a1 + 204) = 19;
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 13;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 15;
                    }
                    *(_DWORD*)(a1 + 348) = 0;
                    if (*(_DWORD*)(a1 + 444) == 25)
                    {
                        *(_DWORD*)(a1 + 424) = *(_DWORD*)(a1 + 424) == 0;
                        *(_DWORD*)(a1 + 348) = -3200;
                        *(_DWORD*)(a1 + 392) = 1;
                    }
                    if (*(_DWORD*)(a1 + 444) == 33)
                        *(_DWORD*)(a1 + 432) = 114;
                    if (!*(_DWORD*)(a1 + 304)
                        || *(int*)(a1 + 444) > 2
                        && Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) != (struct Concurrency::ISchedulerProxy*)99)
                    {
                        *(_DWORD*)(a1 + 304) = 0;
                        *(_DWORD*)(a1 + 432) = 76;
                    }
                }
                return;
            case 0x72:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    *(_DWORD*)(a1 + 392) = 1;
                    *(_DWORD*)(a1 + 316) = *(_DWORD*)(a1 + 304);
                    if (*(_DWORD*)(a1 + 304))
                    {
                        v176 = sub_425D70(*(_DWORD**)(a1 + 304));
                        v318 = v176;
                        *(_DWORD*)(a1 + 372) = 450 * ((__PAIR64__(v176, v176) - 1) >> 32);
                    }
                    else
                    {
                        *(_DWORD*)(a1 + 372) = 0;
                    }
                    *(_DWORD*)(a1 + 304) = 0;
                    *(_DWORD*)(a1 + 376) = 0;
                    *(_DWORD*)(a1 + 340) = 0;
                    *(_DWORD*)(a1 + 344) = 0;
                    *(_DWORD*)(a1 + 348) = -400;
                    *(_DWORD*)(a1 + 352) = 0;
                    *(_DWORD*)(a1 + 356) = 0;
                    *(_DWORD*)(a1 + 360) = 30;
                    *(_DWORD*)(a1 + 436) = 0;
                    *(_BYTE*)(a1 + 248) = 2;
                    *(_BYTE*)(a1 + 253) = 1;
                    *(_BYTE*)(a1 + 250) = 10;
                    if (*(_BYTE*)(a1 + 469))
                        --* (_BYTE*)(a1 + 469);
                }
                *(_BYTE*)(a1 + 212) = 0;
                *(_WORD*)(a1 + 204) = 49;
                return;
            case 0x64:
                if (*(_DWORD*)(a1 + 304))
                {
                    *(_BYTE*)(a1 + 212) = 0;
                    *(_WORD*)(a1 + 204) = (*(_DWORD*)(a1 + 444) - 1) / 2 % 3 + 187;
                    if ((*(_DWORD*)(a1 + 444) - 1) % 6)
                    {
                        if ((*(_DWORD*)(a1 + 444) - 1) % 6 == 5)
                        {
                            SchedulerProxy = Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304));
                            if (SchedulerProxy == (struct Concurrency::ISchedulerProxy*)46)
                            {
                                sub_426050(*(_DWORD**)(a1 + 304), 44);
                            }
                            else if (SchedulerProxy == (struct Concurrency::ISchedulerProxy*)47)
                            {
                                sub_426050(*(_DWORD**)(a1 + 304), 45);
                            }
                        }
                    }
                    else
                    {
                        v177 = sub_41CB3B(a1, 1);
                        sub_41EF8A((_WORD*)a1, v177 / 60);
                        sub_417C15(*(_DWORD*)(a1 + 304), *(_BYTE*)(a1 + 242));
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9AB8, -1, 100, 100, 0);
                    }
                    if (*(int*)(a1 + 444) >= 19)
                        *(_DWORD*)(a1 + 432) = 69;
                }
                else
                {
                    *(_DWORD*)(a1 + 432) = 12;
                    *(_DWORD*)(a1 + 444) = 0;
                }
                return;
            case 0x65:
                if (*(_DWORD*)(a1 + 444) == 1 && *(_DWORD*)(a1 + 304))
                {
                    v316 = 12 * sub_41CB3B(a1, 1) / 100;
                    if (*(_BYTE*)(a1 + 258) == 1)
                    {
                        v316 = 12 * v316 / 10;
                    }
                    else if (*(_BYTE*)(a1 + 258) == 2)
                    {
                        v316 /= 2;
                    }
                    if (!v316)
                        v316 = 1;
                    sub_41EF8A(*(_WORD**)(a1 + 304), v316);
                }
                if ((*(int*)(a1 + 444) > 41 || *(_DWORD*)(a1 + 304))
                    && (*(int*)(a1 + 444) < 2
                        || *(int*)(a1 + 444) > 41
                        || !*(_DWORD*)(a1 + 304)
                        || Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) == (struct Concurrency::ISchedulerProxy*)115))
                {
                    *(_BYTE*)(a1 + 212) = 0;
                    if (*(int*)(a1 + 444) >= 33)
                    {
                        if (*(int*)(a1 + 444) >= 37)
                        {
                            if (*(int*)(a1 + 444) >= 41)
                            {
                                if (*(int*)(a1 + 444) >= 45)
                                {
                                    if (*(int*)(a1 + 444) >= 57)
                                        *(_WORD*)(a1 + 204) = 207;
                                    else
                                        *(_WORD*)(a1 + 204) = 206;
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 205;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 204;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 203;
                        }
                    }
                    else
                    {
                        v315 = (*(_DWORD*)(a1 + 444) - 1) / 4 % 4;
                        if (v315 >= 3)
                            *(_WORD*)(a1 + 204) = 201;
                        else
                            *(_WORD*)(a1 + 204) = v315 + 200;
                    }
                    switch (*(_DWORD*)(a1 + 444))
                    {
                    case '(':
                        v314 = 18 * sub_41CB3B(a1, 1) / 100;
                        if (*(_BYTE*)(a1 + 258) == 1)
                        {
                            v314 = 12 * v314 / 10;
                        }
                        else if (*(_BYTE*)(a1 + 258) == 2)
                        {
                            v314 /= 2;
                        }
                        if (!v314)
                            v314 = 1;
                        sub_41EF8A(*(_WORD**)(a1 + 304), v314);
                        break;
                    case ')':
                        *(_DWORD*)(a1 + 304) = 0;
                        break;
                    case '=':
                        *(_DWORD*)(a1 + 304) = 0;
                        *(_DWORD*)(a1 + 432) = 3;
                        break;
                    }
                }
                else
                {
                    *(_DWORD*)(a1 + 304) = 0;
                    *(_DWORD*)(a1 + 432) = 3;
                }
                return;
            case 0x73:
                *(_BYTE*)(a1 + 212) = 0;
                if ((*(int*)(a1 + 444) > 41 || *(_DWORD*)(a1 + 304))
                    && (*(int*)(a1 + 444) < 2
                        || *(int*)(a1 + 444) > 41
                        || !*(_DWORD*)(a1 + 304)
                        || Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) == (struct Concurrency::ISchedulerProxy*)101))
                {
                    if (*(_DWORD*)(a1 + 444) == 1)
                    {
                        *(_DWORD*)(a1 + 424) = sub_425D70(*(_DWORD**)(a1 + 304)) == 0;
                        *(_BYTE*)(a1 + 223) = sub_426030(*(_BYTE**)(a1 + 304)) - 1;
                        *(_DWORD*)(a1 + 360) = 0;
                        *(_DWORD*)(a1 + 356) = 0;
                        *(_DWORD*)(a1 + 352) = 0;
                        *(_DWORD*)(a1 + 348) = 0;
                        *(_DWORD*)(a1 + 344) = 0;
                        *(_DWORD*)(a1 + 340) = 0;
                        *(_DWORD*)(a1 + 376) = 0;
                        *(_DWORD*)(a1 + 372) = 0;
                        sub_423CF2((_BYTE*)a1, 1, -16, 1, 0, 0, 0);
                    }
                    if (*(int*)(a1 + 444) >= 33)
                    {
                        if (*(int*)(a1 + 444) >= 43)
                            *(_WORD*)(a1 + 204) = 13;
                        else
                            *(_WORD*)(a1 + 204) = 15;
                    }
                    else
                    {
                        *(_DWORD*)(a1 + 360) = 0;
                        *(_DWORD*)(a1 + 356) = 0;
                        *(_DWORD*)(a1 + 352) = 0;
                        *(_DWORD*)(a1 + 348) = 0;
                        *(_DWORD*)(a1 + 344) = 0;
                        *(_DWORD*)(a1 + 340) = 0;
                        *(_DWORD*)(a1 + 376) = 0;
                        *(_DWORD*)(a1 + 372) = 0;
                        v313 = (*(_DWORD*)(a1 + 444) - 1) / 4 % 4;
                        if (v313 == 2)
                        {
                            *(_WORD*)(a1 + 204) = 13;
                        }
                        else if (v313 == 3)
                        {
                            *(_WORD*)(a1 + 204) = 14;
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 15;
                        }
                        if ((*(_DWORD*)(a1 + 444) - 1) % 16 == 8)
                        {
                            sub_41261C((_WORD*)a1, *(unsigned __int16*)(a1 + 242), *(_DWORD*)(a1 + 304), 1);
                            sub_43FFC3((int*)unk_4BDB28, dword_4B9A0C, -1, 100, 100, 0);
                        }
                    }
                    if (*(_DWORD*)(a1 + 444) == 41)
                    {
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A10, -1, 100, 100, 0);
                        sub_41261C((_WORD*)a1, *(unsigned __int16*)(a1 + 242), *(_DWORD*)(a1 + 304), 1);
                        *(_DWORD*)(a1 + 392) = 1;
                        *(_DWORD*)(a1 + 340) = 70 * ((*(_DWORD*)(a1 + 424) == 0) - *(_DWORD*)(a1 + 424));
                        *(_DWORD*)(a1 + 348) = -650;
                        *(_DWORD*)(a1 + 360) = 25;
                        *(_DWORD*)(a1 + 304) = 0;
                        sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                    }
                    else if (*(_DWORD*)(a1 + 444) == 45)
                    {
                        *(_DWORD*)(a1 + 432) = 29;
                    }
                }
                else
                {
                    *(_DWORD*)(a1 + 304) = 0;
                    *(_DWORD*)(a1 + 432) = 76;
                    *(_DWORD*)(a1 + 360) = 0;
                    *(_DWORD*)(a1 + 356) = 0;
                    *(_DWORD*)(a1 + 352) = 0;
                    *(_DWORD*)(a1 + 348) = 0;
                    *(_DWORD*)(a1 + 344) = 0;
                    *(_DWORD*)(a1 + 340) = 0;
                    *(_DWORD*)(a1 + 376) = 0;
                    *(_DWORD*)(a1 + 372) = 0;
                    sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                }
                return;
            case 0xB5:
                if (*(_DWORD*)(a1 + 444) == 1)
                {
                    if (*(_DWORD*)(a1 + 392))
                    {
                        v178 = 75 * sub_41CCEA(a1, 1) / 100;
                        v179 = sub_41CCEA(a1, 1);
                        v180 = sub_41D067(a1, 1);
                        sub_41F169((_WORD*)a1, v179 * v180 / 200 + v178);
                    }
                    else
                    {
                        v181 = sub_41CCEA(a1, 1);
                        sub_41F169((_WORD*)a1, 75 * v181 / 100);
                    }
                    *(_BYTE*)(a1 + 257) = 1;
                    *(_BYTE*)(a1 + 248) = -1;
                    *(_BYTE*)(a1 + 212) = 1;
                    *(_BYTE*)(a1 + 213) = -1;
                    if (!*(_DWORD*)(a1 + 392) || *(unsigned __int8*)(a1 + 238) <= 1u && sub_41BA53(a1, 0x86u, 0))
                        *(_DWORD*)(a1 + 400) = 1;
                }
                if (*(_DWORD*)(a1 + 444) == 5)
                    *(_DWORD*)(a1 + 400) = 0;
                if (*(_BYTE*)(a1 + 195))
                {
                    switch (*(_BYTE*)(a1 + 195))
                    {
                    case 1:
                        if (!(*(_DWORD*)(a1 + 444) % 4))
                        {
                            memset((void*)(a1 + 453), 0, 8u);
                            memset((void*)(a1 + 461), 0, 8u);
                        }
                        if (*(int*)(a1 + 444) >= 4)
                        {
                            if (*(int*)(a1 + 444) >= 8)
                            {
                                if (*(int*)(a1 + 444) >= 12)
                                {
                                    if (*(int*)(a1 + 444) >= 16)
                                    {
                                        if (*(int*)(a1 + 444) >= 22)
                                        {
                                            if (*(int*)(a1 + 444) >= 25)
                                            {
                                                if (*(int*)(a1 + 444) >= 28)
                                                {
                                                    *(_BYTE*)(a1 + 257) = 2;
                                                    *(_WORD*)(a1 + 204) = 23;
                                                }
                                                else
                                                {
                                                    *(_BYTE*)(a1 + 248) = 0;
                                                    *(_WORD*)(a1 + 204) = 22;
                                                }
                                            }
                                            else
                                            {
                                                *(_WORD*)(a1 + 204) = 21;
                                            }
                                        }
                                        else
                                        {
                                            *(_WORD*)(a1 + 204) = 20;
                                        }
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 3;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 2;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 3;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 2;
                        }
                        if (*(_DWORD*)(a1 + 444) == 4 || *(_DWORD*)(a1 + 444) == 12 || *(_DWORD*)(a1 + 444) == 24)
                            sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                        if (*(_DWORD*)(a1 + 444) == 24)
                        {
                            v183 = sub_41CCEA(a1, 1);
                            sub_41F169((_WORD*)a1, 85 * v183 / 100);
                        }
                        if (*(int*)(a1 + 444) > 36)
                        {
                            if (*(_DWORD*)(a1 + 392))
                                *(_DWORD*)(a1 + 432) = 50;
                            else
                                *(_DWORD*)(a1 + 432) = 4;
                        }
                        break;
                    case 2:
                        if (*(_DWORD*)(a1 + 444) == 4 || *(_DWORD*)(a1 + 444) == 11 || *(_DWORD*)(a1 + 444) == 18)
                        {
                            memset((void*)(a1 + 453), 0, 8u);
                            memset((void*)(a1 + 461), 0, 8u);
                        }
                        if (*(int*)(a1 + 444) >= 4)
                        {
                            if (*(int*)(a1 + 444) >= 7)
                            {
                                if (*(int*)(a1 + 444) >= 11)
                                {
                                    if (*(int*)(a1 + 444) >= 14)
                                    {
                                        if (*(int*)(a1 + 444) >= 19)
                                        {
                                            if (*(int*)(a1 + 444) >= 22)
                                            {
                                                if (*(int*)(a1 + 444) >= 26)
                                                {
                                                    *(_BYTE*)(a1 + 257) = 2;
                                                    *(_WORD*)(a1 + 204) = 23;
                                                }
                                                else
                                                {
                                                    *(_BYTE*)(a1 + 248) = 0;
                                                    *(_WORD*)(a1 + 204) = 22;
                                                }
                                            }
                                            else
                                            {
                                                *(_WORD*)(a1 + 204) = 21;
                                            }
                                        }
                                        else
                                        {
                                            *(_WORD*)(a1 + 204) = 20;
                                        }
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 4;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 3;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 4;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 3;
                        }
                        if (*(_DWORD*)(a1 + 444) == 4 || *(_DWORD*)(a1 + 444) == 11 || *(_DWORD*)(a1 + 444) == 22)
                            sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                        if (*(_DWORD*)(a1 + 444) == 22)
                        {
                            v184 = sub_41CCEA(a1, 1);
                            sub_41F169((_WORD*)a1, 85 * v184 / 100);
                        }
                        if (*(int*)(a1 + 444) > 30)
                        {
                            if (*(_DWORD*)(a1 + 392))
                                *(_DWORD*)(a1 + 432) = 50;
                            else
                                *(_DWORD*)(a1 + 432) = 4;
                        }
                        break;
                    case 3:
                        if (!(*(_DWORD*)(a1 + 444) % 4))
                        {
                            memset((void*)(a1 + 453), 0, 8u);
                            memset((void*)(a1 + 461), 0, 8u);
                        }
                        if (*(int*)(a1 + 444) >= 4)
                        {
                            if (*(int*)(a1 + 444) >= 8)
                            {
                                if (*(int*)(a1 + 444) >= 12)
                                {
                                    if (*(int*)(a1 + 444) >= 16)
                                    {
                                        if (*(int*)(a1 + 444) >= 22)
                                        {
                                            if (*(int*)(a1 + 444) >= 25)
                                            {
                                                if (*(int*)(a1 + 444) >= 28)
                                                {
                                                    if (*(int*)(a1 + 444) < 36)
                                                    {
                                                        *(_BYTE*)(a1 + 257) = 2;
                                                        *(_WORD*)(a1 + 204) = 26;
                                                    }
                                                }
                                                else
                                                {
                                                    *(_BYTE*)(a1 + 248) = 0;
                                                    *(_WORD*)(a1 + 204) = 25;
                                                }
                                            }
                                            else
                                            {
                                                *(_WORD*)(a1 + 204) = 24;
                                            }
                                        }
                                        else
                                        {
                                            *(_WORD*)(a1 + 204) = 23;
                                        }
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 4;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 3;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 4;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 3;
                        }
                        if (*(_DWORD*)(a1 + 444) == 4 || *(_DWORD*)(a1 + 444) == 12 || *(_DWORD*)(a1 + 444) == 25)
                            sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                        if (*(_DWORD*)(a1 + 444) == 25)
                        {
                            v185 = sub_41CCEA(a1, 1);
                            sub_41F169((_WORD*)a1, 85 * v185 / 100);
                        }
                        if (*(int*)(a1 + 444) >= 36)
                        {
                            if (*(_DWORD*)(a1 + 392))
                                *(_DWORD*)(a1 + 432) = 50;
                            else
                                *(_DWORD*)(a1 + 432) = 4;
                        }
                        break;
                    }
                }
                else
                {
                    if (!(*(_DWORD*)(a1 + 444) % 4))
                    {
                        memset((void*)(a1 + 453), 0, 8u);
                        memset((void*)(a1 + 461), 0, 8u);
                    }
                    if (*(int*)(a1 + 444) >= 4)
                    {
                        if (*(int*)(a1 + 444) >= 8)
                        {
                            if (*(int*)(a1 + 444) >= 12)
                            {
                                if (*(int*)(a1 + 444) >= 16)
                                {
                                    if (*(int*)(a1 + 444) >= 22)
                                    {
                                        if (*(int*)(a1 + 444) >= 25)
                                        {
                                            if (*(int*)(a1 + 444) >= 28)
                                            {
                                                *(_BYTE*)(a1 + 257) = 2;
                                                *(_WORD*)(a1 + 204) = 19;
                                            }
                                            else
                                            {
                                                *(_WORD*)(a1 + 204) = 18;
                                            }
                                        }
                                        else
                                        {
                                            *(_BYTE*)(a1 + 248) = 0;
                                            *(_WORD*)(a1 + 204) = 17;
                                        }
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 16;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 1;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 0;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 1;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 0;
                    }
                    if (*(_DWORD*)(a1 + 444) == 4 || *(_DWORD*)(a1 + 444) == 12 || *(_DWORD*)(a1 + 444) == 24)
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                    if (*(_DWORD*)(a1 + 444) == 24)
                    {
                        v182 = sub_41CCEA(a1, 1);
                        sub_41F169((_WORD*)a1, 85 * v182 / 100);
                    }
                    if (*(int*)(a1 + 444) >= 33)
                    {
                        if (*(_DWORD*)(a1 + 392))
                            *(_DWORD*)(a1 + 432) = 50;
                        else
                            *(_DWORD*)(a1 + 432) = 4;
                    }
                }
                return;
            }
            if (*(_DWORD*)(a1 + 428) != 182)
            {
                if (*(_DWORD*)(a1 + 428) == 102)
                {
                    if (*(_DWORD*)(a1 + 444) == 1)
                    {
                        *(_BYTE*)(a1 + 212) = 0;
                        v198 = sub_41CCEA(a1, 1);
                        sub_41EF8A((_WORD*)a1, v198 / 25);
                    }
                    if (*(int*)(a1 + 444) >= 5)
                    {
                        v312 = (*(_DWORD*)(a1 + 444) - 5) / 3 % 2;
                        *(_WORD*)(a1 + 204) = v312 + 212;
                        if ((*(_DWORD*)(a1 + 444) - 5) % 6 == 3)
                        {
                            sub_43FFC3((int*)unk_4BDB28, dword_4B9A10, -1, 100, 100, 0);
                            if (*(_DWORD*)(a1 + 304))
                                sub_41261C(*(_WORD**)(a1 + 304), *(unsigned __int16*)(a1 + 242), a1, 1);
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 6;
                    }
                    if (*(int*)(a1 + 444) >= 28
                        || !*(_DWORD*)(a1 + 304)
                        || *(int*)(a1 + 444) >= 2
                        && Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) != (struct Concurrency::ISchedulerProxy*)116)
                    {
                        *(_DWORD*)(a1 + 432) = 3;
                        *(_DWORD*)(a1 + 304) = 0;
                    }
                    return;
                }
                if (*(_DWORD*)(a1 + 428) == 116)
                {
                    *(_BYTE*)(a1 + 212) = 0;
                    if (*(_DWORD*)(a1 + 304))
                    {
                        *(_BYTE*)(a1 + 223) = sub_426030(*(_BYTE**)(a1 + 304)) + 1 - 2 * (*(_DWORD*)(a1 + 444) % 2);
                        if (*(int*)(a1 + 444) >= 5)
                        {
                            v308 = (*(_DWORD*)(a1 + 444) - 5) / 3 % 2;
                            if (*(_DWORD*)(a1 + 436))
                                *(_WORD*)(a1 + 204) = v308 + 27;
                            else
                                *(_WORD*)(a1 + 204) = 18 - v308;
                        }
                        v310 = sub_426090(*(_DWORD**)(a1 + 304));
                        v309 = sub_4260B0(*(_DWORD**)(a1 + 304));
                        v311 = sub_4260D0(*(_DWORD**)(a1 + 304)) - 400;
                        if (sub_425D70(*(_DWORD**)(a1 + 304)))
                            v310 += 1600;
                        else
                            v310 -= 1600;
                        *(_DWORD*)(a1 + 372) = v310 - *(_DWORD*)(a1 + 328);
                        *(_DWORD*)(a1 + 376) = v309 - *(_DWORD*)(a1 + 332);
                        if (*(int*)(a1 + 444) >= 5)
                        {
                            *(_DWORD*)(a1 + 348) = v311 - *(_DWORD*)(a1 + 336);
                            *(_DWORD*)(a1 + 392) = 1;
                        }
                    }
                    if (*(int*)(a1 + 444) >= 28
                        || !*(_DWORD*)(a1 + 304)
                        || *(int*)(a1 + 444) >= 2
                        && Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) != (struct Concurrency::ISchedulerProxy*)102)
                    {
                        *(_DWORD*)(a1 + 304) = 0;
                        if (*(int*)(a1 + 444) >= 28)
                            *(_BYTE*)(a1 + 470) = *(unsigned __int8*)(a1 + 470) / 2;
                        if (*(_DWORD*)(a1 + 436))
                            *(_DWORD*)(a1 + 432) = 45;
                        else
                            *(_DWORD*)(a1 + 432) = 44;
                    }
                    return;
                }
                if (*(_DWORD*)(a1 + 428) == 187)
                {
                    if (*(_DWORD*)(a1 + 444) == 1)
                    {
                        memset((void*)(a1 + 453), 0, 8u);
                        memset((void*)(a1 + 461), 0, 8u);
                        v243 = (double)sub_41CB3B(a1, 1) * 1.5;
                        v199 = sub_41CB3B(a1, 1);
                        v200 = sub_41CA5F(a1, 1) * v199;
                        v242 = (double)(v200 * sub_41D067(a1, 1) / 10000) + v243;
                        v201 = (double)(*(_DWORD*)(a1 + 436) * sub_41CB3B(a1, 1) / 180) + v242;
                        sub_41F169((_WORD*)a1, (__int64)v201);
                        *(_BYTE*)(a1 + 257) = 1;
                        *(_BYTE*)(a1 + 248) = 2;
                        *(_BYTE*)(a1 + 212) = 0;
                        *(_BYTE*)(a1 + 213) = -1;
                        *(_DWORD*)(a1 + 352) = 0;
                        *(_DWORD*)(a1 + 348) = -500 - *(_DWORD*)(a1 + 436);
                        if (2 * *(_DWORD*)(a1 + 372) <= 0)
                            v241 = -2 * *(_DWORD*)(a1 + 372);
                        else
                            v241 = 2 * *(_DWORD*)(a1 + 372);
                        if (*(int*)(a1 + 348) <= 0)
                            v240 = -*(_DWORD*)(a1 + 348);
                        else
                            v240 = *(_DWORD*)(a1 + 348);
                        if (v241 < v240)
                        {
                            if (2 * *(_DWORD*)(a1 + 372) <= 0)
                                v239 = -2 * *(_DWORD*)(a1 + 372);
                            else
                                v239 = 2 * *(_DWORD*)(a1 + 372);
                            *(_DWORD*)(a1 + 348) = -v239;
                        }
                        *(_DWORD*)(a1 + 360) = 30;
                    }
                    if (!(*(_DWORD*)(a1 + 444) % 4))
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                    *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 4 % 6 + 239;
                    return;
                }
                if (*(_DWORD*)(a1 + 428) == 188)
                {
                    *(_BYTE*)(a1 + 212) = 0;
                    if (*(_DWORD*)(a1 + 444) == 1)
                    {
                        *(_DWORD*)(a1 + 436) = 0;
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A18, -1, 100, 100, 0);
                        *(_BYTE*)(a1 + 248) = -1;
                        *(_DWORD*)(a1 + 372) *= 2;
                        *(_DWORD*)(a1 + 380) = *(_DWORD*)(a1 + 372);
                        *(_DWORD*)(a1 + 352) = (__int64)((double)*(int*)(a1 + 352) * 1.5);
                        v202 = sub_417924(a1, 3, 1);
                        v203 = sub_41CA5F(a1, 1);
                        sub_41F169((_WORD*)a1, (v202 + v203 / 2) / 2);
                        memset((void*)(a1 + 453), 0, 8u);
                        memset((void*)(a1 + 461), 0, 8u);
                    }
                    if (!(*(_DWORD*)(a1 + 444) % 10))
                    {
                        memset((void*)(a1 + 453), 0, 8u);
                        memset((void*)(a1 + 461), 0, 8u);
                    }
                    *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 4 % 4 + 245;
                    if (*(int*)(a1 + 372) <= 0)
                        v238 = -*(_DWORD*)(a1 + 372);
                    else
                        v238 = *(_DWORD*)(a1 + 372);
                    if (*(int*)(a1 + 352) <= 0)
                        v237 = -*(_DWORD*)(a1 + 352);
                    else
                        v237 = *(_DWORD*)(a1 + 352);
                    if (v238 <= 10 * v237)
                        *(_DWORD*)(a1 + 432) = 12;
                    return;
                }
                if (*(_DWORD*)(a1 + 428) == 103)
                {
                    if (*(_DWORD*)(a1 + 444) == 1)
                    {
                        *(_BYTE*)(a1 + 212) = 0;
                        memset((void*)(a1 + 453), 0, 8u);
                        memset((void*)(a1 + 461), 0, 8u);
                        *(_DWORD*)(a1 + 372) = 0;
                        *(_DWORD*)(a1 + 376) = 0;
                        *(_DWORD*)(a1 + 340) = 0;
                        *(_DWORD*)(a1 + 344) = 0;
                        *(_DWORD*)(a1 + 352) = 0;
                        *(_DWORD*)(a1 + 356) = 0;
                        *(_DWORD*)(a1 + 436) = 0;
                        v302 = 0;
                        if (*(_BYTE*)(a1 + 195))
                        {
                            switch (*(_BYTE*)(a1 + 195))
                            {
                            case 1:
                                v302 = 32 * sub_4175B4(a1, 1) / 100;
                                break;
                            case 2:
                                v302 = 31 * sub_4175B4(a1, 1) / 100;
                                break;
                            case 3:
                                v302 = 40 * sub_4175B4(a1, 1) / 100;
                                break;
                            }
                        }
                        else
                        {
                            v302 = 35 * sub_4175B4(a1, 1) / 100;
                        }
                        if (*(_BYTE*)(a1 + 258) == 1)
                        {
                            v302 = 12 * v302 / 10;
                        }
                        else if (*(_BYTE*)(a1 + 258) == 2)
                        {
                            v302 = 80 * v302 / 100;
                        }
                        if (!v302)
                            v302 = 1;
                        if (*(_DWORD*)(a1 + 304))
                            sub_41EF8A(*(_WORD**)(a1 + 304), v302);
                    }
                    v303 = 0;
                    v304 = 0;
                    v307 = 0;
                    v305 = 0;
                    v306 = 0;
                    if (*(int*)(a1 + 444) >= 6)
                    {
                        if (*(int*)(a1 + 444) >= 12)
                        {
                            if (*(int*)(a1 + 444) >= 14)
                            {
                                if (*(int*)(a1 + 444) >= 16)
                                {
                                    if (*(int*)(a1 + 444) < 20)
                                        *(_WORD*)(a1 + 204) = 6;
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 252;
                                    v303 = 1100;
                                    v304 = -1200;
                                    v307 = *(_DWORD*)(a1 + 424);
                                    v305 = 17;
                                    v306 = -1;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 251;
                                v303 = 1100;
                                v304 = -1200;
                                v307 = *(_DWORD*)(a1 + 424);
                                v305 = 17;
                                v306 = -1;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 250;
                            v303 = -1400;
                            v304 = -900;
                            v307 = *(_DWORD*)(a1 + 424) == 0;
                            v305 = 15;
                            v306 = -1;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 249;
                        v303 = -1300;
                        v304 = -800;
                        v307 = *(_DWORD*)(a1 + 424) == 0;
                        v305 = 15;
                        v306 = -1;
                    }
                    if (*(_DWORD*)(a1 + 444) == 12)
                    {
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                    }
                    else if (*(_DWORD*)(a1 + 444) == 16)
                    {
                        *(_DWORD*)(a1 + 424) = *(_DWORD*)(a1 + 424) == 0;
                        *(_DWORD*)(a1 + 304) = 0;
                    }
                    if (*(int*)(a1 + 444) > 1
                        && *(int*)(a1 + 444) < 16
                        && (!*(_DWORD*)(a1 + 304)
                            || Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) != (struct Concurrency::ISchedulerProxy*)117))
                    {
                        *(_DWORD*)(a1 + 304) = 0;
                        *(_DWORD*)(a1 + 432) = 3;
                    }
                    if (*(_DWORD*)(a1 + 304))
                    {
                        if (*(_DWORD*)(a1 + 424))
                            v303 = -v303;
                        sub_422B5C(
                            *(_DWORD*)(a1 + 304),
                            v303 + *(_DWORD*)(a1 + 328),
                            *(_DWORD*)(a1 + 332),
                            v304 + *(_DWORD*)(a1 + 336),
                            v307,
                            v305,
                            v306 + *(_BYTE*)(a1 + 223));
                    }
                    if (*(int*)(a1 + 444) >= 20)
                        *(_DWORD*)(a1 + 432) = 12;
                    return;
                }
                if (*(_DWORD*)(a1 + 428) == 117)
                {
                    if (*(_DWORD*)(a1 + 444) == 1)
                        sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                    if (*(_DWORD*)(a1 + 444) == 16 && *(_DWORD*)(a1 + 304))
                    {
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A10, -1, 100, 100, 0);
                        sub_41261C((_WORD*)a1, *(unsigned __int16*)(a1 + 242), *(_DWORD*)(a1 + 304), 1);
                        *(_DWORD*)(a1 + 304) = 0;
                        *(_DWORD*)(a1 + 340) = 150 * ((*(_DWORD*)(a1 + 424) == 0) - *(_DWORD*)(a1 + 424));
                        *(_DWORD*)(a1 + 348) = -300;
                        *(_DWORD*)(a1 + 360) = 30;
                    }
                    if (*(int*)(a1 + 444) > 1
                        && *(int*)(a1 + 444) < 16
                        && (!*(_DWORD*)(a1 + 304)
                            || Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) != (struct Concurrency::ISchedulerProxy*)103))
                    {
                        sub_417C83(a1);
                    }
                    return;
                }
                if (*(_DWORD*)(a1 + 428) == 104)
                {
                    if (*(_DWORD*)(a1 + 444) == 1)
                    {
                        *(_BYTE*)(a1 + 212) = 0;
                        *(_DWORD*)(a1 + 436) = *(_DWORD*)(a1 + 328);
                        *(_DWORD*)(a1 + 440) = *(_DWORD*)(a1 + 336);
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A38, -1, 100, 100, 0);
                        if (*(_BYTE*)(a1 + 224))
                            *(_DWORD*)(a1 + 424) = *(char*)(a1 + 224) > 0;
                        v301 = 0;
                        if (*(_BYTE*)(a1 + 195))
                        {
                            switch (*(_BYTE*)(a1 + 195))
                            {
                            case 1:
                                v301 = 37 * sub_4175B4(a1, 1) / 100;
                                break;
                            case 2:
                                v301 = 36 * sub_4175B4(a1, 1) / 100;
                                break;
                            case 3:
                                v301 = 50 * sub_4175B4(a1, 1) / 100;
                                break;
                            }
                        }
                        else
                        {
                            v301 = 40 * sub_4175B4(a1, 1) / 100;
                        }
                        if (*(_BYTE*)(a1 + 258) == 1)
                        {
                            v301 = 12 * v301 / 10;
                        }
                        else if (*(_BYTE*)(a1 + 258) == 2)
                        {
                            v301 = 50 * v301 / 100;
                        }
                        if (!v301)
                            v301 = 1;
                        if (*(_DWORD*)(a1 + 304))
                        {
                            v204 = sub_417924(a1, 3, 1);
                            v205 = (unsigned __int16)sub_43E520((short*)a1) + v204;
                            v206 = sub_417924(*(_DWORD*)(a1 + 304), 3, 1) + v205;
                            v207 = sub_43E520((short*)*(_DWORD*)(a1 + 304));
                            sub_41F169(*(_WORD**)(a1 + 304), v207 + v206);
                            sub_41EF8A(*(_WORD**)(a1 + 304), v301);
                        }
                    }
                    if (*(int*)(a1 + 444) > 2
                        && *(int*)(a1 + 444) < 61
                        && (!*(_DWORD*)(a1 + 304)
                            || Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) != (struct Concurrency::ISchedulerProxy*)118))
                    {
                        *(_DWORD*)(a1 + 304) = 0;
                        if (*(_DWORD*)(a1 + 392))
                            *(_DWORD*)(a1 + 432) = 50;
                        else
                            *(_DWORD*)(a1 + 432) = 12;
                    }
                    if (*(int*)(a1 + 444) < 61 && *(_DWORD*)(a1 + 304))
                    {
                        v298 = *(_DWORD*)(a1 + 444) / 5 % 4;
                        *(_DWORD*)(a1 + 340) = 300 * (*(_DWORD*)(a1 + 424) - (*(_DWORD*)(a1 + 424) == 0));
                        *(_DWORD*)(a1 + 380) = *(_DWORD*)(a1 + 340);
                        *(_WORD*)(a1 + 204) = v298 + 253;
                        v236 = !v298 || v298 == 3;
                        v235 = v298 == 1 || v298 == 2;
                        v296 = 400 * v235 - 400 * v236;
                        v297 = -800 * (v298 >= 2);
                        v300 = *(_DWORD*)(a1 + 424);
                        v299 = v298 + 63;
                        if (*(_DWORD*)(a1 + 424))
                            v296 = -v296;
                        sub_422B5C(
                            *(_DWORD*)(a1 + 304),
                            v296 + *(_DWORD*)(a1 + 328),
                            *(_DWORD*)(a1 + 332),
                            v297 + *(_DWORD*)(a1 + 336),
                            v300,
                            v299,
                            *(_BYTE*)(a1 + 223) - 1);
                    }
                    else if (*(_DWORD*)(a1 + 444) == 61)
                    {
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A10, -1, 100, 100, 0);
                        *(_DWORD*)(a1 + 304) = 0;
                        *(_DWORD*)(a1 + 372) = 0;
                        *(_DWORD*)(a1 + 352) = 0;
                        *(_DWORD*)(a1 + 340) = 150 * ((*(_DWORD*)(a1 + 424) == 0) - *(_DWORD*)(a1 + 424));
                        *(_DWORD*)(a1 + 348) = -400;
                        *(_DWORD*)(a1 + 360) = 30;
                        *(_DWORD*)(a1 + 392) = 1;
                        *(_WORD*)(a1 + 204) = 6;
                    }
                    else if (*(_DWORD*)(a1 + 444) == 65)
                    {
                        *(_WORD*)(a1 + 204) = 25;
                    }
                    return;
                }
                if (*(_DWORD*)(a1 + 428) == 118)
                {
                    if (*(_DWORD*)(a1 + 444) == 1)
                    {
                        *(_BYTE*)(a1 + 212) = 0;
                        *(_DWORD*)(a1 + 392) = 1;
                        memset((void*)(a1 + 453), 0, 8u);
                        memset((void*)(a1 + 461), 0, 8u);
                        if (*(_DWORD*)(a1 + 304))
                            *(_BYTE*)(a1 + (unsigned __int8)sub_425EF0(*(_BYTE**)(a1 + 304)) + 453) = -1;
                        *(_BYTE*)(a1 + 257) = 1;
                        *(_BYTE*)(a1 + 248) = 2;
                        *(_BYTE*)(a1 + 253) = 1;
                        sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                    }
                    if (*(int*)(a1 + 444) > 2
                        && *(int*)(a1 + 444) < 61
                        && (!*(_DWORD*)(a1 + 304)
                            || Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) != (struct Concurrency::ISchedulerProxy*)104))
                    {
                        *(_DWORD*)(a1 + 304) = 0;
                        sub_417C83(a1);
                    }
                    if (*(int*)(a1 + 444) >= 61 && *(_DWORD*)(a1 + 444) == 61)
                    {
                        *(_BYTE*)(a1 + 257) = 0;
                        sub_41261C((_WORD*)a1, *(unsigned __int16*)(a1 + 242), *(_DWORD*)(a1 + 304), 1);
                        *(_DWORD*)(a1 + 304) = 0;
                        *(_DWORD*)(a1 + 372) = 0;
                        *(_DWORD*)(a1 + 352) = 0;
                        *(_DWORD*)(a1 + 340) = 150 * (*(_DWORD*)(a1 + 424) - (*(_DWORD*)(a1 + 424) == 0));
                        *(_DWORD*)(a1 + 348) = -400;
                        *(_DWORD*)(a1 + 360) = 30;
                        *(_DWORD*)(a1 + 392) = 1;
                        *(_WORD*)(a1 + 204) = 17;
                    }
                    return;
                }
                if (*(_DWORD*)(a1 + 428) == 105)
                {
                    if (*(_DWORD*)(a1 + 444) == 1)
                    {
                        *(_BYTE*)(a1 + 212) = 0;
                        *(_BYTE*)(a1 + 251) = 0;
                        v295 = 0;
                        if (*(_BYTE*)(a1 + 195))
                        {
                            switch (*(_BYTE*)(a1 + 195))
                            {
                            case 1:
                                v295 = 32 * sub_41CB3B(a1, 1) / 100;
                                break;
                            case 2:
                                v295 = 31 * sub_41CB3B(a1, 1) / 100;
                                break;
                            case 3:
                                v295 = 40 * sub_41CB3B(a1, 1) / 100;
                                break;
                            }
                        }
                        else
                        {
                            v295 = 35 * sub_41CB3B(a1, 1) / 100;
                        }
                        if (*(_BYTE*)(a1 + 258) == 1)
                        {
                            v295 = 12 * v295 / 10;
                        }
                        else if (*(_BYTE*)(a1 + 258) == 2)
                        {
                            v295 = 75 * v295 / 100;
                        }
                        if (!v295)
                            v295 = 1;
                        if (*(_DWORD*)(a1 + 304))
                            sub_41EF8A(*(_WORD**)(a1 + 304), v295);
                    }
                    if (*(int*)(a1 + 444) > 2
                        && *(int*)(a1 + 444) < 58
                        && (!*(_DWORD*)(a1 + 304)
                            || Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) != (struct Concurrency::ISchedulerProxy*)119))
                    {
                        *(_DWORD*)(a1 + 304) = 0;
                        *(_DWORD*)(a1 + 432) = 4;
                    }
                    if (*(int*)(a1 + 444) >= 6)
                    {
                        if (*(int*)(a1 + 444) >= 30)
                        {
                            if (*(int*)(a1 + 444) >= 48)
                            {
                                if (*(int*)(a1 + 444) >= 52)
                                {
                                    if (*(int*)(a1 + 444) >= 56)
                                    {
                                        if (*(int*)(a1 + 444) >= 60)
                                            *(_WORD*)(a1 + 204) = 211;
                                        else
                                            *(_WORD*)(a1 + 204) = 210;
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 209;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 208;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 4;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 121;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 31;
                    }
                    if (*(_DWORD*)(a1 + 444) != 6)
                    {
                        if (*(_DWORD*)(a1 + 444) == 58)
                        {
                            *(_DWORD*)(a1 + 304) = 0;
                        }
                        else if (*(int*)(a1 + 444) >= 90)
                        {
                            *(_DWORD*)(a1 + 432) = 4;
                        }
                        return;
                    }
                }
                else
                {
                    if (*(_DWORD*)(a1 + 428) == 119)
                    {
                        if (*(_DWORD*)(a1 + 444) == 1)
                        {
                            *(_DWORD*)(a1 + 436) = 0;
                            *(_BYTE*)(a1 + 212) = 0;
                            *(_DWORD*)(a1 + 372) = 0;
                            *(_DWORD*)(a1 + 340) = 0;
                            *(_DWORD*)(a1 + 352) = 0;
                            *(_DWORD*)(a1 + 376) = 0;
                            *(_DWORD*)(a1 + 344) = 0;
                            *(_DWORD*)(a1 + 356) = 0;
                            *(_DWORD*)(a1 + 348) = 0;
                            *(_DWORD*)(a1 + 360) = 0;
                            sub_423CF2((_BYTE*)a1, 1, 0, 1, 0, 0, 0);
                        }
                        if (*(int*)(a1 + 444) >= 6)
                        {
                            if (*(int*)(a1 + 444) < 57 || *(_DWORD*)(a1 + 436) == 5)
                            {
                                *(_WORD*)(a1 + 204) = (*(_DWORD*)(a1 + 444) - 6) / 5 % 4 + 20;
                            }
                            else if (*(int*)(a1 + 444) >= 80)
                            {
                                if (*(int*)(a1 + 444) >= 90)
                                    *(_WORD*)(a1 + 204) = 19;
                                else
                                    *(_WORD*)(a1 + 204) = 17;
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 16;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 16;
                        }
                        if (*(int*)(a1 + 444) > 2
                            && *(int*)(a1 + 444) < 58
                            && (!*(_DWORD*)(a1 + 304)
                                || Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) != (struct Concurrency::ISchedulerProxy*)105))
                        {
                            *(_DWORD*)(a1 + 436) = 5;
                            *(_DWORD*)(a1 + 304) = 0;
                            *(_DWORD*)(a1 + 372) = 0;
                            *(_DWORD*)(a1 + 376) = 0;
                            sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                        }
                        if (*(int*)(a1 + 444) > 2 && *(int*)(a1 + 444) < 58 && !*(_DWORD*)(a1 + 436) && *(_DWORD*)(a1 + 304))
                            v294[2] = sub_425D70(*(_DWORD**)(a1 + 304));
                        if (*(_DWORD*)(a1 + 444) == 6)
                        {
                            *(_DWORD*)(a1 + 392) = 1;
                            *(_DWORD*)(a1 + 348) = -800;
                            *(_DWORD*)(a1 + 360) = 30;
                        }
                        else if (*(_DWORD*)(a1 + 444) == 57 && *(_DWORD*)(a1 + 304) && !*(_DWORD*)(a1 + 436))
                        {
                            sub_43FFC3((int*)unk_4BDB28, dword_4B9A10, -1, 100, 100, 0);
                            sub_41261C((_WORD*)a1, *(unsigned __int16*)(a1 + 242), *(_DWORD*)(a1 + 304), 1);
                            *(_DWORD*)(a1 + 424) = sub_425D70(*(_DWORD**)(a1 + 304)) == 0;
                            *(_DWORD*)(a1 + 316) = *(_DWORD*)(a1 + 304);
                            *(_DWORD*)(a1 + 304) = 0;
                            sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                            *(_DWORD*)(a1 + 348) = 0;
                            *(_DWORD*)(a1 + 360) = 0;
                        }
                        else if (*(_DWORD*)(a1 + 444) == 59 && !*(_DWORD*)(a1 + 436))
                        {
                            sub_43FFC3((int*)unk_4BDB28, dword_4B9AD8, -1, 100, 100, 0);
                            *(_DWORD*)(a1 + 340) = 300 * ((*(_DWORD*)(a1 + 424) == 0) - *(_DWORD*)(a1 + 424));
                            *(_DWORD*)(a1 + 348) = -800;
                            *(_DWORD*)(a1 + 360) = 30;
                        }
                        if (*(int*)(a1 + 444) >= 59 && !(*(_DWORD*)(a1 + 444) % 10) && !*(_DWORD*)(a1 + 436))
                        {
                            sub_442863(v290);
                            sub_4097DF((void*)a1, (int)v294);
                            v208 = sub_446465((char*)unk_4B9B10);
                            v290[0] = v208 + v294[0];
                            v290[1] = v294[1];
                            v291 = 18;
                            v292 = *(_DWORD*)(a1 + 424);
                            v293 = 0;
                            sub_4561A5((char*)unk_4B9B10, (int)v290);
                        }
                        return;
                    }
                    if (*(_DWORD*)(a1 + 428) == 106)
                    {
                        if (*(_DWORD*)(a1 + 444) == 1)
                        {
                            *(_DWORD*)(a1 + 436) = 0;
                            *(_BYTE*)(a1 + 212) = 0;
                            *(_BYTE*)(a1 + 251) = 0;
                            *(_DWORD*)(a1 + 360) = 0;
                            *(_DWORD*)(a1 + 356) = 0;
                            *(_DWORD*)(a1 + 352) = 0;
                            *(_DWORD*)(a1 + 348) = 0;
                            *(_DWORD*)(a1 + 344) = 0;
                            *(_DWORD*)(a1 + 340) = 0;
                            *(_DWORD*)(a1 + 376) = 0;
                            *(_DWORD*)(a1 + 372) = 0;
                            sub_43FFC3((int*)unk_4BDB28, dword_4B9A18, -1, 100, 100, 0);
                            if (*(_BYTE*)(a1 + 224))
                                *(_DWORD*)(a1 + 424) = *(char*)(a1 + 224) > 0;
                            v289 = 0;
                            switch (*(_BYTE*)(a1 + 195))
                            {
                            case 0:
                            case 1:
                                v289 = 35 * sub_4175B4(a1, 1) / 100;
                                break;
                            case 2:
                                v289 = 30 * sub_4175B4(a1, 1) / 100;
                                break;
                            case 3:
                                v289 = 45 * sub_4175B4(a1, 1) / 100;
                                break;
                            }
                            if (*(_BYTE*)(a1 + 258) == 1)
                            {
                                v289 = 12 * v289 / 10;
                            }
                            else if (*(_BYTE*)(a1 + 258) == 2)
                            {
                                v289 = 75 * v289 / 100;
                            }
                            if (!v289)
                                v289 = 1;
                            if (*(_DWORD*)(a1 + 304))
                            {
                                v209 = sub_4175B4(a1, 1);
                                v210 = sub_417924(*(_DWORD*)(a1 + 304), 3, 1) + v209;
                                v211 = sub_43E520((short*)*(_DWORD*)(a1 + 304));
                                sub_41F169(*(_WORD**)(a1 + 304), v211 + v210);
                                sub_41EF8A(*(_WORD**)(a1 + 304), v289);
                            }
                        }
                        if (*(int*)(a1 + 444) > 1
                            && !*(_DWORD*)(a1 + 436)
                            && (!*(_DWORD*)(a1 + 304)
                                || Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) != (struct Concurrency::ISchedulerProxy*)120))
                        {
                            *(_DWORD*)(a1 + 304) = 0;
                            *(_DWORD*)(a1 + 432) = 4;
                        }
                        if (*(int*)(a1 + 444) >= 50)
                        {
                            if (*(int*)(a1 + 444) >= 54)
                            {
                                if (*(int*)(a1 + 444) >= 58)
                                    *(_WORD*)(a1 + 204) = 211;
                                else
                                    *(_WORD*)(a1 + 204) = 210;
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 209;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 13 * ((*(_DWORD*)(a1 + 444) - 1) / 5 % 2) + 30;
                            *(_DWORD*)(a1 + 340) = 200 * (*(_DWORD*)(a1 + 424) - (*(_DWORD*)(a1 + 424) == 0));
                            *(_DWORD*)(a1 + 380) = *(_DWORD*)(a1 + 340);
                        }
                        if (*(_DWORD*)(a1 + 444) == 50)
                        {
                            sub_43FFC3((int*)unk_4BDB28, dword_4B9A24, -1, 100, 100, 0);
                        }
                        else if (*(_DWORD*)(a1 + 444) == 54)
                        {
                            *(_DWORD*)(a1 + 436) = 1;
                            sub_43FFC3((int*)unk_4BDB28, dword_4B9A38, -1, 100, 100, 0);
                            *(_DWORD*)(a1 + 304) = 0;
                        }
                        if (*(int*)(a1 + 444) >= 88)
                        {
                            *(_DWORD*)(a1 + 304) = 0;
                            *(_DWORD*)(a1 + 432) = 4;
                        }
                        return;
                    }
                    if (*(_DWORD*)(a1 + 428) == 120)
                    {
                        if (*(_DWORD*)(a1 + 444) == 1)
                        {
                            *(_DWORD*)(a1 + 436) = 0;
                            *(_BYTE*)(a1 + 212) = 0;
                            *(_DWORD*)(a1 + 372) = 0;
                            *(_DWORD*)(a1 + 340) = 0;
                            *(_DWORD*)(a1 + 352) = 0;
                            *(_DWORD*)(a1 + 376) = 0;
                            *(_DWORD*)(a1 + 344) = 0;
                            *(_DWORD*)(a1 + 356) = 0;
                            *(_DWORD*)(a1 + 348) = 0;
                            *(_DWORD*)(a1 + 360) = 0;
                            memset((void*)(a1 + 453), 0, 8u);
                            memset((void*)(a1 + 461), 0, 8u);
                            if (*(_DWORD*)(a1 + 304))
                            {
                                *(_BYTE*)(a1 + (unsigned __int8)sub_425EF0(*(_BYTE**)(a1 + 304)) + 453) = -1;
                                *(_DWORD*)(a1 + 424) = sub_425D70(*(_DWORD**)(a1 + 304));
                                *(_BYTE*)(a1 + 223) = sub_426030(*(_BYTE**)(a1 + 304)) - 1;
                            }
                            *(_BYTE*)(a1 + 257) = 1;
                            *(_BYTE*)(a1 + 248) = 2;
                            *(_BYTE*)(a1 + 253) = 1;
                            sub_423CF2((_BYTE*)a1, 1, -16, 1, 0, 0, 0);
                        }
                        if (*(int*)(a1 + 444) > 1
                            && !*(_DWORD*)(a1 + 436)
                            && (!*(_DWORD*)(a1 + 304)
                                || Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) != (struct Concurrency::ISchedulerProxy*)106))
                        {
                            *(_DWORD*)(a1 + 304) = 0;
                            sub_417C83(a1);
                            sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                        }
                        if (*(int*)(a1 + 444) > 1 && *(_DWORD*)(a1 + 304) && sub_426010(*(_DWORD**)(a1 + 304)) == 1)
                        {
                            *(_DWORD*)(a1 + 316) = *(_DWORD*)(a1 + 304);
                            *(_DWORD*)(a1 + 304) = 0;
                            sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                            *(_DWORD*)(a1 + 436) = 1;
                        }
                        if (*(_DWORD*)(a1 + 436) || !*(_DWORD*)(a1 + 304))
                        {
                            if (*(_DWORD*)(a1 + 436) == 1)
                            {
                                *(_DWORD*)(a1 + 340) = 400 * (*(_DWORD*)(a1 + 424) - (*(_DWORD*)(a1 + 424) == 0));
                                *(_DWORD*)(a1 + 380) = *(_DWORD*)(a1 + 340);
                                *(_WORD*)(a1 + 204) = (*(_DWORD*)(a1 + 444) - 1) / 3 % 4 + 234;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = (*(_DWORD*)(a1 + 444) - 1) / 5 % 4 + 234;
                        }
                        return;
                    }
                    if (*(_DWORD*)(a1 + 428) == 107)
                    {
                        if (*(_DWORD*)(a1 + 444) == 1)
                        {
                            *(_DWORD*)(a1 + 436) = 0;
                            *(_DWORD*)(a1 + 392) = 1;
                            *(_BYTE*)(a1 + 212) = 0;
                            *(_BYTE*)(a1 + 251) = 0;
                            *(_BYTE*)(a1 + 212) = 0;
                            *(_BYTE*)(a1 + 251) = 0;
                            v288 = 0;
                            if (*(_BYTE*)(a1 + 195))
                            {
                                switch (*(_BYTE*)(a1 + 195))
                                {
                                case 1:
                                    v288 = 25 * sub_41CB3B(a1, 1) / 100;
                                    break;
                                case 2:
                                    v288 = 15 * sub_41CB3B(a1, 1) / 100;
                                    break;
                                case 3:
                                    v288 = 17 * sub_41CB3B(a1, 1) / 100;
                                    break;
                                }
                            }
                            else
                            {
                                v288 = 20 * sub_41CB3B(a1, 1) / 100;
                            }
                            if (*(_BYTE*)(a1 + 258) == 1)
                            {
                                v288 = 12 * v288 / 10;
                            }
                            else if (*(_BYTE*)(a1 + 258) == 2)
                            {
                                v288 = 75 * v288 / 100;
                            }
                            if (!v288)
                                v288 = 1;
                            sub_41EF8A((_WORD*)a1, v288);
                        }
                        if (*(int*)(a1 + 444) > 1
                            && *(int*)(a1 + 444) < 86
                            && (!*(_DWORD*)(a1 + 304)
                                || Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) != (struct Concurrency::ISchedulerProxy*)121))
                        {
                            sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                            *(_DWORD*)(a1 + 304) = 0;
                            *(_DWORD*)(a1 + 360) = 0;
                            *(_DWORD*)(a1 + 356) = 0;
                            *(_DWORD*)(a1 + 352) = 0;
                            *(_DWORD*)(a1 + 348) = 0;
                            *(_DWORD*)(a1 + 344) = 0;
                            *(_DWORD*)(a1 + 340) = 0;
                            *(_DWORD*)(a1 + 376) = 0;
                            *(_DWORD*)(a1 + 372) = 0;
                            *(_DWORD*)(a1 + 340) = 200 * ((*(_DWORD*)(a1 + 424) == 0) - *(_DWORD*)(a1 + 424));
                            *(_DWORD*)(a1 + 348) = -300;
                            *(_DWORD*)(a1 + 360) = 30;
                            *(_DWORD*)(a1 + 432) = 50;
                        }
                        if (*(int*)(a1 + 444) < 86 && *(_DWORD*)(a1 + 304))
                            sub_423CF2((_BYTE*)a1, 1, 0, 1, 0, 1, -20);
                        if (*(_DWORD*)(a1 + 444) == 6 && *(_DWORD*)(a1 + 304))
                            *(_DWORD*)(a1 + 424) = sub_425D70(*(_DWORD**)(a1 + 304));
                        if (*(int*)(a1 + 444) >= 6)
                        {
                            if (*(int*)(a1 + 444) >= 66)
                            {
                                if (*(int*)(a1 + 444) >= 86)
                                {
                                    if (*(int*)(a1 + 444) >= 96)
                                        *(_WORD*)(a1 + 204) = 25;
                                    else
                                        *(_WORD*)(a1 + 204) = 258;
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 259;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = (*(_DWORD*)(a1 + 444) - 6) / 10 % 2 + 258;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 257;
                        }
                        if (*(_DWORD*)(a1 + 304))
                        {
                            if (*(int*)(a1 + 444) < 6 || *(int*)(a1 + 444) >= 66 || (*(_DWORD*)(a1 + 444) - 6) % 10)
                            {
                                if (*(_DWORD*)(a1 + 444) == 86)
                                {
                                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A10, -1, 100, 100, 0);
                                    sub_41261C(*(_WORD**)(a1 + 304), *(unsigned __int16*)(a1 + 242), a1, 1);
                                    *(_DWORD*)(a1 + 304) = 0;
                                    sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                                }
                            }
                            else
                            {
                                sub_43FFC3((int*)unk_4BDB28, dword_4B9ADC, -1, 100, 100, 0);
                                v287 = *(unsigned __int16*)(a1 + 242) / 6;
                                if (!v287)
                                    v287 = 1;
                                sub_41261C(*(_WORD**)(a1 + 304), v287, a1, 1);
                            }
                        }
                        if (*(_DWORD*)(a1 + 444) == 96)
                        {
                            *(_DWORD*)(a1 + 360) = 0;
                            *(_DWORD*)(a1 + 356) = 0;
                            *(_DWORD*)(a1 + 352) = 0;
                            *(_DWORD*)(a1 + 348) = 0;
                            *(_DWORD*)(a1 + 344) = 0;
                            *(_DWORD*)(a1 + 340) = 0;
                            *(_DWORD*)(a1 + 376) = 0;
                            *(_DWORD*)(a1 + 372) = 0;
                            *(_DWORD*)(a1 + 340) = 200 * ((*(_DWORD*)(a1 + 424) == 0) - *(_DWORD*)(a1 + 424));
                            *(_DWORD*)(a1 + 348) = -300;
                            *(_DWORD*)(a1 + 360) = 30;
                        }
                        return;
                    }
                    if (*(_DWORD*)(a1 + 428) == 121)
                    {
                        if (*(_DWORD*)(a1 + 444) == 1)
                        {
                            *(_BYTE*)(a1 + 212) = 0;
                            *(_DWORD*)(a1 + 360) = 0;
                            *(_DWORD*)(a1 + 356) = 0;
                            *(_DWORD*)(a1 + 352) = 0;
                            *(_DWORD*)(a1 + 348) = 0;
                            *(_DWORD*)(a1 + 344) = 0;
                            *(_DWORD*)(a1 + 340) = 0;
                            *(_DWORD*)(a1 + 376) = 0;
                            *(_DWORD*)(a1 + 372) = 0;
                            sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                            if (*(_DWORD*)(a1 + 304))
                                *(_BYTE*)(a1 + 223) = sub_426030(*(_BYTE**)(a1 + 304)) - 1;
                        }
                        if (*(int*)(a1 + 444) > 1
                            && *(int*)(a1 + 444) < 86
                            && (!*(_DWORD*)(a1 + 304)
                                || Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) != (struct Concurrency::ISchedulerProxy*)107))
                        {
                            *(_DWORD*)(a1 + 304) = 0;
                            sub_417C83(a1);
                        }
                        if (*(int*)(a1 + 444) >= 6)
                        {
                            if (*(int*)(a1 + 444) >= 66)
                            {
                                if (*(int*)(a1 + 444) >= 86)
                                {
                                    if (*(int*)(a1 + 444) >= 96)
                                    {
                                        if (*(int*)(a1 + 444) >= 100)
                                        {
                                            if (*(int*)(a1 + 444) < 104)
                                                *(_WORD*)(a1 + 204) = 17;
                                        }
                                        else
                                        {
                                            *(_WORD*)(a1 + 204) = 16;
                                        }
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 13;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 15;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = (*(_DWORD*)(a1 + 444) - 6) / 10 % 2 + 13;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 15;
                        }
                        if (*(int*)(a1 + 444) >= 108)
                        {
                            *(_DWORD*)(a1 + 304) = 0;
                            *(_DWORD*)(a1 + 432) = 44;
                        }
                        return;
                    }
                    if (*(_DWORD*)(a1 + 428) == 108)
                    {
                        if (*(_DWORD*)(a1 + 444) == 1)
                        {
                            *(_BYTE*)(a1 + 212) = 0;
                            memset((void*)(a1 + 453), 0, 8u);
                            memset((void*)(a1 + 461), 0, 8u);
                            *(_DWORD*)(a1 + 372) = 0;
                            *(_DWORD*)(a1 + 376) = 0;
                            *(_DWORD*)(a1 + 340) = 0;
                            *(_DWORD*)(a1 + 344) = 0;
                            *(_DWORD*)(a1 + 352) = 0;
                            *(_DWORD*)(a1 + 356) = 0;
                            *(_DWORD*)(a1 + 436) = 0;
                            if (!*(_BYTE*)(a1 + 195)
                                || *(_BYTE*)(a1 + 195) == 1
                                || *(_BYTE*)(a1 + 195) == 2
                                || *(_BYTE*)(a1 + 195) == 3)
                            {
                                sub_4175B4(a1, 1);
                            }
                            v286 = sub_41CCEA(a1, 1) / 3 + 10;
                            if (*(_BYTE*)(a1 + 258) == 1)
                            {
                                v286 = 12 * v286 / 10;
                            }
                            else if (*(_BYTE*)(a1 + 258) == 2)
                            {
                                v286 /= 2;
                            }
                            if (!v286)
                                v286 = 1;
                            if (*(_DWORD*)(a1 + 304))
                                sub_41EF8A(*(_WORD**)(a1 + 304), v286);
                        }
                        if (*(int*)(a1 + 444) > 1
                            && *(_DWORD*)(a1 + 304)
                            && Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) != (struct Concurrency::ISchedulerProxy*)122)
                        {
                            *(_DWORD*)(a1 + 304) = 0;
                        }
                        if (*(int*)(a1 + 444) >= 6)
                        {
                            if (*(int*)(a1 + 444) >= 12)
                            {
                                if (*(int*)(a1 + 444) >= 16)
                                {
                                    if (*(int*)(a1 + 444) >= 26)
                                    {
                                        if (*(int*)(a1 + 444) >= 30)
                                        {
                                            if (*(int*)(a1 + 444) >= 32)
                                            {
                                                if (*(int*)(a1 + 444) >= 34)
                                                {
                                                    if (*(int*)(a1 + 444) >= 36)
                                                    {
                                                        if (*(int*)(a1 + 444) >= 46)
                                                        {
                                                            if (*(int*)(a1 + 444) >= 50)
                                                                *(_WORD*)(a1 + 204) = 25;
                                                            else
                                                                *(_WORD*)(a1 + 204) = 272;
                                                        }
                                                        else
                                                        {
                                                            *(_WORD*)(a1 + 204) = 271;
                                                        }
                                                    }
                                                    else
                                                    {
                                                        *(_WORD*)(a1 + 204) = 270;
                                                    }
                                                }
                                                else
                                                {
                                                    *(_WORD*)(a1 + 204) = 269;
                                                }
                                            }
                                            else
                                            {
                                                *(_WORD*)(a1 + 204) = 268;
                                            }
                                        }
                                        else
                                        {
                                            *(_WORD*)(a1 + 204) = 267;
                                        }
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 25;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 6;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 121;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 31;
                        }
                        switch (*(_DWORD*)(a1 + 444))
                        {
                        case 0xC:
                            *(_DWORD*)(a1 + 424) = *(_DWORD*)(a1 + 424) == 0;
                            break;
                        case 0x10:
                            *(_DWORD*)(a1 + 348) = -700;
                            *(_DWORD*)(a1 + 360) = 30;
                            *(_DWORD*)(a1 + 392) = 1;
                            sub_43FFC3((int*)unk_4BDB28, dword_4B9A04, -1, 100, 100, 0);
                            break;
                        case 0x24:
                            *(_DWORD*)(a1 + 436) = 1;
                            *(_DWORD*)(a1 + 304) = 0;
                            sub_43FFC3((int*)unk_4BDB28, dword_4B9A70, -1, 100, 100, 0);
                            break;
                        }
                        if (*(int*)(a1 + 444) < 36 && !*(_DWORD*)(a1 + 304))
                        {
                            if (*(_DWORD*)(a1 + 392))
                                *(_DWORD*)(a1 + 432) = 50;
                            else
                                *(_DWORD*)(a1 + 432) = 4;
                        }
                        return;
                    }
                    if (*(_DWORD*)(a1 + 428) == 122)
                    {
                        if (*(_DWORD*)(a1 + 444) == 1)
                        {
                            *(_BYTE*)(a1 + 212) = 0;
                            memset((void*)(a1 + 453), 0, 8u);
                            memset((void*)(a1 + 461), 0, 8u);
                            *(_DWORD*)(a1 + 372) = 0;
                            *(_DWORD*)(a1 + 376) = 0;
                            *(_DWORD*)(a1 + 340) = 0;
                            *(_DWORD*)(a1 + 344) = 0;
                            *(_DWORD*)(a1 + 352) = 0;
                            *(_DWORD*)(a1 + 356) = 0;
                            *(_DWORD*)(a1 + 392) = 1;
                            sub_423CF2((_BYTE*)a1, 1, -16, 1, 0, 0, 0);
                        }
                        else if (*(_DWORD*)(a1 + 444) == 12)
                        {
                            sub_423CF2((_BYTE*)a1, 1, 16, 1, 0, 0, 0);
                        }
                        if (*(int*)(a1 + 444) >= 6)
                        {
                            *(_WORD*)(a1 + 204) = (*(_DWORD*)(a1 + 444) - 6) / 4 % 4 + 20;
                            if (*(_DWORD*)(a1 + 304))
                            {
                                if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) == (struct Concurrency::ISchedulerProxy*)108
                                    && sub_426010(*(_DWORD**)(a1 + 304)) == 1)
                                {
                                    *(_DWORD*)(a1 + 432) = 169;
                                    sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                                }
                                if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) != (struct Concurrency::ISchedulerProxy*)108)
                                {
                                    sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                                    *(_DWORD*)(a1 + 304) = 0;
                                }
                            }
                            else
                            {
                                sub_423CF2((_BYTE*)a1, 0, 0, 0, 0, 0, 0);
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 16;
                        }
                        if (*(_DWORD*)(a1 + 444) == 6)
                        {
                            *(_DWORD*)(a1 + 348) = -700;
                            *(_DWORD*)(a1 + 360) = 30;
                            *(_DWORD*)(a1 + 392) = 1;
                        }
                        return;
                    }
                    if (*(_DWORD*)(a1 + 428) == 200)
                    {
                        if (*(_DWORD*)(a1 + 444) == 1)
                        {
                            *(_BYTE*)(a1 + 257) = 2;
                            *(_BYTE*)(a1 + 252) = 0;
                            if (*(char*)(a1 + 224) <= 0)
                                v234 = (*(char*)(a1 + 224) >= 0) - 1;
                            else
                                v234 = 1;
                            if (*(char*)(a1 + 225) <= 0)
                                v233 = (*(char*)(a1 + 225) >= 0) - 1;
                            else
                                v233 = 1;
                            *(_DWORD*)(a1 + 440) = v234 + 8 * v233 + 9;
                            sub_43FFC3((int*)unk_4BDB28, dword_4B9AE8, -1, 100, 100, 0);
                        }
                        *(_BYTE*)(a1 + 212) = 0;
                        *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 4 % 2 + 273;
                        if (*(_DWORD*)(a1 + 444) == 16)
                        {
                            sub_42526D((_DWORD*)a1, *(_DWORD*)(a1 + 436));
                            *(_BYTE*)(a1 + 252) = 1;
                        }
                        if (*(int*)(a1 + 444) >= 32)
                            *(_DWORD*)(a1 + 432) = 50;
                        return;
                    }
                    if (*(_DWORD*)(a1 + 428) == 204)
                    {
                        if (*(_DWORD*)(a1 + 444) == 1)
                        {
                            *(_DWORD*)(a1 + 380) = 0;
                            *(_DWORD*)(a1 + 436) = 0;
                            *(_BYTE*)(a1 + 212) = 0;
                            *(_BYTE*)(a1 + 248) = 2;
                            v232 = (double)sub_41CCEA(a1, 1) * 1.5;
                            v212 = sub_41CCEA(a1, 1);
                            v213 = (double)(v212 * sub_41D067(a1, 1) / 200) + v232;
                            sub_41F169((_WORD*)a1, (__int64)v213);
                            *(_BYTE*)(a1 + 213) = -1;
                            memset((void*)(a1 + 453), 0, 8u);
                            memset((void*)(a1 + 461), 0, 8u);
                            *(_BYTE*)(a1 + 257) = 1;
                            *(_BYTE*)(a1 + 212) = 1;
                            *(_BYTE*)(a1 + 452) = 5;
                            *(_BYTE*)(a1 + 259) = 1;
                            *(_BYTE*)(a1 + 260) = 1;
                        }
                        if (*(_DWORD*)(a1 + 444) == 2)
                        {
                            *(_BYTE*)(a1 + 248) = 13 - 10 * (*(_DWORD*)(a1 + 436) == 2);
                            *(_DWORD*)(a1 + 372) = 0;
                            *(_DWORD*)(a1 + 376) = 0;
                            *(_DWORD*)(a1 + 340) = (350 * (*(_DWORD*)(a1 + 436) == 2) + 350)
                                * (*(_DWORD*)(a1 + 424) - (*(_DWORD*)(a1 + 424) == 0));
                            *(_DWORD*)(a1 + 344) = 0;
                            *(_DWORD*)(a1 + 348) = -350 - 150 * (*(_DWORD*)(a1 + 436) == 2);
                            *(_DWORD*)(a1 + 352) = -*(_DWORD*)(a1 + 340) / 20;
                            *(_DWORD*)(a1 + 360) = 30;
                            *(_DWORD*)(a1 + 392) = 1;
                            sub_43FFC3((int*)unk_4BDB28, dword_4B9A3C, -1, 100, 100, 0);
                        }
                        if (*(int*)(a1 + 444) > 2
                            && (!*(_DWORD*)(a1 + 424) && *(int*)(a1 + 372) > 0 || *(_DWORD*)(a1 + 424) && *(int*)(a1 + 372) < 0))
                        {
                            *(_DWORD*)(a1 + 372) = 0;
                            *(_DWORD*)(a1 + 340) = 0;
                            *(_DWORD*)(a1 + 352) = 0;
                        }
                        if (*(int*)(a1 + 436) >= 2)
                        {
                            if (*(_DWORD*)(a1 + 444) == 20)
                            {
                                *(_DWORD*)(a1 + 352) = 0;
                                *(int*)(a1 + 340) /= 2;
                            }
                        }
                        else if (*(_DWORD*)(a1 + 444) == 15)
                        {
                            *(_DWORD*)(a1 + 352) = 0;
                            *(int*)(a1 + 340) /= 2;
                        }
                        if (*(_DWORD*)(a1 + 436) && *(_DWORD*)(a1 + 436) != 2)
                        {
                            if (*(int*)(a1 + 444) >= 21)
                                *(_WORD*)(a1 + 204) = 4;
                            else
                                *(_WORD*)(a1 + 204) = 91;
                        }
                        else if (*(_DWORD*)(a1 + 444) == 1)
                        {
                            *(_WORD*)(a1 + 204) = 72;
                        }
                        else if (*(int*)(a1 + 444) >= 21)
                        {
                            *(_WORD*)(a1 + 204) = 4;
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 90;
                        }
                        if (*(_DWORD*)(a1 + 444) % 4 > 1 && *(int*)(a1 + 444) < 20)
                            *(_WORD*)(a1 + 204) = 92;
                        return;
                    }
                    if (*(_DWORD*)(a1 + 428) == 205)
                    {
                        switch (*(_DWORD*)(a1 + 444))
                        {
                        case 1:
                            *(_DWORD*)(a1 + 392) = 1;
                            *(_DWORD*)(a1 + 372) = 0;
                            *(_DWORD*)(a1 + 376) = 0;
                            *(_DWORD*)(a1 + 340) = 0;
                            *(_DWORD*)(a1 + 344) = 0;
                            *(_DWORD*)(a1 + 352) = 0;
                            *(_DWORD*)(a1 + 348) = -80;
                            *(_DWORD*)(a1 + 360) = 2;
                            *(_BYTE*)(a1 + 250) = 12;
                            memset((void*)(a1 + 453), 0, 8u);
                            memset((void*)(a1 + 461), 0, 8u);
                            *(_BYTE*)(a1 + 257) = 1;
                            *(_BYTE*)(a1 + 212) = 0;
                            *(_BYTE*)(a1 + 248) = 1;
                            *(_BYTE*)(a1 + 259) = 1;
                            v231 = (double)sub_41CCEA(a1, 1) * 1.25;
                            v214 = sub_41CCEA(a1, 1);
                            v215 = (double)(v214 * sub_41D067(a1, 1) / 200) + v231;
                            sub_41F169((_WORD*)a1, (__int64)v215);
                            *(_BYTE*)(a1 + 213) = -1;
                            *(_BYTE*)(a1 + 452) = 8;
                            *(_BYTE*)(a1 + 248) = 12;
                            if (*(unsigned __int8*)(a1 + 238) <= 1u && sub_41BA53(a1, 0x86u, 0))
                                *(_DWORD*)(a1 + 400) = 1;
                            break;
                        case 2:
                        case 0x28:
                            sub_43FFC3((int*)unk_4BDB28, dword_4B9A38, -1, 100, 100, 0);
                            break;
                        case 5:
                            *(_DWORD*)(a1 + 400) = 0;
                            break;
                        }
                        *(_BYTE*)(a1 + 212) = 1;
                        if (*(int*)(a1 + 444) >= 80)
                        {
                            *(_BYTE*)(a1 + 257) = 2;
                            *(_DWORD*)(a1 + 360) = 30;
                            *(_WORD*)(a1 + 204) = 4;
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 4 % 4 + 68;
                            if (*(_DWORD*)(a1 + 444) % 6 > 2)
                                *(_WORD*)(a1 + 204) = *(_DWORD*)(a1 + 444) / 4 % 4 + 93;
                        }
                        return;
                    }
                    if (*(_DWORD*)(a1 + 428) == 206)
                    {
                        if (*(_DWORD*)(a1 + 444) == 1)
                        {
                            *(_DWORD*)(a1 + 392) = 0;
                            *(_DWORD*)(a1 + 380) = 0;
                            *(_DWORD*)(a1 + 372) = 0;
                            *(_DWORD*)(a1 + 376) = 0;
                            *(_DWORD*)(a1 + 340) = 0;
                            *(_DWORD*)(a1 + 344) = 0;
                            *(_DWORD*)(a1 + 352) = 0;
                            *(_DWORD*)(a1 + 348) = 0;
                            *(_DWORD*)(a1 + 360) = 0;
                            memset((void*)(a1 + 453), 0, 8u);
                            memset((void*)(a1 + 461), 0, 8u);
                            *(_BYTE*)(a1 + 257) = 1;
                            *(_BYTE*)(a1 + 212) = 0;
                            *(_BYTE*)(a1 + 248) = 0;
                            *(_BYTE*)(a1 + 259) = 1;
                            *(_BYTE*)(a1 + 260) = 1;
                            v230 = (double)sub_41CB3B(a1, 1) * 1.25;
                            v216 = sub_41CB3B(a1, 1);
                            v217 = (double)(v216 * sub_41D067(a1, 1) / 200) + v230;
                            sub_41F169((_WORD*)a1, (__int64)v217);
                            *(_BYTE*)(a1 + 213) = -1;
                        }
                        *(_BYTE*)(a1 + 212) = 1;
                        if (*(int*)(a1 + 444) >= 4)
                        {
                            if (*(int*)(a1 + 444) >= 10)
                            {
                                if (*(int*)(a1 + 444) >= 30)
                                {
                                    if (*(int*)(a1 + 444) >= 32)
                                    {
                                        if (*(int*)(a1 + 444) >= 34)
                                        {
                                            if (*(int*)(a1 + 444) >= 36)
                                            {
                                                if (*(int*)(a1 + 444) >= 38)
                                                {
                                                    if (*(int*)(a1 + 444) >= 40)
                                                        *(_WORD*)(a1 + 204) = 105;
                                                    else
                                                        *(_WORD*)(a1 + 204) = 101;
                                                }
                                                else
                                                {
                                                    *(_WORD*)(a1 + 204) = 100;
                                                }
                                            }
                                            else
                                            {
                                                *(_WORD*)(a1 + 204) = 99;
                                            }
                                        }
                                        else
                                        {
                                            *(_WORD*)(a1 + 204) = 104;
                                        }
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 103;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 114;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 113;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 112;
                        }
                        if (*(_DWORD*)(a1 + 444) != 4)
                        {
                            if (*(_DWORD*)(a1 + 444) == 10)
                            {
                                sub_43FFC3((int*)unk_4BDB28, dword_4B9A40, -1, 100, 100, 0);
                                *(_BYTE*)(a1 + 248) = 5;
                                *(_DWORD*)(a1 + 392) = 1;
                                *(_DWORD*)(a1 + 340) = 200 * (*(_DWORD*)(a1 + 424) - (*(_DWORD*)(a1 + 424) == 0));
                                *(_DWORD*)(a1 + 352) = -*(_DWORD*)(a1 + 340) / 20;
                                *(_DWORD*)(a1 + 348) = -600;
                                *(_DWORD*)(a1 + 360) = 30;
                            }
                            else if (*(_DWORD*)(a1 + 444) == 30)
                            {
                                *(_DWORD*)(a1 + 372) = 0;
                                *(_DWORD*)(a1 + 340) = 0;
                                *(_DWORD*)(a1 + 352) = 0;
                            }
                            return;
                        }
                    }
                    else
                    {
                        if (*(_DWORD*)(a1 + 428) != 201)
                        {
                            if (*(_DWORD*)(a1 + 428) == 202)
                            {
                                if (*(_DWORD*)(a1 + 444) == 1)
                                {
                                    *(_DWORD*)(a1 + 392) = 1;
                                    *(_DWORD*)(a1 + 372) = 0;
                                    *(_DWORD*)(a1 + 376) = 0;
                                    *(_DWORD*)(a1 + 340) = 0;
                                    *(_DWORD*)(a1 + 344) = 0;
                                    *(_DWORD*)(a1 + 352) = 0;
                                    *(_DWORD*)(a1 + 348) = -100;
                                    *(_DWORD*)(a1 + 360) = 5;
                                    *(_BYTE*)(a1 + 250) = 12;
                                    memset((void*)(a1 + 453), 0, 8u);
                                    memset((void*)(a1 + 461), 0, 8u);
                                    *(_BYTE*)(a1 + 257) = 1;
                                    *(_BYTE*)(a1 + 212) = 0;
                                    *(_BYTE*)(a1 + 248) = 1;
                                    v228 = (double)sub_41CCEA(a1, 1) * 1.25;
                                    v220 = sub_41CCEA(a1, 1);
                                    v221 = (double)(v220 * sub_41D067(a1, 1) / 200) + v228;
                                    sub_41F169((_WORD*)a1, (__int64)v221);
                                    *(_BYTE*)(a1 + 213) = -1;
                                    if (*(_BYTE*)(a1 + 188) == 2 || *(_BYTE*)(a1 + 188) == 3)
                                    {
                                        *(_BYTE*)(a1 + 452) = 8;
                                        *(_BYTE*)(a1 + 248) = 12;
                                        sub_4239D3(a1, 5);
                                    }
                                    if (*(_DWORD*)(a1 + 436) == 1 && *(_DWORD*)(a1 + 304))
                                    {
                                        *(_DWORD*)(a1 + 328) = sub_426090(*(_DWORD**)(a1 + 304));
                                        *(_DWORD*)(a1 + 332) = sub_4260B0(*(_DWORD**)(a1 + 304));
                                        *(_DWORD*)(a1 + 336) = sub_4260D0(*(_DWORD**)(a1 + 304));
                                    }
                                    sub_43FFC3((int*)unk_4BDB28, dword_4B9A38, -1, 100, 100, 0);
                                }
                                *(_BYTE*)(a1 + 212) = 1;
                                if (*(int*)(a1 + 444) >= 40)
                                {
                                    *(_DWORD*)(a1 + 304) = 0;
                                    *(_BYTE*)(a1 + 257) = 2;
                                    *(_DWORD*)(a1 + 360) = 30;
                                    *(_WORD*)(a1 + 204) = 4;
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = (*(_DWORD*)(a1 + 444) / 4 + 2 * *(_DWORD*)(a1 + 436)) % 4 + 68;
                                }
                                if (*(_WORD*)(a1 + 204) == 69 || *(_WORD*)(a1 + 204) == 70)
                                    *(_BYTE*)(a1 + 223) = 127;
                                else
                                    *(_BYTE*)(a1 + 223) = 0x80;
                            }
                            return;
                        }
                        if (*(_DWORD*)(a1 + 444) == 1)
                        {
                            *(_DWORD*)(a1 + 392) = 0;
                            *(_DWORD*)(a1 + 372) = 0;
                            *(_DWORD*)(a1 + 376) = 0;
                            *(_DWORD*)(a1 + 340) = 0;
                            *(_DWORD*)(a1 + 344) = 0;
                            *(_DWORD*)(a1 + 352) = 0;
                            *(_DWORD*)(a1 + 348) = 0;
                            *(_DWORD*)(a1 + 360) = 0;
                            memset((void*)(a1 + 453), 0, 8u);
                            memset((void*)(a1 + 461), 0, 8u);
                            *(_BYTE*)(a1 + 251) = 0;
                            *(_BYTE*)(a1 + 257) = 1;
                            *(_BYTE*)(a1 + 212) = 0;
                            *(_BYTE*)(a1 + 248) = 7;
                            *(_BYTE*)(a1 + 259) = 1;
                            *(_BYTE*)(a1 + 452) = -1;
                            *(_BYTE*)(a1 + 260) = 1;
                            v229 = (double)sub_41CB3B(a1, 1) * 2.5;
                            v218 = sub_41CB3B(a1, 1);
                            v219 = (double)(v218 * sub_41D067(a1, 1) / 100) + v229;
                            sub_41F169((_WORD*)a1, (__int64)v219);
                            *(_BYTE*)(a1 + 213) = -1;
                        }
                        *(_BYTE*)(a1 + 212) = 1;
                        if (*(_DWORD*)(a1 + 444) == 1)
                        {
                            *(_WORD*)(a1 + 204) = 113;
                        }
                        else if (*(int*)(a1 + 444) >= 4)
                        {
                            if (*(int*)(a1 + 444) >= 8)
                            {
                                if (*(int*)(a1 + 444) >= 28)
                                {
                                    if (*(int*)(a1 + 444) >= 32)
                                    {
                                        if (*(int*)(a1 + 444) >= 36)
                                            *(_WORD*)(a1 + 204) = 111;
                                        else
                                            *(_WORD*)(a1 + 204) = 110;
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 109;
                                    }
                                }
                                else
                                {
                                    *(_BYTE*)(a1 + 251) = 1;
                                    *(_WORD*)(a1 + 204) = 108;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 107;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 106;
                        }
                        if (*(_DWORD*)(a1 + 444) != 4)
                        {
                            if (*(_DWORD*)(a1 + 444) == 8)
                            {
                                sub_43FFC3((int*)unk_4BDB28, dword_4B9A40, -1, 100, 100, 0);
                                *(_DWORD*)(a1 + 392) = 1;
                                *(_DWORD*)(a1 + 340) = 200 * (*(_DWORD*)(a1 + 424) - (*(_DWORD*)(a1 + 424) == 0));
                                *(_DWORD*)(a1 + 352) = -*(_DWORD*)(a1 + 340) / 20;
                                *(_DWORD*)(a1 + 348) = -600;
                                *(_DWORD*)(a1 + 360) = 30;
                            }
                            else if (*(_DWORD*)(a1 + 444) == 28)
                            {
                                *(_DWORD*)(a1 + 372) = 0;
                                *(_DWORD*)(a1 + 340) = 0;
                                *(_DWORD*)(a1 + 352) = 0;
                            }
                            return;
                        }
                    }
                }
            LABEL_3441:
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A24, -1, 100, 100, 0);
                return;
            }
            if (*(_DWORD*)(a1 + 444) == 1)
            {
                if (*(_DWORD*)(a1 + 480))
                {
                    v186 = sub_41CB3B(a1, 1);
                    v187 = sub_43E620((short*)*(_DWORD*)(a1 + 480));
                    sub_41F169((_WORD*)a1, v186 * v187 / 200);
                }
                else
                {
                    v188 = sub_41CB3B(a1, 1);
                    sub_41F169((_WORD*)a1, 75 * v188 / 100);
                }
                if (*(_DWORD*)(a1 + 392))
                {
                    v189 = (unsigned __int16)sub_4261B0((short*)a1);
                    v190 = (unsigned __int16)sub_4261B0((short*)a1);
                    v191 = sub_41D067(a1, 1);
                    sub_41F169((_WORD*)a1, v190 * v191 / 200 + v189);
                }
                *(_BYTE*)(a1 + 257) = 1;
                *(_BYTE*)(a1 + 248) = -1;
                *(_BYTE*)(a1 + 212) = 1;
                *(_BYTE*)(a1 + 213) = -1;
                if (!*(_DWORD*)(a1 + 392) || *(unsigned __int8*)(a1 + 238) <= 1u && sub_41BA53(a1, 0x86u, 0))
                {
                    *(_DWORD*)(a1 + 400) = 1;
                    if (!*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 408) = 1;
                }
            }
            if (*(_DWORD*)(a1 + 444) == 5)
            {
                *(_DWORD*)(a1 + 400) = 0;
                *(_DWORD*)(a1 + 408) = 0;
            }
            if (!*(_DWORD*)(a1 + 480))
            {
                if (*(_BYTE*)(a1 + 195))
                {
                    switch (*(_BYTE*)(a1 + 195))
                    {
                    case 1:
                        if (*(_DWORD*)(a1 + 444) == 4 || *(_DWORD*)(a1 + 444) == 11 || *(_DWORD*)(a1 + 444) == 18)
                        {
                            memset((void*)(a1 + 453), 0, 8u);
                            memset((void*)(a1 + 461), 0, 8u);
                        }
                        if (*(int*)(a1 + 444) >= 4)
                        {
                            if (*(int*)(a1 + 444) >= 7)
                            {
                                if (*(int*)(a1 + 444) >= 11)
                                {
                                    if (*(int*)(a1 + 444) >= 14)
                                    {
                                        if (*(int*)(a1 + 444) >= 20)
                                        {
                                            if (*(int*)(a1 + 444) >= 23)
                                            {
                                                if (*(int*)(a1 + 444) >= 26)
                                                {
                                                    *(_BYTE*)(a1 + 257) = 2;
                                                    *(_WORD*)(a1 + 204) = 27;
                                                }
                                                else
                                                {
                                                    *(_WORD*)(a1 + 204) = 26;
                                                }
                                            }
                                            else
                                            {
                                                *(_BYTE*)(a1 + 248) = 0;
                                                *(_WORD*)(a1 + 204) = 25;
                                            }
                                        }
                                        else
                                        {
                                            *(_WORD*)(a1 + 204) = 24;
                                        }
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 1;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 0;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 1;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 0;
                        }
                        if (*(_DWORD*)(a1 + 444) == 4 || *(_DWORD*)(a1 + 444) == 11 || *(_DWORD*)(a1 + 444) == 20)
                            sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                        if (*(_DWORD*)(a1 + 444) == 20)
                        {
                            v195 = sub_41CB3B(a1, 1);
                            sub_41F169((_WORD*)a1, 85 * v195 / 100);
                        }
                        else if (*(_DWORD*)(a1 + 444) == 28)
                        {
                            *(_DWORD*)(a1 + 404) = 1;
                        }
                        if (*(int*)(a1 + 444) > 32)
                        {
                            if (*(_DWORD*)(a1 + 392))
                                *(_DWORD*)(a1 + 432) = 50;
                            else
                                *(_DWORD*)(a1 + 432) = 4;
                        }
                        break;
                    case 2:
                        if (*(_DWORD*)(a1 + 444) == 4 || *(_DWORD*)(a1 + 444) == 12 || *(_DWORD*)(a1 + 444) == 23)
                        {
                            memset((void*)(a1 + 453), 0, 8u);
                            memset((void*)(a1 + 461), 0, 8u);
                        }
                        if (*(int*)(a1 + 444) >= 4)
                        {
                            if (*(int*)(a1 + 444) >= 8)
                            {
                                if (*(int*)(a1 + 444) >= 12)
                                {
                                    if (*(int*)(a1 + 444) >= 16)
                                    {
                                        if (*(int*)(a1 + 444) >= 23)
                                        {
                                            if (*(int*)(a1 + 444) >= 27)
                                            {
                                                if (*(int*)(a1 + 444) >= 31)
                                                {
                                                    *(_BYTE*)(a1 + 257) = 2;
                                                    *(_WORD*)(a1 + 204) = 27;
                                                }
                                                else
                                                {
                                                    *(_WORD*)(a1 + 204) = 26;
                                                }
                                            }
                                            else
                                            {
                                                *(_BYTE*)(a1 + 248) = 0;
                                                *(_WORD*)(a1 + 204) = 25;
                                            }
                                        }
                                        else
                                        {
                                            *(_WORD*)(a1 + 204) = 24;
                                        }
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 2;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 1;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 2;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 1;
                        }
                        if (*(_DWORD*)(a1 + 444) == 4 || *(_DWORD*)(a1 + 444) == 12 || *(_DWORD*)(a1 + 444) == 23)
                            sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                        if (*(_DWORD*)(a1 + 444) == 23)
                        {
                            v196 = sub_41CB3B(a1, 1);
                            sub_41F169((_WORD*)a1, 85 * v196 / 100);
                        }
                        else if (*(_DWORD*)(a1 + 444) == 33)
                        {
                            *(_DWORD*)(a1 + 404) = 1;
                        }
                        if (*(int*)(a1 + 444) >= 36)
                        {
                            if (*(_DWORD*)(a1 + 392))
                                *(_DWORD*)(a1 + 432) = 50;
                            else
                                *(_DWORD*)(a1 + 432) = 4;
                        }
                        break;
                    case 3:
                        if (*(_DWORD*)(a1 + 444) == 4 || *(_DWORD*)(a1 + 444) == 12 || *(_DWORD*)(a1 + 444) == 23)
                        {
                            memset((void*)(a1 + 453), 0, 8u);
                            memset((void*)(a1 + 461), 0, 8u);
                        }
                        if (*(int*)(a1 + 444) >= 4)
                        {
                            if (*(int*)(a1 + 444) >= 8)
                            {
                                if (*(int*)(a1 + 444) >= 12)
                                {
                                    if (*(int*)(a1 + 444) >= 16)
                                    {
                                        if (*(int*)(a1 + 444) >= 23)
                                        {
                                            if (*(int*)(a1 + 444) >= 27)
                                            {
                                                if (*(int*)(a1 + 444) >= 31)
                                                {
                                                    *(_BYTE*)(a1 + 257) = 2;
                                                    *(_WORD*)(a1 + 204) = 30;
                                                }
                                                else
                                                {
                                                    *(_WORD*)(a1 + 204) = 29;
                                                }
                                            }
                                            else
                                            {
                                                *(_BYTE*)(a1 + 248) = 0;
                                                *(_WORD*)(a1 + 204) = 28;
                                            }
                                        }
                                        else
                                        {
                                            *(_WORD*)(a1 + 204) = 27;
                                        }
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 2;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 1;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 2;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 1;
                        }
                        if (*(_DWORD*)(a1 + 444) == 4 || *(_DWORD*)(a1 + 444) == 12 || *(_DWORD*)(a1 + 444) == 23)
                            sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                        if (*(_DWORD*)(a1 + 444) == 23)
                        {
                            v197 = sub_41CB3B(a1, 1);
                            sub_41F169((_WORD*)a1, 85 * v197 / 100);
                        }
                        else if (*(_DWORD*)(a1 + 444) == 33)
                        {
                            *(_DWORD*)(a1 + 404) = 1;
                        }
                        if (*(int*)(a1 + 444) >= 36)
                        {
                            if (*(_DWORD*)(a1 + 392))
                                *(_DWORD*)(a1 + 432) = 50;
                            else
                                *(_DWORD*)(a1 + 432) = 4;
                        }
                        break;
                    }
                }
                else
                {
                    if (*(_DWORD*)(a1 + 444) == 4 || *(_DWORD*)(a1 + 444) == 12 || *(_DWORD*)(a1 + 444) == 22)
                    {
                        memset((void*)(a1 + 453), 0, 8u);
                        memset((void*)(a1 + 461), 0, 8u);
                    }
                    if (*(int*)(a1 + 444) >= 4)
                    {
                        if (*(int*)(a1 + 444) >= 8)
                        {
                            if (*(int*)(a1 + 444) >= 12)
                            {
                                if (*(int*)(a1 + 444) >= 16)
                                {
                                    if (*(int*)(a1 + 444) >= 22)
                                    {
                                        if (*(int*)(a1 + 444) >= 25)
                                        {
                                            if (*(int*)(a1 + 444) >= 28)
                                            {
                                                *(_BYTE*)(a1 + 257) = 2;
                                                *(_WORD*)(a1 + 204) = 23;
                                            }
                                            else
                                            {
                                                *(_WORD*)(a1 + 204) = 22;
                                            }
                                        }
                                        else
                                        {
                                            *(_BYTE*)(a1 + 248) = 0;
                                            *(_WORD*)(a1 + 204) = 21;
                                        }
                                    }
                                    else
                                    {
                                        *(_WORD*)(a1 + 204) = 20;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 3;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 2;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 3;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 2;
                    }
                    if (*(_DWORD*)(a1 + 444) == 4 || *(_DWORD*)(a1 + 444) == 12 || *(_DWORD*)(a1 + 444) == 20)
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
                    if (*(_DWORD*)(a1 + 444) == 20)
                    {
                        v194 = sub_41CB3B(a1, 1);
                        sub_41F169((_WORD*)a1, 85 * v194 / 100);
                    }
                    else if (*(_DWORD*)(a1 + 444) == 30)
                    {
                        *(_DWORD*)(a1 + 404) = 1;
                    }
                    if (*(int*)(a1 + 444) >= 36)
                    {
                        if (*(_DWORD*)(a1 + 392))
                            *(_DWORD*)(a1 + 432) = 50;
                        else
                            *(_DWORD*)(a1 + 432) = 4;
                    }
                }
                return;
            }
            if (*(_DWORD*)(a1 + 444) == 4 || *(_DWORD*)(a1 + 444) == 10 || *(_DWORD*)(a1 + 444) == 17)
            {
                memset((void*)(a1 + 453), 0, 8u);
                memset((void*)(a1 + 461), 0, 8u);
            }
            *(_BYTE*)(a1 + 212) = 0;
            if (*(int*)(a1 + 444) >= 2)
            {
                if (*(int*)(a1 + 444) >= 4)
                {
                    if (*(int*)(a1 + 444) >= 7)
                    {
                        if (*(int*)(a1 + 444) >= 10)
                        {
                            if (*(int*)(a1 + 444) >= 13)
                            {
                                if (*(int*)(a1 + 444) >= 17)
                                {
                                    if (*(int*)(a1 + 444) >= 20)
                                    {
                                        if (*(int*)(a1 + 444) >= 24)
                                        {
                                            *(_BYTE*)(a1 + 257) = 2;
                                            *(_WORD*)(a1 + 204) = 211;
                                        }
                                        else
                                        {
                                            *(_WORD*)(a1 + 204) = 210;
                                        }
                                    }
                                    else
                                    {
                                        *(_BYTE*)(a1 + 248) = 0;
                                        *(_WORD*)(a1 + 204) = 209;
                                    }
                                }
                                else
                                {
                                    *(_WORD*)(a1 + 204) = 208;
                                }
                            }
                            else
                            {
                                *(_WORD*)(a1 + 204) = 196;
                            }
                        }
                        else
                        {
                            *(_WORD*)(a1 + 204) = 195;
                        }
                    }
                    else
                    {
                        *(_WORD*)(a1 + 204) = 196;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 204) = 195;
                }
            }
            else
            {
                *(_WORD*)(a1 + 204) = 194;
            }
            if (*(_DWORD*)(a1 + 444) == 17)
            {
                v192 = sub_41CB3B(a1, 1);
                v193 = sub_43E620((short*)*(_DWORD*)(a1 + 480));
                sub_41F169((_WORD*)a1, v192 * v193 / 150);
            }
            else if (*(_DWORD*)(a1 + 444) == 26)
            {
                *(_DWORD*)(a1 + 404) = 1;
            }
            if (*(int*)(a1 + 444) >= 19 || (*(_DWORD*)(a1 + 444) - 2) % 6)
            {
                if (*(int*)(a1 + 444) >= 32)
                {
                    if (*(_DWORD*)(a1 + 392))
                        *(_DWORD*)(a1 + 432) = 50;
                    else
                        *(_DWORD*)(a1 + 432) = 3;
                }
                return;
            }
            break;
        }
        sub_43FFC3((int*)unk_4BDB28, dword_4B9A08, -1, 100, 100, 0);
        return;
    }
    if (*(_DWORD*)(a1 + 444) == 1)
    {
        if (*(_DWORD*)(a1 + 304))
        {
            v64 = sub_4175B4(a1, 1);
            sub_41EF8A(*(_WORD**)(a1 + 304), v64);
            sub_423CF2(*(_BYTE**)(a1 + 304), 0, 0, 0, 0, 0, 0);
        }
        v386 = (char*)sub_464AC9((char*)unk_4B9B10, (_BYTE*)a1, *(unsigned __int8**)(a1 + 304), 0);
        if (v386)
        {
            v383 = *(_DWORD*)(a1 + 328) - sub_426090((int*)v386);
            v384 = *(_DWORD*)(a1 + 332) - sub_4260B0((int*)v386);
            if (v383 <= 0)
                v259 = -v383;
            else
                v259 = v383;
            if (v384 <= 0)
                v258 = -v384;
            else
                v258 = v384;
            v385 = v259 - v258;
            if (v383 <= 0)
                v257 = -v383;
            else
                v257 = v383;
            if (v384 <= 0)
                v256 = -v384;
            else
                v256 = v384;
            if (v257 <= v256)
            {
                if (v384 <= 0)
                    *(_DWORD*)(a1 + 436) = 2;
                else
                    *(_DWORD*)(a1 + 436) = 1;
            }
            else
            {
                *(_DWORD*)(a1 + 436) = 0;
            }
            *(_DWORD*)(a1 + 424) = v383 < 0;
        }
        else
        {
            *(_DWORD*)(a1 + 436) = 0;
        }
    }
    if (*(int*)(a1 + 444) > 40
        || *(int*)(a1 + 444) < 21 && !*(_DWORD*)(a1 + 304)
        || *(int*)(a1 + 444) >= 2
        && *(int*)(a1 + 444) < 21
        && Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 304)) != (struct Concurrency::ISchedulerProxy*)87)
    {
        *(_DWORD*)(a1 + 304) = 0;
        *(_DWORD*)(a1 + 432) = 3;
    }
    *(_BYTE*)(a1 + 212) = 1;
    if (*(_DWORD*)(a1 + 304))
    {
        v380 = sub_426090(*(_DWORD**)(a1 + 304));
        v382 = sub_4260B0(*(_DWORD**)(a1 + 304));
        v381 = sub_4260D0(*(_DWORD**)(a1 + 304));
        if (*(int*)(a1 + 444) >= 16)
        {
            if (*(int*)(a1 + 444) >= 20)
            {
                if (*(int*)(a1 + 444) >= 24)
                    *(_WORD*)(a1 + 204) = 65;
                else
                    *(_WORD*)(a1 + 204) = 64;
            }
            else
            {
                *(_WORD*)(a1 + 204) = 63;
                v376 = 800;
                v377 = -2500;
                if (*(_DWORD*)(a1 + 424))
                    v376 = -v376;
                sub_422B5C(
                    *(_DWORD*)(a1 + 304),
                    v376 + *(_DWORD*)(a1 + 328),
                    *(_DWORD*)(a1 + 332),
                    v377 + *(_DWORD*)(a1 + 336),
                    *(_DWORD*)(a1 + 424),
                    16,
                    *(_BYTE*)(a1 + 223) - 1);
            }
        }
        else
        {
            *(_WORD*)(a1 + 204) = 62;
            v378 = 2400;
            v379 = -1300;
            if (*(_DWORD*)(a1 + 424))
                v378 = -v378;
            sub_422B5C(
                *(_DWORD*)(a1 + 304),
                v378 + *(_DWORD*)(a1 + 328),
                *(_DWORD*)(a1 + 332),
                v379 + *(_DWORD*)(a1 + 336),
                *(_DWORD*)(a1 + 424),
                15,
                *(_BYTE*)(a1 + 223) - 1);
        }
        switch (*(_DWORD*)(a1 + 444))
        {
        case 1:
            sub_43FFC3((int*)unk_4BDB28, dword_4B9A1C, -1, 100, 100, 0);
            return;
        case 0x10:
            goto LABEL_3441;
        case 0x14:
            v374 = -3500;
            v375 = -1700;
            if (*(_DWORD*)(a1 + 424))
                v374 = -v374;
            sub_422B5C(
                *(_DWORD*)(a1 + 304),
                v374 + *(_DWORD*)(a1 + 328),
                *(_DWORD*)(a1 + 332),
                v375 + *(_DWORD*)(a1 + 336),
                *(_DWORD*)(a1 + 424),
                19,
                *(_BYTE*)(a1 + 223) - 1);
            break;
        case 0x15:
            sub_426050(*(_DWORD**)(a1 + 304), 88);
            sub_408F50(*(_DWORD*)(a1 + 304), a2, a3, a4, 0);
            v373 = (char*)sub_464AC9((char*)unk_4B9B10, (_BYTE*)a1, *(unsigned __int8**)(a1 + 304), 0);
            if (v373
                && *(char**)(a1 + 304) != v373
                && ((v65 = sub_426090((int*)v373), v369 = v65 - sub_426090(*(_DWORD**)(a1 + 304)), v369 >= 0)
                    || !*(_DWORD*)(a1 + 424))
                && (v369 <= 0 || *(_DWORD*)(a1 + 424)))
            {
                v66 = sub_4260B0((int*)v373);
                v365 = v66 - sub_4260B0(*(_DWORD**)(a1 + 304));
                v67 = sub_4260D0((int*)v373);
                v364 = v67 - (sub_4260D0(*(_DWORD**)(a1 + 304)) + 1700);
                v367 = -266631570;
                v368 = 1074340345;
                v68 = (double)v365;
                sub_4A3090(v68, v68, (double)v369);
                X = v68;
                v371 = (__int64)(cos(v68) * 800.0);
                v370 = (__int64)(sin(X) * 800.0);
                v69 = (double)v364;
                sub_4A3090(v69, v69, (double)v369);
                v372 = (__int64)(sin(v69) * 800.0);
                if (v372 < 0)
                    v372 = 0;
                sub_43E540(*(_DWORD**)(a1 + 304), v371);
                sub_43E560(*(_DWORD**)(a1 + 304), v370);
                sub_43E580(*(_DWORD**)(a1 + 304), v372);
                *(_DWORD*)(a1 + 304) = 0;
            }
            else
            {
                sub_43E540(*(_DWORD**)(a1 + 304), 800 * (*(_DWORD*)(a1 + 424) == 1) - 800 * (*(_DWORD*)(a1 + 424) == 0));
                sub_43E560(*(_DWORD**)(a1 + 304), 0);
                sub_43E580(*(_DWORD**)(a1 + 304), 0);
            }
            break;
        }
    }
}



 
__int16 sub_43E520(_WORD* thisx)
{
    return thisx[248];
}

 
_DWORD* sub_43E540(_DWORD* thisx, int a2)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[93] = a2;
    return result;
}

 
_DWORD* sub_43E560(_DWORD* thisx, int a2)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[94] = a2;
    return result;
}

 
_DWORD* sub_43E580(_DWORD* thisx, int a2)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[87] = a2;
    return result;
}

 
__int16 sub_43E5A0(_WORD* thisx)
{
    return thisx[265];
}

 
int sub_43E5C0(_DWORD* thisx)
{
    return thisx[50];
}

 
__int16 sub_43E600(_WORD* thisx)
{
    return thisx[93];
}

 
__int16 sub_43E620(_WORD* thisx)
{
    return thisx[95];
}

 
void sub_43E640(void* thisx)
{
    *(_DWORD*)thisx = off_4AC2B8;
    memset((char*)thisx + 4, 0, 0xBu);
    *((_WORD*)thisx + 8) = 0;
    memset((char*)thisx + 18, 0, 0xAu);
    memset((char*)thisx + 40, 0, 0x10u);
    memset((char*)thisx + 56, 0, 0x14u);
    memset((char*)thisx + 76, 0, 8u);
    memset((char*)thisx + 28, 0, 3u);
    memset((char*)thisx + 31, 0, 6u);
}

 
void sub_43E6E5(void* thisx)
{
    *(_DWORD*)thisx = off_4AC2B8;
    sub_43E701((void**)thisx);
}

 
int sub_43E701(void** thisx)
{
    int result; // eax
    int i; // [esp+Ch] [ebp-4h]
    int j; // [esp+Ch] [ebp-4h]

    for (i = 0; i < 4; ++i)
    {
        if (thisx[i + 10])
            operator delete(thisx[i + 10]);
        thisx[i + 10] = 0;
        result = i + 1;
    }
    for (j = 0; j < 5; ++j)
    {
        if (thisx[j + 14])
            operator delete(thisx[j + 14]);
        thisx[j + 14] = 0;
        result = j + 1;
    }
    return result;
}

 
int sub_43E7AA(int thisx, int a2, int a3)
{
    int result; // eax
    int v5; // [esp+Ch] [ebp-118h]
    size_t v6; // [esp+10h] [ebp-114h]
    size_t v7; // [esp+14h] [ebp-110h]
    char v8; // [esp+18h] [ebp-10Ch]
    char v9; // [esp+1Ch] [ebp-108h]
    char v10; // [esp+20h] [ebp-104h]
    CHAR String1[256]; // [esp+24h] [ebp-100h] BYREF

    sub_43E701((void**)thisx);
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
        result = sub_482D44((_DWORD*)a2, String1);
        if (!result)
            return result;
        if (!lstrcmpiA(String1, String2))
            return sub_482D44((_DWORD*)a2, String1);
        if (lstrcmpiA(String1, aN))
        {
            if (lstrcmpiA(String1, aBasic))
            {
                if (lstrcmpiA(String1, aStatus))
                {
                    if (lstrcmpiA(String1, aMes))
                    {
                        if (lstrcmpiA(String1, aHelp))
                        {
                            if (lstrcmpiA(String1, a1st))
                            {
                                if (lstrcmpiA(String1, a2nd))
                                {
                                    if (lstrcmpiA(String1, a3rd))
                                    {
                                        if (lstrcmpiA(String1, aBiri))
                                        {
                                            if (lstrcmpiA(String1, aSpMove))
                                            {
                                                if (lstrcmpiA(String1, aEtcSkill))
                                                {
                                                    ++v9;
                                                    switch (v8)
                                                    {
                                                    case 1:
                                                        if (v9 == 1)
                                                        {
                                                            memcpy((void*)(thisx + 4), String1, 0xAu);
                                                            *(_BYTE*)(thisx + 14) = 0;
                                                        }
                                                        else if (v9 == 2)
                                                        {
                                                            *(_WORD*)(thisx + 16) = sub_48307F(String1);
                                                        }
                                                        break;
                                                    case 2:
                                                        if (v9 > 0 && v9 < 11)
                                                            *(_BYTE*)(thisx + v9 + 17) = sub_48307F(String1);
                                                        break;
                                                    case 3:
                                                        if (v9 == 1)
                                                            goto LABEL_40;
                                                        if (v9 == 2 && v10 >= 0 && v10 < 4)
                                                        {
                                                            v7 = strlen(String1);
                                                            *(_DWORD*)(thisx + 4 * v10 + 40) = (_DWORD)operator new(v7 + 1);
                                                            strcpy(*(char**)(thisx + 4 * v10 + 40), String1);
                                                        }
                                                        break;
                                                    case 4:
                                                        if (v9 == 1)
                                                        {
                                                        LABEL_40:
                                                            v10 = sub_48307F(String1);
                                                        }
                                                        else if (v9 == 2 && v10 >= 0 && v10 < 5)
                                                        {
                                                            v6 = strlen(String1);
                                                            *(_DWORD*)(thisx + 4 * v10 + 56) = (_DWORD)operator new(v6 + 1);
                                                            strcpy(*(char**)(thisx + 4 * v10 + 56), String1);
                                                        }
                                                        break;
                                                    default:
                                                        if (v8 >= 5 && v8 <= 8 && v9 == 1)
                                                        {
                                                            *(_WORD*)(thisx + 2 * v8 + 66) = sub_485ED0(a3, 256, String1, -1);
                                                        }
                                                        else if (v8 == 9 && v9 < 4)
                                                        {
                                                            *(_BYTE*)(thisx + v9 + 27) = sub_48307F(String1);
                                                        }
                                                        else if (v8 == 10 && v9 < 7)
                                                        {
                                                            v5 = (v9 - 1) / 2;
                                                            if ((v9 - 1) % 2)
                                                                *(_BYTE*)(thisx + 2 * v5 + 32) = sub_48307F(String1);
                                                            else
                                                                *(_BYTE*)(thisx + 2 * v5 + 31) = sub_48307F(String1);
                                                        }
                                                        break;
                                                    }
                                                }
                                                else
                                                {
                                                    v8 = 10;
                                                    v9 = 0;
                                                }
                                            }
                                            else
                                            {
                                                v8 = 9;
                                                v9 = 0;
                                            }
                                        }
                                        else
                                        {
                                            v8 = 8;
                                            v9 = 0;
                                        }
                                    }
                                    else
                                    {
                                        v8 = 7;
                                        v9 = 0;
                                    }
                                }
                                else
                                {
                                    v8 = 6;
                                    v9 = 0;
                                }
                            }
                            else
                            {
                                v8 = 5;
                                v9 = 0;
                            }
                        }
                        else
                        {
                            v8 = 4;
                            v9 = 0;
                        }
                    }
                    else
                    {
                        v8 = 3;
                        v9 = 0;
                    }
                }
                else
                {
                    v8 = 2;
                    v9 = 0;
                }
            }
            else
            {
                v8 = 1;
                v9 = 0;
            }
        }
        else
        {
            v8 = 0;
        }
    }
}

 
int sub_43ED4E(unsigned __int8* thisx, unsigned __int8 a2)
{
    int i; // [esp+4h] [ebp-4h]

    for (i = 0; i < 3; ++i)
    {
        if (thisx[2 * i + 31] == a2)
            return (int)&thisx[2 * i + 31];
    }
    return 0;
}

 
int sub_43ED9E(unsigned __int8* thisx, unsigned __int8 a2, unsigned __int8 a3)
{
    int i; // [esp+4h] [ebp-4h]

    for (i = 0; i < 3; ++i)
    {
        if (thisx[2 * i + 31] == a2 && thisx[2 * i + 32] == a3)
            return 1;
    }
    return 0;
}

 
unsigned __int8 sub_43EE02(unsigned __int8* thisx, int a2, int a3)
{
    char v4; // [esp+4h] [ebp-10h]
    char v5; // [esp+8h] [ebp-Ch]
    int v6; // [esp+Ch] [ebp-8h]
    unsigned __int8 v7; // [esp+10h] [ebp-4h]

    if (!a3)
        return thisx[a2 + 18];
    v7 = thisx[a2 + 18];
    if (v7)
    {
        v6 = sub_43ED4E(thisx, 2u);
        if (v6)
        {
            v5 = *(_BYTE*)(a3 + 243);
            if (v5)
            {
                v4 = 3 * (v5 - 1);
                if (*(_BYTE*)(v6 + 1) == 1)
                    v4 -= 9;
                if (!a2)
                    v4 *= 5;
                v7 += v4;
            }
        }
    }
    return v7;
}


 
void sub_43EED1(void* thisx)
{
    *(_DWORD*)thisx = off_4AC2BC;
}

 
unsigned __int16* sub_43EEE5(unsigned __int16* thisx)
{
    unsigned __int16* result; // eax
    int v3; // [esp+4h] [ebp-38h] BYREF
    int v4; // [esp+8h] [ebp-34h]
    int v5; // [esp+Ch] [ebp-30h]

    result = thisx;
    if (*((_DWORD*)thisx + 1))
    {
        sub_49C15E((int)&v3);
        v4 = *((_DWORD*)thisx + 2);
        v5 = *((_DWORD*)thisx + 3);
        v3 = dword_4B91E4;
        sub_49AB05((int)unk_4BDC60, &v3);
        v4 = v4 + *((_DWORD*)thisx + 4) / 10 - 4;
        ++v3;
        return sub_49AB05((int)unk_4BDC60, &v3);
    }
    return result;
}
 
char sub_43EF5D(int thisx, int a2, char a3)
{
    char result; // al

    *(_DWORD*)(thisx + 4) = a2;
    result = a3;
    *(_BYTE*)(thisx + 20) = a3;
    *(_DWORD*)(thisx + 16) = 0;
    return result;
}

 
int __fastcall sub_43EF86(int a1)
{
    int result; // eax
    int v3[2]; // [esp+4h] [ebp-8h] BYREF

    result = a1;
    if (*(_DWORD*)(a1 + 4))
    {
        if (sub_426410(*(_DWORD**)(a1 + 4))
            || (result = sub_426410(*(_DWORD**)(a1 + 4))) == 0
            && (result = (int)SchedulerBase::GetSchedulerProxy(*(SchedulerBase**)(a1 + 4)),
                result == 82))
        {
            *(_DWORD*)(a1 + 16) += *(char*)(a1 + 20);
            if (*(int*)(a1 + 16) <= 0 || *(int*)(a1 + 16) >= 400)
            {
                if (*(int*)(a1 + 16) >= 0)
                {
                    if (*(int*)(a1 + 16) > 400)
                        *(_DWORD*)(a1 + 16) = 400;
                }
                else
                {
                    *(_DWORD*)(a1 + 16) = 0;
                }
                *(_BYTE*)(a1 + 20) = -*(_BYTE*)(a1 + 20);
            }
            sub_4097DF(*(void**)(a1 + 4), (int)v3);
            *(_DWORD*)(a1 + 8) = v3[0] - 20;
            *(_DWORD*)(a1 + 12) = v3[1] + 2;
            if (*(int*)(a1 + 8) >= 0)
            {
                if (*(_DWORD*)(a1 + 8) + 40 > 320)
                    *(_DWORD*)(a1 + 8) = 280;
            }
            else
            {
                *(_DWORD*)(a1 + 8) = 0;
            }
            result = a1;
            if (*(int*)(a1 + 12) >= 0)
            {
                result = *(_DWORD*)(a1 + 12) + 8;
                if (result > 176)
                    *(_DWORD*)(a1 + 12) = 168;
            }
            else
            {
                *(_DWORD*)(a1 + 12) = 0;
            }
        }
        else
        {
            *(_DWORD*)(a1 + 4) = 0;
        }
    }
    return result;
}

 
BOOL sub_43F0C8(int* thisx)
{
    return thisx[4] >= 130 && thisx[4] <= 270;
}

 
void* sub_43F100(void* thisx, char a2)
{
    sub_43EED1(thisx);
    if ((a2 & 1) != 0)
        operator delete(thisx);
    return thisx;
}

 
void sub_43F130(void* thisx)
{
    *(_DWORD*)thisx = off_4AC2C0;
    *((_WORD*)thisx + 2) = 0;
    *((_DWORD*)thisx + 2) = 0;
    *((_DWORD*)thisx + 3) = 0;
}

 
void sub_43F164(void* thisx)
{
    *(_DWORD*)thisx = off_4AC2C0;
}

 
int sub_43F178(int thisx, __int16 a2, int a3)
{
    int result; // eax

    *(_WORD*)(thisx + 4) = a2;
    result = a3;
    *(_DWORD*)(thisx + 12) = a3;
    *(_DWORD*)(thisx + 8) = 0;
    return result;
}

 
_DWORD* sub_43F1A3(int thisx)
{
    _DWORD* result; // eax

    result = (_DWORD*)thisx;
    if (*(_DWORD*)(thisx + 12))
    {
        result = (_DWORD*)thisx;
        if ((int)++ * (_DWORD*)(thisx + 8) > 24)
        {
            *(_DWORD*)(thisx + 12) = 0;
            *(_WORD*)(thisx + 4) = 0;
            *(_DWORD*)(thisx + 8) = 0;
            return sub_4532B9((_DWORD*) & unk_4B9B10);
        }
    }
    return result;
}

 
int __fastcall sub_43F1F8(int a1)
{
    int result; // eax
    int v3[2]; // [esp+4h] [ebp-54h] BYREF
    int v4; // [esp+Ch] [ebp-4Ch]
    int v5; // [esp+10h] [ebp-48h]
    int i; // [esp+14h] [ebp-44h]
    CHAR String[8]; // [esp+18h] [ebp-40h] BYREF
    int v8[2]; // [esp+20h] [ebp-38h] BYREF
    int v9; // [esp+28h] [ebp-30h]

    result = a1;
    if (*(_DWORD*)(a1 + 12))
    {
        wsprintfA(String, "%2d", *(unsigned __int16*)(a1 + 4));
        v5 = lstrlenA(String);
        sub_4097DF(*(void**)(a1 + 12), (int)v3);
        sub_49C15E((_DWORD)v8);
        v4 = v3[0] - 12;
        if (v3[0] - 12 >= 0)
        {
            if (v4 + 8 * v5 > 320)
                v4 = 320 - 8 * v5;
        }
        else
        {
            v4 = 0;
        }
        result = *(_DWORD*)(a1 + 8) / 2;
        v9 = v3[1] - 32 - result;
        if (v9 < 0)
            v9 = 0;
        for (i = 0; i < v5; ++i)
        {
            if (String[i] != 32)
            {
                v8[1] = v4 + 8 * i;
                v8[0] = dword_4B91FC + String[i] - 48;
                sub_49AB05((int)unk_4BDC60, v8);
            }
            result = i + 1;
        }
    }
    return result;
}

 
int sub_43F308(int thisx)
{
    int result; // eax

    result = thisx;
    *(_WORD*)(thisx + 4) = 0;
    *(_DWORD*)(thisx + 8) = 0;
    *(_DWORD*)(thisx + 12) = 0;
    return result;
}

 
void* sub_43F330(void* thisx, char a2)
{
    sub_43F164(thisx);
    if ((a2 & 1) != 0)
        operator delete(thisx);
    return thisx;
}

 
_DWORD* sub_43F51F(_DWORD* thisx)
{
    _DWORD* result; // eax

    result = thisx;
    *thisx = (_DWORD)&off_4AC2C4;
    return result;
}

 
void* sub_43F533(_DWORD* thisx)
{
    void* result; // eax

    result = memset(thisx + 1, 0, 0x641u);
    thisx[402] = 0;
    return result;
}

 
_DWORD* sub_43F660(_DWORD* thisx, char a2)
{
    sub_43F51F(thisx);
    if ((a2 & 1) != 0)
        operator delete(thisx);
    return thisx;
}

 
_DWORD* sub_43F690(_DWORD* thisx)
{
    int i; // [esp+4h] [ebp-4h]
    int j; // [esp+4h] [ebp-4h]

    *thisx = 0;
    thisx[1] = 0;
    for (i = 0; i < 16; ++i)
    {
        thisx[i + 2] = 0;
        thisx[i + 18] = -1;
    }
    for (j = 0; j < 2; ++j)
        thisx[j + 68] = (_DWORD)CreateEventA(0, 0, 0, 0);
    thisx[34] = 0;
    thisx[35] = 0;
    *((_BYTE*)thisx + 154) = 0;
    thisx[44] = -1;
    memset(thisx + 36, 0, 0xAu);
    thisx[41] = 0;
    thisx[43] = 0;
    thisx[40] = 1;
    thisx[48] = 0;
    thisx[50] = 0;
    thisx[52] = 0;
    thisx[49] = 0;
    return thisx;
}

 
_DWORD* sub_43F7BF(void* thisx)
{
    return sub_43F951((_DWORD*)thisx);
}

 
_BYTE* sub_43F7D2(_BYTE* thisx)
{
    *(_DWORD*)thisx = 0;
    thisx[4] = 0;
    thisx[5] = 0;
    return thisx;
}

 
int sub_43F7F7(DWORD* thisx, int a2)
{
    int v4; // [esp+4h] [ebp-4h]

    if (DirectSoundCreate(0, (LPDIRECTSOUND*)thisx, 0))
    {
        MessageBoxA(0, byte_4B043C, aError_4, 0);
        *thisx = 0;
        return 0;
    }
    else
    {
        v4 = (*(int(__stdcall**)(DWORD, int, int))(*(_DWORD*)*thisx + 24))(*thisx, a2, 1);
        if (v4)
        {
            MessageBoxA(0, Text, Caption, 0);
            if (v4 == -2005401590)
                MessageBoxA(0, aDserrAllocated_0, aError_0, 0);
            if (v4 == -2147024809)
                MessageBoxA(0, aDserrInvalidpa_0, aError_1, 0);
            if (v4 == -2005401430)
                MessageBoxA(0, aDserrUninitial_0, aError_2, 0);
            if (v4 == -2147467263)
                MessageBoxA(0, aDserrUnsupport_0, aError_3, 0);
            return 0;
        }
        else
        {
            thisx[48] = (DWORD)CreateThread(0, 0, (LPTHREAD_START_ROUTINE)StartAddress, thisx, 0, (LPDWORD)thisx + 47);
            return 1;
        }
    }
}

 
int sub_43F91E(_DWORD* thisx)
{
    int result; // eax

    result = (int)thisx;
    if (*thisx)
    {
        result = (*(int(**)(_DWORD, _DWORD))(*(_DWORD*)*thisx + 8))(*thisx, *thisx);
        *thisx = 0;
    }
    *((_BYTE*)thisx + 4) = 0;
    return result;
}

 
_DWORD* sub_43F951(_DWORD* thisx)
{
    _DWORD* result; // eax
    int v3; // [esp+10h] [ebp-Ch]
    int i; // [esp+14h] [ebp-8h]
    int k; // [esp+14h] [ebp-8h]
    char* j; // [esp+18h] [ebp-4h]

    thisx[40] = 0;
    thisx[41] = 0;
    if (thisx[48])
    {
        WaitForSingleObject((HANDLE)thisx[48], 0xFFFFFFFF);
        CloseHandle((HANDLE)thisx[48]);
        thisx[48] = 0;
    }
    for (i = 0; i < 2; ++i)
    {
        if (thisx[i + 68])
        {
            CloseHandle((HANDLE)thisx[i + 68]);
            thisx[i + 68] = 0;
        }
    }
    sub_4901B9((HMMIO*)thisx + 50, (HGLOBAL*)thisx + 51);
    if (thisx[49])
    {
        (*(void(**)(_DWORD, _DWORD))(*(_DWORD*)thisx[49] + 72))(thisx[49], thisx[49]);
        (*(void(**)(_DWORD, _DWORD))(*(_DWORD*)thisx[49] + 8))(thisx[49], thisx[49]);
    }
    if (thisx[52])
        (*(void(__stdcall**)(_DWORD))(*(_DWORD*)thisx[52] + 8))(thisx[52]);
    thisx[52] = 0;
    thisx[49] = 0;
    for (j = (char*)thisx[1]; j; j = (char*)v3)
    {
        v3 = sub_441090((_DWORD*)j);
        sub_440DF5((_DWORD*)j);
        sub_4410B0(j, 1);
    }
    result = thisx;
    thisx[1] = 0;
    for (k = 0; k < 16; ++k)
    {
        result = thisx;
        if (thisx[k + 2])
        {
            (*(void(**)(_DWORD, _DWORD))(*(_DWORD*)thisx[k + 2] + 8))(thisx[k + 2], thisx[k + 2]);
            result = (_DWORD*)k;
            thisx[k + 2] = 0;
        }
    }
    if (*thisx)
    {
        (*(void(__stdcall**)(_DWORD))(*(_DWORD*)*thisx + 8))(*thisx);
        result = thisx;
        *thisx = 0;
    }
    thisx[34] = 0;
    thisx[35] = 0;
    return result;
}

 
int sub_43FB7E(int* thisx, LPSTR pszFileName, int a3)
{
    char* v5; // [esp+4h] [ebp-4h]

    if (!sub_4410E0(thisx))
        return -1;
    if (a3 == -1)
        a3 = thisx[34];
    if (a3 > thisx[34] || a3 < -1)
        return -1;
    v5 = sub_440E6C(thisx, a3, 1);
    if (!v5)
        return -1;
    if (!sub_43FC33((_DWORD*)v5, pszFileName, *thisx))
        return -1;
    ++thisx[34];
    return a3;
}

 
int sub_43FC18(int* thisx, LPSTR pszFileName)
{
    return sub_43FB7E(thisx, pszFileName, -1);
}

 
int sub_43FC33(_DWORD* thisx, LPSTR pszFileName, int a3)
{
    CHAR Text[128]; // [esp+4h] [ebp-D4h] BYREF
    struct _MMCKINFO pmmcki; // [esp+84h] [ebp-54h] BYREF
    HMMIO hmmio; // [esp+98h] [ebp-40h] BYREF
    struct _MMCKINFO v8; // [esp+9Ch] [ebp-3Ch] BYREF
    int v9; // [esp+B0h] [ebp-28h]
    int v10[5]; // [esp+B4h] [ebp-24h] BYREF
    int v11; // [esp+C8h] [ebp-10h] BYREF
    int v12 = 0; // [esp+CCh] [ebp-Ch] BYREF
    int v13; // [esp+D0h] [ebp-8h] BYREF
    int v14; // [esp+D4h] [ebp-4h] BYREF

    sub_43F91E(thisx);
    if (sub_48FD80(pszFileName, (int)&hmmio, (int)&v14, &pmmcki))
    {
        wsprintfA(Text, aS_4, pszFileName);
        messagebox(Text);
        return 0;
    }
    else if (sub_48FF86((int)&hmmio, &v8, &pmmcki))
    {
        messagebox(byte_4B0494);
        return 0;
    }
    else
    {
        memset(v10, 0, sizeof(v10));
        v10[0] = 20;
        v10[1] = 162;
        v10[2] = v8.cksize;
        v10[4] = v14;

        IDirectSound* d = (IDirectSound*)a3;
        v9 = d->CreateSoundBuffer((LPCDSBUFFERDESC)v10, (LPDIRECTSOUNDBUFFER*)thisx, 0);
        //v9 = (*(int(__stdcall**)(int, int*, _DWORD*, _DWORD))(*(_DWORD*)a3 + 12))(a3, v10, thisx, 0);
        if (v9)
        {
            messagebox(byte_4B04B4);
            switch (v9)
            {
            case -2005401590:
                messagebox(aDserrAllocated_1);
                break;
            case -2005401500:
                messagebox(aDserrBadformat_0);
                break;
            case -2147024809:
                messagebox(aDserrInvalidpa_1);
                break;
            case -2147221232:
                messagebox(aDserrNoaggrega_0);
                break;
            case -2147024882:
                messagebox(aDserrOutofmemo_0);
                break;
            case -2005401430:
                messagebox(aDserrUninitial_1);
                break;
            case -2147467263:
                messagebox(aDserrUnsupport_1);
                break;
            }
            sub_4901B9(&hmmio, (HGLOBAL*) & v14);
            return 0;
        }
        else
        {
            IDirectSoundBuffer* d2 = (IDirectSoundBuffer*)*thisx;
            v9 = d2->Lock(
                0,
                0,
                (LPVOID*)&v12,
                (LPDWORD)&v13,
                0,
                0,
                2);
            //v9 = (*(int(**)(_DWORD, _DWORD, _DWORD, _DWORD, int*, int*, _DWORD, _DWORD, int))(*(_DWORD*)*thisx + 44))(
            //    *thisx,
            //    *thisx,
            //    0,
            //    0,
            //    &v12,
            //    &v13,
            //    0,
            //    0,
            //    2);


            if (v9)
            {
                messagebox(byte_4B055C);
                sub_4901B9(&hmmio, (HGLOBAL*)&v14);
                return 0;
            }
            else if (sub_4900C4(hmmio, v13, v12, (int)&v8, (int)&v11))
            {
                (*(void(**)(_DWORD, _DWORD, int, int, _DWORD, _DWORD))(*(_DWORD*)*thisx + 76))(
                    *thisx,
                    *thisx,
                    v12,
                    v13,
                    0,
                    0);
                sub_4901B9(&hmmio, (HGLOBAL*)&v14);
                return 0;
            }
            else
            {
                (*(void(__stdcall**)(_DWORD, int, int, _DWORD, _DWORD))(*(_DWORD*)*thisx + 76))(*thisx, v12, v13, 0, 0);
                sub_4901B9(&hmmio, (HGLOBAL*)&v14);
                *((_BYTE*)thisx + 4) = 1;
                return 1;
            }
        }
    }
}

 
_DWORD* sub_43FED3(_DWORD* thisx, _DWORD* a2)
{
    _DWORD* result; // eax
    _DWORD* v4; // [esp+4h] [ebp-8h]
    _DWORD* i; // [esp+8h] [ebp-4h]
    int j; // [esp+8h] [ebp-4h]

    for (i = a2; (int)i < thisx[35]; i = (_DWORD*)((char*)i + 1))
    {
        v4 = (_DWORD*)sub_440E6C(thisx, (int)i, 0);
        if (v4)
            sub_43F91E(v4);
    }
    result = a2;
    thisx[34] = (_DWORD)a2;
    for (j = 0; j < 16; ++j)
    {
        result = thisx;
        thisx[j + 18] = -1;
    }
    return result;
}

 
int sub_43FFC3(_DWORD* thisx, int a2, int a3, int a4, int a5, int a6)
{
    int v7; // eax
    __int64 X; // [esp+Ch] [ebp-2Ch]
    int v10; // [esp+18h] [ebp-20h]
    unsigned int v11; // [esp+1Ch] [ebp-1Ch] BYREF
    int v12; // [esp+20h] [ebp-18h]
    int v13; // [esp+24h] [ebp-14h]
    int i; // [esp+28h] [ebp-10h]
    int v15; // [esp+2Ch] [ebp-Ch]
    int v16; // [esp+30h] [ebp-8h]
    _BYTE* v17; // [esp+34h] [ebp-4h]

    if (!sub_4410E0(thisx))
        return -1;
    if (a2 < 0 || a2 >= thisx[34])
        return -1;
    if (a3 >= 16)
        return -1;
    v17 = (_BYTE*)sub_440E6C(thisx, a2, 0);
    if (!v17)
        return -1;
    if (sub_425F90(v17))
        return -1;
    sub_441100(v17, 3);
    v15 = a3;
    if (a3 <= -1)
    {
        if (a6)
        {
            for (i = 0; i < 16; ++i)
            {
                if (thisx[i + 18] == a2)
                {
                    v15 = i;
                    break;
                }
            }
        }
        if (v15 <= -1)
            v15 = sub_440363(thisx);
    }
    if (v15 == -1)
        return -1;
    if (thisx[v15 + 18] == a2)
    {
        (*(void(__stdcall**)(_DWORD))(*(_DWORD*)thisx[v15 + 2] + 72))(thisx[v15 + 2]);
        X = (unsigned int)thisx[v15 + 2];
        (*(void(__stdcall**)(_DWORD, _DWORD))(*(_DWORD*)thisx[v15 + 2] + 52))(X, HIDWORD(X));
    }
    else
    {
        if (thisx[v15 + 2])
        {
            (*(void(__stdcall**)(_DWORD))(*(_DWORD*)thisx[v15 + 2] + 72))(thisx[v15 + 2]);
            (*(void(__stdcall**)(_DWORD))(*(_DWORD*)thisx[v15 + 2] + 8))(thisx[v15 + 2]);
            thisx[v15 + 2] = 0;
        }
        v7 = unknown_libname_30((int*)v17);
        if ((*(int(__stdcall**)(_DWORD, int, _DWORD*))(*(_DWORD*)*thisx + 20))(*thisx, v7, &thisx[v15 + 2]))
            return -1;
    }
    thisx[v15 + 18] = a2;
    v16 = thisx[v15 + 2];
    if (a5 > 0)
    {
        if (a5 > 1000)
            a5 = 1000;
    }
    else
    {
        a5 = 1;
    }
    if (a5 == 100)
    {
        (*(void(__stdcall**)(int, _DWORD))(*(_DWORD*)v16 + 60))(v16, 0);
    }
    else
    {
        v13 = (__int64)(log10((double)a5 / 100.0) * 1000.0);
        v12 = (*(int(__stdcall**)(int, int))(*(_DWORD*)v16 + 60))(v16, v13);
        if (v12)
        {
            switch (v12)
            {
            case -2005401570:
                messagebox(aDserrControlun_0);
                break;
            case -2147024809:
                messagebox(aDserrInvalidpa_2);
                break;
            case -2005401530:
                messagebox(aDserrPriolevel_0);
                break;
            default:
                messagebox(byte_4B05C0);
                break;
            }
        }
    }
    if (a4 > 0)
    {
        if (a4 > 1000)
            a4 = 1000;
    }
    else
    {
        a4 = 1;
    }
    if (a4 == 100)
    {
        (*(void(__stdcall**)(int, _DWORD))(*(_DWORD*)v16 + 68))(v16, 0);
    }
    else
    {
        (*(void(__stdcall**)(int, _DWORD))(*(_DWORD*)v16 + 68))(v16, 0);
        v10 = (*(int(__stdcall**)(int, unsigned int*))(*(_DWORD*)v16 + 32))(v16, &v11);
        if (v10)
        {
            switch (v10)
            {
            case -2005401570:
                messagebox(aDserrControlun_1);
                break;
            case -2147024809:
                messagebox(aDserrInvalidpa_3);
                break;
            case -2005401530:
                messagebox(aDserrPriolevel_1);
                break;
            default:
                messagebox(byte_4B0628);
                break;
            }
        }
        else
        {
            v11 = a4 * v11 / 0x64;
            if ((*(int(__stdcall**)(int, unsigned int))(*(_DWORD*)v16 + 68))(v16, v11))
                messagebox(byte_4B05D0);
        }
    }
    (*(void(__stdcall**)(int, _DWORD, _DWORD, _DWORD))(*(_DWORD*)v16 + 48))(v16, 0, 0, 0);
    return v15;
}

 
int sub_440363(_DWORD* thisx)
{
    int v3; // [esp+4h] [ebp-8h] BYREF
    int i; // [esp+8h] [ebp-4h]

    if (!sub_4410E0(thisx))
        return -1;
    for (i = 0; i < 16; ++i)
    {
        if (!thisx[i + 2])
            return i;
        (*(void(**)(_DWORD, _DWORD, int*))(*(_DWORD*)thisx[i + 2] + 36))(thisx[i + 2], thisx[i + 2], &v3);
        if ((v3 & 1) == 0)
            return i;
    }
    return -1;
}

 
int sub_4404CB(_DWORD* thisx, LPSTR pszFileName, int a3)
{
    int i; // [esp+4h] [ebp-8h]

    sub_440B78((_DWORD)thisx);
    sub_4901B9((HMMIO*)thisx + 50, (HGLOBAL*)thisx + 51);
    if (thisx[52])
    {
        (*(void(__stdcall**)(_DWORD))(*(_DWORD*)thisx[52] + 8))(thisx[52]);
        thisx[52] = 0;
    }
    if (thisx[49])
    {
        (*(void(__stdcall**)(_DWORD))(*(_DWORD*)thisx[49] + 8))(thisx[49]);
        thisx[49] = 0;
    }
    for (i = 0; i < 2; ++i)
    {
        if (!thisx[i + 68])
            return 0;
    }
    if (sub_48FD80(pszFileName, (int)(thisx + 50), (int)(thisx + 51), (LPMMCKINFO)(thisx + 58)))
        return 0;
    if (sub_48FF86((int)(thisx + 50), (LPMMCKINFO)(thisx + 53), (MMCKINFO*)(thisx + 58)))
        return 0;
    thisx[46] = *(_DWORD*)(thisx[51] + 8) * thisx[46] / 0x3E8u;
    thisx[46] += thisx[46] % (unsigned int)*(unsigned __int16*)(thisx[51] + 12);
    memset(thisx + 63, 0, 0x14u);
    thisx[63] = 20;
    thisx[64] = 98688;
    thisx[65] = 2 * *(_DWORD*)(thisx[51] + 8);
    thisx[67] = thisx[51];
    if ((*(int(__stdcall**)(_DWORD, _DWORD*, _DWORD*, _DWORD))(*(_DWORD*)*thisx + 12))(
        *thisx,
        thisx + 63,
        thisx + 49,
        0) >= 0)
    {
        thisx[44] = -1;
        *((_BYTE*)thisx + 296) = 0;
        sub_44076B((int)thisx, 1);
        (*(void(**)(_DWORD, _DWORD, _DWORD, _DWORD, int))(*(_DWORD*)thisx[49] + 48))(
            thisx[49],
            thisx[49],
            0,
            0,
            1);
        thisx[41] = 1;
        thisx[42] = a3;
        return 1;
    }
    else
    {
        sub_4901B9((HMMIO*)thisx + 50, (HGLOBAL*)thisx + 51);
        return 0;
    }
}

 
int sub_44076B(int thisx, int a2)
{
    int v3; // eax
    int Size; // [esp+4h] [ebp-44h]
    int v6; // [esp+8h] [ebp-40h]
    int v7; // [esp+10h] [ebp-38h] BYREF
    char v8[4]; // [esp+14h] [ebp-34h] BYREF
    int v9; // [esp+18h] [ebp-30h]
    void* v10; // [esp+1Ch] [ebp-2Ch] BYREF
    void* v11; // [esp+20h] [ebp-28h]
    void* v12; // [esp+24h] [ebp-24h] BYREF
    int i; // [esp+28h] [ebp-20h]
    int v14; // [esp+2Ch] [ebp-1Ch]
    int v15; // [esp+30h] [ebp-18h] BYREF
    int v16; // [esp+34h] [ebp-14h] BYREF
    int v17; // [esp+38h] [ebp-10h] BYREF
    int v18; // [esp+3Ch] [ebp-Ch] BYREF
    int v19; // [esp+40h] [ebp-8h]

    v12 = 0;
    v10 = 0;
    v15 = 0;
    v16 = 0;
    (*(void(__stdcall**)(_DWORD, int*, char*))(**(_DWORD**)(thisx + 196) + 16))(*(_DWORD*)(thisx + 196), &v7, v8);
    if (*(int*)(thisx + 176) < 0)
        goto LABEL_6;
    v6 = v7 - *(_DWORD*)(thisx + 156);
    if (v6 < 0)
        v6 += *(_DWORD*)(thisx + 260);
    *(_DWORD*)(thisx + 176) -= v6;
    if (*(int*)(thisx + 176) > 0)
    {
    LABEL_6:
        *(_DWORD*)(thisx + 156) = v7;
        v14 = v7;
        if (a2 == 1)
        {
            v9 = 0;
            v19 = *(_DWORD*)(thisx + 260);
        }
        else
        {
            v9 = *(_DWORD*)(thisx + 180);
            v19 = v14 - *(_DWORD*)(thisx + 180);
            if (v19 < 0)
                v19 += *(_DWORD*)(thisx + 260);
        }
        if ((*(int(__stdcall**)(_DWORD, int, int, void**, int*, void**, int*, _DWORD))(**(_DWORD**)(thisx + 196) + 44))(
            *(_DWORD*)(thisx + 196),
            v9,
            v19,
            &v12,
            &v15,
            &v10,
            &v16,
            0))
        {
            return 0;
        }
        else
        {
            *(_DWORD*)(thisx + 180) = v7;
            for (i = 0; i < 2; ++i)
            {
                if (i)
                {
                    Size = v16;
                    v11 = v10;
                }
                else
                {
                    Size = v15;
                    v11 = v12;
                }
                while (Size)
                {
                    if (*(_DWORD*)(thisx + 176) == -1)
                    {
                        sub_4900C4(*(HMMIO*)(thisx + 200), Size, (int)v11, thisx + 212, (int)&v17);
                        Size -= v17;
                        v11 = (char*)v11 + v17;
                    }
                    else
                    {
                        v3 = -(*(_WORD*)(*(_DWORD*)(thisx + 268) + 14) != 8);
                        LOBYTE(v3) = v3 & 0x80;
                        memset(v11, v3 + 128, Size);
                        Size = 0;
                    }
                    if (!*(_DWORD*)(thisx + 216))
                    {
                        if (*(_DWORD*)(thisx + 168))
                        {
                            sub_48FF86(thisx + 200, (LPMMCKINFO)(thisx + 212), (MMCKINFO*)(thisx + 232));
                            sub_48FFDC(*(HMMIO*)(thisx + 200), *(_DWORD*)(thisx + 184), thisx + 212, (int)&v18);
                        }
                        else if (*(_DWORD*)(thisx + 176) == -1)
                        {
                            *(_DWORD*)(thisx + 176) = *(_DWORD*)(thisx + 260);
                        }
                    }
                }
            }
            (*(void(__stdcall**)(_DWORD, void*, int, void*, int))(**(_DWORD**)(thisx + 196) + 76))(
                *(_DWORD*)(thisx + 196),
                v12,
                v15,
                v10,
                v16);
            return 1;
        }
    }
    else
    {
        (*(void(__stdcall**)(_DWORD))(**(_DWORD**)(thisx + 196) + 72))(*(_DWORD*)(thisx + 196));
        *(_DWORD*)(thisx + 164) = 0;
        return 1;
    }
}

 
int __stdcall sub_440A5D(int a1)
{
    int v2; // [esp+0h] [ebp-4h]

    v2 = 0;
    while (*(_DWORD*)(a1 + 160))
    {
        while (!*(_DWORD*)(a1 + 164))
        {
            Sleep(0x10u);
            if (!*(_DWORD*)(a1 + 160))
                return 0;
        }
        if (v2 >= 60)
        {
            v2 = 0;
            *(_DWORD*)(a1 + 172) = 1;
            sub_44076B(a1, 0);
            *(_DWORD*)(a1 + 172) = 0;
        }
        Sleep(0x10u);
        if (*(_BYTE*)(a1 + 296))
            sub_440CD0(a1);
        ++v2;
    }
    return 0;
}

 
char*  sub_440B04(_DWORD* thisx)
{
    char* result; // eax
    char* v2; // [esp+4h] [ebp-10h]
    int j; // [esp+8h] [ebp-Ch]
    char* i; // [esp+Ch] [ebp-8h]

    result = (char*)thisx;
    for (i = (char*)thisx[1]; i; i = result)
    {
        for (j = 0; j < 64; ++j)
        {
            v2 = sub_44106A(i, j);
            if (sub_425F90(v2))
                sub_441120(v2, -1);
        }
        result = (char*)sub_441090((_DWORD*)i);
    }
    return result;
}

 
int sub_440B78(int thisx)
{
    int result; // eax

    result = thisx;
    if (*(_DWORD*)(thisx + 196))
    {
        while (*(_DWORD*)(thisx + 172))
            ;
        result = (*(int(__stdcall**)(_DWORD))(**(_DWORD**)(thisx + 196) + 72))(*(_DWORD*)(thisx + 196));
        *(_DWORD*)(thisx + 164) = 0;
    }
    return result;
}

 
int sub_440BC2(int thisx)
{
    int result; // eax

    result = thisx;
    if (*(_DWORD*)(thisx + 196))
    {
        result = (*(int(**)(_DWORD, _DWORD, _DWORD, _DWORD, int))(**(_DWORD**)(thisx + 196) + 48))(
            *(_DWORD*)(thisx + 196),
            *(_DWORD*)(thisx + 196),
            0,
            0,
            1);
        *(_DWORD*)(thisx + 164) = 1;
    }
    return result;
}

 
_DWORD* sub_440C04(_DWORD* thisx, int a2)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[46] = a2;
    return result;
}

 
int sub_440C1D(_DWORD** thisx, int a2)
{
    int v4; // [esp+Ch] [ebp-4h]

    if (a2 >= 0)
    {
        if (a2 > 100)
            a2 = 100;
    }
    else
    {
        a2 = 0;
    }
    if (a2 == 100)
        return (*(int(__stdcall**)(_DWORD*, _DWORD))(*thisx[49] + 60))(thisx[49], 0);
    if (!a2)
        return (*(int(__stdcall**)(_DWORD*, int))(*thisx[49] + 60))(thisx[49], -10000);
    v4 = (__int64)(log10((double)a2 / 100.0) * 1000.0);
    return (*(int(**)(_DWORD*, _DWORD*, int))(*thisx[49] + 60))(thisx[49], thisx[49], v4);
}

 
int sub_440CD0(int thisx)
{
    int result; // eax
    int v3; // [esp+4h] [ebp-4h]

    ++* (_DWORD*)(thisx + 304);
    if (*(int*)(thisx + 300) <= 0)
        *(_DWORD*)(thisx + 300) = 1;
    v3 = 100 * *(_DWORD*)(thisx + 304) / *(_DWORD*)(thisx + 300);
    if (*(_BYTE*)(thisx + 296) == 1)
        v3 = 100 - v3;
    sub_440C1D((_DWORD**)thisx, v3);
    result = thisx;
    if (*(_DWORD*)(thisx + 304) >= *(_DWORD*)(thisx + 300))
    {
        result = thisx;
        *(_BYTE*)(thisx + 296) = 0;
    }
    return result;
}

 
int sub_440D69(int thisx, char a2, int a3)
{
    int result; // eax

    *(_BYTE*)(thisx + 296) = a2;
    result = a3;
    *(_DWORD*)(thisx + 300) = a3;
    *(_DWORD*)(thisx + 304) = 0;
    return result;
}

 
_DWORD* sub_440D9B(_DWORD* thisx)
{
    sub_402080((int)thisx, 8, 64, (void(*)(int))sub_43F7D2);
    thisx[128] = 0;
    thisx[130] = 0;
    thisx[129] = 0;
    return thisx;
}

 
int sub_440DE2(void* thisx)
{
    return sub_440DF5((_DWORD*)thisx);
}

 
int sub_440DF5(_DWORD* thisx)
{
    int result; // eax
    int i; // [esp+4h] [ebp-4h]

    for (i = 0; i < 64; ++i)
    {
        sub_43F91E(&thisx[2 * i]);
        result = i + 1;
    }
    return result;
}

 
char* sub_440E6C(_DWORD* thisx, int a2, int a3)
{
    int i; // [esp+8h] [ebp-14h]
    int v6; // [esp+Ch] [ebp-10h]
    char* v7; // [esp+14h] [ebp-8h]

    if (a2 < 0)
        return 0;
    if (!a3 && thisx[34] <= a2)
        return 0;
    if (a3 && thisx[35] <= a2)
    {
        v6 = (a2 - thisx[34] + 1) / 64 + 1;
        for (i = 0; i < v6; ++i)
            sub_440F3C(thisx);
    }
    v7 = (char*)sub_44101E(thisx, a2 / 64);
    return sub_44106A(v7, a2 & 0x3F);
}
 
int sub_440F3C(_DWORD* thisx)
{
    int i; // eax
    struct Concurrency::IUMSCompletionList* v3; // [esp+0h] [ebp-24h]
    _DWORD* Block; // [esp+8h] [ebp-1Ch]
    Concurrency::details::UMSThreadScheduler* v6; // [esp+10h] [ebp-14h]

    Block = (_DWORD*)operator new(0x20Cu);
    if (Block)
        v3 = (struct Concurrency::IUMSCompletionList*)sub_440D9B(Block);
    else
        v3 = 0;
    if (!v3)
        return 0;
    if (thisx[1])
    {
        v6 = (Concurrency::details::UMSThreadScheduler*)thisx[1];
        for (i = sub_441090((_DWORD*)v6); i; i = sub_441090((_DWORD*)v6))
            v6 = (Concurrency::details::UMSThreadScheduler*)sub_441090((_DWORD*)v6);
        Concurrency::details::UMSThreadScheduler::SetCompletionList(v6, v3);
        sub_441140((_DWORD*)v3, (int)v6);
    }
    else
    {
        thisx[1] = (_DWORD)v3;
    }
    thisx[35] += 64;
    return 1;
}

 
_DWORD* sub_44101E(_DWORD* thisx, int a2)
{
    int i; // [esp+4h] [ebp-8h]
    _DWORD* v4; // [esp+8h] [ebp-4h]

    v4 = (_DWORD*)thisx[1];
    for (i = 0; i < a2; ++i)
    {
        if (!v4)
            return 0;
        v4 = (_DWORD*)sub_441090(v4);
    }
    return v4;
}
 
char* sub_44106A(char* thisx, int a2)
{
    if (a2 >= 0 && a2 < 64)
        return &thisx[8 * a2];
    else
        return 0;
}

 
int sub_441090(_DWORD* thisx)
{
    return thisx[130];
}

 
void* sub_4410B0(void* thisx, char a2)
{
    sub_440DE2(thisx);
    if ((a2 & 1) != 0)
        operator delete(thisx);
    return thisx;
}

 
BOOL sub_4410E0(_DWORD* thisx)
{
    return *thisx != 0;
}

 
_BYTE* sub_441100(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[5] = a2;
    return result;
}

 
_BYTE* sub_441120(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[5] += a2;
    return result;
}

 
_DWORD* sub_441140(_DWORD* thisx, int a2)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[129] = a2;
    return result;
}


 
int __cdecl sub_441180(int a1, LPCSTR lpName)
{
    void* Src; // [esp+0h] [ebp-1Ch] BYREF
    int v4; // [esp+4h] [ebp-18h] BYREF
    int v5; // [esp+8h] [ebp-14h] BYREF
    int v6; // [esp+Ch] [ebp-10h]
    int v7[2]; // [esp+10h] [ebp-Ch] BYREF
    int v8; // [esp+18h] [ebp-4h] BYREF

    v4 = 0;
    v5 = 0;
    v6 = 0;
    v7[0] = 0;
    v7[1] = 0;
    v8 = 0;
    if (sub_441282(0, lpName, (int)&v8, (int)&Src, (int)v7))
    {
        v5 = 20;
        v6 = 65538;
        if ((*(int(__stdcall**)(int, int*, int*, _DWORD))(*(_DWORD*)a1 + 12))(a1, &v5, &v4, 0) < 0)
        {
            return 0;
        }
        else if (!sub_4416F7(v4, Src, v7[0]))
        {
            (*(void(__stdcall**)(int))(*(_DWORD*)v4 + 8))(v4);
            return 0;
        }
    }
    return v4;
}

 
int __cdecl sub_441282(HMODULE hModule, LPCSTR lpName, int a3, int a4, int a5)
{
    HRSRC hResInfo; // [esp+0h] [ebp-Ch]
    LPVOID v7; // [esp+4h] [ebp-8h]
    HGLOBAL hResData; // [esp+8h] [ebp-4h]

    hResInfo = FindResourceA(hModule, lpName, "WAV");
    if (hResInfo)
    {
        hResData = LoadResource(hModule, hResInfo);
        if (hResData)
        {
            v7 = LockResource(hResData);
            if (v7)
            {
                if (sub_441799((_DWORD*)v7, (_DWORD*)a3, (_DWORD*)a4, (unsigned int*)a5))
                    return 1;
            }
        }
    }
    if (!hResInfo)
    {
        MessageBoxA(0, byte_4B0644, aError_5, 0);
        MessageBoxA(0, lpName, aError_6, 0);
    }
    return 0;
}

 
HLOCAL __cdecl sub_441434(HLOCAL hMem)
{
    HLOCAL result; // eax
    int i; // [esp+0h] [ebp-4h]

    if (hMem)
    {
        for (i = 0; i < *((_DWORD*)hMem + 2); ++i)
        {
            if (*((_DWORD*)hMem + i + 4))
            {
                (*(void(__stdcall**)(_DWORD))(**((_DWORD**)hMem + i + 4) + 8))(*((_DWORD*)hMem + i + 4));
                *((_DWORD*)hMem + i + 4) = 0;
            }
        }
        return LocalFree(hMem);
    }
    return result;
}

 
int __cdecl sub_4414A0(int a1)
{
    int v2; // [esp+4h] [ebp-8h] BYREF
    int v3; // [esp+8h] [ebp-4h]

    if (!a1)
        return 0;
    v3 = *(_DWORD*)(a1 + 4 * *(_DWORD*)(a1 + 12) + 16);
    if (v3)
    {
        if ((*(int(__stdcall**)(int, int*))(*(_DWORD*)v3 + 36))(v3, &v2) < 0)
            v2 = 0;
        if ((v2 & 1) == 1)
        {
            if (*(int*)(a1 + 8) <= 1)
            {
                v3 = 0;
            }
            else
            {
                if (++ * (_DWORD*)(a1 + 12) >= *(_DWORD*)(a1 + 8))
                    *(_DWORD*)(a1 + 12) = 0;
                v3 = *(_DWORD*)(a1 + 4 * *(_DWORD*)(a1 + 12) + 16);
                if ((*(int(__stdcall**)(int, int*))(*(_DWORD*)v3 + 36))(v3, &v2) >= 0 && (v2 & 1) == 1)
                {
                    (*(void(__stdcall**)(int))(*(_DWORD*)v3 + 72))(v3);
                    (*(void(__stdcall**)(int, _DWORD))(*(_DWORD*)v3 + 52))(v3, 0);
                }
            }
        }
        if (v3
            && (v2 & 2) != 0
            && ((*(int(__stdcall**)(int))(*(_DWORD*)v3 + 80))(v3) < 0 || !sub_4416F7(v3, *(void**)a1, *(_DWORD*)(a1 + 4))))
        {
            return 0;
        }
    }
    return v3;
}

 
int __cdecl sub_4416F7(int a1, void* Src, int a3)
{
    void* v4; // [esp+0h] [ebp-10h] BYREF
    void* v5; // [esp+4h] [ebp-Ch] BYREF
    size_t v6; // [esp+8h] [ebp-8h] BYREF
    size_t Size; // [esp+Ch] [ebp-4h] BYREF

    if (!a1
        || !Src
        || !a3
        || (*(int(__stdcall**)(int, _DWORD, int, void**, size_t*, void**, size_t*, _DWORD))(*(_DWORD*)a1 + 44))(
            a1,
            0,
            a3,
            &v5,
            &Size,
            &v4,
            &v6,
            0) < 0)
    {
        return 0;
    }
    memcpy(v5, Src, Size);
    if (v6)
        memcpy(v4, (char*)Src + Size, v6);
    (*(void(__stdcall**)(int, void*, size_t, void*, size_t))(*(_DWORD*)a1 + 76))(a1, v5, Size, v4, v6);
    return 1;
}

 
int __cdecl sub_441799(_DWORD* a1, _DWORD* a2, _DWORD* a3, unsigned int* a4)
{
    unsigned int v5; // eax
    unsigned int v6; // [esp+4h] [ebp-14h]
    unsigned int v7; // [esp+Ch] [ebp-Ch]
    _DWORD* v8; // [esp+10h] [ebp-8h]
    unsigned int* v9; // [esp+10h] [ebp-8h]
    _DWORD* v10; // [esp+10h] [ebp-8h]
    int v11; // [esp+14h] [ebp-4h]

    if (a2)
        *a2 = 0;
    if (a3)
        *a3 = 0;
    if (a4)
        *a4 = 0;
    v8 = a1 + 3;
    if (*a1 == 1179011410 && a1[2] == 1163280727)
    {
        v6 = (unsigned int)v8 + a1[1] - 4;
        while ((unsigned int)v8 < v6)
        {
            v11 = *v8;
            v9 = (unsigned int*)v8 + 1;
            v7 = *v9;
            v10 = (_DWORD*)v9 + 1;
            if (v11 == 544501094)
            {
                if (a2 && !*a2)
                {
                    if (v7 < 0xE)
                        return 0;
                    *a2 = (_DWORD)v10;
                    if ((!a3 || *a3) && (!a4 || *a4))
                        return 1;
                }
            }
            else if (v11 == 1635017060 && (a3 && !*a3 || a4 && !*a4))
            {
                if (a3)
                    *a3 = (_DWORD)v10;
                if (a4)
                    *a4 = v7;
                if (!a2 || *a2)
                    return 1;
            }
            v5 = v7 + 1;
            LOBYTE(v5) = (v7 + 1) & 0xFE;
            v8 = (_DWORD*)((char*)v10 + v5);
        }
    }
    return 0;
}

 
void sub_441930(void* thisx)
{
    *(_DWORD*)thisx = off_4AC2D8;
    *((_BYTE*)thisx + 20) = 0;
    *((_DWORD*)thisx + 3) = 0;
    *((_DWORD*)thisx + 1) = 0;
    *((_DWORD*)thisx + 2) = 0;
}

 
void sub_44196C(void* thisx)
{
    *(_DWORD*)thisx = off_4AC2D8;
}

 
int sub_441980(int thisx, int a2)
{
    int result; // eax

    if (a2)
    {
        *(_DWORD*)(thisx + 4) = *(_DWORD*)a2;
        *(_DWORD*)(thisx + 8) = *(_DWORD*)(a2 + 4);
        *(_BYTE*)(thisx + 20) = *(_BYTE*)(a2 + 8);
        *(_DWORD*)(thisx + 28) = *(_DWORD*)(a2 + 12);
        *(_DWORD*)(thisx + 16) = *(_DWORD*)(a2 + 16);
        *(_DWORD*)(thisx + 12) = -1;
        *(_DWORD*)(thisx + 32) = 0;
        result = sub_4419F6(thisx);
        *(_DWORD*)(thisx + 12) = 0;
    }
    return result;
}

 
int __fastcall sub_4419F6(int a1)
{
    int result; // eax

    result = a1;
    if (*(_BYTE*)(a1 + 20))
    {
        ++* (_DWORD*)(a1 + 12);
        result = *(unsigned __int8*)(a1 + 20);
        if (result == 1)
        {
            if (!*(_DWORD*)(a1 + 12))
            {
                *(_DWORD*)(a1 + 4) -= 4;
                *(_DWORD*)(a1 + 8) -= 4;
            }
            result = (*(_DWORD*)(a1 + 12) - 1) / 2;
            *(_DWORD*)(a1 + 24) = result;
            if (*(_DWORD*)(a1 + 12) == 6)
            {
                result = a1;
                *(_BYTE*)(a1 + 20) = 0;
            }
        }
        else if (*(unsigned __int8*)(a1 + 20) < 2u || (result = a1, *(unsigned __int8*)(a1 + 20) > 0x10u))
        {
            switch (*(_BYTE*)(a1 + 20))
            {
            case 0x11:
                if (*(_DWORD*)(a1 + 12) != 75
                    && *(_DWORD*)(a1 + 16)
                    && SchedulerBase::GetSchedulerProxy(*(SchedulerBase**)(a1 + 16)) == (struct Concurrency::ISchedulerProxy*)96)
                {
                    if (!*(_DWORD*)(a1 + 12))
                    {
                        if (*(_DWORD*)(a1 + 28))
                            *(_DWORD*)(a1 + 4) = -*(_DWORD*)(a1 + 4);
                        *(_DWORD*)(a1 + 4) -= 4;
                        *(_DWORD*)(a1 + 8) -= 4;
                    }
                    *(_DWORD*)(a1 + 24) = 3;
                    result = a1;
                    *(_DWORD*)(a1 + 32) = *(_DWORD*)(a1 + 12) % 2 == 0;
                }
                else
                {
                    result = a1;
                    *(_BYTE*)(a1 + 20) = 0;
                }
                break;
            case 0x12:
                result = *(_DWORD*)(a1 + 12) / 8 + 4;
                *(_DWORD*)(a1 + 24) = result;
                if (*(int*)(a1 + 12) >= 24)
                {
                    result = a1;
                    *(_BYTE*)(a1 + 20) = 0;
                }
                break;
            case 0x13:
                result = a1;
                if (*(int*)(a1 + 12) >= 15)
                {
                    result = (*(_DWORD*)(a1 + 12) - 15) / 4 + 1;
                    *(_DWORD*)(a1 + 24) = result;
                }
                else
                {
                    *(_DWORD*)(a1 + 24) = 0;
                }
                if (*(int*)(a1 + 12) >= 31)
                {
                    result = a1;
                    *(_BYTE*)(a1 + 20) = 0;
                }
                break;
            case 0x14:
                result = a1;
                if (*(int*)(a1 + 12) >= 20)
                    *(_BYTE*)(a1 + 20) = 0;
                break;
            }
        }
        else
        {
            result = *(_DWORD*)(a1 + 12) / 3;
            if (!(*(_DWORD*)(a1 + 12) % 3))
            {
                result = *(_DWORD*)(a1 + 8) - 1;
                *(_DWORD*)(a1 + 8) = result;
            }
            if (*(int*)(a1 + 12) >= 60)
            {
                result = a1;
                *(_BYTE*)(a1 + 20) = 0;
            }
            switch (*(_BYTE*)(a1 + 20))
            {
            case 2:
                result = a1;
                *(_DWORD*)(a1 + 24) = 3;
                break;
            case 3:
                result = a1;
                *(_DWORD*)(a1 + 24) = 4;
                break;
            case 4:
                result = a1;
                *(_DWORD*)(a1 + 24) = 4;
                break;
            case 5:
                result = a1;
                *(_DWORD*)(a1 + 24) = 1;
                break;
            case 6:
                result = a1;
                *(_DWORD*)(a1 + 24) = 0;
                break;
            case 7:
                result = a1;
                *(_DWORD*)(a1 + 24) = 2;
                break;
            case 8:
                result = a1;
                *(_DWORD*)(a1 + 24) = 5;
                break;
            case 9:
                result = a1;
                *(_DWORD*)(a1 + 24) = 5;
                break;
            case 0xA:
                result = a1;
                *(_DWORD*)(a1 + 24) = 6;
                break;
            case 0xB:
                result = a1;
                *(_DWORD*)(a1 + 24) = 7;
                break;
            case 0xC:
                result = a1;
                *(_DWORD*)(a1 + 24) = 7;
                break;
            case 0xD:
                result = a1;
                *(_DWORD*)(a1 + 24) = 8;
                break;
            case 0xE:
                result = a1;
                *(_DWORD*)(a1 + 24) = 10;
                break;
            case 0xF:
                result = a1;
                *(_DWORD*)(a1 + 24) = 8;
                break;
            case 0x10:
                result = a1;
                *(_DWORD*)(a1 + 24) = 8;
                break;
            }
        }
    }
    return result;
}

 
unsigned __int16* __fastcall sub_441DB3(int a1)
{
    unsigned __int16* result; // eax
    BOOL v2; // [esp+4h] [ebp-DCh]
    BOOL v3; // [esp+8h] [ebp-D8h]
    int v4; // [esp+Ch] [ebp-D4h]
    int v5; // [esp+10h] [ebp-D0h]
    int v7; // [esp+1Ch] [ebp-C4h]
    int ii; // [esp+20h] [ebp-C0h]
    int v9; // [esp+24h] [ebp-BCh]
    int v10; // [esp+28h] [ebp-B8h]
    int n; // [esp+2Ch] [ebp-B4h]
    int v12; // [esp+30h] [ebp-B0h]
    int v13; // [esp+34h] [ebp-ACh]
    int k; // [esp+38h] [ebp-A8h]
    int v15; // [esp+3Ch] [ebp-A4h]
    int v16; // [esp+40h] [ebp-A0h]
    int j; // [esp+44h] [ebp-9Ch]
    unsigned __int16* v18; // [esp+48h] [ebp-98h]
    int v19; // [esp+4Ch] [ebp-94h]
    int v20; // [esp+50h] [ebp-90h]
    char v21[8]; // [esp+54h] [ebp-8Ch]
    int m; // [esp+5Ch] [ebp-84h]
    char v23[8]; // [esp+60h] [ebp-80h]
    unsigned __int16* v24; // [esp+68h] [ebp-78h]
    int v25; // [esp+6Ch] [ebp-74h]
    int v26; // [esp+70h] [ebp-70h]
    int v27; // [esp+74h] [ebp-6Ch]
    int v28; // [esp+78h] [ebp-68h]
    int v29; // [esp+7Ch] [ebp-64h]
    int i; // [esp+80h] [ebp-60h]
    unsigned __int16* v31; // [esp+84h] [ebp-5Ch]
    int kk; // [esp+88h] [ebp-58h]
    int v33; // [esp+8Ch] [ebp-54h]
    int v34; // [esp+90h] [ebp-50h]
    int v35; // [esp+94h] [ebp-4Ch]
    unsigned __int16* jj; // [esp+98h] [ebp-48h]
    int v37; // [esp+9Ch] [ebp-44h]
    int v38[2]; // [esp+A0h] [ebp-40h] BYREF
    int v39; // [esp+A8h] [ebp-38h] BYREF
    int v40; // [esp+ACh] [ebp-34h]
    unsigned __int16* v41; // [esp+B0h] [ebp-30h]
    int v42; // [esp+C0h] [ebp-20h]
    BOOL v43; // [esp+C4h] [ebp-1Ch]

    result = (unsigned __int16*)a1;
    if (*(_BYTE*)(a1 + 20) && !*(_DWORD*)(a1 + 32))
    {
        sub_49C15E((int)&v39);
        if (*(_DWORD*)(a1 + 16))
        {
            sub_4097DF(*(void**)(a1 + 16), (int)v38);
            v40 = *(_DWORD*)(a1 + 4) + v38[0];
            v41 = (unsigned __int16*)(*(_DWORD*)(a1 + 8) + v38[1]);
        }
        else
        {
            v40 = *(_DWORD*)(a1 + 4) - sub_446465((char*)unk_4B9B10);
            v41 = *(unsigned __int16**)(a1 + 8);
        }
        if ((*(unsigned __int8*)(a1 + 20) < 2u || *(unsigned __int8*)(a1 + 20) > 9u)
            && (*(unsigned __int8*)(a1 + 20) < 0xBu || *(unsigned __int8*)(a1 + 20) > 0x10u))
        {
            switch (*(_BYTE*)(a1 + 20))
            {
            case 0xA:
                v40 -= 16;
                v39 = dword_4B91F0 + *(_DWORD*)(a1 + 24) + 17;
                return sub_49AB05((int)unk_4BDC60, &v39);
            case 0x11:
                v39 = dword_4B91F0 + *(_DWORD*)(a1 + 24);
                v42 = *(_DWORD*)(a1 + 28);
                sub_49AB05((int)unk_4BDC60, &v39);
                result = (unsigned __int16*)a1;
                if (*(int*)(a1 + 12) > 55)
                {
                    v29 = v40;
                    v31 = v41;
                    for (i = 0; i < 8; ++i)
                    {
                        switch (i)
                        {
                        case 0:
                            v28 = 0;
                            v27 = -100;
                            break;
                        case 1:
                            v28 = 70;
                            v27 = -70;
                            break;
                        case 2:
                            v28 = 100;
                            v27 = 0;
                            break;
                        case 3:
                            v28 = 70;
                            v27 = 70;
                            break;
                        case 4:
                            v28 = 0;
                            v27 = 100;
                            break;
                        case 5:
                            v28 = -70;
                            v27 = 70;
                            break;
                        case 6:
                            v28 = -100;
                            v27 = 0;
                            break;
                        case 7:
                            v28 = -70;
                            v27 = -70;
                            break;
                        default:
                            break;
                        }
                        v25 = (*(_DWORD*)(a1 + 12) - 50) * v28 / 150;
                        v26 = v27 * (*(_DWORD*)(a1 + 12) - 50) / 150;
                        if (*(int*)(a1 + 12) >= 65)
                        {
                            v25 = v28 * (*(_DWORD*)(a1 + 12) - 65) / 400 + 15 * v28 / 150;
                            v26 = v27 * (*(_DWORD*)(a1 + 12) - 65) / 400 + 15 * v27 / 150;
                        }
                        v40 = v25 + v29;
                        v41 = (unsigned __int16*)((char*)v31 + v26);
                        sub_49AB05((int)unk_4BDC60, &v39);
                        result = (unsigned __int16*)(i + 1);
                    }
                }
                break;
            case 0x13:
                if (*(_DWORD*)(a1 + 24))
                {
                    if (*(_DWORD*)(a1 + 24) == 1)
                    {
                        v40 -= 4;
                        v41 -= 2;
                        v39 = dword_4B91F0 + 3;
                        return sub_49AB05((int)unk_4BDC60, &v39);
                    }
                    else if (*(_DWORD*)(a1 + 24) == 2)
                    {
                        v16 = v40;
                        result = v41;
                        v15 = (int)v41;
                        v39 = dword_4B91F0 + 7;
                        for (j = 0; j < 4; ++j)
                        {
                            v40 = v16 - 8 * (j % 2 == 0);
                            v41 = (unsigned __int16*)(v15 - 8 * (j / -2 == 0));
                            v3 = j == 1 || j == 3;
                            v42 = v3;
                            v43 = j >= 2;
                            result = sub_49AB05((int)unk_4BDC60, &v39);
                        }
                    }
                    else
                    {
                        result = (unsigned __int16*)a1;
                        if (*(_DWORD*)(a1 + 24) == 3 || *(_DWORD*)(a1 + 24) == 4)
                        {
                            v13 = v40;
                            v12 = (int)v41;
                            result = (unsigned __int16*)dword_4B91F0;
                            v39 = dword_4B91F0 + *(_DWORD*)(a1 + 24) + 5;
                            for (k = 0; k < 4; ++k)
                            {
                                v40 = v13 - 16 * (k % 2 == 0);
                                v41 = (unsigned __int16*)(v12 - 16 * (k / -2 == 0));
                                v2 = k == 1 || k == 3;
                                v42 = v2;
                                v43 = k >= 2;
                                result = sub_49AB05((int)unk_4BDC60, &v39);
                            }
                        }
                    }
                }
                else
                {
                    v19 = v40 - 4;
                    v18 = v41 - 2;
                    result = (unsigned __int16*)(*(_DWORD*)(a1 + 12) * *(_DWORD*)(a1 + 12) / 7);
                    v24 = result;
                    v20 = 32 - (_DWORD)result;
                    v23[0] = -10;
                    v23[1] = -7;
                    v23[2] = 0;
                    v23[3] = 7;
                    v23[4] = 10;
                    v23[5] = 7;
                    v23[6] = 0;
                    v23[7] = -7;
                    v21[0] = 0;
                    v21[1] = -7;
                    v21[2] = -10;
                    v21[3] = -7;
                    v21[4] = 0;
                    v21[5] = 7;
                    v21[6] = 10;
                    v21[7] = 7;
                    for (m = 0; m < 8; ++m)
                    {
                        v40 = v23[m] * v20 / 10 + v19;
                        v41 = (unsigned __int16*)((char*)v18 + v21[m] * v20 / 10);
                        v42 = v23[m] > 0;
                        v43 = v21[m] > 0;
                        if (v23[m] <= 0)
                            v5 = -v23[m];
                        else
                            v5 = v23[m];
                        if (v23[m] <= 0)
                            v4 = -v23[m];
                        else
                            v4 = v23[m];
                        v39 = 3 * (v4 == 7) + dword_4B91F0 + (v5 == 10) + 9 + 2 * (v23[m] == 0);
                        sub_49AB05((int)unk_4BDC60, &v39);
                        result = (unsigned __int16*)(m + 1);
                    }
                }
                break;
            case 0x14:
                v10 = v40;
                result = v41;
                v9 = (int)v41;
                for (n = 0; n < 2; ++n)
                {
                    result = (unsigned __int16*)a1;
                    v7 = 5 * n + *(_DWORD*)(a1 + 12);
                    if (*(int*)(a1 + 12) > 12)
                    {
                        result = (unsigned __int16*)(dword_4B93B0 / 2u);
                        if (dword_4B93B0 % 2u == 1)
                            continue;
                    }
                    if (v7 > 20)
                        return result;
                    for (ii = 0; ii < 2; ++ii)
                    {
                        v40 = v10 + (v7 / (3 - n) + 2) * ((__PAIR64__(ii == 1, ii) - 1) >> 32) - 4;
                        v41 = (unsigned __int16*)(v9 + (5 * v7 - 100) * v7 / 100 - 4 - 4 * n);
                        v42 = ii == 1;
                        v39 = dword_4B91F0 + (v7 > 10) + 13;
                        result = sub_49AB05((int)unk_4BDC60, &v39);
                    }
                }
                break;
            default:
                v39 = dword_4B91F0 + *(_DWORD*)(a1 + 24);
                v42 = *(_DWORD*)(a1 + 28);
                return sub_49AB05((int)unk_4BDC60, &v39);
            }
        }
        else
        {
            v35 = 2;
            v37 = 24;
            v34 = v40;
            v40 -= 24;
            if (byte_4B066A[3 * *(unsigned __int8*)(a1 + 20) - 6] >= 0)
            {
                v35 = 3;
                v40 -= v37 / 2;
            }
            for (jj = 0; ; jj = (unsigned __int16*)((char*)jj + 1))
            {
                result = jj;
                if ((int)jj >= v35)
                    break;
                v37 = 24;
                v33 = byte_4B0668[(_DWORD)jj + 3 * *(unsigned __int8*)(a1 + 20) - 6];
                if (v33 == 9)
                    v37 = 32;
                v39 = dword_4B91F0 + v33 + 15;
                sub_49AB05((int)unk_4BDC60, &v39);
                v40 += v37;
            }
            if (*(_BYTE*)(a1 + 20) == 4)
            {
                result = v41 - 4;
                v41 -= 4;
                v40 = v34 - 24;
                for (kk = 0; kk < 2; ++kk)
                {
                    v39 = dword_4B91F0 + byte_4B0671[kk] + 15;
                    result = sub_49AB05((int)unk_4BDC60, &v39);
                    v40 += 24;
                }
            }
        }
    }
    return result;
}

 
int sub_442815(int thisx)
{
    int result; // eax

    *(_BYTE*)(thisx + 20) = 0;
    *(_DWORD*)(thisx + 12) = 0;
    *(_DWORD*)(thisx + 24) = 0;
    *(_DWORD*)(thisx + 4) = 0;
    *(_DWORD*)(thisx + 8) = 0;
    *(_DWORD*)(thisx + 28) = 0;
    result = thisx;
    *(_DWORD*)(thisx + 16) = 0;
    return result;
}

 
_DWORD* sub_442863(_DWORD* thisx)
{
    *thisx = 0;
    thisx[1] = 0;
    thisx[3] = 0;
    *((_BYTE*)thisx + 8) = 0;
    thisx[4] = 0;
    return thisx;
}

 
void* sub_4428A0(void* thisx, char a2)
{
    sub_44196C(thisx);
    if ((a2 & 1) != 0)
        operator delete(thisx);
    return thisx;
}

 //Õâ¸öthisÊÇunk_4B9B10
char* sub_4428D0(char* thisx)
{
    int v1; // edx
    char v4[11]; // [esp+4h] [ebp-2Ch] BYREF
    char Src[11]; // [esp+10h] [ebp-20h] BYREF
    char j; // [esp+1Ch] [ebp-14h]
    int i; // [esp+20h] [ebp-10h]
    int v8; // [esp+2Ch] [ebp-4h]

    sub_486060((_DWORD*)thisx + 128);
    v8 = 17;
    sub_47F190((_DWORD*)thisx + 736);
    sub_48E870((_DWORD*)thisx + 1300);
    eh_vector_constructor_iterator(
        thisx + 2628,
        0x264u,
        8,
        sub_40211F,
        (void(*)(void*))Concurrency::details::VirtualProcessorRoot::_VirtualProcessorRoot);
        eh_vector_constructor_iterator(thisx + 7524, 0xC4u, 8, sub_490B80, sub_490BC8);
            eh_vector_constructor_iterator(thisx + 9096, 0x10u, 32, sub_43F130, sub_43F164);
            eh_vector_constructor_iterator(thisx + 9608, 0x24u, 32, sub_441930, sub_44196C);
            eh_vector_constructor_iterator(thisx + 10760, 0x28u, 8, sub_47EFC0, sub_47EFDE);

            eh_vector_constructor_iterator(
            thisx + 11080,
            0x18u,
            4,
            (void(*)(void*)) new_DNameNode,
            sub_43EED1);
            sub_463E60((_DWORD)(thisx + 11436));
            sub_402080((int)(thisx + 11816), 76, 2, (void(*)(int))sub_463EF0);
            sub_483390((_DWORD*)(thisx + 13400));//Ç¿×ª//Õâ¸öºóÃæµÄ+»á¸ù¾ÝÇ°ÃæÇ¿ÖÆ×ª»»µÄÖ¸ÕëÀàÐÍ¶ø¸Ä±ä´óÐ¡¡£Ò²»á¸ù¾ÝËû±¾À´µÄÀàÐÍ£¬¸Ä±ä£¬ÀýÈçint*ÀàÐÍ+1£¬ÆäÊµ¾ÍÊÇthis+4×Ö½Ú£¬Õâ¸öÖ»ÏÞÓÚÖ¸ÕëÀàÐÍ
            eh_vector_constructor_iterator(thisx + 15644, 0x24u, 4, sub_47FC70, sub_47FCCF);
            sub_48E210((thisx + 15788));//Ç¿×ª
            sub_4851A0(thisx + 15824);
            sub_48F050(thisx + 15860);
            sub_48E990(thisx + 15896);
            sub_401000(thisx + 15956);
            sub_485750(thisx + 15992);
            sub_480BC0((_DWORD*)(thisx + 16048));
            sub_480F30((_DWORD*)(thisx + 16084));
            *(_DWORD*)thisx = off_4AC2DC;
            *((_DWORD*)thisx + 26) = 3;
            *((_DWORD*)thisx + 622) = 100;
            thisx[2496] = 1;
            *((_DWORD*)thisx + 2273) = 0;
            *((_DWORD*)thisx + 628) = 0;
            thisx[2516] = 0;
            byte_4B9985 = 4;
            byte_4B9986 = 1;
            byte_4B9987 = 3;
            byte_4B99CD = 0;
            thisx[79] = 1;
            thisx[80] = 0;
            thisx[76] = 1;
            thisx[30] = 4;
            thisx[98] = 0;
            thisx[99] = 1;
            thisx[100] = 0;
            *((_DWORD*)thisx + 3349) = 0;
            thisx[11352] = 0;
            *((_DWORD*)thisx + 2839) = 0;
            *((_DWORD*)thisx + 2840) = 0;
            thisx[11364] = 0;
            *((_DWORD*)thisx + 2842) = 0;
            *((_DWORD*)thisx + 3276) = -1;
            *((_DWORD*)thisx + 3277) = 0;
            *((_DWORD*)thisx + 3278) = 0;
            *((_DWORD*)thisx + 3279) = 0;
            *((_DWORD*)thisx + 3280) = 0;
            memset(thisx + 16140, 0, 0x104u);
            thisx[11420] = 0;
            *((_DWORD*)thisx + 2856) = 0;
            thisx[11432] = 0;
            thisx[13124] = 0;
            *((_DWORD*)thisx + 3348) = 0;
            *((_DWORD*)thisx + 3907) = 0;
            *((_DWORD*)thisx + 3908) = 0;
            *((_DWORD*)thisx + 3909) = 0;
            thisx[11690] = 1;
            for (i = 0; i < 8; ++i)
            {
                for (j = 0; j < 11; ++j)
                {
                    if (j < 4)
                        v1 = -(j + 1);
                    else
                        LOBYTE(v1) = j - 4;
                    thisx[11 * i + 11176 + j] = v1;
                }
                if (i % 2)
                {
                    memcpy(v4, "&(%'IOPKL89", sizeof(v4));
                    memcpy(&thisx[11 * i + 11264], v4, 0xBu);
                }
                else
                {
                    memcpy(Src, "YBGJASDZXQW", sizeof(Src));
                    memcpy(&thisx[11 * i + 11264], Src, 0xBu);
                }
            }
            for (i = 0; i < 5; ++i)
                *(_DWORD*)&thisx[4 * i + 11380] = 0;
            for (i = 0; i < 8; ++i)
            {
                byte_4B9988[i] = i;
                thisx[i + 2620] = 0;
            }
            for (i = 0; i < 14; ++i)
                *(_WORD*)&thisx[2 * i + 48] = 10;
            *((_DWORD*)thisx + 4101) = 0;
            return thisx;
}

 
int sub_442E54(_DWORD* thisx)
{
    *thisx = off_4AC2DC;
    sub_45566E((int)thisx);
    sub_45F935((int)thisx);
    sub_45FD81((int)thisx);
    sub_467C6D((int)thisx);
    sub_46D6CB((int)thisx);
    sub_481010(thisx + 4021);
    sub_480D15(thisx + 4012);
    sub_48578B(thisx + 3998);
    sub_401119(thisx + 3989);
    sub_48E9CB(thisx + 3974);
    sub_48F08B(thisx + 3965);
    sub_4851DB(thisx + 3956);
    sub_48E374(thisx + 3947);
    eh_vector_destructor_iterator(thisx + 3911, 0x24u, 4, sub_47FCCF);
        sub_4833CE(thisx + 3350);
    eh_vector_destructor_iterator(thisx + 2770, 0x18u, 4, sub_43EED1);
        eh_vector_destructor_iterator(thisx + 2690, 0x28u, 8, sub_47EFDE);
        eh_vector_destructor_iterator(thisx + 2402, 0x24u, 32, sub_44196C);
        eh_vector_destructor_iterator(thisx + 2274, 0x10u, 32, sub_43F164);
        eh_vector_destructor_iterator(thisx + 1881, 0xC4u, 8, sub_490BC8);
        eh_vector_destructor_iterator(
        thisx + 657,
        0x264u,
        8,
        (void(*)(void*))VirtualProcessorRoot::_VirtualProcessorRoot);
        sub_48E8A4(thisx + 325);
        sub_47F1FD(thisx + 184);
        return sub_486119(thisx + 32);
}

 
int sub_443059(_DWORD* thisx, double a2, double a3, double a4, char a5)
{
    sub_474DB0((char*)unk_4BDC60, a5);
    switch (thisx[26])
    {
    case 1:
        sub_456FC8((int)thisx);
        break;
    case 2:
        sub_453AAA((int)thisx);
        break;
    case 3:
        sub_44C60C((int)thisx);
        break;
    case 4:
        sub_474BC1((int)thisx);
        break;
    case 5:
        sub_44E835((int)thisx);
        break;
    case 6:
        sub_46753B((int)thisx);
        break;
    case 7:
        sub_44ED4D((UINT)thisx);
        break;
    case 8:
        sub_447651((int)thisx);
        break;
    case 9:
        sub_452368((int)thisx);
        break;
    case 0xA:
        sub_44E5BA(thisx, a2, a3, a4);
        break;
    case 0xB:
        sub_448929((int)thisx, a2, a3, a4);
        break;
    case 0xC:
        sub_44B63F((int)thisx, a2, a3, a4);
        break;
    case 0xD:
        sub_457F11((int)thisx);
        break;
    case 0xE:
        sub_45AB5E((int)thisx);
        break;
    case 0xF:
        sub_45BDE8((int)thisx);
        break;
    case 0x10:
        sub_45C809((int)thisx);
        break;
    case 0x11:
        sub_45CC4E((int)thisx);
        break;
    case 0x12:
        sub_45D7AB((int)thisx);
        break;
    case 0x13:
        sub_45E773((int)thisx);
        break;
    case 0x14:
        sub_4617E5((int)thisx);
        break;
    case 0x15:
        sub_47336A((int)thisx);
        break;
    case 0x16:
        sub_46881A((int)thisx);
        break;
    case 0x17:
        sub_46E35A((int)thisx, a2, a3, a4);
        break;
    case 0x18:
        sub_470C48((int)thisx);
        break;
    case 0x19:
        sub_47188C((int)thisx);
        break;
    case 0x1A:
        sub_4724BD((int)thisx);
        break;
    case 0x1B:
        sub_473D4B((int)thisx);
        break;
    default:
        break;
    }
    sub_4532F2((int)thisx, a2, a3, a4);
    sub_457408((int)thisx);
    return sub_48E8E1((int)(thisx + 325));
}
 
int sub_44325C(int thisx)
{
    int v1; // ebx
    int v2; // eax
    int result; // eax
    CHAR String[256]; // [esp+Ch] [ebp-140h] BYREF
    int v6; // [esp+10Ch] [ebp-40h]
    int mm; // [esp+110h] [ebp-3Ch]
    int kk; // [esp+114h] [ebp-38h]
    int v9; // [esp+118h] [ebp-34h]
    _DWORD* v10; // [esp+11Ch] [ebp-30h]
    int jj; // [esp+120h] [ebp-2Ch]
    int ii; // [esp+124h] [ebp-28h]
    int v13; // [esp+128h] [ebp-24h]
    int n; // [esp+12Ch] [ebp-20h]
    int m; // [esp+130h] [ebp-1Ch]
    int v16; // [esp+134h] [ebp-18h]
    int k; // [esp+138h] [ebp-14h]
    int v18; // [esp+13Ch] [ebp-10h]
    int j; // [esp+140h] [ebp-Ch]
    int v20; // [esp+144h] [ebp-8h]
    int i; // [esp+148h] [ebp-4h]

    for (i = 0; i < *(unsigned __int8*)(thisx + 11352); ++i)
    {
        *(_BYTE*)(*(_DWORD*)(thisx + 11356) + i) = 0;
        *(_DWORD*)(*(_DWORD*)(thisx + 11360) + 4 * i) = 0;
    }
    if (*(_DWORD*)(thisx + 104) != 1)
    {
        for (i = 0; i < 8; ++i)
        {
            if (unknown_libname_7((_DWORD*)(thisx + 612 * i + 2628)))
            {
                v20 = sub_4260B0((_DWORD*)(thisx + 612 * i + 2628));
                for (j = 0; j < 8; ++j)
                {
                    v18 = 0;
                    if (v20 == *(_DWORD*)(*(_DWORD*)(thisx + 11360) + 4 * j))
                    {
                        if (*(_BYTE*)(*(_DWORD*)(thisx + 11356) + j))
                        {
                            v1 = (unsigned __int8)sub_426030((_BYTE*)(thisx + 612 * i + 2628));
                            if (v1 < (unsigned __int8)sub_426030((_BYTE*)(thisx
                                + 612
                                * (*(unsigned __int8*)(*(_DWORD*)(thisx + 11356) + j) - 1)
                                + 2628)))
                                v18 = 1;
                        }
                    }
                    if (v18 || v20 < *(_DWORD*)(*(_DWORD*)(thisx + 11360) + 4 * j) || !*(_BYTE*)(*(_DWORD*)(thisx + 11356) + j))
                    {
                        for (k = 7; k > j; --k)
                        {
                            *(_DWORD*)(*(_DWORD*)(thisx + 11360) + 4 * k) = *(_DWORD*)(*(_DWORD*)(thisx + 11360) + 4 * k - 4);
                            *(_BYTE*)(*(_DWORD*)(thisx + 11356) + k) = *(_BYTE*)(*(_DWORD*)(thisx + 11356) + k - 1);
                        }
                        *(_DWORD*)(*(_DWORD*)(thisx + 11360) + 4 * j) = v20;
                        *(_BYTE*)(*(_DWORD*)(thisx + 11356) + j) = i + 1;
                        break;
                    }
                }
            }
        }
        for (i = 0; i < 8; ++i)
        {
            if (sub_426290((unsigned __int8*)(thisx + 40 * i + 10760)))
            {
                v16 = 100 * unknown_libname_26((_DWORD*)(thisx + 40 * i + 10760));
                for (m = 0; m < *(unsigned __int8*)(thisx + 11352); ++m)
                {
                    if (v16 < *(_DWORD*)(*(_DWORD*)(thisx + 11360) + 4 * m) || !*(_BYTE*)(*(_DWORD*)(thisx + 11356) + m))
                    {
                        for (n = *(unsigned __int8*)(thisx + 11352) - 1; n > m; --n)
                        {
                            *(_DWORD*)(*(_DWORD*)(thisx + 11360) + 4 * n) = *(_DWORD*)(*(_DWORD*)(thisx + 11360) + 4 * n - 4);
                            *(_BYTE*)(*(_DWORD*)(thisx + 11356) + n) = *(_BYTE*)(*(_DWORD*)(thisx + 11356) + n - 1);
                        }
                        *(_DWORD*)(*(_DWORD*)(thisx + 11360) + 4 * m) = v16;
                        *(_BYTE*)(*(_DWORD*)(thisx + 11356) + m) = i + 9;
                        break;
                    }
                }
            }
        }
        for (i = 0; i < 8; ++i)
        {
            if (unknown_libname_22((_DWORD*)(thisx + 196 * i + 7524))
                && unknown_libname_12((_DWORD*)(thisx + 196 * i + 7524)) != 1)
            {
                v13 = sub_426530((_DWORD*)(thisx + 196 * i + 7524));
                for (ii = 0; ii < *(unsigned __int8*)(thisx + 11352); ++ii)
                {
                    if (v13 < *(_DWORD*)(*(_DWORD*)(thisx + 11360) + 4 * ii) || !*(_BYTE*)(*(_DWORD*)(thisx + 11356) + ii))
                    {
                        for (jj = *(unsigned __int8*)(thisx + 11352) - 1; jj > ii; --jj)
                        {
                            *(_DWORD*)(*(_DWORD*)(thisx + 11360) + 4 * jj) = *(_DWORD*)(*(_DWORD*)(thisx + 11360) + 4 * jj - 4);
                            *(_BYTE*)(*(_DWORD*)(thisx + 11356) + jj) = *(_BYTE*)(*(_DWORD*)(thisx + 11356) + jj - 1);
                        }
                        *(_DWORD*)(*(_DWORD*)(thisx + 11360) + 4 * ii) = v13;
                        *(_BYTE*)(*(_DWORD*)(thisx + 11356) + ii) = i + 17;
                        break;
                    }
                }
            }
        }
    }
    for (i = 0; i < *(unsigned __int8*)(thisx + 11364); ++i)
    {
        v10 = (_DWORD*)sub_488E1E((_DWORD*)(thisx + 128), *(_DWORD*)(*(_DWORD*)(thisx + 11368) + 4 * i));
        if (v10)
        {
            v9 = 100 * sub_474DD0(v10);
            for (kk = 0; kk < *(unsigned __int8*)(thisx + 11352); ++kk)
            {
                if (v9 < *(_DWORD*)(*(_DWORD*)(thisx + 11360) + 4 * kk) || !*(_BYTE*)(*(_DWORD*)(thisx + 11356) + kk))
                {
                    for (mm = *(unsigned __int8*)(thisx + 11352) - 1; mm > kk; --mm)
                    {
                        *(_DWORD*)(*(_DWORD*)(thisx + 11360) + 4 * mm) = *(_DWORD*)(*(_DWORD*)(thisx + 11360) + 4 * mm - 4);
                        *(_BYTE*)(*(_DWORD*)(thisx + 11356) + mm) = *(_BYTE*)(*(_DWORD*)(thisx + 11356) + mm - 1);
                    }
                    *(_DWORD*)(*(_DWORD*)(thisx + 11360) + 4 * kk) = v9;
                    *(_BYTE*)(*(_DWORD*)(thisx + 11356) + kk) = i + 25;
                    break;
                }
            }
        }
    }
    for (i = 0; i < *(unsigned __int8*)(thisx + 11352); ++i)
    {
        if (*(_BYTE*)(*(_DWORD*)(thisx + 11356) + i))
        {
            if (*(unsigned __int8*)(*(_DWORD*)(thisx + 11356) + i) >= 9u)
            {
                if (*(unsigned __int8*)(*(_DWORD*)(thisx + 11356) + i) >= 0x11u)
                {
                    if (*(unsigned __int8*)(*(_DWORD*)(thisx + 11356) + i) >= 0x19u)
                    {
                        v6 = sub_488E1E(
                            (_DWORD*)(thisx + 128),
                            *(_DWORD*)(*(_DWORD*)(thisx + 11368) + 4 * *(unsigned __int8*)(*(_DWORD*)(thisx + 11356) + i) - 100));
                        if (v6)
                        {
                            v2 = unknown_libname_10((_DWORD*)(thisx + 128));
                            sub_48D421(v6, v2 + 1);
                        }
                    }
                    else
                    {
                        sub_490D23(thisx + 196 * (*(unsigned __int8*)(*(_DWORD*)(thisx + 11356) + i) - 17) + 7524);
                    }
                }
                else
                {
                    sub_47F0B1(thisx + 40 * (*(unsigned __int8*)(*(_DWORD*)(thisx + 11356) + i) - 9) + 10760);
                }
            }
            else
            {
                sub_40230C(thisx + 612 * (*(unsigned __int8*)(*(_DWORD*)(thisx + 11356) + i) - 1) + 2628);
            }
        }
    }
    result = (unsigned __int8)byte_4B91D9;
    if (byte_4B91D9 == 2)
    {
        for (i = 0; ; ++i)
        {
            result = *(unsigned __int8*)(thisx + 11352);
            if (i >= result)
                break;
            wsprintfA(
                String,
                "%2d, %d",
                *(unsigned __int8*)(*(_DWORD*)(thisx + 11356) + i),
                *(_DWORD*)(*(_DWORD*)(thisx + 11360) + 4 * i));
            sub_47B7ED(8, 10 * i, String, 0, -1);
        }
    }
    return result;
} 
BOOL __stdcall sub_443B2A(_DWORD* a1, _DWORD* a2)
{
    int v3; // eax
    int v4; // eax
    int* v5; // eax
    int v6; // esi
    int v7; // esi
    int v8; // esi
    int v9; // eax
    int v10; // eax
    int v11; // eax
    int v12; // eax
    int v13; // eax
    int ExecutingProxy; // eax
    int v15; // eax
    int v16; // eax
    int v17; // eax
    int v18; // eax
    int v19; // eax
    int v20; // [esp+4h] [ebp-68h]
    int v21[4]; // [esp+Ch] [ebp-60h] BYREF
    struct tagRECT v22; // [esp+1Ch] [ebp-50h] BYREF
    int v23[4]; // [esp+2Ch] [ebp-40h] BYREF
    int v24; // [esp+3Ch] [ebp-30h]
    int v25; // [esp+40h] [ebp-2Ch]
    int v26; // [esp+44h] [ebp-28h]
    int v27; // [esp+48h] [ebp-24h]
    struct tagRECT v28; // [esp+4Ch] [ebp-20h]
    char* v29; // [esp+5Ch] [ebp-10h]
    char* v30; // [esp+60h] [ebp-Ch]
    Concurrency::details::UMSFreeVirtualProcessorRoot* v31; // [esp+64h] [ebp-8h]
    int v32; // [esp+68h] [ebp-4h]

    v30 = (char*)sub_41C915((_DWORD)a1);
    v29 = (char*)sub_41C915((_DWORD)a2);
    if (!v30 || !v29)
        return 0;
    v3 = sub_425D70(a1);
    v28 = *(struct tagRECT*)sub_425B90(v30, v23, v3, 0);
    v31 = (Concurrency::details::UMSFreeVirtualProcessorRoot*)sub_426910(a1);
    v32 = 0;
    if (v31 && !v28.left && !v28.top && !v28.right && !v28.bottom)
    {
        v28 = *sub_491709((int)v31, &v22, 0);
        v32 = 1;
    }
    v4 = sub_425D70(a2);
    v5 = sub_425BD0(v29, v21, v4, 0);
    v24 = *v5;
    v25 = v5[1];
    v26 = v5[2];
    v27 = v5[3];
    if (!sub_474E10((unsigned char*)a1) && !v28.left && !v28.top && !v28.right && !v28.bottom)
        return 0;
    if (!v24 && !v25 && !v26 && !v27)
        return 0;
    if (sub_474E10((unsigned char*)a1))
        return 1;
    v6 = sub_4260B0(a1) / 100;
    if (v6 - sub_4260B0(a2) / 100 <= 0)
    {
        v8 = sub_4260B0(a1) / 100;
        v20 = sub_4260B0(a2) / 100 - v8;
    }
    else
    {
        v7 = sub_4260B0(a1) / 100;
        v20 = v7 - sub_4260B0(a2) / 100;
    }
    if (v20 > (unsigned __int8)sub_4264B0((char*)a1))
        return 0;
    if (v32)
    {
        v13 = sub_426470((_DWORD*)v31);
        v28.left += v13 / 100;
        ExecutingProxy = (int)Concurrency::details::UMSFreeVirtualProcessorRoot::GetExecutingProxy(v31);
        v28.top += ExecutingProxy / 100;
        v15 = sub_426470((_DWORD*)v31);
        v28.right += v15 / 100;
        v12 = (int)Concurrency::details::UMSFreeVirtualProcessorRoot::GetExecutingProxy(v31);
    }
    else
    {
        v9 = sub_426090(a1);
        v28.left += v9 / 100;
        v10 = sub_4260D0(a1);
        v28.top += v10 / 100;
        v11 = sub_426090(a1);
        v28.right += v11 / 100;
        v12 = sub_4260D0(a1);
    }
    v28.bottom += v12 / 100;
    v16 = sub_426090(a2);
    v24 += v16 / 100;
    v17 = sub_4260D0(a2);
    v25 += v17 / 100;
    v18 = sub_426090(a2);
    v26 += v18 / 100;
    v19 = sub_4260D0(a2);
    v27 += v19 / 100;
    return v28.left - v24 <= v26 - v24
        && v24 - v28.left <= v28.right - v28.left
        && v28.top - v25 <= v27 - v25
        && v25 - v28.top <= v28.bottom - v28.top;
}

 
int sub_443E80(int thisx)
{
    int v1; // eax
    int v2; // eax
    unsigned __int16 v3; // ax
    int v4; // esi
    int v5; // eax
    int v6; // eax
    unsigned __int16 v7; // ax
    char v8; // al
    int result; // eax
    int v10; // [esp-10h] [ebp-5F0h]
    CHAR v12[1024]; // [esp+10h] [ebp-5D0h] BYREF
    struct tagRECT v13; // [esp+410h] [ebp-1D0h] BYREF
    struct tagRECT v14; // [esp+420h] [ebp-1C0h] BYREF
    int v15; // [esp+430h] [ebp-1B0h]
    int v16; // [esp+434h] [ebp-1ACh]
    int v17; // [esp+438h] [ebp-1A8h]
    __int16 v18; // [esp+43Ch] [ebp-1A4h]
    struct tagRECT v19; // [esp+440h] [ebp-1A0h] BYREF
    int v20; // [esp+450h] [ebp-190h]
    struct tagRECT v21; // [esp+454h] [ebp-18Ch] BYREF
    int v22; // [esp+464h] [ebp-17Ch]
    struct tagRECT v23; // [esp+468h] [ebp-178h] BYREF
    struct tagRECT rc; // [esp+478h] [ebp-168h] BYREF
    int v25; // [esp+488h] [ebp-158h]
    int v26; // [esp+48Ch] [ebp-154h]
    int v27; // [esp+490h] [ebp-150h]
    int v28; // [esp+494h] [ebp-14Ch]
    int v29; // [esp+498h] [ebp-148h]
    int xLeft; // [esp+49Ch] [ebp-144h]
    int v31; // [esp+4A0h] [ebp-140h]
    int i; // [esp+4A4h] [ebp-13Ch]
    CHAR String[256]; // [esp+4A8h] [ebp-138h] BYREF
    int v34; // [esp+5A8h] [ebp-38h] BYREF
    int v35; // [esp+5ACh] [ebp-34h]
    int v36; // [esp+5B0h] [ebp-30h]

    sub_49C15E((int)&v34);
    v35 = 0;
    v36 = 176;
    if (*(_DWORD*)(thisx + 116) == 3)
        v34 = dword_4B9208;
    else
        v34 = dword_4B920C;
    sub_49AB05((int)unk_4BDC60, &v34);
    for (i = 0; i < 8 && (*(_DWORD*)(thisx + 116) != 3 || i <= 0); ++i)
    {
        LOBYTE(v29) = byte_4B9988[i];
        LOBYTE(v27) = sub_425E70((_BYTE*)(thisx + 612 * (unsigned __int8)v29 + 2628));
        if (unknown_libname_7((_DWORD*)(thisx + 612 * (unsigned __int8)v29 + 2628)))
        {
            xLeft = 79 * (i % 4) + 8;
            v28 = 28 * (i / 4) + 182;
            if (sub_41BEA6((_DWORD*)(thisx + 612 * (unsigned __int8)v29 + 2628)))
            {
                v35 = xLeft;
                v36 = v28;
                v34 = dword_4B9200 + 9;
                sub_49AB05((int)unk_4BDC60, &v34);
                v35 += 8;
                v34 = dword_4B9200 + 10;
            }
            else
            {
                v35 = xLeft;
                v36 = v28;
                v34 = (unsigned __int8)v29 + dword_4B9200;
                sub_49AB05((int)unk_4BDC60, &v34);
                v35 += 8;
                v34 = dword_4B9200 + 8;
            }
            sub_49AB05((int)unk_4BDC60, &v34);
            sub_422C10((char*)(thisx + 612 * (unsigned __int8)v29 + 2628), String);
            sub_47B91A(xLeft + 18, v28, String, 0, -1);
            v35 = xLeft + 17;
            v36 = v28 + 10;
            if ((unsigned __int8)byte_4B9985 <= 4u && *(_DWORD*)(thisx + 116) == 4)
            {
                v1 = sub_474E70((_DWORD*)thisx + 612 * (unsigned __int8)v29 + 2628);
                wsprintfA(String, "%3d", v1);
                sub_47B7ED(v35 - 3, v36 + 24, String, 0, -1);
                sub_47B91A(v35 + 21, v36 + 24, byte_4B0884, 0, -1);
            }
            if (*(_DWORD*)(thisx + 2504) && (unsigned __int8)byte_4B9985 > 4u && *(_DWORD*)(thisx + 116) == 4)
            {
                v2 = sub_474E70((_DWORD*)thisx + 612 * (unsigned __int8)v29 + 2628);
                wsprintfA(String, "%3d", v2);
                sub_47B7ED(v35 + 16, v36 + 4, String, 0, -1);
                sub_47B91A(v35 + 40, v36 + 4, byte_4B088C, 0, -1);
            }
            else if (*(_BYTE*)(thisx + (unsigned __int8)v29 + 13052) && *(_DWORD*)(thisx + 116) != 3)
            {
                LOBYTE(v22) = *(_BYTE*)(thisx + (unsigned __int8)v29 + 13052);
                wsprintfA(String, "%d", (unsigned __int8)v22);
                if ((unsigned __int8)byte_4B9985 > 4u && *(_DWORD*)(thisx + 116) == 4)
                {
                    sub_47B7ED(xLeft + 20, v28 + 12, String, 0, -1);
                    sub_47B91A(xLeft + 28, v28 + 12, byte_4B0898, 0, -1);
                    v6 = sub_474E70((_DWORD*)thisx + 612 * (unsigned __int8)v29 + 2628);
                    wsprintfA(String, "%3d", v6);
                    sub_47B7ED(xLeft + 40, v28 + 12, String, 0, -1);
                    sub_47B91A(xLeft + 64, v28 + 12, byte_4B08A0, 0, -1);
                }
                else
                {
                    sub_47B7ED(xLeft + 30, v28 + 12, String, 0, -1);
                    sub_47B91A(xLeft + 38, v28 + 12, byte_4B08A4, 0, -1);
                }
            }
            else
            {
                v3 = sub_474EB0((short*)thisx + 612 * (unsigned __int8)v29 + 2628);
                v25 = v3 / 256;
                v26 = v3 % 256;
                if (v26 >= 128)
                {
                    if (v26 < 255)
                    {
                        v34 = dword_4B920C + 2;
                        sub_49AB05((int)unk_4BDC60, &v34);
                    }
                    if (v26 == 255)
                        SetRect(&v23, 0, 0, 48, 8);
                    else
                        SetRect(&v23, 0, 0, 48 * (v26 - 128) / 128, 8);
                    v34 = dword_4B920C + 3;
                    sub_49C8A6((int)unk_4BDC60, &v34, (_DWORD*)&v23);
                }
                else
                {
                    if (v25 <= 0)
                        v34 = dword_4B920C + 1;
                    else
                        v34 = dword_4B920C + 3;
                    sub_49AB05((int)unk_4BDC60, &v34);
                    SetRect(&rc, 0, 0, 48 * v26 / 128, 8);
                    v34 = dword_4B920C + 2;
                    sub_49C8A6((int)unk_4BDC60, &v34, (_DWORD*)&rc);
                }
                if (v25 > 0)
                {
                    wsprintfA(String, "%d", v25);
                    v10 = v28 + 10;
                    v4 = xLeft + 64;
                    v5 = lstrlenA(String);
                    sub_47B7ED(v4 - 8 * v5, v10, String, 0, -1);
                }
            }
            v35 = xLeft;
            v36 = v28 + 8;
            if ((unsigned __int8)v27 == 1)
            {
                v34 = dword_4B9204;
                sub_49AB05((int)unk_4BDC60, &v34);
            }
            else
            {
                v34 = dword_4B9204
                    + *((__int16*)dword_4B9394 + (unsigned __int16)sub_43E5A0((short*)thisx + 612 * (unsigned __int8)v29 + 2628))
                    + 1;
                if (sub_4264F0((_BYTE*)(thisx + 612 * (unsigned __int8)v29 + 2628)) == 4)
                {
                    SetRect(&v21, 16, 0, 16, 16);
                    v34 = dword_4B9204 + 1;
                    sub_49C8A6((int)unk_4BDC60, &v34, (_DWORD*)&v21);
                    ++v36;
                    v7 = sub_420F74(thisx + 612 * (unsigned __int8)v29 + 2628);
                    sub_478682(&v34, 1u, v7, 0, -1, -1);
                }
                else if (Concurrency::details::SchedulerBase::GetSchedulerProxy((Concurrency::details::SchedulerBase*)(thisx + 612 * (unsigned __int8)v29 + 2628)) == (struct Concurrency::ISchedulerProxy*)80)
                {
                    SetRect(&v21, 48, 0, 16, 16);
                    sub_49C8A6((int)unk_4BDC60, &v34, (_DWORD*)&v21);
                }
                else
                {
                    SetRect(&v21, 0, 0, 16, 16);
                    sub_49C8A6((int)unk_4BDC60, &v34, (_DWORD*)&v21);
                    LOWORD(v20) = sub_420F74(thisx + 612 * (unsigned __int8)v29 + 2628);
                    ++v35;
                    ++v36;
                    sub_478682(&v34, 1u, (unsigned __int16)v20, 0, -1, -1);
                }
            }
            if (!*(_BYTE*)(thisx + (unsigned __int8)v29 + 13052) && ((unsigned __int8)v27 == 2 || (unsigned __int8)v27 == 3))
            {
                v16 = xLeft + 17;
                v15 = v28 + 14;
                v35 = xLeft + 17;
                v36 = v28 + 18;
                v34 = dword_4B91DC;
                sub_49AB05((int)unk_4BDC60, &v34);
                v18 = sub_474E30((short*)thisx + 612 * (unsigned __int8)v29 + 2628);
                SetRect(&v19, 0, 0, 48 * v18 / 300, 8);
                v34 = dword_4B91DC + 1;
                sub_49C8A6((int)unk_4BDC60, &v34, (_DWORD*)&v19);
                v35 = v16 + 32;
                v36 = v15;
                v34 = dword_4B91DC + 2;
                sub_49AB05((int)unk_4BDC60, &v34);
                LOBYTE(v17) = v18 / 100;
                v35 = v16 + 40;
                v36 = v15;
                v34 = dword_4B91DC + (unsigned __int8)v17 + 3;
                sub_49AB05((int)unk_4BDC60, &v34);
            }
            LOBYTE(v31) = sub_474E90((char*)thisx + 612 * (unsigned __int8)v29 + 2628);
            if ((_BYTE)v31)
            {
                SetRect(&v14, xLeft + 16, v28 + 14, xLeft + 64, v28 + 24);
                sub_49EF70((int)unk_4BDC60, (_DWORD*)&v14, 0, 0, 0, 0x20u);
                if ((unsigned __int8)v31 >= 0x80u)
                    sub_47B91A(xLeft + 16, v28 + 16, (LPCSTR)&byte_4B06C0[13 * (unsigned __int8)v31 - 1664], 0, -1);
                else
                    sub_47B91A(xLeft + 16, v28 + 16, (LPCSTR)&byte_4B0698[13 * (unsigned __int8)v31 - 13], 0, -1);
            }
            if (*(_DWORD*)(thisx + 116) == 4)
            {
                if (sub_474E50((_DWORD*)thisx + 612 * (unsigned __int8)v29 + 2628))
                {
                    v8 = sub_474E50((_DWORD*)thisx + 612 * (unsigned __int8)v29 + 2628);
                    *(_BYTE*)(thisx + (unsigned __int8)v29 + 16120) = v8;
                    *(_BYTE*)(thisx + (unsigned __int8)v29 + 16128) = 60;
                    if (!*(_DWORD*)(thisx + 2504))
                    {
                        if (*(_DWORD*)(thisx + 2372))
                            sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
                    }
                }
            }
            if (*(_BYTE*)(thisx + (unsigned __int8)v29 + 16128))
            {
                --* (_BYTE*)(thisx + (unsigned __int8)v29 + 16128);
                if (*(_DWORD*)(thisx + 2372))
                {
                    wsprintfA(String, "%2d", *(char*)(thisx + (unsigned __int8)v29 + 16120));
                    if ((unsigned __int8)byte_4B9985 <= 4u)
                    {
                        sub_47B7ED(xLeft + 48, v28 + 34, String, 0, -1);
                    }
                    else
                    {
                        SetRect(&v13, xLeft, v28 + 14, xLeft + 16, v28 + 24);
                        sub_49EF70((int)unk_4BDC60, (_DWORD*)&v13, 0, 0, 0, 0x20u);
                        sub_47B7ED(xLeft, v28 + 16, String, 0, -1);
                    }
                }
            }
        }
    }
    result = thisx;
    if (*(_DWORD*)(thisx + 116) == 3)
    {
        sub_47B91A(105, 190, byte_4B08AC, 0, -1);
        wsprintfA(v12, "%3d", *(_DWORD*)(thisx + 11376));
        sub_47B7ED(185, 190, v12, 0, -1);
        sub_47B91A(209, 190, byte_4B08C4, 0, -1);
        sub_47B91A(105, 206, byte_4B08C8, 0, -1);
        wsprintfA(v12, "%3d", *(_DWORD*)(thisx + 4 * *(unsigned __int8*)(thisx + 11372) + 11380));
        sub_47B7ED(185, 206, v12, 0, -1);
        return sub_47B91A(209, 206, byte_4B08DC, 0, -1);
    }
    return result;
}

 
int sub_444DE2(_DWORD* thisx, int a2, struct Concurrency::ISchedulerProxy* a3, int a4, int a5, char a6)
{
    int v7; // [esp+4h] [ebp-44h]
    int v8; // [esp+8h] [ebp-40h]
    int v9; // [esp+Ch] [ebp-3Ch]
    int v11; // [esp+18h] [ebp-30h]
    int v12; // [esp+1Ch] [ebp-2Ch]
    int v13; // [esp+24h] [ebp-24h]
    int v14; // [esp+28h] [ebp-20h]
    int v15; // [esp+2Ch] [ebp-1Ch]
    int i; // [esp+30h] [ebp-18h]
    int v17; // [esp+34h] [ebp-14h]
    int v18; // [esp+38h] [ebp-10h]
    int v19; // [esp+3Ch] [ebp-Ch]
    char v20; // [esp+40h] [ebp-8h]
    int v21; // [esp+44h] [ebp-4h]

    v15 = -1;
    v14 = 0;
    v18 = sub_426090(&thisx[153 * a2 + 657]) / 100;
    v17 = sub_4260B0(&thisx[153 * a2 + 657]) / 100;
    v19 = sub_4260D0(&thisx[153 * a2 + 657]) / 100;
    v20 = sub_426070((char*)&thisx[153 * a2 + 657]);
    v21 = sub_425D70(&thisx[153 * a2 + 657]);
    for (i = 0; i < 8; ++i)
    {
        if (i != a2
            && unknown_libname_7(&thisx[153 * i + 657])
            && SchedulerBase::GetSchedulerProxy((SchedulerBase*)&thisx[153 * i + 657]) == a3
            && ((a6 != 1 || byte_4B99CC) && a6 != 2 || v20 != sub_426070((char*)&thisx[153 * i + 657])))
        {
            v12 = sub_4260D0(&thisx[153 * i + 657]) / 100;
            if (v19 - v12 <= 0)
                v9 = v12 - v19;
            else
                v9 = v19 - v12;
            if (v9 <= 16)
            {
                if ((v13 = sub_426090(&thisx[153 * i + 657]) / 100, v11 = sub_4260B0(&thisx[153 * i + 657]) / 100, !a4)
                    || v21 && v18 < v13
                    || !v21 && v18 > v13)
                {
                    if (v18 - v13 <= 0)
                        v8 = v13 - v18;
                    else
                        v8 = v18 - v13;
                    if (v8 < a5)
                    {
                        if (v17 - v11 <= 0)
                            v7 = v11 - v17;
                        else
                            v7 = v17 - v11;
                        if (v7 <= 5 && (v15 == -1 || v8 < v14))
                        {
                            v15 = i;
                            v14 = v8;
                        }
                    }
                }
            }
        }
    }
    return v15;
}

 
int sub_44508E(int a1, double a2, double a3, double a4)
{
    BOOL v5; // eax
    char v6; // al
    __int16 v7; // ax
    unsigned __int8 v8; // al
    char v9; // al
    int v10; // edx
    char v11; // al
    char v12; // al
    char v13; // al
    char v14; // al
    char v15; // al
    char v16; // al
    char v17; // al
    char v18; // al
    char v19; // al
    _DWORD* v20; // eax
    _DWORD* v21; // eax
    unsigned __int8 v22; // al
    int v23; // [esp-8h] [ebp-C4h]
    int v24; // [esp-4h] [ebp-C0h]
    _BYTE* v25; // [esp+4h] [ebp-B8h]
    signed int i14; // [esp+Ch] [ebp-B0h]
    int v28; // [esp+18h] [ebp-A4h]
    _BYTE* v29; // [esp+1Ch] [ebp-A0h]
    int v30; // [esp+24h] [ebp-98h]
    signed int i9; // [esp+28h] [ebp-94h]
    int v32; // [esp+2Ch] [ebp-90h]
    _BYTE* v33; // [esp+34h] [ebp-88h]
    unsigned __int8 v34; // [esp+38h] [ebp-84h]
    int i7; // [esp+3Ch] [ebp-80h]
    int i8; // [esp+3Ch] [ebp-80h]
    int v37; // [esp+40h] [ebp-7Ch]
    int v38; // [esp+40h] [ebp-7Ch]
    signed int i6; // [esp+44h] [ebp-78h]
    int v40; // [esp+48h] [ebp-74h]
    int v41; // [esp+4Ch] [ebp-70h]
    _BYTE* v42; // [esp+54h] [ebp-68h]
    int v43; // [esp+58h] [ebp-64h]
    _BYTE* v44; // [esp+5Ch] [ebp-60h]
    BOOL v45; // [esp+60h] [ebp-5Ch]
    char v46; // [esp+64h] [ebp-58h]
    unsigned __int8 v47; // [esp+68h] [ebp-54h]
    int v48; // [esp+6Ch] [ebp-50h]
    int i1; // [esp+70h] [ebp-4Ch]
    int v50; // [esp+74h] [ebp-48h]
    _BYTE* v51; // [esp+78h] [ebp-44h]
    int v52; // [esp+7Ch] [ebp-40h]
    int v53; // [esp+80h] [ebp-3Ch]
    Concurrency::details::InternalContextBase* v54; // [esp+84h] [ebp-38h]
    signed int mm; // [esp+88h] [ebp-34h]
    int kk; // [esp+8Ch] [ebp-30h]
    int v57; // [esp+90h] [ebp-2Ch]
    _BYTE* v58; // [esp+94h] [ebp-28h]
    int jj; // [esp+98h] [ebp-24h]
    signed int n; // [esp+9Ch] [ebp-20h]
    int k; // [esp+A0h] [ebp-1Ch]
    int v62; // [esp+A4h] [ebp-18h]
    signed int i; // [esp+A8h] [ebp-14h]
    signed int j; // [esp+A8h] [ebp-14h]
    int m; // [esp+A8h] [ebp-14h]
    int ii; // [esp+A8h] [ebp-14h]
    int nn; // [esp+A8h] [ebp-14h]
    signed int i2; // [esp+A8h] [ebp-14h]
    int i3; // [esp+A8h] [ebp-14h]
    int i4; // [esp+A8h] [ebp-14h]
    int i5; // [esp+A8h] [ebp-14h]
    signed int i10; // [esp+A8h] [ebp-14h]
    int i11; // [esp+A8h] [ebp-14h]
    int i12; // [esp+A8h] [ebp-14h]
    int i13; // [esp+A8h] [ebp-14h]
    int i15; // [esp+A8h] [ebp-14h]
    int i16; // [esp+A8h] [ebp-14h]
    int v78[4]; // [esp+ACh] [ebp-10h] BYREF

    *(_DWORD*)(a1 + 11376) = 0;
    sub_456617(a1);
    dword_4B93AC = 0;
    *(_DWORD*)(a1 + 2488) = 100;
    *(_DWORD*)(a1 + 2492) = 0;
    byte_4B9999 = *(_BYTE*)(a1 + 29);
    memset(byte_4B999B, 0, sizeof(byte_4B999B));
    memset(byte_4B99A3, 0, 8u);
    for (i = 0; i < (int)dword_4B93A0; ++i)
        *((_WORD*)dword_4B9394 + i) = -1;
    for (j = 0; j < (int)dword_4B93A0; ++j)
    {
        for (k = 0; k < 4; ++k)
            *((_WORD*)*(&dword_4B9370 + k) + j) = -1;
    }
    for (m = 0; m < dword_4B9368; ++m)
    {
        for (n = 0; n < (int)dword_4B93A0; ++n)
            *(_DWORD*)(*((_DWORD*)dword_4B9360 + m) + 4 * n) = 0;
    }
    for (ii = 0; ii < 8; ++ii)
        sub_42424D((void*)(a1 + 612 * ii + 2628));
    if (*(_DWORD*)(a1 + 104) == 19)
    {
        sub_49DA8A((int*)unk_4BDC60, *(_DWORD*)(a1 + 13104));
        *(_DWORD*)(a1 + 13104) = -1;
        sub_45F935(a1);
        sub_45FD81(a1);
    }
    dword_4B99EC = 1;
    *(_DWORD*)(a1 + 104) = 10;
    *(_BYTE*)(a1 + 2516) = 1;
    *(_DWORD*)(a1 + 2520) = 0;
    *(_DWORD*)(a1 + 2500) = 0;
    *(_DWORD*)(a1 + 2504) = 0;
    *(_BYTE*)(a1 + 2544) = 0;
    *(_BYTE*)(a1 + 2545) = 0;
    if (dword_4B9974)
    {
        if (!sub_484723(a1 + 13400, aReplayBin))
        {
            sub_48E8B8(a1 + 1300, (wchar_t*)&word_4B08EC, 120);
            *(_DWORD*)(a1 + 104) = 0;
            return sub_453B66(a1);
        }
        *(_DWORD*)(a1 + 116) = sub_4750B0((int*)a1 + 13400);
        if (*(_DWORD*)(a1 + 116) == 3)
            *(_BYTE*)(a1 + 11372) = byte_4B9998;
        memset((void*)(a1 + 2546), 0, 8u);
        for (jj = 0; jj < (unsigned __int8)byte_4B9985; ++jj)
        {
            v57 = (unsigned __int8)byte_4B9988[jj];
            v58 = (_BYTE*)(a1 + 612 * v57 + 2628);
            v25 = (_BYTE*)(a1 + (unsigned __int8)sub_426070(v58) + 2546);
            ++* v25;
            *(_WORD*)(a1 + 2 * jj + 2564) = sub_43E600((short*)v58);
            sub_41BF1D((int)v58);
            sub_475030(v58, v57);
        }
    }
    else if (*(_DWORD*)(a1 + 116) == 3)
    {
        byte_4B9990 = 2;
        *(_BYTE*)(a1 + 2546) = 1;
        *(_BYTE*)(a1 + 2547) = 7;
        byte_4B9985 = 8;
        byte_4B9987 = 7;
        for (kk = (unsigned __int8)byte_4B9986; kk < (unsigned __int8)byte_4B9985; ++kk)
        {
            for (mm = rand() % (int)Size; ; ++mm)
            {
                if (mm >= 0)
                {
                    if (mm >= (int)Size)
                        mm = 0;
                    v5 = sub_44E484((_BYTE*)a1, kk, mm);
                }
                else
                {
                    mm = Size - 1;
                    v5 = sub_44E484((_BYTE*)a1, kk, Size - 1);
                }
                if (!v5)
                    break;
            }
            *(_WORD*)(a1 + 2 * kk + 2564) = mm;
            *(_BYTE*)(kk + a1 + 2588) = 1;
            *(_BYTE*)(kk + a1 + 2580) = MarkedForDetachment((_BYTE*)(36 * mm + dword_4B92E0));
        }
    }
    else if (!*(_DWORD*)(a1 + 116))
    {
        byte_4B99CC = *(_BYTE*)(a1 + 11664);
        byte_4B999A = *(_BYTE*)(a1 + 11614);
        byte_4B99C8 = *(_BYTE*)(a1 + 11660);
        byte_4B99DF = *(_BYTE*)(a1 + 11683);
        byte_4B99E0 = *(_BYTE*)(a1 + 11684);
    }
    if (!byte_4B9999)
        byte_4B9999 = rand() % *(_DWORD*)(a1 + 13388) + 1;
    if (*(_DWORD*)(a1 + 116) || byte_4B9984 != 2)
    {
        if (*(_DWORD*)(a1 + 116) || byte_4B9984 != 3)
        {
            if (*(_DWORD*)(a1 + 116) || byte_4B9984 != 4)
                sub_486189(a1 + 128, (unsigned __int8)byte_4B9999, 0);
            else
                sub_486189(a1 + 128, (unsigned __int8)byte_4B9999, aDoubledragonWa);
        }
        else
        {
            sub_486189(a1 + 128, (unsigned __int8)byte_4B9999, aBoss03Wav);
        }
    }
    else
    {
        sub_486189(a1 + 128, (unsigned __int8)byte_4B9999, aBoss02Wav);
    }
    for (nn = 0; nn < (unsigned __int8)byte_4B9985; ++nn)
    {
        v53 = (unsigned __int8)byte_4B9988[nn];
        v54 = (Concurrency::details::InternalContextBase*)(a1 + 612 * v53 + 2628);
        sub_41BF1D((int)v54);
        Concurrency::details::InternalContextBase::UNSAFE_SetVirtualProcessor(
            v54,
            (struct Concurrency::details::VirtualProcessor*)1);
        if (!dword_4B9974)
        {
            sub_475010((short*)v54, *(_WORD*)(a1 + 2 * nn + 2564));
            if (*(_DWORD*)(a1 + 116) || nn >= 2)
                sub_474FB0((int*)v54, 0);
            else
                sub_474FB0((int*)v54, 1);
        }
        sub_475030((char*)v54, v53);
        if (!dword_4B9974)
        {
            if (*(_DWORD*)(a1 + 116) == 1 || !*(_DWORD*)(a1 + 116) || *(_DWORD*)(a1 + 116) == 4)
            {
                sub_474F90((short*)v54, 1);
                v6 = sub_4575B4((unsigned __int8*)a1, v53, 0);
                sub_475050((char*)v54, v6);
                if (!*(_DWORD*)(a1 + 116))
                {
                    if (nn >= 2)
                    {
                        v52 = *(unsigned __int8*)(a1 + 11690);
                        switch (*(_BYTE*)(a1 + 11805))
                        {
                        case 0:
                            v52 /= 2;
                            break;
                        case 1:
                            v52 = 75 * v52 / 100;
                            break;
                        case 2:
                            v52 = 134 * v52 / 100;
                            break;
                        case 3:
                            v52 = 2 * v52 + 5;
                            break;
                        case 4:
                            v52 = 3 * v52 + 10;
                            break;
                        default:
                            break;
                        }
                        if (*(_BYTE*)(a1 + 11690) == 19)
                            v52 = 75 * v52 / 100;
                        sub_474F90((short*)v54, *(_WORD*)(a1 + 11814) + v52);
                    }
                    else
                    {
                        v7 = sub_4750D0((void*)(a1 + 76 * nn + 11816));
                        sub_474F90((short*)v54, v7);
                    }
                }
            }
            else if (*(_DWORD*)(a1 + 116) == 2 || *(_DWORD*)(a1 + 116) == 3)
            {
                if (nn >= (unsigned __int8)byte_4B9986)
                    sub_475050((char*)v54, byte_4B9986);
                else
                    sub_475050((char*)v54, 0);
            }
            sub_474FF0((char*)v54, *(_BYTE*)(nn + a1 + 2580));
            sub_474F30((char*)v54, *(_BYTE*)(nn + a1 + 2620));
        }
        if (!dword_4B9974)
        {
            sub_41D84A((int)v54);
            if (*(_DWORD*)(a1 + 116) == 4)
            {
                v8 = sub_426070((char*)v54);
                v50 = a1 + 244 * v8 + 1392;
                v51 = (_BYTE*)(84 * *(__int16*)(a1 + 244 * v8 + 1628) + dword_4B92D4);
                v9 = sub_43EE02((unsigned char*)v51, 0, v50);
                sub_41EBBC((int)v54, v10, v9, 1);
                v11 = sub_43EE02((unsigned char*)v51, 1, v50);
                sub_41EC40((short*)v54, v11);
                v12 = sub_43EE02((unsigned char*)v51, 2, v50);
                sub_41ECAB((short*)v54, v12);
                v13 = sub_43EE02((unsigned char*)v51, 3, v50);
                sub_41ED16((short*)v54, v13);
                v14 = sub_43EE02((unsigned char*)v51, 4, v50);
                sub_420D47((short*)v54, v14);
                v15 = sub_43EE02((unsigned char*)v51, 5, v50);
                sub_420DB2((short*)v54, v15);
                v16 = sub_43EE02((unsigned char*)v51, 6, v50);
                sub_41EDEC((short*)v54, v16);
                v17 = sub_43EE02((unsigned char*)v51, 7, v50);
                sub_420E1D((short*)v54, v17);
                v18 = sub_43EE02((unsigned char*)v51, 8, v50);
                sub_420E88((short*)v54, v18);
                v19 = sub_43EE02((unsigned char*)v51, 9, v50);
                sub_41ED81((short*)v54, v19);
                for (i1 = 0; i1 < 3; ++i1)
                {
                    v46 = sub_475090(v51, i1);
                    if (v46)
                    {
                        v48 = 0;
                        v45 = 0;
                        do
                        {
                            v47 = sub_474F10((char*)v54, v48);
                            if (!v47)
                                break;
                            v45 = sub_47744C(v47, v46);
                            if (v45)
                                break;
                            ++v48;
                        } while (v48 != 3);
                        if (v48 == 3)
                            break;
                        if (!v45)
                            sub_474EF0((char*)v54, v48, v46);
                    }
                }
            }
            sub_42371C((int)v54);
            if (*(_BYTE*)(nn + a1 + 2580) == 4)
                sub_474F70((short*)v54, nn % 2 + 23);
        }
        if (v53 >= (unsigned __int8)byte_4B9986)
        {
            Concurrency::details::InternalContextBase::SetOversubscribedVProc(
                v54,
                (struct Concurrency::details::VirtualProcessor*)1);
            v20 = sub_41F0A9((int*)v54);
            sub_41F712(v20);
            v24 = sub_4261D0((char*)(a1 + 128));
            v23 = sub_4897D0((_BYTE*)(a1 + 128)) / 8;
            v21 = sub_41F0A9((int*)v54);
            sub_42132D((int)v21, v23, v24);
        }
        else
        {
            Concurrency::details::InternalContextBase::SetOversubscribedVProc(v54, 0);
        }
        if (dword_4B9974 || *(_DWORD*)(a1 + 116) == 4)
        {
            if (!dword_4B9974)
                sub_474ED0((short*)v54, word_4B99CE[nn]);
        }
        else
        {
            sub_417763((short*)v54);
            word_4B99CE[nn] = sub_474EB0((short*)v54);
        }
    }
    v62 = (unsigned __int8)byte_4B9985;
    memset(v78, 0, sizeof(v78));
    if (*(_DWORD*)(a1 + 116) == 3)
    {
        for (i2 = 0; i2 < (int)Size; ++i2)
        {
            v44 = (_BYTE*)(36 * i2 + dword_4B92E0);
            if (sub_401782(v44, 38) || sub_401782(v44, 255))
            {
                v43 = (unsigned __int8)MarkedForDetachment(v44);
                if (v43 < 4)
                    v78[v43] = 1;
            }
        }
    }
    else
    {
        for (i3 = 0; i3 < (unsigned __int8)byte_4B9985; ++i3)
        {
            v42 = (_BYTE*)(a1 + 612 * (unsigned __int8)byte_4B9988[i3] + 2628);
            if (sub_41BA53((int)v42, 0x26u, 0))
            {
                v41 = (unsigned __int8)sub_4264F0(v42);
                if (v41 < 4)
                    v78[v41] = 1;
            }
        }
    }
    if (*(_DWORD*)(a1 + 116) == 3)
    {
        memcpy((void*)dword_4B9394, (void*)Src, 2 * dword_4B93A0);
        for (i4 = 0; i4 < 4; ++i4)
            memcpy((void*)*(&dword_4B9370 + i4), (void*)*(&dword_4B9380 + i4), 2 * dword_4B93A0);
        for (i5 = 0; i5 < 4; ++i5)
        {
            if (v78[i5])
            {
                v40 = 0;
                for (i6 = 0; i6 < (int)dword_4B93A0; ++i6)
                {
                    if (*((__int16*)dword_4B9394 + i6) >= 0)
                        *((_WORD*)*(&dword_4B9370 + i5) + i6) = v40++;
                }
            }
        }
    }
    else
    {
        for (i7 = 0; i7 < v62; ++i7)
        {
            v33 = (_BYTE*)(a1 + 612 * (unsigned __int8)byte_4B9988[i7] + 2628);
            v32 = (unsigned __int16)sub_474F50((short*)v33);
            v34 = sub_4264F0(v33);
            if (v34 < 4u)
                *((_WORD*)*(&dword_4B9370 + v34) + v32) = 1;
            *((_WORD*)dword_4B9394 + v32) = 1;
        }
        for (i8 = 0; i8 < 4; ++i8)
        {
            if (v78[i8])
            {
                v37 = 0;
                for (i9 = 0; i9 < (int)dword_4B93A0; ++i9)
                {
                    if (*((__int16*)dword_4B9394 + i9) >= 0)
                        *((_WORD*)*(&dword_4B9370 + i8) + i9) = v37++;
                }
            }
        }
        v38 = 0;
        for (i10 = 0; i10 < (int)dword_4B93A0; ++i10)
        {
            if (*((__int16*)dword_4B9394 + i10) != -1)
                *((_WORD*)dword_4B9394 + i10) = v38++;
        }
    }
    sub_466A41();
    if (*(_DWORD*)(a1 + 116) == 3)
        sub_456207();
    if (*(_DWORD*)(a1 + 116) == 4)
    {
        v30 = 4 * *(_DWORD*)(a1 + 2368) + 4;
        for (i11 = 0; i11 < v30; ++i11)
            *(_BYTE*)(i11 + a1 + 2612) = *(_BYTE*)(a1
                + 244 * (unsigned __int8)sub_426070((_BYTE*)(a1 + 612 * i11 + 2628))
                + 1630);
    }
    for (i12 = 0; i12 < (unsigned __int8)byte_4B9985; ++i12)
    {
        v28 = (unsigned __int8)byte_4B9988[i12];
        v29 = (_BYTE*)(a1 + 612 * v28 + 2628);
        if (*(_DWORD*)(a1 + 116) == 3 && v28 >= (unsigned __int8)byte_4B9986)
        {
            v22 = sub_4264F0(v29);
            sub_474FD0((int*)v29, dword_4B9220[v22]);
        }
        else if (dword_4B9974)
        {
            sub_41C48F((int)v29, -2);
        }
        else if (*(_DWORD*)(a1 + 116) || i12 < 2 || byte_4B9984 != 2)
        {
            if (*(_DWORD*)(a1 + 116) && *(_DWORD*)(a1 + 116) != 4)
                sub_41C48F((int)v29, -1);
            else
                sub_41C48F((int)v29, *(unsigned __int8*)(v28 + a1 + 2612) + 1);
        }
        else
        {
            sub_41C48F((int)v29, 3);
        }
    }
    while (i12 < 8)
        Concurrency::details::InternalContextBase::UNSAFE_SetVirtualProcessor(
            (Concurrency::details::InternalContextBase*)(a1 + 612 * (unsigned __int8)byte_4B9988[i12++] + 2628),
            0);
    sub_452E9A(a1);
    if (*(_DWORD*)(a1 + 116) == 3)
    {
        for (i13 = 0; i13 < dword_4B9368; ++i13)
        {
            for (i14 = 0; i14 < (int)dword_4B93A0; ++i14)
            {
                if (*(_BYTE*)(*((_DWORD*)dword_4B9364 + i13) + i14) == 1)
                    *(_DWORD*)(*((_DWORD*)dword_4B9360 + i13) + 4 * i14) = 1;
            }
        }
    }
    sub_4680EF();
    if (*(_DWORD*)(a1 + 116) || dword_4B9974)
    {
        if (*(_DWORD*)(a1 + 116) == 4 && !dword_4B9974)
        {
            memcpy(byte_4B999B, (const void*)(a1 + 2403), sizeof(byte_4B999B));
            memcpy(byte_4B99A3, (const void*)(a1 + 2411), 8u);
        }
    }
    else
    {
        for (i15 = 0; i15 < 2; ++i15)
        {
            if (*(_BYTE*)(i15 + a1 + 11808))
            {
                byte_4B999B[i15] = *(_BYTE*)(i15 + a1 + 11808);
                byte_4B99A3[i15] = *(_BYTE*)(i15 + a1 + 11810);
            }
        }
    }
    *(_DWORD*)(a1 + 2508) = 0;
    for (i16 = 0; i16 < (unsigned __int8)byte_4B9985; ++i16)
        *(_DWORD*)(a1 + 2508) += (unsigned __int16)sub_43E520((short*)a1 + 612 * i16 + 2628);
    *(int*)(a1 + 2508) /= (int)(unsigned __int8)byte_4B9985;
    return sub_4647F2(a1, a2, a3, a4);
}

 
void sub_446442(_DWORD* thisx, int a2, int a3)
{
	sub_48651C(thisx + 32, (_DWORD*)a2, (_DWORD*)a3);
}

 
int sub_446465(char* thisx)
{
    return unknown_libname_11((_DWORD*)thisx + 32);
}

 
int sub_44647E(char* thisx)
{
    return sub_4261D0(thisx + 128);
}

 
int sub_446497(_DWORD* thisx, int a2, int a3)
{
	return sub_486633(thisx + 32, a2, a3);
}


 
unsigned int sub_4464BA(int thisx)
{
    return ExecutionResource::GetNodeId((ExecutionResource*)(thisx + 128));
}


 
char sub_4464D3(int thisx, char a1, char a2)
{
	return sub_4868C1((void*)(thisx + 128), a1, a2);
}


 
char sub_4464F6(_DWORD* thisx, char a1, char a2)
{
	return sub_4868F8(thisx + 32, a1, a2);
}

 
int sub_446714(void* thisx, int a2)
{
    if (a2 >= 0 && a2 < 8)
        return (int)thisx + 612 * a2 + 2628;
    else
        return 0;
}

 
void sub_446744(_DWORD* thisx, __int16 a2, int a3)
{
    int i; // [esp+4h] [ebp-4h]

    if (dword_4B99F0)
    {
        for (i = thisx[2273]; i < 32; ++i)
        {
            if (!sub_475130(&thisx[4 * i + 2274]))
            {
            LABEL_5:
                sub_43F178((int)&thisx[4 * i + 2274], a2, a3);
                return;
            }
        }
        for (i = 0; i < thisx[2273]; ++i)
        {
            if (!sub_475130(&thisx[4 * i + 2274]))
                goto LABEL_5;
        }
    }
}

 
int sub_446814(_DWORD* thisx, _DWORD* a2)
{
    int v3; // [esp+0h] [ebp-34h]
    int v4; // [esp+4h] [ebp-30h]
    int v6; // [esp+Ch] [ebp-28h]
    struct Concurrency::ISchedulerProxy* SchedulerProxy; // [esp+10h] [ebp-24h]
    int v8; // [esp+14h] [ebp-20h]
    int v9; // [esp+18h] [ebp-1Ch]
    int v10; // [esp+1Ch] [ebp-18h]
    int v11; // [esp+20h] [ebp-14h]
    int i; // [esp+24h] [ebp-10h]
    int v13; // [esp+28h] [ebp-Ch]
    int v14; // [esp+2Ch] [ebp-8h]
    unsigned __int8 v15; // [esp+30h] [ebp-4h]

    if (sub_425D30(a2) || sub_426410(a2) || sub_425D50(a2) || sub_425FF0(a2))
        return 0;
    v11 = sub_426090(a2);
    v13 = sub_4260B0(a2);
    v14 = sub_4260D0(a2);
    v15 = sub_425EF0((char*)a2);
    for (i = 0; i < 8; ++i)
    {
        if (i != v15
            && unknown_libname_7(&thisx[153 * i + 657])
            && !sub_4263D0((unsigned __int8*)&thisx[153 * i + 657])
            && (unsigned __int16)sub_474EB0((short*)&thisx[153 * i + 657]))
        {
            v9 = sub_426090(&thisx[153 * i + 657]);
            v10 = sub_4260B0(&thisx[153 * i + 657]);
            v8 = sub_4260D0(&thisx[153 * i + 657]);
            v4 = v11 - v9 <= 0 ? v9 - v11 : v11 - v9;
            if (v4 <= 600)
            {
                v3 = v13 - v10 <= 0 ? v10 - v13 : v13 - v10;
                if (v3 <= 500 && v14 == v8)
                {
                    if ((SchedulerProxy = SchedulerBase::GetSchedulerProxy((SchedulerBase*)&thisx[153 * i + 657]),
                        v6 = sub_425F30(&thisx[153 * i + 657]),
                        SchedulerProxy == (struct Concurrency::ISchedulerProxy*)44)
                        && v6 == 44
                        || SchedulerProxy == (struct Concurrency::ISchedulerProxy*)45 && v6 == 45)
                    {
                        if (!sub_425D50(&thisx[153 * i + 657]) && !sub_426410(&thisx[153 * i + 657]))
                            return (int)&thisx[153 * i + 657];
                    }
                }
            }
        }
    }
    return 0;
}

 
int sub_446A62(_DWORD* thisx, _DWORD* a2, char a3)
{
    int v4; // [esp+4h] [ebp-44h]
    int v5; // [esp+8h] [ebp-40h]
    int v7; // [esp+10h] [ebp-38h]
    int v8; // [esp+14h] [ebp-34h]
    _BYTE* v9; // [esp+18h] [ebp-30h]
    struct Concurrency::ISchedulerProxy* SchedulerProxy; // [esp+1Ch] [ebp-2Ch]
    int v11; // [esp+20h] [ebp-28h]
    int v12; // [esp+24h] [ebp-24h]
    int v13; // [esp+28h] [ebp-20h]
    int v14; // [esp+2Ch] [ebp-1Ch]
    int i; // [esp+30h] [ebp-18h]
    int v16; // [esp+34h] [ebp-14h]
    int v17; // [esp+38h] [ebp-10h]
    unsigned __int8 v18; // [esp+3Ch] [ebp-Ch]
    char v19; // [esp+40h] [ebp-8h]
    int v20; // [esp+44h] [ebp-4h]

    if (sub_425D30(a2) || sub_426410(a2) || sub_425D50(a2))
        return 0;
    v14 = sub_426090(a2);
    v16 = sub_4260B0(a2);
    v17 = sub_4260D0(a2);
    v18 = sub_425EF0((char*)a2);
    v19 = sub_426070((char*)a2);
    v20 = sub_425D70(a2);
    for (i = 0; i < 8; ++i)
    {
        v9 = (char*)&thisx[153 * i + 657];
        if (i != v18
            && unknown_libname_7(&thisx[153 * i + 657])
            && !sub_4263D0((unsigned __int8*)&thisx[153 * i + 657])
            && (byte_4B99CC || v19 != sub_426070((char*)&thisx[153 * i + 657])))
        {
            v12 = sub_426090(&thisx[153 * i + 657]);
            v13 = sub_4260B0(&thisx[153 * i + 657]);
            v11 = sub_4260D0(&thisx[153 * i + 657]);
            v5 = v14 - v12 <= 0 ? v12 - v14 : v14 - v12;
            if (v5 <= 1600)
            {
                v4 = v16 - v13 <= 0 ? v13 - v16 : v16 - v13;
                if (v4 <= 500 && v17 == v11)
                {
                    SchedulerProxy = SchedulerBase::GetSchedulerProxy((SchedulerBase*)&thisx[153 * i + 657]);
                    if ((SchedulerProxy == (struct Concurrency::ISchedulerProxy*)44
                        || SchedulerProxy == (struct Concurrency::ISchedulerProxy*)45
                        || SchedulerProxy == (struct Concurrency::ISchedulerProxy*)46
                        || SchedulerProxy == (struct Concurrency::ISchedulerProxy*)47)
                        && !sub_425D50(&thisx[153 * i + 657])
                        && !sub_426410(&thisx[153 * i + 657]))
                    {
                        if (a3 != 1)
                            return (int)&thisx[153 * i + 657];
                        if (SchedulerProxy != (struct Concurrency::ISchedulerProxy*)46
                            && SchedulerProxy != (struct Concurrency::ISchedulerProxy*)47
                            && (SchedulerProxy != (struct Concurrency::ISchedulerProxy*)44 || v20 != sub_425D70((_DWORD*)v9))
                            && (SchedulerProxy != (struct Concurrency::ISchedulerProxy*)45 || v20 == sub_425D70((_DWORD*)v9)))
                        {
                            v7 = v12 - v14;
                            v8 = 800;
                            if (sub_425E70(v9) == 1)
                                v8 = 0;
                            if (!v20 && v7 <= -v8 || v20 && v7 >= v8)
                                return (int)&thisx[153 * i + 657];
                        }
                    }
                }
            }
        }
    }
    return 0;
}

 
_DWORD* sub_446D6F(_DWORD* thisx, SchedulerBase* a2)
{
    int v3; // esi
    int v4; // eax
    int* v5; // eax
    int v6; // eax
    int* v7; // eax
    int v8; // [esp+4h] [ebp-80h]
    int v9; // [esp+8h] [ebp-7Ch]
    int v10; // [esp+Ch] [ebp-78h]
    int v11; // [esp+10h] [ebp-74h]
    int v13[4]; // [esp+1Ch] [ebp-68h] BYREF
    int v14[4]; // [esp+2Ch] [ebp-58h] BYREF
    int v15; // [esp+3Ch] [ebp-48h]
    int v16; // [esp+40h] [ebp-44h]
    int v17; // [esp+44h] [ebp-40h]
    int v18; // [esp+48h] [ebp-3Ch]
    int v19; // [esp+4Ch] [ebp-38h]
    int v20; // [esp+50h] [ebp-34h]
    char* v21; // [esp+54h] [ebp-30h]
    struct Concurrency::ISchedulerProxy* v22; // [esp+58h] [ebp-2Ch]
    int v23; // [esp+5Ch] [ebp-28h]
    int v24; // [esp+60h] [ebp-24h]
    int v25; // [esp+64h] [ebp-20h]
    int v26; // [esp+68h] [ebp-1Ch]
    int i; // [esp+6Ch] [ebp-18h]
    int v28; // [esp+70h] [ebp-14h]
    int v29; // [esp+74h] [ebp-10h]
    int v30; // [esp+78h] [ebp-Ch]
    struct Concurrency::ISchedulerProxy* SchedulerProxy; // [esp+7Ch] [ebp-8h]
    int v32; // [esp+80h] [ebp-4h]

    if (sub_425D30((_DWORD*)a2) || sub_426410((_DWORD*)a2) || sub_425D50((_DWORD*)a2))
        return 0;
    SchedulerProxy = SchedulerBase::GetSchedulerProxy(a2);
    if (SchedulerProxy != (struct Concurrency::ISchedulerProxy*)3
        && SchedulerProxy != (struct Concurrency::ISchedulerProxy*)4
        && SchedulerProxy != (struct Concurrency::ISchedulerProxy*)5
        && SchedulerProxy != (struct Concurrency::ISchedulerProxy*)6)
    {
        return 0;
    }
    v26 = sub_426090((_DWORD*)a2);
    v28 = sub_4260B0((_DWORD*)a2);
    v29 = sub_4260D0((_DWORD*)a2);
    LOBYTE(v32) = sub_425EF0((char*)a2);
    v30 = 2400;
    switch (sub_4264F0((char*)a2))
    {
    case 0:
        v30 = 2400;
        break;
    case 1:
        v30 = 1600;
        break;
    case 2:
        v30 = 1200;
        break;
    case 3:
        v30 = 3200;
        break;
    case 4:
        v30 = 3600;
        break;
    default:
        break;
    }
    for (i = 0; i < 8; ++i)
    {
        if (!sub_475150(&thisx[153 * i + 657]) && !sub_426430(&thisx[153 * i + 657]) && i != (unsigned __int8)v32)
        {
            if (unknown_libname_7(&thisx[153 * i + 657]))
            {
                if (!sub_4263D0((unsigned __int8*)&thisx[153 * i + 657]) && !sub_41BE56(&thisx[153 * i + 657]))
                {
                    v3 = sub_425D70((_DWORD*)a2);
                    if (v3 != sub_425D70(&thisx[153 * i + 657]))
                    {
                        v24 = sub_426090(&thisx[153 * i + 657]);
                        v25 = sub_4260B0(&thisx[153 * i + 657]);
                        v23 = sub_4260D0(&thisx[153 * i + 657]);
                        v21 = (char*)sub_41C915((int)&thisx[153 * i + 657]);
                        if (v21)
                        {
                            v4 = sub_425D70(&thisx[153 * i + 657]);
                            v5 = sub_425BD0(v21, v14, v4, 0);
                            v17 = *v5;
                            v18 = v5[1];
                            v19 = v5[2];
                            v20 = v5[3];
                            v16 = 0;
                            if (sub_425D70(&thisx[153 * i + 657]) || v17 >= 0)
                            {
                                if (sub_425D70(&thisx[153 * i + 657]) && v19 > 0)
                                    v16 = 100 * v19;
                            }
                            else
                            {
                                v16 = 100 * v17;
                            }
                            v6 = sub_425D70(&thisx[153 * i + 657]);
                            v7 = sub_425B90(v21, v13, v6, 0);
                            v17 = *v7;
                            v18 = v7[1];
                            v19 = v7[2];
                            v20 = v7[3];
                            v15 = 0;
                            if (sub_425D70(&thisx[153 * i + 657]) || v17 >= 0)
                            {
                                if (sub_425D70(&thisx[153 * i + 657]) && v19 > 0)
                                    v15 = 100 * v19;
                            }
                            else
                            {
                                v15 = 100 * v17;
                            }
                            if (v16 <= 0)
                                v11 = -v16;
                            else
                                v11 = v16;
                            if (v15 <= 0)
                                v10 = -v15;
                            else
                                v10 = v15;
                            if (v11 <= v10)
                                v24 += v15;
                            else
                                v24 += v16;
                        }
                        v9 = v26 - v24 <= 0 ? v24 - v26 : v26 - v24;
                        if (v9 <= v30)
                        {
                            v8 = v28 - v25 <= 0 ? v25 - v28 : v28 - v25;
                            if (v8 <= 500 && v29 == v23 && (sub_425D70((_DWORD*)a2) && v24 - v26 > 0 || !sub_425D70((_DWORD*)a2) && v24 - v26 < 0))
                            {
                                v22 = SchedulerBase::GetSchedulerProxy((SchedulerBase*)&thisx[153 * i + 657]);
                                if ((v22 == (struct Concurrency::ISchedulerProxy*)10
                                    || v22 == (struct Concurrency::ISchedulerProxy*)126
                                    || v22 == (struct Concurrency::ISchedulerProxy*)125
                                    || v22 == (struct Concurrency::ISchedulerProxy*)135
                                    || v22 == (struct Concurrency::ISchedulerProxy*)89
                                    || v22 == (struct Concurrency::ISchedulerProxy*)188)
                                    && !sub_425D50(&thisx[153 * i + 657])
                                    && !sub_426410(&thisx[153 * i + 657]))
                                {
                                    return &thisx[153 * i + 657];
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return 0;
}
 
char* sub_447276(char* thisx, int a2)
{
    char v3; // al
    int v4; // [esp+0h] [ebp-3Ch]
    int v5; // [esp+4h] [ebp-38h]
    int v6; // [esp+8h] [ebp-34h]
    int SchedulerProxy; // [esp+10h] [ebp-2Ch]
    int v9; // [esp+14h] [ebp-28h]
    int v10; // [esp+18h] [ebp-24h]
    int v11; // [esp+1Ch] [ebp-20h]
    int v12; // [esp+24h] [ebp-18h]
    int i; // [esp+28h] [ebp-14h]
    int v14; // [esp+2Ch] [ebp-10h]
    int v15; // [esp+30h] [ebp-Ch]
    int v16; // [esp+34h] [ebp-8h]
    unsigned __int8 v17; // [esp+38h] [ebp-4h]

    if (sub_425D30((_DWORD*)a2) || sub_426410((_DWORD*)a2) || sub_425D50((_DWORD*)a2))
        return 0;
    v12 = sub_426090((_DWORD*)a2);
    v14 = sub_4260B0((_DWORD*)a2);
    v15 = sub_4260D0((_DWORD*)a2);
    v17 = sub_425EF0((char*)a2);
    v16 = 0;
    if (sub_425E70((char*)a2) == 1)
    {
        v16 = 3200;
    }
    else
    {
        v3 = sub_4264F0((char*)a2);
        if (v3 && v3 != 1)
        {
            if (v3 == 2)
            {
                v16 = 1200;
            }
            else if (v3 == 3)
            {
                v16 = 2400;
            }
        }
        else
        {
            v16 = 1600;
        }
    }
    for (i = 0; i < 8; ++i)
    {
        if (!sub_475150((_DWORD*)&thisx[153 * i + 657])
            && !sub_426430((_DWORD*)&thisx[153 * i + 657])
            && i != v17
            && unknown_libname_7((_DWORD*)&thisx[153 * i + 657])
            && !sub_4263D0((unsigned __int8*)&thisx[153 * i + 657])
            && !sub_41BE56((_DWORD*)&thisx[153 * i + 657])
            && !sub_425D50((_DWORD*)&thisx[153 * i + 657])
            && !sub_426410((_DWORD*)&thisx[153 * i + 657]))
        {
            v10 = sub_426090((_DWORD*)&thisx[153 * i + 657]);
            v11 = sub_4260B0((_DWORD*)&thisx[153 * i + 657]);
            v9 = sub_4260D0((_DWORD*)&thisx[153 * i + 657]);
            v6 = v12 - v10 <= 0 ? v10 - v12 : v12 - v10;
            if (v6 <= v16)
            {
                v5 = v14 - v11 <= 0 ? v11 - v14 : v14 - v11;
                if (v5 <= 500)
                {
                    v4 = v15 - v9 <= 0 ? v9 - v15 : v15 - v9;
                    if (v4 <= 800
                        && !sub_425D30((_DWORD*)&thisx[153 * i + 657])
                        && (sub_425D70((int*)a2) && v10 - v12 > 0 || !sub_425D70((int*)a2) && v10 - v12 < 0))
                    {
                        SchedulerProxy = (int)SchedulerBase::GetSchedulerProxy((SchedulerBase*)&thisx[153 * i + 657]);
                        if (SchedulerProxy != 44
                            && SchedulerProxy != 45
                            && SchedulerProxy != 46
                            && SchedulerProxy != 47
                            && SchedulerProxy != 42
                            && SchedulerProxy != 14
                            && SchedulerProxy != 48
                            && SchedulerProxy != 52
                            && SchedulerProxy != 53
                            && SchedulerProxy != 54
                            && SchedulerProxy != 55
                            && SchedulerProxy != 56
                            && SchedulerProxy != 57
                            && SchedulerProxy != 58
                            && SchedulerProxy != 59
                            && SchedulerProxy != 60
                            && SchedulerProxy != 62
                            && SchedulerProxy != 63
                            && SchedulerProxy != 64
                            && SchedulerProxy != 75
                            && SchedulerProxy != 78
                            && SchedulerProxy != 79
                            && SchedulerProxy != 26
                            && SchedulerProxy != 82
                            && SchedulerProxy != 85
                            && SchedulerProxy < 123)
                        {
                            return &thisx[153 * i + 657];
                        }
                    }
                }
            }
        }
    }
    return 0;
}

 
int sub_447651(int thisx)
{
    int v1; // edx
    int v2; // eax
    int v3; // esi
    int v4; // ecx
    int v5; // esi
    int v6; // edx
    int v7; // eax
    BOOL v8; // eax
    BOOL v9; // eax
    int v10; // ecx
    int v11; // ecx
    int v12; // eax
    int result; // eax
    int v14; // ebx
    unsigned __int8 v16; // [esp+14h] [ebp-4A4h]
    int i1; // [esp+18h] [ebp-4A0h]
    int v18; // [esp+1Ch] [ebp-49Ch]
    int mm; // [esp+20h] [ebp-498h]
    unsigned __int8 v20; // [esp+24h] [ebp-494h]
    int kk; // [esp+28h] [ebp-490h]
    int v22; // [esp+2Ch] [ebp-48Ch]
    int v23; // [esp+30h] [ebp-488h]
    int v24; // [esp+34h] [ebp-484h]
    int v25; // [esp+38h] [ebp-480h]
    int v26; // [esp+3Ch] [ebp-47Ch]
    signed int n; // [esp+44h] [ebp-474h]
    int v28; // [esp+48h] [ebp-470h]
    int ii; // [esp+4Ch] [ebp-46Ch]
    int v30; // [esp+50h] [ebp-468h]
    int v31; // [esp+54h] [ebp-464h]
    int m; // [esp+58h] [ebp-460h]
    int v33; // [esp+5Ch] [ebp-45Ch]
    int v34; // [esp+60h] [ebp-458h]
    int v35; // [esp+68h] [ebp-450h]
    int i; // [esp+6Ch] [ebp-44Ch]
    int j; // [esp+6Ch] [ebp-44Ch]
    int k; // [esp+6Ch] [ebp-44Ch]
    int jj; // [esp+6Ch] [ebp-44Ch]
    int nn; // [esp+6Ch] [ebp-44Ch]
    int i2; // [esp+6Ch] [ebp-44Ch]
    int i3; // [esp+6Ch] [ebp-44Ch]
    int v43; // [esp+70h] [ebp-448h]
    CHAR String[1024]; // [esp+74h] [ebp-444h] BYREF
    int v45; // [esp+474h] [ebp-44h]
    int v46[14]; // [esp+478h] [ebp-40h] BYREF
    int v47; // [esp+4B0h] [ebp-8h]
    int v48; // [esp+4B4h] [ebp-4h]

    sub_49C15E((int)v46);
    v46[1] = 0;
    v46[2] = 0;
    v46[0] = dword_4B9248;
    sub_49AB05((int)unk_4BDC60, v46);
    wsprintfA(String, byte_4B0944);
    v47 = 4 * lstrlenA(String) + 16;
    v45 = 320 / v47 + 2;
    for (i = 0; i < v45; ++i)
        sub_47B91A(v47 * i + -*(_DWORD*)(thisx + 2540) / 2, 4, String, 0, -1);
    if (++ * (_DWORD*)(thisx + 2540) == 2 * v47)
        *(_DWORD*)(thisx + 2540) = 0;
    v48 = (unsigned __int8)byte_4B9986;
    if (!byte_4B9986)
        v48 = 1;
    for (j = 0; j < v48; ++j)
        sub_477F0C(j);
    v43 = 0;
    for (k = 0; k < (unsigned __int8)byte_4B9985; ++k)
    {
        v34 = 0;
        if (!*(_BYTE*)(thisx + 2516))
        {
            v33 = -1;
            for (m = 0; ; ++m)
            {
                v1 = m;
                if (m >= v48)
                    break;
                if (k == *(unsigned __int8*)(m + thisx + 2554))
                {
                    v1 = m;
                    v33 = m;
                    break;
                }
            }
            if (v33 != -1 && !*(_BYTE*)(k + thisx + 2588))
            {
                LOBYTE(v1) = v33;
                v2 = sub_476D78(v1);
                v3 = v2;
                LOBYTE(v2) = v33;
                v31 = v3 - sub_476D29(v2);
                LOBYTE(v4) = v33;
                v5 = sub_476CDA(v4);
                LOBYTE(v6) = v33;
                v30 = v5 - sub_476C8B(v6);
                v7 = k + thisx;
                if (*(_BYTE*)(k + thisx + 2604))
                {
                    if (++ * (_BYTE*)(k + thisx + 2604) == 5)
                        *(_BYTE*)(k + thisx + 2604) = 1;
                    v7 = k + thisx;
                    if (*(_BYTE*)(k + thisx + 2604) == 1)
                    {
                        for (n = rand() % (int)Size; ; ++n)
                        {
                            if (n >= 0)
                            {
                                if (n >= (int)Size)
                                    n = 0;
                                v9 = sub_44E484((_BYTE*)thisx, k, n);
                            }
                            else
                            {
                                n = Size - 1;
                                v9 = sub_44E484((_BYTE*)thisx, k, Size - 1);
                            }
                            if (!v9)
                                break;
                        }
                        *(_WORD*)(thisx + 2 * k + 2564) = n;
                        if (*(_BYTE*)(thisx + 98))
                            *(_BYTE*)(k + thisx + 2580) = rand() % 4;
                        else
                            *(_BYTE*)(k + thisx + 2580) = MarkedForDetachment((_BYTE*)(36 * n + dword_4B92E0));
                        v34 = 1;
                        v7 = sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
                    }
                }
                else if (v31)
                {
                    *(_BYTE*)(k + thisx + 13092) = 0;
                    for (ii = v31 + *(unsigned __int16*)(thisx + 2 * k + 2564); ; ii += v31)
                    {
                        if (ii >= 0)
                        {
                            if (ii >= (int)Size)
                                ii = 0;
                            v8 = sub_44E484((_BYTE*)thisx, k, ii);
                        }
                        else
                        {
                            ii = Size - 1;
                            v8 = sub_44E484((_BYTE*)thisx, k, Size - 1);
                        }
                        if (!v8)
                            break;
                    }
                    *(_WORD*)(thisx + 2 * k + 2564) = ii;
                    *(_BYTE*)(k + thisx + 2580) = MarkedForDetachment((_BYTE*)(36 * ii + dword_4B92E0));
                    v34 = 1;
                    v7 = sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
                }
                else if (v30)
                {
                    if (*(_BYTE*)(k + thisx + 2596) == 2)
                    {
                        *(_BYTE*)(k + thisx + 13092) = (*(unsigned __int8*)(k + thisx + 13092) + v30 + 4) % 4;
                    }
                    else
                    {
                        v28 = v30 + *(unsigned __int8*)(k + thisx + 2580);
                        if (v28 >= 0)
                        {
                            if (v28 >= 4)
                                LOBYTE(v28) = 0;
                        }
                        else
                        {
                            LOBYTE(v28) = 3;
                        }
                        *(_BYTE*)(k + thisx + 2580) = v28;
                    }
                    v34 = 1;
                    v7 = sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
                }
                LOBYTE(v7) = v33;
                if (sub_476DC7(v7, 0) && !sub_44E484((_BYTE*)thisx, k, -1))
                {
                    *(_BYTE*)(k + thisx + 2588) = 1;
                    v34 = 1;
                    sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
                }
                LOBYTE(v10) = v33;
                if (sub_476DC7(v10, 2))
                {
                    if ((unsigned __int8)++ * (_BYTE*)(k + thisx + 2596) > 2u)
                        *(_BYTE*)(k + thisx + 2596) = 0;
                    *(_BYTE*)(k + thisx + 13092) = 0;
                    v34 = 1;
                    sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
                }
                LOBYTE(v11) = v33;
                v12 = sub_476DC7(v11, 5);
                if (v12)
                {
                    v12 = *(unsigned __int8*)(k + thisx + 2604);
                    if (*(_BYTE*)(k + thisx + 2604))
                        *(_BYTE*)(k + thisx + 2604) = 0;
                    else
                        *(_BYTE*)(k + thisx + 2604) = 1;
                }
                LOBYTE(v12) = v33;
                if (sub_476DC7(v12, 6))
                    v43 = 1;
                if (v34)
                    sub_454469((_BYTE*)thisx, k);
            }
        }
    }
    result = *(unsigned __int8*)(thisx + 2516);
    if (!*(_BYTE*)(thisx + 2516))
    {
        for (jj = 0; jj < v48; ++jj)
        {
            LOBYTE(result) = jj;
            result = sub_476DC7(result, 1);
            v25 = result;
            v26 = *(unsigned __int8*)(jj + thisx + 2554);
            if (!result)
            {
                if (*(unsigned __int8*)(jj + thisx + 2554) >= 8u)
                    continue;
                result = v26 + thisx;
                if (*(_BYTE*)(v26 + thisx + 2588) != 1)
                    continue;
            }
            v23 = *(unsigned __int8*)(jj + thisx + 2554);
            if (v25 && *(unsigned __int8*)(jj + thisx + 2554) >= 0x64u && *(unsigned __int8*)(jj + thisx + 2554) < 0x6Cu)
            {
                result = v26 - 99;
                v23 = v26 - 99;
                v26 -= 100;
            }
            if (v25)
            {
                *(_BYTE*)(v26 + thisx + 2588) = 0;
            }
            else
            {
                result = v26 + thisx;
                *(_BYTE*)(v26 + thisx + 2588) = 2;
            }
            v22 = 1;
            v24 = 0;
            while (v22)
            {
                ++v24;
                if (v25)
                    --v23;
                else
                    ++v23;
                if (v23 < (unsigned __int8)byte_4B9985)
                {
                    if (v23 < 0)
                        v23 = (unsigned __int8)byte_4B9985 - 1;
                }
                else
                {
                    v23 = 0;
                }
                result = v24 - 1;
                if (v24 - 1 == (unsigned __int8)byte_4B9985)
                {
                    v23 = -1;
                    break;
                }
                if (!v25 && (result = *(unsigned __int8*)(v23 + thisx + 2588), !*(_BYTE*)(v23 + thisx + 2588)) || v25)
                {
                    if (jj == (unsigned __int8)byte_4B9988[v23]
                        || (result = v23, (unsigned __int8)byte_4B9988[v23] >= (int)(unsigned __int8)byte_4B9986))
                    {
                        v14 = (unsigned __int8)sub_4575B4((unsigned __int8*)thisx, v23, 1);
                        result = (unsigned __int8)sub_4575B4((unsigned __int8*)thisx, v26, 1);
                        if (v14 == result)
                        {
                            for (kk = 0; ; ++kk)
                            {
                                result = (unsigned __int8)byte_4B9986;
                                if (kk >= (unsigned __int8)byte_4B9986)
                                    break;
                                if (kk != jj)
                                {
                                    result = *(unsigned __int8*)(kk + thisx + 2554);
                                    if (result == v23)
                                        break;
                                }
                            }
                            if (kk == (unsigned __int8)byte_4B9986)
                                v22 = 0;
                        }
                        else
                        {
                            v23 = -1;
                        }
                    }
                }
                if (v25 && (result = sub_4576F0(jj), v26 != result) || !v25)
                {
                    if (v23 == -1 && !jj)
                    {
                        result = (unsigned __int8)byte_4B9987;
                        if (byte_4B9987)
                        {
                            v20 = sub_4575B4((unsigned __int8*)thisx, v26, 1);
                            v18 = v26 - (unsigned __int8)sub_457659((unsigned __int8*)thisx, v26, 1);
                            if (v25)
                                v20 = (v20 + (unsigned __int8)byte_4B9990 - 1) % (unsigned __int8)byte_4B9990;
                            for (mm = 0; ; ++mm)
                            {
                                if (v25)
                                {
                                    result = ((unsigned __int8)byte_4B9985 + v18 - *(unsigned __int8*)(thisx + v20 + 2546))
                                        / (unsigned __int8)byte_4B9985;
                                    v18 = ((unsigned __int8)byte_4B9985 + v18 - *(unsigned __int8*)(thisx + v20 + 2546))
                                        % (unsigned __int8)byte_4B9985;
                                }
                                else
                                {
                                    result = *(unsigned __int8*)(thisx + v20 + 2546) + v18;
                                    v18 = result;
                                }
                                if (v18 >= (unsigned __int8)byte_4B9985)
                                    v18 = 0;
                                if (mm >= (unsigned __int8)byte_4B9990)
                                {
                                    v23 = -1;
                                    v22 = 0;
                                    goto LABEL_139;
                                }
                                if (!byte_4B9988[v18] || (unsigned __int8)byte_4B9988[v18] >= (int)(unsigned __int8)byte_4B9986)
                                {
                                    if (!v25)
                                    {
                                        result = *(unsigned __int8*)(v18 + thisx + 2588);
                                        if (!*(_BYTE*)(v18 + thisx + 2588))
                                        {
                                            v23 = v18;
                                            v22 = 0;
                                            goto LABEL_139;
                                        }
                                    }
                                    if (v25)
                                        break;
                                }
                                if (v25)
                                    v20 = (v20 + (unsigned __int8)byte_4B9990 - 1) % (unsigned __int8)byte_4B9990;
                                else
                                    v20 = (v20 + (unsigned __int8)byte_4B9990 + 1) % (unsigned __int8)byte_4B9990;
                            }
                            result = v18 + *(unsigned __int8*)(thisx + v20 + 2546) - 1;
                            v23 = result;
                            v22 = 0;
                        }
                    }
                }
            LABEL_139:
                if (v23 == -1)
                    break;
            }
            if (v23 == -1)
            {
                if (!v25)
                {
                    result = v26 + 100;
                    *(_BYTE*)(jj + thisx + 2554) = v26 + 100;
                }
            }
            else
            {
                LOBYTE(result) = v23;
                *(_BYTE*)(jj + thisx + 2554) = v23;
                if (v25)
                {
                    *(_BYTE*)(v23 + thisx + 2588) = 0;
                    sub_454469((_BYTE*)thisx, v23);
                }
            }
        }
        if (v43)
        {
            for (nn = 0; nn < (unsigned __int8)byte_4B9985; ++nn)
            {
                if (!*(_BYTE*)(nn + thisx + 2588))
                {
                    for (i1 = rand() % (int)Size; sub_44E484((_BYTE*)thisx, nn, i1); i1 = (int)(i1 + Size + 1) % (int)Size)
                        ;
                    *(_WORD*)(thisx + 2 * nn + 2564) = i1;
                    if (*(_BYTE*)(thisx + 98))
                        *(_BYTE*)(nn + thisx + 2580) = rand() % 4;
                    else
                        *(_BYTE*)(nn + thisx + 2580) = MarkedForDetachment((_BYTE*)(36 * i1 + dword_4B92E0));
                    *(_BYTE*)(nn + thisx + 2588) = 2;
                }
            }
            result = sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
        }
    }
    v35 = 0;
    for (i2 = 0; i2 < (unsigned __int8)byte_4B9985; ++i2)
    {
        result = (*(_BYTE*)(i2 + thisx + 2588) == 2) + v35;
        v35 = result;
    }
    if (v35 == (unsigned __int8)byte_4B9985)
    {
        *(_DWORD*)(thisx + 108) = 9;
        result = thisx;
        *(_BYTE*)(thisx + 2516) = 2;
    }
    for (i3 = 0; i3 < v48; ++i3)
    {
        v16 = *(_BYTE*)(i3 + thisx + 2554);
        wsprintfA(String, "%d>", i3 + 1);
        result = sub_47B91A(160 * (v16 / 4), 56 * (v16 & 3) + 24, String, 0, -1);
    }
    return result;
}

 
int sub_448750(int thisx)
{
    int v3; // [esp+4h] [ebp-10h]
    int v4; // [esp+8h] [ebp-Ch]
    unsigned __int8 v5; // [esp+Ch] [ebp-8h]
    int i; // [esp+10h] [ebp-4h]
    int j; // [esp+10h] [ebp-4h]
    int k; // [esp+10h] [ebp-4h]

    *(_DWORD*)(thisx + 104) = 8;
    *(_DWORD*)(thisx + 2540) = 0;
    *(_BYTE*)(thisx + 2516) = 1;
    *(_BYTE*)(thisx + 2562) = 0;
    memset((void*)(thisx + 2620), 0, 8u);
    for (i = 0; i < (unsigned __int8)byte_4B9986; ++i)
    {
        v4 = sub_4576F0(i);
        *(_WORD*)(thisx + 2 * v4 + 2564) = 0;
        *(_BYTE*)(v4 + thisx + 2580) = MarkedForDetachment((_BYTE*)dword_4B92E0);
        if (v4 < 0)
            *(_BYTE*)(i + thisx + 2554) = -1;
        else
            *(_BYTE*)(i + thisx + 2554) = v4;
    }
    v5 = 4;
    if (!byte_4B9986)
    {
        v5 = 0;
        *(_BYTE*)(thisx + 2554) = 0;
    }
    for (j = (unsigned __int8)byte_4B9986; j < (unsigned __int8)byte_4B9985; ++j)
    {
        v3 = sub_4576F0(j);
        *(_WORD*)(thisx + 2 * v3 + 2564) = v5;
        *(_BYTE*)(v3 + thisx + 2580) = MarkedForDetachment((_BYTE*)(36 * v5 + dword_4B92E0));
        v5 += 4;
        if (v5 >= 0x10u)
            v5 = 1;
    }
    for (k = 0; k < 8; ++k)
    {
        *(_BYTE*)(k + thisx + 2596) = 0;
        *(_BYTE*)(k + thisx + 2588) = 0;
        *(_BYTE*)(k + thisx + 2604) = 0;
        *(_BYTE*)(k + thisx + 13092) = 0;
    }
    sub_47C427();
    sub_454469((_BYTE*)thisx, -1);
    return sub_456D33((const CHAR*)thisx, aCharselWav, 1, 0);
}

 
unsigned __int16* sub_448929(int a1, double a2, double a3, double a4)
{
    int v4; // eax
    int v5; // eax
    struct Concurrency::details::UMSThreadProxy* ExecutingProxy; // esi
    struct Concurrency::details::UMSThreadProxy* v7; // esi
    struct Concurrency::ISchedulerProxy* SchedulerProxy; // eax
    int v9; // eax
    int v10; // esi
    const void* v11; // eax
    int v12; // esi
    int v13; // esi
    int v14; // esi
    int v15; // esi
    int v16; // esi
    int v17; // esi
    struct Concurrency::ISchedulerProxy* v18; // eax
    int v19; // eax
    int v20; // esi
    int v21; // esi
    int v22; // eax
    int v23; // eax
    char v24; // al
    char v25; // al
    int v26; // esi
    int v27; // eax
    int v28; // edx
    unsigned __int16* result; // eax
    int v30; // eax
    int v31; // [esp+14h] [ebp-238h]
    int v32; // [esp+18h] [ebp-234h]
    int yTop; // [esp+20h] [ebp-22Ch]
    CHAR String[64]; // [esp+24h] [ebp-228h] BYREF
    struct tagRECT v36; // [esp+64h] [ebp-1E8h] BYREF
    Concurrency::details::SchedulerBase* v37; // [esp+74h] [ebp-1D8h]
    struct tagRECT v38; // [esp+78h] [ebp-1D4h] BYREF
    struct tagRECT rc; // [esp+88h] [ebp-1C4h] BYREF
    struct Concurrency::ISchedulerProxy* v40; // [esp+98h] [ebp-1B4h]
    struct Concurrency::ISchedulerProxy* v41; // [esp+9Ch] [ebp-1B0h]
    int jj; // [esp+A0h] [ebp-1ACh]
    int v43; // [esp+A4h] [ebp-1A8h]
    Concurrency::details::SchedulerBase* v44; // [esp+A8h] [ebp-1A4h]
    int ii; // [esp+ACh] [ebp-1A0h]
    int v46; // [esp+B0h] [ebp-19Ch]
    char v47[8]; // [esp+B4h] [ebp-198h] BYREF
    int v48; // [esp+BCh] [ebp-190h]
    _DWORD* v49; // [esp+C0h] [ebp-18Ch]
    int v50; // [esp+C4h] [ebp-188h]
    int v51; // [esp+C8h] [ebp-184h]
    int v52; // [esp+CCh] [ebp-180h] BYREF
    char v53; // [esp+D0h] [ebp-17Ch]
    int v54; // [esp+D8h] [ebp-174h]
    char v55; // [esp+DCh] [ebp-170h]
    char v56; // [esp+DDh] [ebp-16Fh]
    int v57; // [esp+E0h] [ebp-16Ch]
    char v58; // [esp+E8h] [ebp-164h]
    int v59; // [esp+ECh] [ebp-160h]
    int v60; // [esp+F0h] [ebp-15Ch]
    char v61; // [esp+F4h] [ebp-158h]
    int v62; // [esp+F8h] [ebp-154h]
    int v63; // [esp+100h] [ebp-14Ch]
    int v64; // [esp+104h] [ebp-148h]
    int v65; // [esp+108h] [ebp-144h]
    int QueueLength; // [esp+10Ch] [ebp-140h]
    int v67; // [esp+110h] [ebp-13Ch]
    int v68; // [esp+114h] [ebp-138h]
    int n; // [esp+118h] [ebp-134h]
    int v70; // [esp+11Ch] [ebp-130h]
    int v71; // [esp+120h] [ebp-12Ch]
    int v72; // [esp+124h] [ebp-128h]
    int v73; // [esp+128h] [ebp-124h] BYREF
    char v74; // [esp+12Ch] [ebp-120h]
    int v75; // [esp+130h] [ebp-11Ch]
    int v76; // [esp+134h] [ebp-118h]
    char v77; // [esp+138h] [ebp-114h]
    char v78; // [esp+139h] [ebp-113h]
    int v79; // [esp+13Ch] [ebp-110h]
    char v80; // [esp+144h] [ebp-108h]
    char v81; // [esp+145h] [ebp-107h]
    char v82; // [esp+146h] [ebp-106h]
    int v83; // [esp+148h] [ebp-104h]
    struct Concurrency::ISchedulerProxy* v84; // [esp+14Ch] [ebp-100h]
    char v85; // [esp+150h] [ebp-FCh]
    int v86; // [esp+154h] [ebp-F8h]
    int v87; // [esp+158h] [ebp-F4h]
    int v88; // [esp+15Ch] [ebp-F0h]
    int v89; // [esp+160h] [ebp-ECh]
    int v90; // [esp+164h] [ebp-E8h]
    int v91; // [esp+168h] [ebp-E4h]
    BOOL v92; // [esp+16Ch] [ebp-E0h]
    int v93; // [esp+170h] [ebp-DCh]
    int m; // [esp+174h] [ebp-D8h]
    int k; // [esp+178h] [ebp-D4h]
    int v96; // [esp+17Ch] [ebp-D0h]
    int v97[13]; // [esp+180h] [ebp-CCh] BYREF
    int v98; // [esp+1B4h] [ebp-98h]
    __int16 v99[28]; // [esp+1B8h] [ebp-94h] BYREF
    Concurrency::details::SchedulerBase* v100; // [esp+1F0h] [ebp-5Ch]
    void* Src; // [esp+1F4h] [ebp-58h]
    int v102; // [esp+1F8h] [ebp-54h]
    int ExecutingCollection; // [esp+1FCh] [ebp-50h]
    Concurrency::details::ContextBase* v104; // [esp+200h] [ebp-4Ch]
    int j; // [esp+204h] [ebp-48h]
    int v106; // [esp+208h] [ebp-44h] BYREF
    int v107; // [esp+210h] [ebp-3Ch]
    int v108; // [esp+214h] [ebp-38h]
    int v109; // [esp+218h] [ebp-34h]
    int v110; // [esp+21Ch] [ebp-30h]
    int v111; // [esp+220h] [ebp-2Ch]
    int v112; // [esp+224h] [ebp-28h]
    int v113; // [esp+228h] [ebp-24h]
    int v114; // [esp+22Ch] [ebp-20h]
    int v115; // [esp+230h] [ebp-1Ch]
    BOOL v116; // [esp+234h] [ebp-18h]
    int v117; // [esp+238h] [ebp-14h]
    BOOL v118; // [esp+23Ch] [ebp-10h]
    int i; // [esp+240h] [ebp-Ch]
    int v120; // [esp+244h] [ebp-8h]
    int v121; // [esp+248h] [ebp-4h]

    if (*(int*)(a1 + 2488) > 100)
        dword_4B99EC = 1;
    *(_DWORD*)(a1 + 2492) += *(_DWORD*)(a1 + 2488);
LABEL_4:
    while (*(int*)(a1 + 2492) >= 100)
    {
        *(_DWORD*)(a1 + 2492) -= 100;
        v118 = dword_4B93B0 % (unsigned int)*(unsigned __int8*)(a1 + 2496) != 0;
        if (*(_BYTE*)(a1 + 2496) == 1)
            v118 = 1;
        if ((!*(_DWORD*)(a1 + 2504) && v118 || *(_DWORD*)(a1 + 2504) && sub_476DC7(0, 5))
            && *(int*)(a1 + 16136) > 0
            && (int)-- * (_DWORD*)(a1 + 16136) > 0)
        {
            for (i = 0; i < 32; ++i)
            {
                if (MarkedForDetachment((_BYTE*)(a1 + 36 * i + 9608)) == 19)
                    sub_4419F6(a1 + 36 * i + 9608);
            }
        }
        if ((!*(_DWORD*)(a1 + 2504) && v118 || *(_DWORD*)(a1 + 2504) && sub_476DC7(0, 5)) && !*(_DWORD*)(a1 + 16136))
        {
            ++dword_4B93AC;
            *(_DWORD*)(a1 + 16400) = 0;
            v113 = sub_446465((char*)(_DWORD*)a1);
            v110 = 0;
            v111 = 0;
            v115 = 0;
            v114 = 0;
            v108 = 0;
            for (i = 0; i < (unsigned __int8)byte_4B9985 && (i <= 0 || *(_DWORD*)(a1 + 116) != 3); ++i)
            {
                if (unknown_libname_7((_DWORD*)(a1 + 612 * i + 2628))
                    && Concurrency::details::SchedulerBase::GetSchedulerProxy((Concurrency::details::SchedulerBase*)(a1 + 612 * i + 2628)) != (struct Concurrency::ISchedulerProxy*)80
                    && !Concurrency::details::SchedulerProxy::GetNumExternalThreads((Concurrency::details::SchedulerProxy*)(a1 + 612 * i + 2628)))
                {
                    sub_48651C((_DWORD*)(a1 + 128), (_DWORD*)(a1 + 612 * i + 2628), &v106);
                    if (v106 > 8)
                    {
                        if (v106 >= 311)
                            v108 = 1;
                    }
                    else
                    {
                        v114 = 1;
                    }
                    v107 = sub_426270((int*)a1 + 612 * i + 2628);
                    if (v106 < 80 && v107 < 0 || v106 > 240 && v107 > 0)
                    {
                        if (v107 <= 0)
                            v32 = -v107;
                        else
                            v32 = v107;
                        if (v32 > 8000)
                        {
                            if (v107 <= 0)
                                v31 = (v107 >= 0) - 1;
                            else
                                v31 = 1;
                            v107 = 8000 * v31;
                        }
                        v110 += v107;
                        ++v115;
                    }
                }
            }
            if (v115 > 0)
            {
                v110 /= v115;
                if ((v110 >= 0 || !v108) && (v110 <= 0 || !v114))
                    sub_486947((int*)a1 + 128, v113 + v110 / 100 + 160, 1);
            }
            sub_488981((int*)a1 + 128);
            if (*(_BYTE*)(a1 + 2544))
            {
                if (*(_BYTE*)(a1 + 2544) == 1 && *(unsigned __int8*)(a1 + 2545) >= 4u)
                {
                    *(_BYTE*)(a1 + 2544) = 0;
                    *(_BYTE*)(a1 + 2545) = 0;
                }
                ++* (_BYTE*)(a1 + 2545);
            }
            for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
            {
                if (unknown_libname_7((_DWORD*)(a1 + 612 * i + 2628))
                    && Concurrency::details::SchedulerBase::GetSchedulerProxy((Concurrency::details::SchedulerBase*)(a1 + 612 * i + 2628)) != (struct Concurrency::ISchedulerProxy*)80)
                {
                    sub_402C05(a1 + 612 * i + 2628);
                    if (!sub_41BEA6((_DWORD*)(a1 + 612 * i + 2628)) && dword_4B9974)
                    {
                        v4 = sub_425E10((void*)(a1 + 13400), i);
                        sub_4844AE(v4);
                    }
                    if (!sub_41BEA6((_DWORD*)(a1 + 612 * i + 2628)) && dword_4B9978 && !dword_4B9974)
                        sub_4837FA((int*)(a1 + 13400), a1 + 612 * i + 2628);
                }
            }
            byte_4B997C = 0;
            for (i = 0; i < (unsigned __int8)byte_4B999A; ++i)
            {
                if (unknown_libname_22((_DWORD*)(a1 + 196 * i + 7524)))
                    sub_4914CC(a1 + 196 * i + 7524, a3, a2, a4);
            }
            if (byte_4B999A && byte_4B999A == byte_4B997C)
            {
                for (i = 0; i < (unsigned __int8)byte_4B999A; ++i)
                {
                    if (unknown_libname_22((_DWORD*)(a1 + 196 * i + 7524)))
                        sub_49507B((_DWORD*)(a1 + 196 * i + 7524), a2, a3, a4);
                }
            }
            for (i = 0; ; ++i)
            {
                v5 = sub_4755F0((int*)a1 + 128);
                if (i >= v5)
                    break;
                v104 = (Concurrency::details::ContextBase*)sub_488E1E((_DWORD*)(a1 + 128), i);
                if (sub_4754B0((char*)v104))
                {
                    for (j = 0; j < (unsigned __int8)byte_4B9985; ++j)
                    {
                        if (!sub_475410((char*)v104, j))
                        {
                            v100 = (Concurrency::details::SchedulerBase*)(a1 + 612 * j + 2628);
                            if (unknown_libname_7((int*)v100))
                            {
                                if ((unsigned __int8)sub_475210((char*)v100)
                                    && !sub_4263D0((unsigned __int8*)v100)
                                    && sub_474234((void*)a1, v104, (int)v100))
                                {
                                    ExecutingProxy = Concurrency::details::UMSFreeVirtualProcessorRoot::GetExecutingProxy((Concurrency::details::UMSFreeVirtualProcessorRoot*)v104);
                                    if ((int)ExecutingProxy >= sub_426090((int*)v100))
                                    {
                                        v7 = Concurrency::details::UMSFreeVirtualProcessorRoot::GetExecutingProxy((Concurrency::details::UMSFreeVirtualProcessorRoot * )v104);
                                        if ((int)v7 <= sub_426090((int*)v100))
                                            ExecutingCollection = (int)Concurrency::details::ContextBase::GetExecutingCollection(v104);
                                        else
                                            ExecutingCollection = 0;
                                    }
                                    else
                                    {
                                        ExecutingCollection = 1;
                                    }
                                    Src = (void*)sub_475490((char*)v104);
                                    v98 = *(_DWORD*)Src;
                                    SchedulerProxy = Concurrency::details::SchedulerBase::GetSchedulerProxy(v100);
                                    LOWORD(v102) = sub_417924((int)v100, (int)SchedulerProxy, 1);
                                    v9 = sub_425D70((int*)v100);
                                    if (ExecutingCollection == v9)
                                        LOWORD(v102) = 85 * (unsigned __int16)v102 / 100;
                                    if (sub_475450((short*)v104))
                                    {
                                        v10 = (unsigned __int16)v102;
                                        LOWORD(v102) = v10 * (unsigned __int16)sub_475450((short*)v104) / 100;
                                        if (!(_WORD)v102)
                                            LOWORD(v102) = 1;
                                        v98 = 4 * v98 / (unsigned __int16)v102;
                                        if (v98 <= 0)
                                            v98 = 1;
                                    }
                                    else
                                    {
                                        v98 = *(_DWORD*)Src;
                                    }
                                    sub_4810C0(v99);
                                    v11 = (const void*)sub_475430((char*)v104);
                                    memcpy(v99, v11, sizeof(v99));
                                    v99[0] = v98;
                                    v99[1] = 0;
                                    v99[2] = 1;
                                    sub_4020B0(v97);
                                    memcpy(v97, Src, sizeof(v97));
                                    v97[6] = 0;
                                    LOBYTE(v97[10]) = j;
                                    if ((unsigned __int8)sub_485120((char*)v104))
                                    {
                                        sub_42455B((int)v100, v99);
                                    }
                                    else
                                    {
                                        if (byte_4B99DF)
                                            v97[0] = v98;
                                        else
                                            v97[0] = 0;
                                        v97[3] = ExecutingCollection;
                                        LOBYTE(v97[1]) = v99[5];
                                        LOBYTE(v97[4]) = v99[3];
                                        BYTE1(v97[4]) = v99[4];
                                        v97[11] = (int)v100;
                                        sub_407756((int)v100, 1, (int)v97, 0);
                                    }
                                    sub_48DC76((int)v104, 0, (int)v97);
                                }
                            }
                        }
                    }
                }
            }
            for (i = 0; ; ++i)
            {
                if (i >= (unsigned __int8)byte_4B9985)
                    goto LABEL_203;
                if (unknown_libname_7((_DWORD*)(a1 + 612 * i + 2628)) && (unsigned __int8)sub_4751F0((char*)a1 + 612 * i + 2628))
                    break;
            LABEL_120:
                ;
            }
            if (*(_DWORD*)(a1 + 116) != 3 || i < 1 || dword_4B93AC % 2u)
            {
                LOBYTE(v96) = sub_426070((_BYTE*)(a1 + 612 * i + 2628));
                for (k = 0; ; ++k)
                {
                    if (k >= 2)
                        goto LABEL_120;
                    if (k)
                    {
                        if (k == 1)
                            v93 = (unsigned __int8)byte_4B999A;
                    }
                    else
                    {
                        v93 = (unsigned __int8)byte_4B9985;
                    }
                    for (m = 0; m < v93; ++m)
                    {
                        if (k)
                        {
                            if (k == 1
                                && (!unknown_libname_22((_DWORD*)(a1 + 196 * m + 7524)) || sub_4753F0(
                                    (_BYTE*)(a1 + 612 * i + 2628),
                                    m)))
                            {
                                continue;
                            }
                        }
                        else
                        {
                            if (i == m)
                                continue;
                            if (!unknown_libname_7((_DWORD*)(a1 + 612 * m + 2628)))
                                continue;
                            if (sub_4753D0((_BYTE*)(a1 + 612 * i + 2628), m))
                                continue;
                            if (!(unsigned __int8)sub_475210((char*)a1 + 612 * m + 2628))
                                continue;
                            if (sub_4263D0((unsigned __int8*)(a1 + 612 * m + 2628)))
                                continue;
                            if (!byte_4B99CC)
                            {
                                v12 = (unsigned __int8)v96;
                                if (v12 == (unsigned __int8)sub_426070((_BYTE*)(a1 + 612 * m + 2628))
                                    && !(unsigned __int8)sub_4752F0((char*)a1 + 612 * i + 2628))
                                {
                                    continue;
                                }
                            }
                            v13 = (unsigned __int8)v96;
                            if (v13 == (unsigned __int8)sub_426070((_BYTE*)(a1 + 612 * m + 2628))
                                && (unsigned __int8)sub_4752F0((char*)a1 + 612 * i + 2628) == 2)
                            {
                                continue;
                            }
                        }
                        if (k)
                        {
                            if (k == 1)
                                v92 = sub_466BEC(
                                    a1 + 612 * i + 2628,
                                    (Concurrency::details::UMSFreeVirtualProcessorRoot*)(a1 + 196 * m + 7524));
                        }
                        else
                        {
                            v92 = sub_443B2A((_DWORD*)(a1 + 612 * i + 2628), (_DWORD*)(a1 + 612 * m + 2628));
                        }
                        if (v92)
                        {
                            if (k)
                            {
                                if (k != 1)
                                    goto LABEL_174;
                                v16 = sub_426090((_DWORD*)(a1 + 612 * i + 2628));
                                if (v16 < sub_426470((_DWORD*)(a1 + 196 * m + 7524)))
                                {
                                    v91 = 1;
                                    goto LABEL_174;
                                }
                                v17 = sub_426090((_DWORD*)(a1 + 612 * i + 2628));
                                if (v17 > sub_426470((_DWORD*)(a1 + 196 * m + 7524)))
                                {
                                    v91 = 0;
                                    goto LABEL_174;
                                }
                            LABEL_173:
                                v91 = sub_425D70((_DWORD*)(a1 + 612 * i + 2628));
                                goto LABEL_174;
                            }
                            v14 = sub_426090((_DWORD*)(a1 + 612 * i + 2628));
                            if (v14 >= sub_426090((_DWORD*)(a1 + 612 * m + 2628)))
                            {
                                v15 = sub_426090((_DWORD*)(a1 + 612 * i + 2628));
                                if (v15 <= sub_426090((_DWORD*)(a1 + 612 * m + 2628)))
                                    goto LABEL_173;
                                v91 = 0;
                            }
                            else
                            {
                                v91 = 1;
                            }
                        LABEL_174:
                            LOWORD(v89) = sub_4261B0((short*)a1 + 612 * i + 2628);
                            v88 = (unsigned __int16)v89;
                            if (!k)
                            {
                                v18 = Concurrency::details::SchedulerBase::GetSchedulerProxy((Concurrency::details::SchedulerBase*)(a1 + 612 * i + 2628));
                                LOWORD(v72) = sub_417924(a1 + 612 * m + 2628, (int)v18, 1);
                                v19 = sub_425D70((_DWORD*)(a1 + 612 * m + 2628));
                                if (v91 == v19)
                                    LOWORD(v72) = 85 * (unsigned __int16)v72 / 100;
                                LOBYTE(v71) = sub_475290((char*)a1 + 612 * i + 2628);
                                if ((unsigned __int8)v71 == 1)
                                    LOWORD(v72) = (unsigned __int16)v72 / 2;
                                if (!(_WORD)v72)
                                    LOWORD(v72) = 1;
                                v88 = 4 * (unsigned __int16)v89 / (unsigned __int16)v72;
                                if ((unsigned __int8)v71 == 2)
                                    v88 = (unsigned __int16)v89;
                            }
                            if (v88 <= 0)
                                v88 = 1;
                            sub_4020B0(&v73);
                            v73 = v88;
                            v84 = Concurrency::details::SchedulerBase::GetSchedulerProxy((Concurrency::details::SchedulerBase*)(a1 + 612 * i + 2628));
                            v76 = v91;
                            LOBYTE(v90) = sub_475170((char*)a1 + 612 * i + 2628);
                            if ((_BYTE)v90)
                            {
                                if ((unsigned __int8)v90 == 1)
                                {
                                    v76 = sub_425D70((_DWORD*)(a1 + 612 * i + 2628));
                                }
                                else if ((unsigned __int8)v90 == 2)
                                {
                                    v76 = sub_425D70((_DWORD*)(a1 + 612 * i + 2628)) == 0;
                                }
                            }
                            v74 = sub_4753B0((char*)a1 + 612 * i + 2628);
                            v80 = sub_475250((char*)a1 + 612 * i + 2628);
                            v85 = m;
                            v77 = 0;
                            v78 = sub_475310((char*)a1 + 612 * i + 2628);
                            v75 = sub_4752D0((short*)a1 + 612 * i + 2628);
                            v83 = a1 + 612 * i + 2628;
                            v86 = a1 + 612 * m + 2628;
                            v79 = sub_4752B0((unsigned char*)v83);
                            v87 = sub_475270((int*)a1 + 612 * i + 2628);
                            v81 = sub_4751B0((char*)a1 + 612 * i + 2628);
                            v82 = sub_475190((char*)a1 + 612 * i + 2628);
                            if (Concurrency::details::SchedulerBase::GetSchedulerProxy((Concurrency::details::SchedulerBase*)(a1 + 612 * i + 2628)) == (struct Concurrency::ISchedulerProxy*)97)
                            {
                                if (k || !sub_4211AC((char*)a1 + 612 * m + 2628))
                                {
                                    v87 = 83;
                                    v79 = 1;
                                }
                                else
                                {
                                    v73 = 40 * sub_4175B4(a1 + 612 * i + 2628, 1) / 100;
                                }
                            }
                            sub_407756(a1 + 612 * i + 2628, 0, (int)&v73, k > 0);
                            if (k)
                            {
                                if (k == 1)
                                    sub_494257(a1 + 196 * m + 7524, 1, (int)&v73, 0);
                            }
                            else
                            {
                                sub_407756(a1 + 612 * m + 2628, 1, (int)&v73, 0);
                            }
                            continue;
                        }
                    }
                }
            }
        LABEL_203:
            for (i = 0; i < (unsigned __int8)byte_4B999A; ++i)
            {
                if (sub_494209((int*)a1 + 196 * i + 7524))
                {
                    v70 = unknown_libname_12((_DWORD*)(a1 + 196 * i + 7524));
                    v68 = 0;
                    for (n = 0; n < (unsigned __int8)byte_4B9985; ++n)
                    {
                        if (unknown_libname_7((_DWORD*)(a1 + 612 * n + 2628)) && !sub_4755B0((_BYTE*)(a1 + 196 * i + 7524), n))
                        {
                            if ((unsigned __int8)sub_4751D0((char*)a1 + 612 * n + 2628) && sub_475530((int*)a1 + 196 * i + 7524) && v70 != 8)
                            {
                                QueueLength = Concurrency::details::SchedulerProxy::GetQueueLength((Concurrency::details::SchedulerProxy*)(a1 + 196 * i + 7524));
                                v67 = sub_425D70((_DWORD*)(a1 + 612 * n + 2628));
                                if (!QueueLength || (QueueLength <= 0 || !v67) && (QueueLength >= 0 || v67))
                                {
                                    if (sub_464550(
                                        (Concurrency::details::UMSFreeVirtualProcessorRoot*)(a1 + 196 * i + 7524),
                                        a1 + 612 * n + 2628))
                                    {
                                        sub_4238DE(a1 + 612 * n + 2628, (Concurrency::details::SchedulerProxy*)(a1 + 196 * i + 7524));
                                        v68 = 0;
                                        break;
                                    }
                                }
                            }
                            if (!sub_4263D0((unsigned __int8*)(a1 + 612 * n + 2628))
                                && sub_464550(
                                    (Concurrency::details::UMSFreeVirtualProcessorRoot*)(a1 + 196 * i + 7524),
                                    a1 + 612 * n + 2628))
                            {
                                v20 = sub_426470((_DWORD*)(a1 + 196 * i + 7524));
                                if (v20 >= sub_426090((_DWORD*)(a1 + 612 * n + 2628)))
                                {
                                    v21 = sub_426470((_DWORD*)(a1 + 196 * i + 7524));
                                    if (v21 <= sub_426090((_DWORD*)(a1 + 612 * n + 2628)))
                                        v65 = sub_475590((int*)a1 + 196 * i + 7524);
                                    else
                                        v65 = 0;
                                }
                                else
                                {
                                    v65 = 1;
                                }
                                if ((int)Concurrency::details::SchedulerProxy::GetQueueLength((Concurrency::details::SchedulerProxy*)(a1 + 196 * i + 7524)) <= 0)
                                {
                                    if ((Concurrency::details::SchedulerProxy::GetQueueLength((Concurrency::details::SchedulerProxy*)(a1 + 196 * i + 7524)) & 0x80000000) == 0)
                                        v65 = sub_475590((int*)a1 + 196 * i + 7524);
                                    else
                                        v65 = 0;
                                }
                                else
                                {
                                    v65 = 1;
                                }
                                LOWORD(v64) = sub_475570((short*)a1 + 196 * i + 7524);
                                v63 = (unsigned __int16)v64;
                                if (v70 != 8)
                                {
                                    LOWORD(v51) = sub_417924(a1 + 612 * n + 2628, 3, 1);
                                    v22 = sub_425D70((_DWORD*)(a1 + 612 * n + 2628));
                                    if (v65 == v22)
                                        LOWORD(v51) = 85 * (unsigned __int16)v51 / 100;
                                    if (!(_WORD)v51)
                                        LOWORD(v51) = 1;
                                    v63 = 4 * (unsigned __int16)v64 / (unsigned __int16)v51;
                                }
                                if (v63 <= 0)
                                    v63 = 1;
                                sub_4020B0(&v52);
                                v52 = v63;
                                v60 = 3;
                                v54 = v65;
                                v53 = sub_475550((char*)a1 + 196 * i + 7524);
                                v58 = 6;
                                v61 = n;
                                v55 = 0;
                                v56 = sub_4754F0((char*)a1 + 196 * i + 7524);
                                v59 = unknown_libname_8((_DWORD*)(a1 + 196 * i + 7524));
                                v62 = a1 + 612 * n + 2628;
                                if (v70 == 8)
                                    v57 = 0;
                                else
                                    v57 = sub_475510((unsigned char*)a1 + 196 * i + 7524);
                                v68 = 1;
                                sub_407756(a1 + 612 * n + 2628, 1, (int)&v52, 0);
                                sub_494257(a1 + 196 * i + 7524, 0, (int)&v52, 0);
                            }
                        }
                    }
                    if (v68)
                        sub_494257(a1 + 196 * i + 7524, 0, 0, 1);
                }
            }
            i = 0;
            while (2)
            {
                if (i >= (unsigned __int8)byte_4B9985)
                {
                    v112 = 0;
                    if (*(_DWORD*)(a1 + 116) != 3)
                    {
                        v48 = 0;
                        memset(v47, 0, sizeof(v47));
                        for (i = 0; i < (unsigned __int8)byte_4B9990; ++i)
                        {
                            LOBYTE(v46) = *(_BYTE*)(i + a1 + 2546);
                            if (*(_BYTE*)(i + a1 + 13044))
                            {
                                v112 += (unsigned __int8)v46;
                            }
                            else
                            {
                                for (ii = 0; ii < (unsigned __int8)v46; ++ii)
                                {
                                    v44 = (Concurrency::details::SchedulerBase*)(a1 + 612 * (unsigned __int8)byte_4B9988[ii + v112] + 2628);
                                    if (unknown_libname_7((int*)v44))
                                    {
                                        if (Concurrency::details::SchedulerBase::GetSchedulerProxy(v44) != (struct Concurrency::ISchedulerProxy*)80)
                                            break;
                                    }
                                }
                                if (ii == (unsigned __int8)v46)
                                {
                                    v47[i] = 1;
                                    ++v48;
                                }
                                v112 += (unsigned __int8)v46;
                            }
                        }
                        if (v48 > 0)
                        {
                            *(_BYTE*)(a1 + 13042) -= v48;
                            for (i = 0; i < (unsigned __int8)byte_4B9990; ++i)
                            {
                                if (v47[i])
                                {
                                    *(_BYTE*)(i + a1 + 13044) = *(_BYTE*)(a1 + 13042);
                                    if (--v48 <= 0)
                                        break;
                                }
                            }
                        }
                    }
                    v117 = 0;
                    v116 = -1;
                    for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
                    {
                        if (unknown_libname_7((_DWORD*)(a1 + 612 * i + 2628)))
                        {
                            if (Concurrency::details::SchedulerBase::GetSchedulerProxy((Concurrency::details::SchedulerBase*)(a1 + 612 * i + 2628)) != (struct Concurrency::ISchedulerProxy*)80)
                            {
                                v24 = sub_426070((_BYTE*)(a1 + 612 * i + 2628));
                                if (v24 != v116)
                                {
                                    ++v117;
                                    LOBYTE(v116) = sub_426070((_BYTE*)(a1 + 612 * i + 2628));
                                    v116 = v116;
                                }
                            }
                        }
                        if (v117 >= 2)
                            break;
                    }
                    if (v117 <= 1 && (v116 || *(_DWORD*)(a1 + 116) != 3))
                    {
                        if (v116 < 0)
                        {
                            if (!v117)
                                sub_44B5EF((_DWORD*)a1, -1);
                        }
                        else
                        {
                            v43 = 1;
                            for (jj = 0; jj < (unsigned __int8)byte_4B9985; ++jj)
                            {
                                if (unknown_libname_7((_DWORD*)(a1 + 612 * jj + 2628)))
                                {
                                    if (Concurrency::details::SchedulerBase::GetSchedulerProxy((Concurrency::details::SchedulerBase*)(a1 + 612 * jj + 2628)) != (struct Concurrency::ISchedulerProxy*)80)
                                    {
                                        v25 = sub_426070((_BYTE*)(a1 + 612 * jj + 2628));
                                        if (v25 == v116)
                                        {
                                            *(_BYTE*)(jj + a1 + 13052) = 1;
                                            if (!sub_41BEBA(a1 + 612 * jj + 2628))
                                                v43 = 0;
                                        }
                                    }
                                }
                            }
                            if (v43)
                            {
                                sub_44B5EF((_DWORD*)a1, v116);
                                *(_BYTE*)(v116 + a1 + 13044) = 1;
                            }
                        }
                    }
                    for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
                    {
                        if (unknown_libname_7((_DWORD*)(a1 + 612 * i + 2628)))
                        {
                            if (Concurrency::details::SchedulerBase::GetSchedulerProxy((Concurrency::details::SchedulerBase*)(a1 + 612 * i + 2628)) != (struct Concurrency::ISchedulerProxy*)80)
                            {
                                v41 = Concurrency::details::SchedulerBase::GetSchedulerProxy((Concurrency::details::SchedulerBase*)(a1 + 612 * i + 2628));
                                if (v41 != (struct Concurrency::ISchedulerProxy*)69
                                    && v41 != (struct Concurrency::ISchedulerProxy*)70)
                                {
                                    sub_408F50(a1 + 612 * i + 2628, a2, a3, a4, 0);
                                }
                            }
                        }
                    }
                    for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
                    {
                        if (unknown_libname_7((_DWORD*)(a1 + 612 * i + 2628)))
                        {
                            if (Concurrency::details::SchedulerBase::GetSchedulerProxy((Concurrency::details::SchedulerBase*)(a1 + 612 * i + 2628)) != (struct Concurrency::ISchedulerProxy*)80)
                            {
                                v40 = Concurrency::details::SchedulerBase::GetSchedulerProxy((Concurrency::details::SchedulerBase*)(a1 + 612 * i + 2628));
                                if (v40 == (struct Concurrency::ISchedulerProxy*)69
                                    || v40 == (struct Concurrency::ISchedulerProxy*)70)
                                {
                                    sub_408F50(a1 + 612 * i + 2628, a2, a3, a4, 1);
                                }
                            }
                        }
                    }
                    for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
                    {
                        if (unknown_libname_7((_DWORD*)(a1 + 612 * i + 2628))
                            && Concurrency::details::SchedulerBase::GetSchedulerProxy((Concurrency::details::SchedulerBase*)(a1 + 612 * i + 2628)) != (struct Concurrency::ISchedulerProxy*)80
                            && !sub_426170((char*)a1 + 612 * i + 2628))
                        {
                            sub_4126CE(a1 + 612 * i + 2628, a2, a3, a4);
                        }
                    }
                    for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
                    {
                        if (unknown_libname_7((_DWORD*)(a1 + 612 * i + 2628))
                            && Concurrency::details::SchedulerBase::GetSchedulerProxy((Concurrency::details::SchedulerBase*)(a1 + 612 * i + 2628)) != (struct Concurrency::ISchedulerProxy*)80
                            && sub_426170((char*)a1 + 612 * i + 2628))
                        {
                            sub_4126CE(a1 + 612 * i + 2628, a2, a3, a4);
                        }
                    }
                    for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
                    {
                        if (unknown_libname_7((_DWORD*)(a1 + 612 * i + 2628))
                            && Concurrency::details::SchedulerBase::GetSchedulerProxy((Concurrency::details::SchedulerBase*)(a1 + 612 * i + 2628)) != (struct Concurrency::ISchedulerProxy*)80)
                        {
                            sub_417780(a1 + 612 * i + 2628);
                        }
                    }
                    for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
                    {
                        if (*(__int16*)(a1 + 2 * i + 11404) > 0 && !-- * (_WORD*)(a1 + 2 * i + 11404))
                            sub_456879((_DWORD*)a1, i);
                    }
                    if (dword_4B99F0)
                    {
                        for (i = *(_DWORD*)(a1 + 9092); i < 32; ++i)
                            sub_43F1A3(a1 + 16 * i + 9096);
                        for (i = 0; i < *(_DWORD*)(a1 + 9092); ++i)
                            sub_43F1A3(a1 + 16 * i + 9096);
                    }
                    for (i = 0; i < 32; ++i)
                        sub_4419F6(a1 + 36 * i + 9608);
                    for (i = 0; i < 8; ++i)
                        sub_47F04A(a1 + 40 * i + 10760);
                    for (i = 0; i < 4; ++i)
                        sub_43EF86(a1 + 24 * i + 11080);
                    v109 = 0;
                    for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
                    {
                        if (*(unsigned __int8*)(i + a1 + 13052) == 255)
                            ++v109;
                    }
                    if (v109 > 0)
                    {
                        *(_BYTE*)(a1 + 13043) -= v109;
                        for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
                        {
                            if (*(unsigned __int8*)(i + a1 + 13052) == 255)
                            {
                                *(_BYTE*)(i + a1 + 13052) = *(_BYTE*)(a1 + 13043);
                                if (--v109 <= 0)
                                    break;
                            }
                        }
                    }
                    sub_4744E5(a1);
                    goto LABEL_4;
                }
                if (unknown_libname_7((_DWORD*)(a1 + 612 * i + 2628))
                    && Concurrency::details::SchedulerBase::GetSchedulerProxy((Concurrency::details::SchedulerBase*)(a1 + 612 * i + 2628)) != (struct Concurrency::ISchedulerProxy*)80)
                {
                    if ((unsigned __int8)sub_475370((char*)a1 + 612 * i + 2628) == 2 && sub_4262D0((int*)a1 + 612 * i + 2628))
                    {
                        v50 = sub_4262D0((int*)a1 + 612 * i + 2628);
                        if (sub_475330((int*)a1 + 612 * i + 2628)
                            || sub_475330((int*)v50)
                            || (v23 = sub_4262D0((int*)v50), v23 != a1 + 612 * i + 2628))
                        {
                            sub_425D10((_DWORD*)(a1 + 612 * i + 2628), 0);
                        }
                        else
                        {
                            sub_420FC4(a1 + 612 * i + 2628, 1);
                        }
                        goto LABEL_253;
                    }
                    if ((unsigned __int8)sub_475370((char*)a1 + 612 * i + 2628) == 1)
                    {
                        if (!sub_475330((int*)a1 + 612 * i + 2628))
                        {
                            sub_41242D(a1 + 612 * i + 2628);
                            goto LABEL_253;
                        }
                    }
                    else
                    {
                        if (!sub_475350((int*)a1 + 612 * i + 2628))
                            goto LABEL_253;
                        if (!sub_475330((int*)a1 + 612 * i + 2628))
                        {
                            sub_41B6F5(a1 + 612 * i + 2628);
                            goto LABEL_253;
                        }
                        v49 = (_DWORD*)sub_426430((int*)a1 + 612 * i + 2628);
                        if (v49)
                            sub_41B6CF(v49, 0, 0);
                    }
                    sub_475390((_DWORD*)(a1 + 612 * i + 2628), 0);
                }
            LABEL_253:
                ++i;
                continue;
            }
        }
    }
    sub_477F0C(0);
    v26 = sub_476D78(0);
    v121 = v26 - sub_476D29(0);
    if (sub_476DC7(0, 6))
        *(_DWORD*)(a1 + 2500) = 1;
    for (i = 1; i < (unsigned __int8)byte_4B9986; ++i)
    {
        v27 = sub_477F0C(i);
        LOBYTE(v27) = i;
        if (sub_476DC7(v27, 6))
            *(_DWORD*)(a1 + 2500) = 1;
    }
    if (*(_BYTE*)(a1 + 2544) || *(_DWORD*)(a1 + 16136))
    {
        if (*(int*)(a1 + 16136) <= 0)
        {
            if (*(_BYTE*)(a1 + 2544) == 1)
            {
                SetRect(&v38, 0, 0, 320, 176);
                if (((*(unsigned __int8*)(a1 + 2545) / 2) & 0x80000001) != 0)
                    sub_49EDC1((int)unk_4BDC60, 0, (int*)&v38, 0xFFFFFF);
                else
                    sub_49EDC1((int)unk_4BDC60, 0, (int*)&v38, 0);
                if (*(unsigned __int8*)(a1 + 2545) >= 4u)
                {
                    *(_BYTE*)(a1 + 2544) = 0;
                    *(_BYTE*)(a1 + 2545) = 0;
                }
            }
            ++* (_BYTE*)(a1 + 2545);
        }
        else
        {
            SetRect(&rc, 0, 0, 320, 176);
            sub_49EDC1((int)unk_4BDC60, v28, (int*)&rc, 0);
        }
    }
    else
    {
        sub_486476((_DWORD*)(a1 + 128));
    }
    sub_44325C(a1);
    if (dword_4B99F0)
    {
        for (i = *(_DWORD*)(a1 + 9092); i < 32; ++i)
            sub_43F1F8(a1 + 16 * i + 9096);
        for (i = 0; i < *(_DWORD*)(a1 + 9092); ++i)
            sub_43F1F8(a1 + 16 * i + 9096);
    }
    for (i = 0; i < 32; ++i)
        sub_441DB3(a1 + 36 * i + 9608);
    result = (unsigned __int16*)sub_443E80(a1);
    for (i = 0; i < 4; ++i)
        result = sub_43EEE5((unsigned __int16*)(a1 + 24 * i + 11080));
    if (*(_DWORD*)(a1 + 2500))
    {
        *(_DWORD*)(a1 + 2500) = 0;
        *(_DWORD*)(a1 + 2504) = *(_DWORD*)(a1 + 2504) == 0;
        sub_43FFC3((int*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
        if (*(_DWORD*)(a1 + 2504))
            result = (unsigned __int16*)sub_440B78((int)unk_4BDB28);
        else
            result = (unsigned __int16*)sub_440BC2((int)unk_4BDB28);
    }
    v120 = 1;
    for (i = 0; i < 8; ++i)
    {
        v37 = (Concurrency::details::SchedulerBase*)(a1 + 612 * i + 2628);
        result = (unsigned __int16*)unknown_libname_7((int*)v37);
        if (result)
        {
            result = (unsigned __int16*)sub_41BEA6((int*)v37);
            if (!result)
            {
                result = (unsigned __int16*)Concurrency::details::SchedulerBase::GetSchedulerProxy(v37);
                if (result != (unsigned __int16*)80)
                {
                    v120 = 0;
                    break;
                }
            }
        }
    }
    if (dword_4B9974 || v120)
    {
        if (v121)
        {
            sub_43FFC3((int*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
            if (v121 + *(_DWORD*)(a1 + 2488) <= 100)
            {
                if (v121 + *(_DWORD*)(a1 + 2488) < 100)
                    *(_DWORD*)(a1 + 2488) += 10 * v121;
            }
            else
            {
                *(_DWORD*)(a1 + 2488) += 100 * v121;
            }
            if (*(int*)(a1 + 2488) >= 10)
            {
                if (*(int*)(a1 + 2488) > 900)
                    *(_DWORD*)(a1 + 2488) = 900;
            }
            else
            {
                *(_DWORD*)(a1 + 2488) = 10;
            }
        }
        yTop = 8 * (dword_4B99F4 == 1);
        wsprintfA(String, "FRAME:%d", dword_4B93AC);
        v30 = lstrlenA(String);
        SetRect(&v36, 0, yTop, 8 * v30, yTop + 8);
        sub_49EF70((int)unk_4BDC60, (int*)&v36, 0, 0, 0, 0x20u);
        sub_47B7ED(0, yTop, String, 0, -1);
        yTop += 8;
        wsprintfA(String, "SPEED:%3d%%", *(_DWORD*)(a1 + 2488));
        SetRect(&v36, 0, yTop, 80, yTop + 8);
        sub_49EF70((int)unk_4BDC60, (int*)&v36, 0, 0, 0, 0x20u);
        return (unsigned __int16*)sub_47B7ED(0, yTop, String, 0, -1);
    }
    return result;
} 
int sub_44B5EF(_DWORD* thisx, int a2)
{
    int result; // eax

    thisx[26] = 12;
    thisx[630] = 0;
    result = a2;
    thisx[631] = a2;
    if (dword_4B9978)
    {
        if (!dword_4B9974)
            return sub_484175((_DWORD)thisx + 3350);
    }
    return result;
}

 
int  sub_44B63F(int thisx, double a2, double a3, double a4)
{
    int result; // eax
    int v5; // esi
    int v7; // [esp+Ch] [ebp-168h]
    int v8; // [esp+14h] [ebp-160h]
    struct tagRECT v9; // [esp+18h] [ebp-15Ch] BYREF
    int v10; // [esp+28h] [ebp-14Ch]
    CHAR String[256]; // [esp+2Ch] [ebp-148h] BYREF
    struct tagRECT rc; // [esp+12Ch] [ebp-48h] BYREF
    int k; // [esp+13Ch] [ebp-38h]
    _BYTE* v14; // [esp+140h] [ebp-34h]
    char v15; // [esp+144h] [ebp-30h]
    int v16; // [esp+148h] [ebp-2Ch]
    Concurrency::details::SchedulerBase* v17; // [esp+14Ch] [ebp-28h]
    int v18; // [esp+150h] [ebp-24h]
    int v19; // [esp+154h] [ebp-20h]
    int v20; // [esp+158h] [ebp-1Ch]
    int i; // [esp+15Ch] [ebp-18h]
    _BYTE* v22; // [esp+160h] [ebp-14h]
    int j; // [esp+164h] [ebp-10h]
    unsigned __int8* v24; // [esp+168h] [ebp-Ch]
    int v25; // [esp+16Ch] [ebp-8h]
    int v26; // [esp+170h] [ebp-4h]

    v24 = sub_463101((unsigned __int8*)thisx, *(_DWORD*)(thisx + 2524), 0);
    v25 = -1;
    LOBYTE(v26) = 0;
    if (v24)
    {
        v25 = (unsigned __int8)sub_425EF0((char*)v24);
        LOBYTE(v26) = *(_BYTE*)(thisx + *(_DWORD*)(thisx + 2524) + 2546);
    }
    if (*(int*)(thisx + 2520) < 241)
        ++* (_DWORD*)(thisx + 2520);
    if (*(_DWORD*)(thisx + 2520) == 25)
    {
        if (*(_DWORD*)(thisx + 116) == 3)
        {
            if (*(_DWORD*)(thisx + 11376) <= *(_DWORD*)(thisx + 4 * *(unsigned __int8*)(thisx + 11372) + 11380))
                sub_456D33((const CHAR*)thisx, aLoseWav, 0, 0);
            else
                sub_456D33((const CHAR*)thisx, aWinWav, 0, 0);
        }
        else if (*(int*)(thisx + 2524) < 0 || sub_41BEA6((int*)v24))
        {
            if (sub_425E70((_BYTE*)(thisx + 3852)) == 1)
                sub_456D33((const CHAR*)thisx, aLoseMisuzuWav, 0, 0);
            else
                sub_456D33((const CHAR*)thisx, aLoseWav_0, 0, 0);
        }
        else
        {
            sub_456D33((const CHAR*)thisx, aWinWav_0, 0, 0);
        }
    }
    else if (*(_DWORD*)(thisx + 2520) == 240)
    {
        *(_DWORD*)(thisx + 2528) = 0;
        if (!dword_4B9974)
        {
            if (*(_DWORD*)(thisx + 116))
            {
                if (*(_DWORD*)(thisx + 116) == 4)
                {
                    *(_DWORD*)(thisx + 108) = 24;
                    *(_BYTE*)(thisx + 2516) = 2;
                    ++* (_BYTE*)(thisx + 2476);
                    for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
                    {
                        v17 = (Concurrency::details::SchedulerBase*)(thisx + 612 * (unsigned __int8)byte_4B9988[i] + 2628);
                        LOBYTE(v20) = sub_426070((char*)v17);
                        v18 = thisx + 244 * (unsigned __int8)v20 + 1392;
                        v15 = *(_BYTE*)(v18 + i % (*(_DWORD*)(thisx + 2368) + 1) + 240);
                        v16 = 28 * v15 + v18;
                        v19 = sub_474E70((int*)v17);
                        *(_WORD*)(v16 + 6) += v19;
                        if (*(__int16*)(v16 + 22) < v19)
                            *(_WORD*)(v16 + 22) = v19;
                        if (*(__int16*)(v16 + 24) > v19)
                            *(_WORD*)(v16 + 24) = v19;
                        *(_BYTE*)(v16 + 26) += sub_475610((char*)v17);
                        ++* (_BYTE*)(v16 + 20);
                        if (Concurrency::details::SchedulerBase::GetSchedulerProxy(v17) == (struct Concurrency::ISchedulerProxy*)80)
                        {
                            if ((unsigned __int16)sub_474EB0((short*)v17))
                                *(_WORD*)(v16 + 8) = (unsigned __int16)sub_474EB0((short*)v17) / 2;
                            else
                                *(_WORD*)(v16 + 8) = 16;
                        }
                        else
                        {
                            *(_WORD*)(v16 + 8) = sub_474EB0((short*)v17);
                        }
                        *(_DWORD*)(v18 + 168) += *(__int16*)(v16 + 6);
                        if (!sub_425FF0((int*)v17)
                            || Concurrency::details::SchedulerBase::GetSchedulerProxy(v17) == (struct Concurrency::ISchedulerProxy*)80)
                        {
                            *(_BYTE*)(v16 + 10) = 0;
                            *(_BYTE*)(v16 + 11) = 0;
                        }
                        else
                        {
                            v14 = (_BYTE*)sub_426910((int*)v17);
                            *(_BYTE*)(v16 + 10) = sub_425CB0(v14) + 1;
                            *(_BYTE*)(v16 + 11) = sub_43E620((short*)v14);
                        }
                    }
                }
                else if (*(_DWORD*)(thisx + 116) == 3
                    && *(_DWORD*)(thisx + 11376) > *(_DWORD*)(thisx + 4 * *(unsigned __int8*)(thisx + 11372) + 11380))
                {
                    *(_DWORD*)(thisx + 4 * *(unsigned __int8*)(thisx + 11372) + 11380) = *(_DWORD*)(thisx + 11376);
                }
            }
            else
            {
                for (j = 0; j < 2; ++j)
                {
                    if (sub_425FF0((int*)thisx + 612 * j + 2628))
                    {
                        v22 = (_BYTE*)sub_426910((int*)thisx + 612 * j + 2628);
                        *(_BYTE*)(j + thisx + 11808) = sub_425CB0(v22) + 1;
                        *(_BYTE*)(j + thisx + 11810) = sub_43E620((short*)v22);
                    }
                    else
                    {
                        *(_BYTE*)(j + thisx + 11808) = 0;
                        *(_BYTE*)(j + thisx + 11810) = 0;
                    }
                }
                *(_DWORD*)(thisx + 108) = 16;
                *(_BYTE*)(thisx + 2516) = 2;
            }
        }
    }
    sub_488981((int*)thisx + 128);
    sub_486476((_DWORD*)(thisx + 128));
    if (*(int*)(thisx + 2524) >= 0)
    {
        for (k = 0; k < (unsigned __int8)byte_4B9985; ++k)
        {
            if ((unsigned __int8)sub_426070((_BYTE*)(thisx + 612 * k + 2628)) == *(_DWORD*)(thisx + 2524)
                && Concurrency::details::SchedulerBase::GetSchedulerProxy((Concurrency::details::SchedulerBase*)(thisx + 612 * k + 2628)) != (struct Concurrency::ISchedulerProxy*)80)
            {
                if (unknown_libname_7((_DWORD*)(thisx + 612 * k + 2628)))
                {
                    sub_41BEBA(thisx + 612 * k + 2628);
                    sub_402C05(thisx + 612 * k + 2628);
                    sub_408F50(thisx + 612 * k + 2628, a2, a3, a4, 0);
                    sub_4126CE(thisx + 612 * k + 2628, a2, a3, a4);
                    sub_417780(thisx + 612 * k + 2628);
                }
            }
        }
    }
    sub_44325C(thisx);
    result = sub_443E80(thisx);
    if (*(int*)(thisx + 2520) < 240 && *(_DWORD*)(thisx + 116) != 3)
    {
        SetRect(&rc, 0, 168, 320, 176);
        result = sub_49EF70((int)unk_4BDC60, (int*)&rc, 0, 0, 0, 0x20u);
    }
    if (*(int*)(thisx + 2520) < 240)
    {
        result = *(_DWORD*)(thisx + 2520) / 10 % 2;
        if (result)
        {
            v10 = 160;
            if (*(_DWORD*)(thisx + 116) == 3)
            {
                if (!dword_4B9974)
                {
                    result = *(unsigned __int8*)(thisx + 11372);
                    if (*(_DWORD*)(thisx + 11376) > *(_DWORD*)(thisx + 4 * result + 11380))
                        return sub_47B91A(140, 224, byte_4B0B10, 0, -1);
                }
            }
            else if (*(int*)(thisx + 2524) < 0)
            {
                return sub_47B7ED(v10, 168, ::String, 2, -1);
            }
            else
            {
                if (sub_425E70((char*)v24) == 1)
                {
                    wsprintfA(String, aMisuzuWin);
                }
                else if (*(_DWORD*)(thisx + 116))
                {
                    if (sub_41BEA6((int*)v24))
                    {
                        if ((unsigned __int8)v26 == 1)
                            wsprintfA(String, aCpuWin);
                        else
                            wsprintfA(String, aCpuTeamWin);
                    }
                    else if ((unsigned __int8)v26 == 1)
                    {
                        wsprintfA(String, "%dP WIN!!", v25 + 1);
                    }
                    else
                    {
                        wsprintfA(String, "%dP TEAM WIN!!", v25 + 1);
                    }
                }
                else if (sub_41BEA6((int*)v24))
                {
                    wsprintfA(String, aYourTeamLose);
                }
                else
                {
                    wsprintfA(String, aYourTeamWin);
                }
                return sub_47B7ED(v10, 168, String, 2, -1);
            }
            return result;
        }
    }
    if (*(int*)(thisx + 2520) >= 240)
    {
        if ((result = thisx, *(_DWORD*)(thisx + 116)) && *(_DWORD*)(thisx + 116) != 4 || dword_4B9974)
        {
            sub_477F0C(0);
            v5 = sub_476CDA(0);
            v8 = v5 - sub_476C8B(0);
            v7 = 3;
            if (dword_4B9974)
                v7 = 1;
            if (v8)
            {
                *(_DWORD*)(thisx + 2528) += v8;
                if (*(int*)(thisx + 2528) >= 0)
                {
                    if (*(_DWORD*)(thisx + 2528) > v7)
                        *(_DWORD*)(thisx + 2528) = 0;
                }
                else
                {
                    *(_DWORD*)(thisx + 2528) = v7;
                }
                sub_43FFC3((int*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
            }
            SetRect(&v9, 100, 60, 208, 8 * (2 * v7 + 2) + 68);
            sub_49EDC1((int)unk_4BDC60, (int)&v9, (int*)&v9, 0);
            if (dword_4B9974)
            {
                sub_47B91A(120, 68, byte_4B0B24, 0, -1);
                sub_47B91A(120, 84, byte_4B0B38, 0, -1);
            }
            else
            {
                sub_47B91A(120, 68, byte_4B0B50, 0, -1);
                sub_47B91A(120, 84, byte_4B0B60, 0, -1);
                sub_47B91A(120, 100, byte_4B0B74, 0, -1);
                sub_47B91A(120, 116, byte_4B0B8C, 0, -1);
            }
            sub_47B91A(108, 16 * *(_DWORD*)(thisx + 2528) + 68, asc_4B0BA0, 0, -1);
            result = sub_476DC7(0, 0);
            if (result)
            {
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
                result = thisx;
                if (!*(_DWORD*)(thisx + 2528))
                {
                    if (!dword_4B9974)
                    {
                        *(_BYTE*)(thisx + 2516) = 2;
                        *(_DWORD*)(thisx + 108) = 11;
                        return result;
                    }
                    return sub_453B66(thisx);
                }
                result = thisx;
                if (*(_DWORD*)(thisx + 2528) == 1)
                {
                    if (dword_4B9974)
                    {
                        *(_BYTE*)(thisx + 2516) = 2;
                        *(_DWORD*)(thisx + 108) = 11;
                    }
                    else
                    {
                        result = thisx;
                        *(_BYTE*)(thisx + 2516) = 2;
                        *(_DWORD*)(thisx + 108) = 9;
                    }
                    return result;
                }
                if (*(_DWORD*)(thisx + 2528) != 2)
                {
                    result = thisx;
                    if (*(_DWORD*)(thisx + 2528) != 3)
                        return result;
                    return sub_453B66(thisx);
                }
                result = thisx;
                *(_BYTE*)(thisx + 2516) = 2;
                *(_DWORD*)(thisx + 108) = 8;
                if (*(_DWORD*)(thisx + 116) == 3)
                {
                    byte_4B9985 = 1;
                    byte_4B9987 = 0;
                }
            }
        }
    }
    return result;
}

 
int sub_44C3D6(int thisx)
{
    int i; // [esp+4h] [ebp-4h]
    int j; // [esp+4h] [ebp-4h]

    *(_DWORD*)(thisx + 104) = 3;
    *(_BYTE*)(thisx + 2516) = 1;
    *(_DWORD*)(thisx + 2512) = 0;
    *(_DWORD*)(thisx + 2528) = 0;
    *(_DWORD*)(thisx + 2532) = 0;
    *(_BYTE*)(thisx + 2562) = 0;
    *(_BYTE*)(thisx + 11372) = 2;
    byte_4B999A = *(_BYTE*)(thisx + 30);
    for (i = 0; i < 14; ++i)
        word_4B99AC[i] = *(_WORD*)(thisx + 2 * i + 48);
    byte_4B99C8 = *(_BYTE*)(thisx + 76);
    byte_4B99C9 = *(_BYTE*)(thisx + 77);
    byte_4B99CA = *(_BYTE*)(thisx + 78);
    byte_4B99CB = *(_BYTE*)(thisx + 79);
    byte_4B99CC = *(_BYTE*)(thisx + 80);
    byte_4B99CD = *(_BYTE*)(thisx + 81);
    sub_480054(thisx + 15644, (int)&unk_4B0BA4);
    sub_475630((_BYTE*)(thisx + 15644), 14, 2, 11, 4);
    sub_475690((_BYTE*)(thisx + 15644), 2);
    streambuf::unbuffered((streambuf*)(thisx + 15644), 0);
    sub_475670((_DWORD*)(thisx + 15644), 0);
    sub_480054(thisx + 15680, (int)&unk_4B0BB4);
    sub_475630((_BYTE*)(thisx + 15680), 13, 8, 13, 12);
    streambuf::unbuffered((streambuf*)(thisx + 15680), 0);
    sub_475670((_DWORD*)(thisx + 15680), 1);
    sub_48089C(thisx + 15896, 0);
    sub_48089C(thisx + 15956, 0);
    sub_48089C(thisx + 16048, 0);
    sub_48089C(thisx + 16084, 0);
    *(_DWORD*)(thisx + 15640) = thisx + 15680;
    for (j = 2; j < 4; ++j)
    {
        streambuf::unbuffered((streambuf*)(thisx + 36 * j + 15644), 1);
        sub_475670((_DWORD*)(thisx + 36 * j + 15644), 0);
    }
    sub_453B85(thisx, 1, 1);
    return sub_456D33((const CHAR*)thisx, aMenuWav, 1, 0);
}

 
unsigned __int8  sub_44C60C(int thisx)
{
    unsigned __int8 result; // al
    int v2; // edx
    unsigned __int8 v4; // [esp+4h] [ebp-98h]
    unsigned __int8 v5; // [esp+8h] [ebp-94h]
    int i11; // [esp+Ch] [ebp-90h]
    int i12; // [esp+Ch] [ebp-90h]
    char v8; // [esp+10h] [ebp-8Ch]
    int i9; // [esp+14h] [ebp-88h]
    int i10; // [esp+14h] [ebp-88h]
    unsigned __int8 v11; // [esp+18h] [ebp-84h]
    int i8; // [esp+1Ch] [ebp-80h]
    int v13; // [esp+20h] [ebp-7Ch]
    int i7; // [esp+24h] [ebp-78h]
    int i2; // [esp+2Ch] [ebp-70h]
    int i3; // [esp+2Ch] [ebp-70h]
    int i4; // [esp+2Ch] [ebp-70h]
    int i5; // [esp+2Ch] [ebp-70h]
    int i6; // [esp+2Ch] [ebp-70h]
    Concurrency::details::_CancellationTokenRegistration* v20; // [esp+30h] [ebp-6Ch]
    unsigned __int8 v21; // [esp+34h] [ebp-68h]
    unsigned __int8 v22; // [esp+38h] [ebp-64h]
    int nn; // [esp+3Ch] [ebp-60h]
    int i1; // [esp+3Ch] [ebp-60h]
    char v25; // [esp+40h] [ebp-5Ch]
    int kk; // [esp+44h] [ebp-58h]
    int mm; // [esp+44h] [ebp-58h]
    unsigned __int8 v28; // [esp+48h] [ebp-54h]
    int jj; // [esp+4Ch] [ebp-50h]
    int n; // [esp+4Ch] [ebp-50h]
    int ii; // [esp+4Ch] [ebp-50h]
    int m; // [esp+4Ch] [ebp-50h]
    int i; // [esp+50h] [ebp-4Ch]
    int j; // [esp+54h] [ebp-48h]
    int k; // [esp+54h] [ebp-48h]
    int v36; // [esp+58h] [ebp-44h]
    int v37[14]; // [esp+5Ch] [ebp-40h] BYREF
    int v38; // [esp+94h] [ebp-8h]
    int v39; // [esp+98h] [ebp-4h]

    sub_477F0C(0);
    v38 = 0;
    v36 = 0;
    v39 = 0;
    if (*(_DWORD*)(thisx + 15640) && !*(_BYTE*)(thisx + 2516))
    {
        v39 = (*(int(**)(_DWORD))(**(_DWORD**)(thisx + 15640) + 16))(*(_DWORD*)(thisx + 15640));
        *(_DWORD*)(thisx + 2528) = unknown_libname_13(*(_DWORD**)(thisx + 15640));
    }
    switch (*(_BYTE*)(thisx + 2562))
    {
    case 0:
        if (v39 != 1)
        {
            if (v39 == 3)
                v36 = 1;
            break;
        }
        sub_475670((_DWORD*)(thisx + 15680), 0);
        *(_DWORD*)(thisx + 15640) = 0;
        if (*(_DWORD*)(thisx + 2528))
            byte_4B9984 = 0;
        switch (*(_DWORD*)(thisx + 2528))
        {
        case 0:
            *(_DWORD*)(thisx + 116) = 0;
            byte_4B99CB = 1;
            byte_4B99CC = 0;
            *(_BYTE*)(thisx + 2562) = 7;
            sub_480054(thisx + 15716, (int)&unk_4B0C10);
            sub_4756B0((_BYTE*)(thisx + 15716), 20, 8);
            if (*(_DWORD*)(thisx + 15640))
                (*(void(**)(_DWORD, _DWORD))(**(_DWORD**)(thisx + 15640) + 4))(*(_DWORD*)(thisx + 15640), 0);
            (*(void(**)(int, int))(*(_DWORD*)(thisx + 15716) + 4))(thisx + 15716, 1);
            *(_DWORD*)(thisx + 15640) = thisx + 15716;
            v38 = 1;
            v36 = 1;
            goto LABEL_224;
        case 1:
            if (sub_476485((_DWORD*)player_list, 2))
                *(_DWORD*)(thisx + 116) = 2;
            else
                *(_DWORD*)(thisx + 116) = 1;
            *(_BYTE*)(thisx + 2562) = 1;
            v38 = 1;
            v36 = 1;
            byte_4B9985 = 4;
            byte_4B9986 = 1;
            byte_4B9987 = 3;
            *(_DWORD*)(thisx + 15640) = thisx + 15824;
            (*(void(**)(_DWORD, int))(**(_DWORD**)(thisx + 15640) + 4))(*(_DWORD*)(thisx + 15640), 1);
            goto LABEL_224;
        case 2:
            *(_BYTE*)(thisx + 2562) = 2;
            if (*(_DWORD*)(thisx + 15640))
                (*(void(**)(_DWORD, _DWORD))(**(_DWORD**)(thisx + 15640) + 4))(*(_DWORD*)(thisx + 15640), 0);
            (*(void(**)(int, int))(*(_DWORD*)(thisx + 15992) + 4))(thisx + 15992, 1);
            *(_DWORD*)(thisx + 15640) = thisx + 15992;
            v38 = 1;
            v36 = 1;
            goto LABEL_224;
        }
        if (*(_DWORD*)(thisx + 2528) != 3)
        {
            if (*(_DWORD*)(thisx + 2528) == 4)
            {
                result = thisx;
                *(_BYTE*)(thisx + 2516) = 2;
                *(_DWORD*)(thisx + 108) = 5;
                return result;
            }
            break;
        }
        *(_DWORD*)(thisx + 116) = 4;
        *(_BYTE*)(thisx + 2562) = 10;
        if (*(_DWORD*)(thisx + 15640))
            (*(void(**)(_DWORD, _DWORD))(**(_DWORD**)(thisx + 15640) + 4))(*(_DWORD*)(thisx + 15640), 0);
        goto LABEL_24;
    case 1:
        switch (v39)
        {
        case 1:
            (*(void(**)(_DWORD, _DWORD))(**(_DWORD**)(thisx + 15640) + 4))(*(_DWORD*)(thisx + 15640), 0);
            *(_DWORD*)(thisx + 15640) = 0;
            if (*(_DWORD*)(thisx + 116) == 2)
            {
                byte_4B9990 = 2;
                *(_BYTE*)(thisx + 2546) = byte_4B9986;
                *(_BYTE*)(thisx + 2547) = byte_4B9987;
                for (i = 0; i < 8; ++i)
                    byte_4B9988[i] = i;
                *(_BYTE*)(thisx + 2516) = 2;
                byte_4B99CB = 0;
                byte_4B99CC = 0;
                byte_4B999A = *(_BYTE*)(thisx + 30);
                byte_4B99C8 = 0;
                result = thisx;
                *(_DWORD*)(thisx + 108) = 8;
                return result;
            }
            *(_BYTE*)(thisx + 2562) = 3;
            sub_480054(thisx + 15716, (int)&unk_4B0C28);
            sub_475690((_BYTE*)(thisx + 15716), 4);
            sub_475630((_BYTE*)(thisx + 15716), 11, 11, 17, 8);
            (*(void(**)(int, int))(*(_DWORD*)(thisx + 15716) + 4))(thisx + 15716, 1);
            *(_DWORD*)(thisx + 15640) = thisx + 15716;
            byte_4B9990 = byte_4B9985;
            memset((void*)(thisx + 2546), 0, 8u);
            for (j = 0; j < (unsigned __int8)byte_4B9990; ++j)
                *(_BYTE*)(j + thisx + 2546) = 1;
            for (k = 0; k < 8; ++k)
                byte_4B9988[k] = k;
            *(_DWORD*)(thisx + 2528) = 0;
            v38 = 1;
            v36 = 1;
            break;
        case 2:
            (*(void(**)(_DWORD, _DWORD))(**(_DWORD**)(thisx + 15640) + 4))(*(_DWORD*)(thisx + 15640), 0);
            (*(void(**)(int, int))(*(_DWORD*)(thisx + 15680) + 4))(thisx + 15680, 1);
            *(_DWORD*)(thisx + 15640) = thisx + 15680;
            *(_BYTE*)(thisx + 2562) = 0;
            v38 = 1;
            v36 = 1;
            break;
        case 3:
            v38 = 1;
            break;
        }
        break;
    case 2:
        if (v39 == 1)
        {
            *(_BYTE*)(thisx + 11372) = unknown_libname_13(*(_DWORD**)(thisx + 15640));
            byte_4B9998 = unknown_libname_13(*(_DWORD**)(thisx + 15640));
            byte_4B99CB = 0;
            byte_4B99CC = 0;
            *(_DWORD*)(thisx + 116) = 3;
            byte_4B9985 = 1;
            byte_4B9986 = 1;
            byte_4B9987 = 1;
            byte_4B999A = *(_BYTE*)(thisx + 30);
            byte_4B99C8 = 0;
            result = thisx;
            *(_BYTE*)(thisx + 2516) = 2;
            *(_DWORD*)(thisx + 108) = 8;
            return result;
        }
        if (v39 == 2)
        {
            if (*(_DWORD*)(thisx + 15640))
                (*(void(**)(_DWORD, _DWORD))(**(_DWORD**)(thisx + 15640) + 4))(*(_DWORD*)(thisx + 15640), 0);
            (*(void(**)(int, int))(*(_DWORD*)(thisx + 15680) + 4))(thisx + 15680, 1);
            *(_DWORD*)(thisx + 15640) = thisx + 15680;
            *(_BYTE*)(thisx + 2562) = 0;
            v36 = 1;
            v38 = 1;
        }
        break;
    case 3:
        switch (v39)
        {
        case 1:
            (*(void(**)(_DWORD, _DWORD))(**(_DWORD**)(thisx + 15640) + 4))(*(_DWORD*)(thisx + 15640), 0);
            *(_DWORD*)(thisx + 15640) = 0;
            switch (*(_DWORD*)(thisx + 2528))
            {
            case 0:
                *(_BYTE*)(thisx + 2516) = 2;
                byte_4B99CB = *(_BYTE*)(thisx + 79);
                byte_4B99CC = *(_BYTE*)(thisx + 80);
                byte_4B999A = *(_BYTE*)(thisx + 30);
                byte_4B99C8 = *(_BYTE*)(thisx + 76);
                byte_4B99DF = *(_BYTE*)(thisx + 99);
                result = *(_BYTE*)(thisx + 100);
                byte_4B99E0 = result;
                *(_DWORD*)(thisx + 108) = 8;
                return result;
            case 1:
                *(_BYTE*)(thisx + 2562) = 4;
                *(_DWORD*)(thisx + 15640) = thisx + 15860;
                (*(void(**)(_DWORD, int))(**(_DWORD**)(thisx + 15640) + 4))(*(_DWORD*)(thisx + 15640), 1);
                v38 = 1;
                v36 = 1;
                break;
            case 2:
                *(_BYTE*)(thisx + 2562) = 6;
                if (*(_DWORD*)(thisx + 15640))
                    (*(void(**)(_DWORD, _DWORD))(**(_DWORD**)(thisx + 15640) + 4))(*(_DWORD*)(thisx + 15640), 0);
                (*(void(**)(int, int))(*(_DWORD*)(thisx + 15956) + 4))(thisx + 15956, 1);
                *(_DWORD*)(thisx + 15640) = thisx + 15956;
                v38 = 1;
                v36 = 1;
                break;
            }
            break;
        case 2:
            (*(void(**)(_DWORD, _DWORD))(**(_DWORD**)(thisx + 15640) + 4))(*(_DWORD*)(thisx + 15640), 0);
            *(_DWORD*)(thisx + 15640) = thisx + 15824;
            (*(void(**)(_DWORD, int))(**(_DWORD**)(thisx + 15640) + 4))(*(_DWORD*)(thisx + 15640), 1);
            *(_BYTE*)(thisx + 2562) = 1;
            v38 = 1;
            v36 = 1;
            break;
        case 3:
            v36 = 1;
            break;
        }
        break;
    case 4:
        if (v39 != 1)
        {
            if (v39 == 2)
            {
                for (m = 0; m < (unsigned __int8)byte_4B9986; ++m)
                    *(_WORD*)(thisx + 2 * m + 2564) = (unsigned __int8)sub_4575B4((unsigned __int8*)thisx, m, 0);
                *(_BYTE*)(thisx + 2562) = 3;
                (*(void(**)(int, int))(*(_DWORD*)(thisx + 15716) + 4))(thisx + 15716, 1);
                *(_DWORD*)(thisx + 15640) = thisx + 15716;
                v38 = 1;
                v36 = 1;
            }
            else if (v39)
            {
                v38 = 1;
            }
            break;
        }
        (*(void(**)(_DWORD, _DWORD))(**(_DWORD**)(thisx + 15640) + 4))(*(_DWORD*)(thisx + 15640), 0);
        *(_DWORD*)(thisx + 15640) = 0;
        if ((unsigned __int8)byte_4B9986 >= 2u)
        {
            for (n = 0; n < 8; ++n)
                byte_4B9988[n] = n;
            for (ii = 0; ii < 8; ++ii)
                sub_48EC25(thisx + 15896, ii + thisx, ii, *(_BYTE*)(ii + thisx + 2546));
            sub_48EC62((_BYTE*)(thisx + 15896));
            *(_DWORD*)(thisx + 15640) = thisx + 15896;
            (*(void(**)(_DWORD, int))(**(_DWORD**)(thisx + 15640) + 4))(*(_DWORD*)(thisx + 15640), 1);
            *(_BYTE*)(thisx + 2562) = 5;
            v38 = 1;
            v36 = 1;
            break;
        }
        for (jj = 0; jj < 8; ++jj)
            byte_4B9988[jj] = jj;
        goto LABEL_124;
    case 5:
        if (v39 == 1)
        {
            for (kk = 0; kk < 8; ++kk)
                *(_WORD*)(thisx + 2 * kk + 2564) = (unsigned __int8)sub_475710((_BYTE*)(thisx + 15896), kk);
            v28 = 0;
            v25 = 0;
            for (mm = 0; mm < (unsigned __int8)byte_4B9990; ++mm)
            {
                v22 = 0;
                for (nn = 0; nn < (unsigned __int8)byte_4B9986; ++nn)
                {
                    if (*(unsigned __int16*)(thisx + 2 * nn + 2564) == mm)
                    {
                        byte_4B9988[v28++] = nn;
                        ++v22;
                    }
                }
                if (v22 < (int)*(unsigned __int8*)(mm + thisx + 2546))
                {
                    v21 = *(_BYTE*)(mm + thisx + 2546) - v22;
                    for (i1 = 0; i1 < v21; ++i1)
                    {
                        byte_4B9988[v28] = v25 + byte_4B9986;
                        ++v25;
                        ++v28;
                    }
                }
            }
            (*(void(**)(_DWORD, _DWORD))(**(_DWORD**)(thisx + 15640) + 4))(*(_DWORD*)(thisx + 15640), 0);
            *(_DWORD*)(thisx + 15640) = thisx + 15716;
            (*(void(**)(_DWORD, int))(**(_DWORD**)(thisx + 15640) + 4))(*(_DWORD*)(thisx + 15640), 1);
            *(_BYTE*)(thisx + 2562) = 3;
            v38 = 1;
            v36 = 1;
        }
        else if (v39 == 2)
        {
            (*(void(**)(_DWORD, _DWORD))(**(_DWORD**)(thisx + 15640) + 4))(*(_DWORD*)(thisx + 15640), 0);
            *(_DWORD*)(thisx + 15640) = thisx + 15860;
            (*(void(**)(_DWORD, int))(**(_DWORD**)(thisx + 15640) + 4))(*(_DWORD*)(thisx + 15640), 1);
            *(_BYTE*)(thisx + 2562) = 4;
            v38 = 1;
            v36 = 1;
        }
        else if (v39)
        {
            v38 = 1;
        }
        break;
    case 6:
        if (v39 != 1 && v39 != 2)
        {
            if (v39)
            {
                v38 = 1;
                v36 = 1;
            }
            break;
        }
        (*(void(**)(_DWORD, _DWORD))(**(_DWORD**)(thisx + 15640) + 4))(*(_DWORD*)(thisx + 15640), 0);
        if (*(_DWORD*)(thisx + 15640))
            (*(void(**)(_DWORD, _DWORD))(**(_DWORD**)(thisx + 15640) + 4))(*(_DWORD*)(thisx + 15640), 0);
    LABEL_124:
        (*(void(**)(int, int))(*(_DWORD*)(thisx + 15716) + 4))(thisx + 15716, 1);
        *(_DWORD*)(thisx + 15640) = thisx + 15716;
        *(_BYTE*)(thisx + 2562) = 3;
        v38 = 1;
        v36 = 1;
        break;
    case 7:
        if (v39 == 1)
        {
            sub_475670((_DWORD*)(thisx + 15716), 0);
            if (*(_DWORD*)(thisx + 2528))
            {
                if (*(_DWORD*)(thisx + 2528) == 1)
                {
                    *(_BYTE*)(thisx + 2562) = 0;
                    *(_DWORD*)(thisx + 108) = 20;
                    *(_BYTE*)(thisx + 2516) = 2;
                }
            }
            else
            {
                *(_BYTE*)(thisx + 2562) = 8;
                v38 = 1;
                v36 = 1;
                sub_463F05(thisx + 11436);
                sub_475730((_WORD*)(thisx + 11816), 0);
                sub_475730((_WORD*)(thisx + 11892), 0);
                sub_480054(thisx + 15752, (int)&unk_4B0C5C);
                sub_4756B0((_BYTE*)(thisx + 15752), 26, 8);
                (*(void(**)(int, int))(*(_DWORD*)(thisx + 15752) + 4))(thisx + 15752, 1);
                *(_DWORD*)(thisx + 15640) = thisx + 15752;
            }
        }
        else if (v39 == 2)
        {
            (*(void(**)(int, _DWORD))(*(_DWORD*)(thisx + 15716) + 4))(thisx + 15716, 0);
            (*(void(**)(int, int))(*(_DWORD*)(thisx + 15680) + 4))(thisx + 15680, 1);
            *(_DWORD*)(thisx + 15640) = thisx + 15680;
            *(_BYTE*)(thisx + 2562) = 0;
            v38 = 1;
            v36 = 1;
        }
        break;
    case 8:
        if (v39 == 1)
        {
            *(_BYTE*)(thisx + 11968) = *(_DWORD*)(thisx + 2528) + 1;
            result = thisx;
            *(_BYTE*)(thisx + 2516) = 2;
            *(_DWORD*)(thisx + 108) = 4;
            return result;
        }
        if (v39 == 2)
        {
            (*(void(**)(int, _DWORD))(*(_DWORD*)(thisx + 15752) + 4))(thisx + 15752, 0);
            (*(void(**)(int, int))(*(_DWORD*)(thisx + 15716) + 4))(thisx + 15716, 1);
            *(_DWORD*)(thisx + 15640) = thisx + 15716;
            *(_BYTE*)(thisx + 2562) = 7;
            v38 = 1;
            v36 = 1;
        }
        break;
    case 0xA:
        switch (v39)
        {
        case 1:
            v20 = (Concurrency::details::_CancellationTokenRegistration*)unknown_libname_12((_DWORD*)(thisx + 16048));
            *(_BYTE*)(thisx + 2477) = (unsigned __int8)Concurrency::details::_CancellationTokenRegistration::_GetToken(v20);
            *(_DWORD*)(thisx + 2368) = (_DWORD)Concurrency::details::_CancellationTokenRegistration::_GetToken((Concurrency::details::_CancellationTokenRegistration*)((char*)v20 + 32));
            byte_4B9986 = (unsigned __int8)Concurrency::details::_CancellationTokenRegistration::_GetToken((Concurrency::details::_CancellationTokenRegistration*)((char*)v20 + 64));
            byte_4B99CB = (unsigned __int8)Concurrency::details::_CancellationTokenRegistration::_GetToken((Concurrency::details::_CancellationTokenRegistration*)((char*)v20 + 96));
            byte_4B999A = (unsigned __int8)Concurrency::details::_CancellationTokenRegistration::_GetToken((Concurrency::details::_CancellationTokenRegistration*)((char*)v20 + 128));
            *(_DWORD*)(thisx + 2372) = (_DWORD)Concurrency::details::_CancellationTokenRegistration::_GetToken((Concurrency::details::_CancellationTokenRegistration*)((char*)v20 + 160));
            byte_4B99DF = (unsigned __int8)Concurrency::details::_CancellationTokenRegistration::_GetToken((Concurrency::details::_CancellationTokenRegistration*)((char*)v20 + 192));
            byte_4B99E0 = (unsigned __int8)Concurrency::details::_CancellationTokenRegistration::_GetToken((Concurrency::details::_CancellationTokenRegistration*)((char*)v20 + 224));
            byte_4B9985 = 4 * *(_DWORD*)(thisx + 2368) + 4;
            byte_4B9987 = byte_4B9985 - byte_4B9986;
            byte_4B9990 = 4;
            memcpy((void*)(thisx + 2376), &dword_4B9980, 0x64u);
            memset((void*)(thisx + 2546), 0, 8u);
            for (i2 = 0; i2 < (unsigned __int8)byte_4B9990; ++i2)
                *(_BYTE*)(i2 + thisx + 2546) = *(_BYTE*)(thisx + 2368) + 1;
            for (i3 = 0; i3 < 8; ++i3)
                byte_4B9988[i3] = i3;
            if (!*(_DWORD*)(thisx + 2368))
            {
                *(_BYTE*)(thisx + 2516) = 2;
                result = thisx;
                *(_DWORD*)(thisx + 108) = 22;
                return result;
            }
            for (i4 = 0; i4 < 8; ++i4)
                byte_4B9988[i4] = -1;
            for (i5 = 0; i5 < (unsigned __int8)byte_4B9986; ++i5)
                byte_4B9988[2 * (i5 % 4) + (i5 >= 4)] = i5;
            for (i6 = 0; i6 < (unsigned __int8)byte_4B9985; ++i6)
            {
                for (i7 = i6; (unsigned __int8)byte_4B9988[i7] != 255; ++i7)
                    ;
                byte_4B9988[i7] = i6 + byte_4B9986;
            }
            *(_BYTE*)(thisx + 2562) = 11;
            if (*(_DWORD*)(thisx + 15640))
                (*(void(**)(_DWORD, _DWORD))(**(_DWORD**)(thisx + 15640) + 4))(*(_DWORD*)(thisx + 15640), 0);
            (*(void(**)(int, int))(*(_DWORD*)(thisx + 16084) + 4))(thisx + 16084, 1);
            *(_DWORD*)(thisx + 15640) = thisx + 16084;
            v36 = 1;
            v38 = 1;
            break;
        case 2:
            *(_BYTE*)(thisx + 2562) = 0;
            if (*(_DWORD*)(thisx + 15640))
                (*(void(**)(_DWORD, _DWORD))(**(_DWORD**)(thisx + 15640) + 4))(*(_DWORD*)(thisx + 15640), 0);
            (*(void(**)(int, int))(*(_DWORD*)(thisx + 15680) + 4))(thisx + 15680, 1);
            *(_DWORD*)(thisx + 15640) = thisx + 15680;
            v38 = 1;
            v36 = 1;
            break;
        case 3:
        case 4:
            v36 = 1;
            v38 = 1;
            break;
        }
        break;
    case 0xB:
        if (v39 == 1)
        {
            if (!*(_DWORD*)(thisx + 2528))
            {
                v13 = unknown_libname_12((_DWORD*)(thisx + 16084));
                byte_4B99C8 = (unsigned __int8)Concurrency::details::_CancellationTokenRegistration::_GetToken((Concurrency::details::_CancellationTokenRegistration*)(v13 + 32));
                byte_4B99CC = (unsigned __int8)Concurrency::details::_CancellationTokenRegistration::_GetToken((Concurrency::details::_CancellationTokenRegistration*)(v13 + 64));
                memcpy((void*)(thisx + 2376), &dword_4B9980, 0x64u);
                result = thisx;
                *(_BYTE*)(thisx + 2516) = 2;
                *(_DWORD*)(thisx + 108) = 22;
                return result;
            }
            v2 = thisx;
            if (*(_DWORD*)(thisx + 2528) == 3)
            {
                if ((unsigned __int8)byte_4B9986 >= 2u)
                {
                    for (i8 = 0; i8 < 8; ++i8)
                    {
                        LOBYTE(v2) = i8;
                        sub_48EC25(thisx + 15896, v2, i8, *(_BYTE*)(i8 + thisx + 2546));
                        v2 = i8 + 1;
                    }
                    sub_48EC62((_BYTE*)(thisx + 15896));
                    *(_DWORD*)(thisx + 15640) = thisx + 15896;
                    (*(void(**)(_DWORD, int))(**(_DWORD**)(thisx + 15640) + 4))(*(_DWORD*)(thisx + 15640), 1);
                    *(_BYTE*)(thisx + 2562) = 12;
                    v38 = 1;
                    v36 = 1;
                }
                else
                {
                    sub_451EB5((_BYTE*)thisx, 0, 1);
                    sub_47B91A(16, 208, byte_4B0C68, 0, dword_4B9248);
                }
            }
            break;
        }
        if (v39 != 2)
        {
            if (v39 == 3)
            {
                v36 = 1;
            }
            else if (v39 == 4)
            {
                v38 = 1;
            }
            break;
        }
        *(_BYTE*)(thisx + 2562) = 10;
        if (*(_DWORD*)(thisx + 15640))
            (*(void(**)(_DWORD, _DWORD))(**(_DWORD**)(thisx + 15640) + 4))(*(_DWORD*)(thisx + 15640), 0);
    LABEL_24:
        (*(void(**)(int, int))(*(_DWORD*)(thisx + 16048) + 4))(thisx + 16048, 1);
        *(_DWORD*)(thisx + 15640) = thisx + 16048;
        v38 = 1;
        v36 = 1;
        break;
    case 0xC:
        if (v39 == 1)
        {
            for (i9 = 0; i9 < 8; ++i9)
                *(_WORD*)(thisx + 2 * i9 + 2564) = (unsigned __int8)sub_475710((_BYTE*)(thisx + 15896), i9);
            v11 = 0;
            v8 = 0;
            for (i10 = 0; i10 < (unsigned __int8)byte_4B9990; ++i10)
            {
                v5 = 0;
                for (i11 = 0; i11 < (unsigned __int8)byte_4B9986; ++i11)
                {
                    if (*(unsigned __int16*)(thisx + 2 * i11 + 2564) == i10)
                    {
                        byte_4B9988[v11++] = i11;
                        ++v5;
                    }
                }
                if (v5 < (int)*(unsigned __int8*)(i10 + thisx + 2546))
                {
                    v4 = *(_BYTE*)(i10 + thisx + 2546) - v5;
                    for (i12 = 0; i12 < v4; ++i12)
                    {
                        byte_4B9988[v11] = v8 + byte_4B9986;
                        ++v8;
                        ++v11;
                    }
                }
            }
            *(_BYTE*)(thisx + 2562) = 11;
            if (*(_DWORD*)(thisx + 15640))
                (*(void(**)(_DWORD, _DWORD))(**(_DWORD**)(thisx + 15640) + 4))(*(_DWORD*)(thisx + 15640), 0);
        }
        else
        {
            if (v39 != 2)
            {
                if (v39)
                    v38 = 1;
                break;
            }
            *(_BYTE*)(thisx + 2562) = 11;
            if (*(_DWORD*)(thisx + 15640))
                (*(void(**)(_DWORD, _DWORD))(**(_DWORD**)(thisx + 15640) + 4))(*(_DWORD*)(thisx + 15640), 0);
        }
        (*(void(**)(int, int))(*(_DWORD*)(thisx + 16084) + 4))(thisx + 16084, 1);
        *(_DWORD*)(thisx + 15640) = thisx + 16084;
        v38 = 1;
        v36 = 1;
        break;
    }
LABEL_224:
    if (v38 || v36)
        sub_453B85(thisx, v38, v36);
    sub_49C15E((int)v37);
    v37[1] = 0;
    v37[2] = 0;
    v37[0] = dword_4B9248;
    result = (unsigned __int8)sub_49AB05((int)unk_4BDC60, v37);
    if (!*(_BYTE*)(thisx + 2516))
    {
        result = thisx;
        if (*(_DWORD*)(thisx + 15640))
            return (*(int(**)(_DWORD))(**(_DWORD**)(thisx + 15640) + 8))(*(_DWORD*)(thisx + 15640));
    }
    return result;
}

 
BOOL sub_44E484(_BYTE* thisx, int a2, int a3)
{
    int v4; // [esp+8h] [ebp-8h]
    int i; // [esp+Ch] [ebp-4h]

    v4 = a3;
    if (a3 == -1)
        v4 = *(unsigned __int16*)&thisx[2 * a2 + 2564];
    if (byte_4B99CD || (int)Size < (unsigned __int8)byte_4B9985)
        return 0;
    for (i = 0;
        i < (unsigned __int8)byte_4B9985
        && (i == a2 || *(unsigned __int16*)&thisx[2 * i + 2564] != v4 || !thisx[i + 2588]);
        ++i)
    {
        ;
    }
    return i != (unsigned __int8)byte_4B9985;
}

 
_DWORD*  sub_44E543(_DWORD* thisx)
{
    int v1; // eax
    _DWORD* result; // eax
    _DWORD* v3; // eax

    sub_45F935((int)thisx);
    sub_45FD81((int)thisx);
    thisx[3276] = -1;
    v1 = unknown_libname_10(thisx + 32);
    sub_49DA8A((_DWORD*)unk_4BDC60, v1);
    result = (_DWORD*)sub_4894E3(thisx + 32, 0);
    if ((int)result >= 0)
    {
        v3 = (_DWORD*)sub_4894E3(thisx + 32, 0);
        return sub_43FED3((_DWORD*)unk_4BDB28, v3);
    }
    return result;
}


 
int sub_44E5BA(_DWORD* thisx, double a2, double a3, double a4)
{
    int v6[14]; // [esp+4h] [ebp-3Ch] BYREF
    int i; // [esp+3Ch] [ebp-4h]

    sub_488981(thisx + 32);
    sub_486476(thisx + 32);
    for (i = 0; i < 8; ++i)
    {
        if (unknown_libname_7(&thisx[153 * i + 657]))
        {
            if (Concurrency::details::SchedulerBase::GetSchedulerProxy((Concurrency::details::SchedulerBase*)&thisx[153 * i + 657]) != (struct Concurrency::ISchedulerProxy*)80)
                sub_402C05((int)&thisx[153 * i + 657]);
        }
    }
    for (i = 0; i < 8; ++i)
    {
        if (unknown_libname_7(&thisx[153 * i + 657])
            && Concurrency::details::SchedulerBase::GetSchedulerProxy((Concurrency::details::SchedulerBase*)&thisx[153 * i + 657]) != (struct Concurrency::ISchedulerProxy*)80)
        {
            sub_408F50((int)&thisx[153 * i + 657], a2, a3, a4, 0);
        }
    }
    for (i = 0; i < 8; ++i)
    {
        if (unknown_libname_7(&thisx[153 * i + 657])
            && Concurrency::details::SchedulerBase::GetSchedulerProxy((Concurrency::details::SchedulerBase*)&thisx[153 * i + 657]) != (struct Concurrency::ISchedulerProxy*)80)
        {
            sub_4126CE((int)&thisx[153 * i + 657], a2, a3, a4);
        }
    }
    for (i = 0; i < 8; ++i)
    {
        if (unknown_libname_7(&thisx[153 * i + 657])
            && Concurrency::details::SchedulerBase::GetSchedulerProxy((Concurrency::details::SchedulerBase*)&thisx[153 * i + 657]) != (struct Concurrency::ISchedulerProxy*)80)
        {
            sub_417780((int)&thisx[153 * i + 657]);
        }
    }
    sub_44325C((int)thisx);
    if ((int)++thisx[630] < 120)
    {
        sub_49C15E((int)v6);
        v6[1] = 124;
        v6[2] = 68;
        v6[0] = (thisx[630] >= 60) + dword_4B9240;
        if (!(thisx[630] / 10 % 2))
            sub_49AB05((int)unk_4BDC60, v6);
    }
    else
    {
        thisx[26] = 11;
    }
    return sub_443E80((int)thisx);
}
 
int sub_44E835(int thisx)
{
    int v3; // [esp+4h] [ebp-60h]
    int v4; // [esp+10h] [ebp-54h]
    int v5; // [esp+14h] [ebp-50h]
    int i; // [esp+18h] [ebp-4Ch]
    int j; // [esp+18h] [ebp-4Ch]
    int v8; // [esp+1Ch] [ebp-48h]
    int v9[3]; // [esp+20h] [ebp-44h]
    int v10[14]; // [esp+2Ch] [ebp-38h] BYREF

    sub_477F0C(0);
    v5 = 0;
    v4 = 0;
    for (i = 0; i < 3; ++i)
        v9[i] = 0;
    if (!*(_BYTE*)(thisx + 2516))
    {
        if (sub_476CDA(0))
        {
            v4 = 1;
        }
        else if (sub_476C8B(0))
        {
            v4 = -1;
        }
        if (sub_476D29(0))
        {
            v5 = -1;
        }
        else if (sub_476D78(0))
        {
            v5 = 1;
        }
        for (j = 0; j < 3; ++j)
            v9[j] = sub_476DC7(0, j);
    }
    v8 = 0;
    if (v5 || v4)
    {
        v8 = 1;
        if (v5)
        {
            if (*(_DWORD*)(thisx + 2528))
            {
                switch (*(_DWORD*)(thisx + 2528))
                {
                case 1:
                    *(_BYTE*)(thisx + 2496) -= v5;
                    if (*(unsigned __int8*)(thisx + 2496) < 0xBu)
                    {
                        if (*(_BYTE*)(thisx + 2496) == 1)
                        {
                            *(_BYTE*)(thisx + 2496) = 2;
                        }
                        else if (*(_BYTE*)(thisx + 2496))
                        {
                            if (*(_BYTE*)(thisx + 2496) == 2 && v5 < 0)
                                *(_BYTE*)(thisx + 2496) = 1;
                        }
                        else
                        {
                            *(_BYTE*)(thisx + 2496) = 10;
                        }
                    }
                    else
                    {
                        *(_BYTE*)(thisx + 2496) = 1;
                    }
                    break;
                case 2:
                    *(_BYTE*)(thisx + 77) = *(_BYTE*)(thisx + 77) == 0;
                    break;
                case 3:
                    *(_BYTE*)(thisx + 81) = *(_BYTE*)(thisx + 81) == 0;
                    break;
                case 4:
                    dword_4B99F0 = dword_4B99F0 == 0;
                    break;
                case 5:
                    *(_BYTE*)(thisx + 30) = (*(unsigned __int8*)(thisx + 30) + v5 + 9) % 9;
                    break;
                case 6:
                    *(_BYTE*)(thisx + 78) = *(_BYTE*)(thisx + 78) == 0;
                    break;
                case 7:
                    *(_BYTE*)(thisx + 98) = *(_BYTE*)(thisx + 98) == 0;
                    break;
                }
            }
            else
            {
                dword_4B99F4 = dword_4B99F4 == 0;
            }
        }
        if (v4)
        {
            *(_DWORD*)(thisx + 2528) += v4;
            v3 = *(_DWORD*)(thisx + 2528) - *(unsigned __int16*)(thisx + 2564);
            if (v3 < 0 || v3 >= 7)
                *(_WORD*)(thisx + 2564) += v4;
            if (*(int*)(thisx + 2528) >= 0)
            {
                if (*(int*)(thisx + 2528) >= 10)
                {
                    *(_DWORD*)(thisx + 2528) = 0;
                    *(_WORD*)(thisx + 2564) = 0;
                }
            }
            else
            {
                *(_DWORD*)(thisx + 2528) = 9;
                *(_WORD*)(thisx + 2564) = 3;
            }
            sub_4557D1(thisx,-2);
        }
        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
    }
    if (v9[0])
    {
        if (*(_DWORD*)(thisx + 2528) == 8)
        {
            *(_DWORD*)(thisx + 108) = 6;
            *(_BYTE*)(thisx + 2516) = 2;
            *(_DWORD*)(thisx + 2512) = 0;
        }
        else if (*(_DWORD*)(thisx + 2528) == 9)
        {
            *(_DWORD*)(thisx + 108) = 7;
            *(_BYTE*)(thisx + 2516) = 2;
            *(_DWORD*)(thisx + 2512) = 0;
        }
        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
    }
    if (v9[0] && *(int*)(thisx + 2528) < 8 || v9[1])
    {
        *(_DWORD*)(thisx + 108) = 3;
        *(_BYTE*)(thisx + 2516) = 2;
        *(_DWORD*)(thisx + 2512) = 0;
    }
    if (v8)
        sub_4557D1(thisx, 0);
    sub_49C15E((int)v10);
    v10[1] = 0;
    v10[2] = 0;
    v10[0] = dword_4B9248;
    sub_49AB05((int)unk_4BDC60, v10);
    if (dword_4B93B0 / 5u % 2)
    {
        if (*(_WORD*)(thisx + 2564))
            sub_47B91A(160, 44, byte_4B0CA0, 0, -1);
        if (*(unsigned __int16*)(thisx + 2564) < 3u)
            sub_47B91A(160, 168, byte_4B0CA4, 0, -1);
    }
    return sub_47B91A(92, 16 * (*(_DWORD*)(thisx + 2528) - *(unsigned __int16*)(thisx + 2564)) + 60, asc_4B0CA8, 0, -1);
}

 
UINT sub_44ED4D(UINT thisx)
{
    int v1; // esi
    UINT result; // eax
    UINT NumDevs; // eax
    int v4; // esi
    int v5; // edx
    UINT v6; // ecx
    int v7; // ecx
    char v8; // al
    int v9; // eax
    int v10; // eax
    unsigned __int8 v11; // al
    int v12; // [esp-10h] [ebp-2D8h]
    int v13; // [esp-10h] [ebp-2D8h]
    SHORT AsyncKeyState; // [esp+Ch] [ebp-2BCh]
    int v16; // [esp+10h] [ebp-2B8h]
    int vKey; // [esp+14h] [ebp-2B4h]
    int v18; // [esp+18h] [ebp-2B0h]
    char ii; // [esp+1Ch] [ebp-2ACh]
    char n; // [esp+20h] [ebp-2A8h]
    int k; // [esp+24h] [ebp-2A4h]
    CHAR v22[256]; // [esp+28h] [ebp-2A0h] BYREF
    UINT v23; // [esp+128h] [ebp-1A0h]
    char v24; // [esp+12Ch] [ebp-19Ch]
    int m; // [esp+130h] [ebp-198h]
    int v26; // [esp+134h] [ebp-194h]
    char v27; // [esp+138h] [ebp-190h]
    int v28; // [esp+13Ch] [ebp-18Ch]
    int v29; // [esp+140h] [ebp-188h]
    int j; // [esp+144h] [ebp-184h]
    struct joyinfo_tag v31; // [esp+148h] [ebp-180h] BYREF
    UINT uJoyID; // [esp+158h] [ebp-170h]
    struct joyinfo_tag pji; // [esp+15Ch] [ebp-16Ch] BYREF
    char v34; // [esp+16Ch] [ebp-15Ch]
    int v35; // [esp+170h] [ebp-158h]
    UINT v36; // [esp+174h] [ebp-154h]
    int v37; // [esp+178h] [ebp-150h]
    int v38; // [esp+17Ch] [ebp-14Ch]
    int v39; // [esp+180h] [ebp-148h]
    int v40; // [esp+184h] [ebp-144h]
    int v41; // [esp+188h] [ebp-140h]
    int i; // [esp+18Ch] [ebp-13Ch]
    CHAR String[256]; // [esp+190h] [ebp-138h] BYREF
    int v44[14]; // [esp+290h] [ebp-38h] BYREF

    for (i = 0; i < 8; ++i)
        sub_477F0C(i);
    LOBYTE(v38) = *(_BYTE*)(thisx + 2562);
    if (!*(_BYTE*)(thisx + 2516))
    {
        if (*(_BYTE*)(thisx + 2562))
        {
            if (*(_BYTE*)(thisx + 2562) == 1)
            {
                NumDevs = joyGetNumDevs();
                v36 = NumDevs;
                LOBYTE(NumDevs) = *(_BYTE*)(thisx + 2528);
                v4 = sub_476D78(NumDevs);
                LOBYTE(v5) = *(_BYTE*)(thisx + 2528);
                v35 = v4 - sub_476D29(v5);
                v34 = *(_BYTE*)(thisx + 2536);
                if (v34 < 0 && v35)
                {
                    if (!joyGetPos(0, &pji))
                    {
                        v6 = thisx;
                        *(_DWORD*)(thisx + 2536) = 0;
                    }
                }
                else if (v34 >= 0 && v35)
                {
                    uJoyID = v35 + v34;
                    if ((uJoyID & 0x80000000) != 0 || joyGetPos(uJoyID, &v31))
                    {
                        v6 = thisx;
                        *(_DWORD*)(thisx + 2536) = -*(_DWORD*)(thisx + 2528) - 1;
                    }
                    else
                    {
                        v6 = uJoyID;
                        *(_DWORD*)(thisx + 2536) = uJoyID;
                    }
                }
                if (v35)
                {
                    sub_43FFC3((int*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
                }
                else
                {
                    LOBYTE(v6) = *(_BYTE*)(thisx + 2528);
                    if (sub_476DC7(v6, 0))
                    {
                        //sub_47652C(player_list[27 * *(_DWORD*)(thisx + 2528)], *(_DWORD*)(thisx + 2536));
                        sub_47652C((int*)&player_list[27 * *(_DWORD*)(thisx + 2528)], *(_DWORD*)(thisx + 2536));
                        *(_BYTE*)(thisx + 2562) = 2;
                        *(_BYTE*)(thisx + *(_DWORD*)(thisx + 2528) + 2588) = 2;
                        *(_WORD*)(thisx + 2 * *(_DWORD*)(thisx + 2528) + 2564) = 0;
                        sub_43FFC3((int*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
                        for (j = 0; j < 256; ++j)
                            byte_4B9874[j] = 2;
                    }
                    else
                    {
                        LOBYTE(v7) = *(_BYTE*)(thisx + 2528);
                        if (sub_476DC7(v7, 1))
                            *(_BYTE*)(thisx + 2562) = 0;
                    }
                }
            }
        }
        else
        {
            v1 = sub_476D78(0);
            v37 = v1 - sub_476D29(0);
            *(_DWORD*)(thisx + 2528) += v37;
            if (*(int*)(thisx + 2528) >= 0)
            {
                if (*(int*)(thisx + 2528) > 7)
                    *(_DWORD*)(thisx + 2528) = 7;
            }
            else
            {
                *(_DWORD*)(thisx + 2528) = 0;
            }
            if (*(_DWORD*)(thisx + 2528) - *(_DWORD*)(thisx + 2532) < 4)
            {
                if (*(_DWORD*)(thisx + 2528) < *(_DWORD*)(thisx + 2532))
                    *(_DWORD*)(thisx + 2532) += v37;
            }
            else
            {
                *(_DWORD*)(thisx + 2532) += v37;
            }
            if (v37)
                sub_43FFC3((int*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
            if (sub_476DC7(0, 0))
            {
                *(_BYTE*)(thisx + 2562) = 1;
                *(_DWORD*)(thisx + 2536) = (char)sub_4768D5((int*)&player_list[27 * *(_DWORD*)(thisx + 2528)]);
                if (*(_DWORD*)(thisx + 2536))
                {
                    if (*(int*)(thisx + 2536) >= 1)
                        --* (_DWORD*)(thisx + 2536);
                }
                else
                {
                    *(_DWORD*)(thisx + 2536) = -1;
                }
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
            }
            else if (sub_476DC7(0, 1))
            {
                result = thisx;
                *(_DWORD*)(thisx + 108) = 5;
                *(_BYTE*)(thisx + 2516) = 2;
                *(_DWORD*)(thisx + 2512) = 0;
                return result;
            }
        }
    }
    sub_49C15E((int)v44);
    v44[1] = 0;
    v44[2] = 0;
    v44[0] = dword_4B9248;
    sub_49AB05((int)unk_4BDC60, v44);
    v41 = 16;
    v39 = 16;
    if (*(int*)(thisx + 2532) > 0)
        sub_47B91A(v41 + 48, v39, asc_4B0CAC, 0, -1);
    if (*(int*)(thisx + 2532) < 4)
        sub_47B91A(298, v39, asc_4B0CB0, 0, -1);
    v40 = -1;
    for (i = *(_DWORD*)(thisx + 2532); i < *(_DWORD*)(thisx + 2532) + 4; ++i)
    {
        ++v40;
        v29 = v41 + 52 * v40 + 82;
        wsprintfA(String, "%dP", i + 1);
        sub_47B7ED(v29 - 8, v39, String, 0, -1);
        if (!*(_BYTE*)(thisx + 2562) && *(_DWORD*)(thisx + 2528) == i)
            sub_47B91A(v29 - 20, v39, asc_4B0CB8, 0, -1);
        v27 = sub_4768D5((int*)&player_list[27 * i]);
        if (*(_BYTE*)(thisx + 2562) == 1 && *(_DWORD*)(thisx + 2528) == i)
        {
            if (*(int*)(thisx + 2536) >= 0)
                v27 = *(_BYTE*)(thisx + 2536) + 1;
            else
                v27 = 0;
        }
        if (v27)
        {
            if (v27 >= 1)
                wsprintfA(String, "JS%d", v27);
        }
        else
        {
            wsprintfA(String, aKb);
        }
        v28 = lstrlenA(String);
        sub_47B7ED(v29 - 4 * v28, v39 + 16, String, 0, -1);
        if (*(_BYTE*)(thisx + 2562) == 1 && *(_DWORD*)(thisx + 2528) == i)
            sub_47B91A(v29 - 22, v39 + 16, asc_4B0CC8, 0, -1);
        if (v27 >= 0)
        {
            v26 = v39 + 86;
            if (v27 < 1)
            {
                if (!v27)
                {
                    v26 = v39 + 36;
                    for (k = 0; k < 11; ++k)
                    {
                        v11 = sub_4768F5((int*)&player_list[27 * i], k);
                        v23 = MapVirtualKeyA(v11, 0);
                        GetKeyNameTextA(v23 << 16, v22, 16);
                        v28 = lstrlenA(v22);
                        if (k == 4)
                        {
                            v26 = v39 + 86;
                        }
                        else if (k == 9)
                        {
                            v26 = v39 + 146;
                        }
                        sub_47B7ED(v29 - 4 * v28, v26, v22, 0, -1);
                        if (*(_BYTE*)(thisx + 2562) == 2
                            && *(_DWORD*)(thisx + 2528) == i
                            && *(unsigned __int16*)(thisx + 2 * i + 2564) == k)
                        {
                            sub_47B91A(v29 - 30, v26, asc_4B0CE4, 0, -1);
                        }
                        v26 += 10;
                    }
                }
            }
            else
            {
                v26 = v39 + 36;
                for (m = 0; m < 11; ++m)
                {
                    if (m == 4)
                    {
                        v26 = v39 + 86;
                    }
                    else if (m == 9)
                    {
                        v26 = v39 + 146;
                    }
                    v24 = sub_4768BD((int*)&player_list[27 * i], m);
                    if (v24 < 0)
                    {
                        switch (v24)
                        {
                        case -4:
                            wsprintfA(String, aRi);
                            break;
                        case -3:
                            wsprintfA(String, aLe);
                            break;
                        case -2:
                            wsprintfA(String, aDo);
                            break;
                        case -1:
                            wsprintfA(String, aUp);
                            break;
                        default:
                            break;
                        }
                        v13 = v26;
                        v10 = lstrlenA(String);
                        sub_47B91A(v29 - 2 * v10, v13, String, 0, -1);
                    }
                    else
                    {
                        v8 = sub_4768BD((int*)&player_list[27 * i], m);
                        wsprintfA(String, "%d", v8 + 1);
                        v12 = v26;
                        v9 = lstrlenA(String);
                        sub_47B7ED(v29 - 4 * v9, v12, String, 0, -1);
                    }
                    if (*(_BYTE*)(thisx + 2562) == 2
                        && *(_DWORD*)(thisx + 2528) == i
                        && *(unsigned __int16*)(thisx + 2 * i + 2564) == m)
                    {
                        sub_47B91A(v29 - 20, v26, asc_4B0CE0, 0, -1);
                    }
                    v26 += 10;
                }
            }
            if (*(_BYTE*)(thisx + 2562) == 2 && *(_DWORD*)(thisx + 2528) == i)
            {
                if (v27 <= 0)
                {
                    if (!v27)
                    {
                        v16 = 0;
                        for (vKey = 0; vKey < 256; ++vKey)
                        {
                            AsyncKeyState = GetAsyncKeyState(vKey);
                            if (AsyncKeyState >= 0 || (AsyncKeyState & 1) != 0 || byte_4B9874[vKey])
                            {
                                if (!AsyncKeyState && byte_4B9874[vKey] == 1)
                                {
                                    byte_4B9874[vKey] = 0;
                                    v16 = vKey;
                                    break;
                                }
                                if (!AsyncKeyState && (unsigned __int8)byte_4B9874[vKey] > 1u)
                                    byte_4B9874[vKey] = 0;
                            }
                            else
                            {
                                byte_4B9874[vKey] = 1;
                            }
                        }
                        if (v16 <= 0)
                            *(_BYTE*)(i + thisx + 2588) = 0;
                        else
                            ++* (_BYTE*)(i + thisx + 2588);
                        if (*(_BYTE*)(i + thisx + 2588) == 1)
                        {
                            *(_BYTE*)(thisx + 11 * i + 11264 + *(unsigned __int16*)(thisx + 2 * i + 2564)) = v16;
                            sub_47690D((int*)&player_list[27 * i], *(_BYTE*)(thisx + 2 * i + 2564), v16);
                            ++* (_WORD*)(thisx + 2 * i + 2564);
                            sub_43FFC3((int*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
                        }
                    }
                }
                else
                {
                    for (n = -4;
                        n < 16
                        && (n >= 0 || !sub_476A8E((int*)&player_list[27 * i], n))
                        && (n < 0 || !sub_47646A((int*)&player_list[27 * i], n));
                        ++n)
                    {
                        ;
                    }
                    if (n < 16 || *(_BYTE*)(i + thisx + 2588) == 2)
                        ++* (_BYTE*)(i + thisx + 2588);
                    else
                        *(_BYTE*)(i + thisx + 2588) = 0;
                    if (*(_BYTE*)(i + thisx + 2588) == 1 && *(unsigned __int16*)(thisx + 2 * i + 2564) < 0xBu)
                    {
                        for (ii = -4; ii < 16; ++ii)
                        {
                            if (ii >= 0)
                                v18 = sub_47646A((int*)&player_list[27 * i], ii);
                            else
                                v18 = sub_476A8E((int*)&player_list[27 * i], ii);
                            if (v18)
                            {
                                sub_4768A2((int*)&player_list[27 * i], *(_BYTE*)(thisx + 2 * i + 2564), ii);
                                *(_BYTE*)(thisx + 11 * i + 11176 + (unsigned __int16)(*(_WORD*)(thisx + 2 * i + 2564))++) = ii;
                                sub_43FFC3((int*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
                                break;
                            }
                        }
                    }
                }
            }
        }
    }
    if (*(_BYTE*)(thisx + 2562) == 2 && *(unsigned __int16*)(thisx + 2 * *(_DWORD*)(thisx + 2528) + 2564) >= 0xBu)
        *(_BYTE*)(thisx + 2562) = 0;
    result = *(unsigned __int8*)(thisx + 2562);
    if ((unsigned __int8)v38 != result)
        return (UINT)sub_455268((_BYTE*)thisx, -2);
    return result;
}

 
_BYTE* sub_44FE2E(int thisx)
{
	*(_DWORD*)(thisx + 104) = 7;
	*(_BYTE*)(thisx + 2516) = 1;
	*(_DWORD*)(thisx + 2512) = 0;
	*(_BYTE*)(thisx + 2562) = 0;
	*(_DWORD*)(thisx + 2528) = 0;
	*(_DWORD*)(thisx + 2532) = 0;
	return sub_455268((_BYTE*)thisx, -1);
}

 
int sub_44FE88(int thisx, LPCSTR lpFileName)
{
    char v2; // al
    int result; // eax
    int j; // [esp+4h] [ebp-44Ch]
    int k; // [esp+4h] [ebp-44Ch]
    int v7; // [esp+8h] [ebp-448h]
    int v8; // [esp+8h] [ebp-448h]
    int v9; // [esp+8h] [ebp-448h]
    int v10; // [esp+8h] [ebp-448h]
    int v11; // [esp+8h] [ebp-448h]
    int v12; // [esp+8h] [ebp-448h]
    int v13; // [esp+8h] [ebp-448h]
    int v14; // [esp+8h] [ebp-448h]
    int v15; // [esp+8h] [ebp-448h]
    int v16; // [esp+8h] [ebp-448h]
    int v17; // [esp+8h] [ebp-448h]
    int v18; // [esp+8h] [ebp-448h]
    int v19; // [esp+8h] [ebp-448h]
    int v20; // [esp+8h] [ebp-448h]
    int v21; // [esp+8h] [ebp-448h]
    int v22; // [esp+8h] [ebp-448h]
    int v23; // [esp+8h] [ebp-448h]
    int v24; // [esp+8h] [ebp-448h]
    int v25; // [esp+8h] [ebp-448h]
    int v26; // [esp+8h] [ebp-448h]
    int v27; // [esp+8h] [ebp-448h]
    int v28; // [esp+8h] [ebp-448h]
    int v29; // [esp+8h] [ebp-448h]
    int v30; // [esp+8h] [ebp-448h]
    int v31; // [esp+8h] [ebp-448h]
    int v32; // [esp+8h] [ebp-448h]
    int v33; // [esp+8h] [ebp-448h]
    int v34; // [esp+8h] [ebp-448h]
    int v35; // [esp+8h] [ebp-448h]
    int v36; // [esp+8h] [ebp-448h]
    int v37; // [esp+8h] [ebp-448h]
    int v38; // [esp+8h] [ebp-448h]
    int v39; // [esp+8h] [ebp-448h]
    int v40; // [esp+8h] [ebp-448h]
    int v41; // [esp+8h] [ebp-448h]
    int v42; // [esp+8h] [ebp-448h]
    int v43; // [esp+8h] [ebp-448h]
    CHAR String[1024]; // [esp+Ch] [ebp-444h] BYREF
    int i; // [esp+40Ch] [ebp-44h]
    CHAR AppName[64]; // [esp+410h] [ebp-40h] BYREF

    memset(AppName, 0, sizeof(AppName));
    memset(String, 0, sizeof(String));
    wsprintfA(String, "ShowFPS = %d", dword_4B99F4);
    v7 = lstrlenA(String) + 1;
    wsprintfA(&String[v7], "PutDamage = %d", dword_4B99F0);
    v8 = v7 + lstrlenA(&String[v7]) + 1;
    wsprintfA(&String[v8], "GameSpeed = %d", *(unsigned __int8*)(thisx + 2496));
    v9 = v8 + lstrlenA(&String[v8]) + 1;
    wsprintfA(&String[v9], "HitStop = %d", *(unsigned __int8*)(thisx + 77));
    v10 = v9 + lstrlenA(&String[v9]) + 1;
    wsprintfA(&String[v10], "SameChar = %d", *(unsigned __int8*)(thisx + 81));
    v11 = v10 + lstrlenA(&String[v10]) + 1;
    wsprintfA(&String[v11], "UseItem = %d", *(unsigned __int8*)(thisx + 79));
    v12 = v11 + lstrlenA(&String[v11]) + 1;
    wsprintfA(&String[v12], "HitSameTeam = %d", *(unsigned __int8*)(thisx + 80));
    v13 = v12 + lstrlenA(&String[v12]) + 1;
    wsprintfA(&String[v13], "UseWeaponNum = %d", *(unsigned __int8*)(thisx + 30));
    v14 = v13 + lstrlenA(&String[v13]) + 1;
    wsprintfA(&String[v14], "UseCombineMove = %d", *(unsigned __int8*)(thisx + 76));
    v15 = v14 + lstrlenA(&String[v14]) + 1;
    wsprintfA(&String[v15], "AttackButtonGuard = %d", *(unsigned __int8*)(thisx + 78));
    v16 = v15 + lstrlenA(&String[v15]) + 1;
    wsprintfA(&String[v16], "GroundDamage = %d", *(unsigned __int8*)(thisx + 99));
    v17 = v16 + lstrlenA(&String[v16]) + 1;
    wsprintfA(&String[v17], "BlackHoleType = %d", *(unsigned __int8*)(thisx + 100));
    v18 = v17 + lstrlenA(&String[v17]) + 1;
    wsprintfA(&String[v18], "RandomSelectFightType = %d", *(unsigned __int8*)(thisx + 98));
    v19 = v18 + lstrlenA(&String[v18]) + 1;
    wsprintfA(&String[v19], "SurvivalRecordVeryEasy = %d", *(_DWORD*)(thisx + 11380));
    v20 = v19 + lstrlenA(&String[v19]) + 1;
    wsprintfA(&String[v20], "SurvivalRecordEasy = %d", *(_DWORD*)(thisx + 11384));
    v21 = v20 + lstrlenA(&String[v20]) + 1;
    wsprintfA(&String[v21], "SurvivalRecordNormal = %d", *(_DWORD*)(thisx + 11388));
    v22 = v21 + lstrlenA(&String[v21]) + 1;
    wsprintfA(&String[v22], "SurvivalRecordHard = %d", *(_DWORD*)(thisx + 11392));
    v23 = v22 + lstrlenA(&String[v22]) + 1;
    wsprintfA(&String[v23], "SurvivalRecordVeryHard = %d", *(_DWORD*)(thisx + 11396));
    lstrlenA(&String[v23]);
    WritePrivateProfileSectionA(::AppName, String, lpFileName);
    memset(String, 0, sizeof(String));
    wsprintfA(String, "GameNum = %d", *(unsigned __int8*)(thisx + 2477));
    v24 = lstrlenA(String) + 1;
    wsprintfA(&String[v24], "IsTag = %d", *(_DWORD*)(thisx + 2368));
    v25 = v24 + lstrlenA(&String[v24]) + 1;
    wsprintfA(&String[v25], "PlayerNum = %d", *(unsigned __int8*)(thisx + 2382));
    v26 = v25 + lstrlenA(&String[v25]) + 1;
    wsprintfA(&String[v26], "IsUseItem = %d", *(unsigned __int8*)(thisx + 2451));
    v27 = v26 + lstrlenA(&String[v26]) + 1;
    wsprintfA(&String[v27], "WeaponNum = %d", *(unsigned __int8*)(thisx + 2402));
    v28 = v27 + lstrlenA(&String[v27]) + 1;
    wsprintfA(&String[v28], "ShowPoint = %d", *(_DWORD*)(thisx + 2372));
    v29 = v28 + lstrlenA(&String[v28]) + 1;
    wsprintfA(&String[v29], "GroundDamage = %d", *(unsigned __int8*)(thisx + 2471));
    v30 = v29 + lstrlenA(&String[v29]) + 1;
    wsprintfA(&String[v30], "BlackHoleType = %d", *(unsigned __int8*)(thisx + 2472));
    v31 = v30 + lstrlenA(&String[v30]) + 1;
    wsprintfA(&String[v31], "UseCombineMove = %d", *(unsigned __int8*)(thisx + 2448));
    v32 = v31 + lstrlenA(&String[v31]) + 1;
    wsprintfA(&String[v32], "HitSameTeam = %d", *(unsigned __int8*)(thisx + 2452));
    lstrlenA(&String[v32]);
    WritePrivateProfileSectionA(aKkconfig, String, lpFileName);
    memset(String, 0, sizeof(String));
    wsprintfA(String, "FullScreen = %d", (unsigned __int8)byte_4B99E9);
    v33 = lstrlenA(String) + 1;
    wsprintfA(&String[v33], "BackGroundRun = %d", (unsigned __int8)byte_4B99E6);
    v34 = v33 + lstrlenA(&String[v33]) + 1;
    wsprintfA(&String[v34], "VsyncWait = %d", (unsigned __int8)byte_4B99E8);
    v35 = v34 + lstrlenA(&String[v34]) + 1;
    wsprintfA(&String[v35], "Zoom = %d", (unsigned __int8)byte_4B99E7);
    String[v35 + 1 + lstrlenA(&String[v35])] = 0;
    if (!WritePrivateProfileSectionA(aDirectdrawconf, String, lpFileName))
        MessageBoxA(0, aDirectdrawconf_4, aError_7, 0);
    memset(String, 0, sizeof(String));
    v36 = 0;
    wsprintfA(AppName, aInitdevice);
    for (i = 0; i < 8; ++i)
    {
        v2 = sub_4768D5((_DWORD*)(char*)&player_list + 27 * i);
        wsprintfA(&String[v36], "%dP = %d", i + 1, v2 - 1);
        v36 += lstrlenA(&String[v36]) + 1;
        String[v36] = 0;
    }
    if (!WritePrivateProfileSectionA(AppName, String, lpFileName))
        MessageBoxA(0, byte_4B0FC0, aError_8, 0);
    v37 = 0;
    wsprintfA(AppName, aWeaponrate);
    for (i = 0; i < 14; ++i)
    {
        wsprintfA(&String[v37], "%02d = %d", i, *(unsigned __int16*)(thisx + 2 * i + 48));
        v37 += lstrlenA(&String[v37]) + 1;
        String[v37] = 0;
    }
    result = WritePrivateProfileSectionA(AppName, String, lpFileName);
    if (!result)
        result = MessageBoxA(0, byte_4B0FFC, aError_9, 0);
    for (i = 0; i < 8; ++i)
    {
        wsprintfA(AppName, "JoyStickAssign%dP", i + 1);
        wsprintfA(String, "Up = %d", *(char*)(thisx + 11 * i + 11176));
        v38 = lstrlenA(String) + 1;
        wsprintfA(&String[v38], "Down = %d", *(char*)(thisx + 11 * i + 11177));
        v39 = v38 + lstrlenA(&String[v38]) + 1;
        wsprintfA(&String[v39], "Left = %d", *(char*)(thisx + 11 * i + 11178));
        v40 = v39 + lstrlenA(&String[v39]) + 1;
        wsprintfA(&String[v40], "Right = %d", *(char*)(thisx + 11 * i + 11179));
        v41 = v40 + lstrlenA(&String[v40]) + 1;
        for (j = 4; j < 9; ++j)
        {
            wsprintfA(&String[v41], "Trigger%d = %d", j - 3, *(char*)(thisx + 11 * i + j + 11176));
            v41 += lstrlenA(&String[v41]) + 1;
        }
        wsprintfA(&String[v41], "Select = %d", *(char*)(thisx + 11 * i + 11185));
        v42 = v41 + lstrlenA(&String[v41]) + 1;
        wsprintfA(&String[v42], "Start = %d", *(char*)(thisx + 11 * i + 11186));
        String[v42 + 1 + lstrlenA(&String[v42])] = 0;
        if (!WritePrivateProfileSectionA(AppName, String, lpFileName))
            MessageBoxA(0, byte_4B1088, aError_10, 0);
        wsprintfA(AppName, "KeyBoardAssign%dP", i + 1);
        v43 = 0;
        memset(String, 0, sizeof(String));
        for (k = 0; k < 11; ++k)
        {
            if (k)
            {
                switch (k)
                {
                case 1:
                    wsprintfA(&String[v43], "Down = %3d", *(unsigned __int8*)(thisx + 11 * i + 1 + 11264));
                    break;
                case 2:
                    wsprintfA(&String[v43], "Left = %3d", *(unsigned __int8*)(thisx + 11 * i + 2 + 11264));
                    break;
                case 3:
                    wsprintfA(&String[v43], "Right = %3d", *(unsigned __int8*)(thisx + 11 * i + 3 + 11264));
                    break;
                case 9:
                    wsprintfA(&String[v43], "Select = %3d", *(unsigned __int8*)(thisx + 11 * i + 9 + 11264));
                    break;
                case 10:
                    wsprintfA(&String[v43], "Start = %3d", *(unsigned __int8*)(thisx + 11 * i + 10 + 11264));
                    break;
                default:
                    wsprintfA(&String[v43], "Trigger%d = %3d", k - 3, *(unsigned __int8*)(thisx + 11 * i + k + 11264));
                    break;
                }
            }
            else
            {
                wsprintfA(&String[v43], "Up = %3d", *(unsigned __int8*)(thisx + 11 * i + 11264));
            }
            v43 += lstrlenA(&String[v43]) + 1;
        }
        String[v43] = 0;
        result = WritePrivateProfileSectionA(AppName, String, lpFileName);
    }
    return result;
}

 
UINT ¶ÁÈ¡ÅäÖÃÎÄ¼þ(int thisx, LPCSTR lpFileName)
{
    UINT result; // eax
    __int16 PrivateProfileIntA; // ax
    char v4; // al
    char v5; // al
    int k; // [esp+4h] [ebp-94h]
    int m; // [esp+4h] [ebp-94h]
    int v9; // [esp+8h] [ebp-90h]
    int i; // [esp+Ch] [ebp-8Ch]
    int j; // [esp+Ch] [ebp-8Ch]
    signed int v12; // [esp+10h] [ebp-88h]
    CHAR KeyName[64]; // [esp+14h] [ebp-84h] BYREF
    INT nDefault; // [esp+54h] [ebp-44h]
    CHAR AppName[64]; // [esp+58h] [ebp-40h] BYREF

    //¶ÁÈ¡ÅäÖÃÎÄ¼þ
    dword_4B99F4 = GetPrivateProfileIntA(aConfig_0, ::KeyName, 0, lpFileName);
    dword_4B99F0 = GetPrivateProfileIntA(aConfig_1, aPutdamage, 1, lpFileName);
    *(_BYTE*)(thisx + 2496) = GetPrivateProfileIntA(aConfig_2, aGamespeed, 1, lpFileName);
    if (!*(_BYTE*)(thisx + 2496))
        *(_BYTE*)(thisx + 2496) = 1;
    *(_BYTE*)(thisx + 77) = GetPrivateProfileIntA(aConfig_3, aHitstop, 1, lpFileName);
    *(_BYTE*)(thisx + 81) = GetPrivateProfileIntA(aConfig_4, aSamechar, 0, lpFileName);
    *(_BYTE*)(thisx + 79) = GetPrivateProfileIntA(aConfig_5, aUseitem, 1, lpFileName);
    *(_BYTE*)(thisx + 80) = GetPrivateProfileIntA(aConfig_6, aHitsameteam, 0, lpFileName);
    *(_BYTE*)(thisx + 30) = GetPrivateProfileIntA(aConfig_7, aUseweaponnum, 4, lpFileName);
    *(_BYTE*)(thisx + 78) = GetPrivateProfileIntA(aConfig_8, aAttackbuttongu_0, 1, lpFileName);
    *(_BYTE*)(thisx + 76) = GetPrivateProfileIntA(aConfig_9, aUsecombinemove_1, 1, lpFileName);
    *(_BYTE*)(thisx + 99) = GetPrivateProfileIntA(aConfig_10, aGrounddamage, 1, lpFileName);
    *(_BYTE*)(thisx + 100) = GetPrivateProfileIntA(aConfig_11, aBlackholetype, 1, lpFileName);
    *(_BYTE*)(thisx + 98) = GetPrivateProfileIntA(aConfig_12, aRandomselectfi_0, 0, lpFileName);
    *(_DWORD*)(thisx + 11380) = GetPrivateProfileIntA(aConfig_13, aSurvivalrecord_4, 0, lpFileName);
    *(_DWORD*)(thisx + 11384) = GetPrivateProfileIntA(aConfig_14, aSurvivalrecord_5, 0, lpFileName);
    *(_DWORD*)(thisx + 11388) = GetPrivateProfileIntA(aConfig_15, aSurvivalrecord_6, 0, lpFileName);
    *(_DWORD*)(thisx + 11392) = GetPrivateProfileIntA(aConfig_16, aSurvivalrecord_7, 0, lpFileName);
    *(_DWORD*)(thisx + 11396) = GetPrivateProfileIntA(aConfig_17, aSurvivalrecord_8, 0, lpFileName);
    *(_BYTE*)(thisx + 2477) = GetPrivateProfileIntA(aKkconfig_0, aGamenum, 3, lpFileName) % 0xA;
    if (!*(_BYTE*)(thisx + 2477))
        *(_BYTE*)(thisx + 2477) = 3;
    *(_DWORD*)(thisx + 2368) = GetPrivateProfileIntA(aKkconfig_1, aIstag, 0, lpFileName);
    *(_BYTE*)(thisx + 2382) = GetPrivateProfileIntA(aKkconfig_2, aPlayernum, 1, lpFileName);
    *(_BYTE*)(thisx + 2451) = GetPrivateProfileIntA(aKkconfig_3, aIsuseitem, 1, lpFileName);
    *(_BYTE*)(thisx + 2402) = (unsigned __int8)GetPrivateProfileIntA(aKkconfig_4, aWeaponnum, 4, lpFileName) % 9;
    *(_DWORD*)(thisx + 2372) = GetPrivateProfileIntA(aKkconfig_5, aShowpoint, 0, lpFileName);
    *(_BYTE*)(thisx + 2471) = GetPrivateProfileIntA(aKkconfig_6, aGrounddamage_0, 1, lpFileName);
    *(_BYTE*)(thisx + 2472) = (unsigned __int8)GetPrivateProfileIntA(aKkconfig_7, aBlackholetype_0, 0, lpFileName) % 3;
    *(_BYTE*)(thisx + 2448) = GetPrivateProfileIntA(aKkconfig_8, aUsecombinemove_2, 1, lpFileName);
    *(_BYTE*)(thisx + 2452) = GetPrivateProfileIntA(aKkconfig_9, aHitsameteam_0, 0, lpFileName);
    byte_4B99E9 = GetPrivateProfileIntA(aDirectdrawconf_0, aFullscreen, 0, lpFileName);//ÕâÀï¶ÁÈ¡ÅäÖÃÊÇ·ñÈ«ÆÁ
    byte_4B99E6 = GetPrivateProfileIntA(aDirectdrawconf_1, aBackgroundrun, 0, lpFileName);
    byte_4B99E8 = GetPrivateProfileIntA(aDirectdrawconf_2, aVsyncwait, 0, lpFileName);
    result = GetPrivateProfileIntA(aDirectdrawconf_3, aZoom, 1, lpFileName);
    byte_4B99E7 = result;
    for (nDefault = 0; nDefault < 14; ++nDefault)
    {
        wsprintfA(AppName, aWeaponrate_0);
        wsprintfA(KeyName, "%02d", nDefault);
        PrivateProfileIntA = GetPrivateProfileIntA(AppName, KeyName, 10, lpFileName);
        *(_WORD*)(thisx + 2 * nDefault + 48) = PrivateProfileIntA;
        result = nDefault + 1;
    }
    for (nDefault = 0; nDefault < 8; ++nDefault)
    {
        wsprintfA(AppName, aInitdevice_0);
        wsprintfA(KeyName, "%dP", nDefault + 1);
        v12 = GetPrivateProfileIntA(AppName, KeyName, nDefault, lpFileName);
        sub_47652C((_DWORD*)&player_list[27 * nDefault], v12);
        wsprintfA(AppName, "JoyStickAssign%dP", nDefault + 1);
        for (i = 0; i < 11; ++i)
        {
            v9 = i - 3;
            if (i < 4)
                v9 = -(i + 1);
            if (i)
            {
                switch (i)
                {
                case 1:
                    wsprintfA(KeyName, aDown);
                    break;
                case 2:
                    wsprintfA(KeyName, aLeft);
                    break;
                case 3:
                    wsprintfA(KeyName, aRight);
                    break;
                case 9:
                    wsprintfA(KeyName, aSelect);
                    break;
                case 10:
                    wsprintfA(KeyName, aStart);
                    break;
                default:
                    wsprintfA(KeyName, "Trigger%d", i - 3);
                    break;
                }
            }
            else
            {
                wsprintfA(KeyName, aUp_0);
            }
            v4 = GetPrivateProfileIntA(AppName, KeyName, v9, lpFileName);
            *(_BYTE*)(thisx + 11 * nDefault + i + 11176) = v4;
        }
        wsprintfA(AppName, "KeyBoardAssign%dP", nDefault + 1);
        for (j = 0; j < 11; ++j)
        {
            if (j)
            {
                switch (j)
                {
                case 1:
                    wsprintfA(KeyName, aDown_0);
                    break;
                case 2:
                    wsprintfA(KeyName, aLeft_0);
                    break;
                case 3:
                    wsprintfA(KeyName, aRight_0);
                    break;
                case 9:
                    wsprintfA(KeyName, aSelect_0);
                    break;
                case 10:
                    wsprintfA(KeyName, aStart_0);
                    break;
                default:
                    wsprintfA(KeyName, "Trigger%d", j - 3);
                    break;
                }
            }
            else
            {
                wsprintfA(KeyName, aUp_1);
            }
            v5 = GetPrivateProfileIntA(AppName, KeyName, *(unsigned __int8*)(thisx + 11 * nDefault + j + 11264), lpFileName);
            *(_BYTE*)(thisx + 11 * nDefault + j + 11264) = v5;
        }
        result = nDefault + 1;
    }
    for (nDefault = 0; nDefault < 8; ++nDefault)
    {
        for (k = 0; k < 11; ++k)
        {
            sub_4768A2((int*)&player_list[27 * nDefault], k, *(_BYTE*)(thisx + 11 * nDefault + k + 11176));
            result = k + 1;
        }
        for (m = 0; m < 11; ++m)
        {
            sub_47690D((int*)&player_list[27 * nDefault], m, *(_BYTE*)(thisx + 11 * nDefault + m + 11264));
            result = m + 1;
        }
    }
    return result;
} 
_DWORD* sub_451A0A(_DWORD* thisx, char a2, unsigned __int8 a3)
{
    _DWORD* result; // eax
    char v5[16]; // [esp+4h] [ebp-2Ch] BYREF
    int j; // [esp+14h] [ebp-1Ch]
    _DWORD* v7; // [esp+18h] [ebp-18h]
    int i; // [esp+1Ch] [ebp-14h]
    struct tagRECT v9; // [esp+20h] [ebp-10h]

    v9 = *sub_488A07(thisx + 32, (struct tagRECT*)v5, a2, a3);
    for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
    {
        if (sub_41BEA6(&thisx[153 * i + 657]))
        {
            v7 = (_DWORD*)sub_41F0A9(&thisx[153 * i + 657]);
            for (j = v9.left; j < v9.right; ++j)
            {
                sub_422B03((_DWORD*)v7, j, a3);
                sub_422526(v7);
            }
        }
    }
    *((_BYTE*)thisx + 2544) = 1;
    result = thisx;
    *((_BYTE*)thisx + 2545) = 0;
    return result;
} 
int sub_451AF1(int thisx)
{
    _DWORD* v3; // [esp+4h] [ebp-184h]
    int v4; // [esp+8h] [ebp-180h]
    int v5; // [esp+Ch] [ebp-17Ch] BYREF
    int v6; // [esp+10h] [ebp-178h]
    int v7; // [esp+14h] [ebp-174h]
    int v8; // [esp+1Ch] [ebp-16Ch]
    int v9; // [esp+20h] [ebp-168h]
    int v10; // [esp+44h] [ebp-144h]
    int i; // [esp+48h] [ebp-140h]
    int v12; // [esp+4Ch] [ebp-13Ch] BYREF
    int v13; // [esp+50h] [ebp-138h]
    int v14; // [esp+54h] [ebp-134h]
    int v15; // [esp+58h] [ebp-130h]
    int v16; // [esp+5Ch] [ebp-12Ch]
    int v17; // [esp+60h] [ebp-128h]
    int v18; // [esp+70h] [ebp-118h]
    CHAR FileName[256]; // [esp+88h] [ebp-100h] BYREF

    *(_DWORD*)(thisx + 104) = 9;
    *(_BYTE*)(thisx + 2516) = 1;
    *(_BYTE*)(thisx + 29) = 0;
    *(_DWORD*)(thisx + 2540) = 0;
    sub_49DB90(&v12);
    v13 = 0;
    v14 = 0;
    v15 = 32;
    v16 = 32;
    v17 = 2;
    v18 = 0;
    v12 = -1;
    sub_49DA45((_DWORD*)unk_4BDC60, aGraphicStagese, (int)&v12);
    if (v12 <= 0)
        dword_4B9244 = 0;
    else
        dword_4B9244 = v12;
    for (i = 0; i < *(_DWORD*)(thisx + 13388); ++i)
    {
        v13 = 0;
        v14 = 0;
        v15 = -1;
        v16 = -1;
        v17 = 1;
        v18 = -1;
        v12 = -1;
        wsprintfA(FileName, "Stage\\Stage%02d_Select.bmp", i + 1);
        sub_49DA45((_DWORD*)unk_4BDC60, FileName, (int)&v12);
        sub_475770((_WORD*)(20 * i + *(_DWORD*)(thisx + 13392)), v12);
        if (v12 <= 0)
        {
            v4 = sub_49CB92((int)unk_4BDC60, -1, 32, 32, 0, 0);
            if (v4 != -1)
            {
                wsprintfA(FileName, "Stage\\Stage%02d.bmp", i + 1);
                if (sub_49B9E0((_DWORD*)unk_4BDC60, FileName))
                {
                    v3 = (_DWORD*)sub_475750((_DWORD*)unk_4BDC60);
                    v10 = unknown_libname_13(v3);
                    v13 = v10 / 2 - 88;
                    v14 = 0;
                    v15 = 176;
                    v16 = 176;
                    v17 = 1;
                    v18 = -1;
                    v12 = -1;
                    if (sub_49D318((int)unk_4BDC60, (int)&v12))
                    {
                        sub_49C15E((int)&v5);
                        v6 = 0;
                        v7 = 0;
                        v5 = v12;
                        v8 = 46;
                        v9 = 46;
                        sub_49CC5B((short*)unk_4BDC60, v4, &v5);
                        v6 = 0;
                        v7 = 0;
                        v5 = dword_4B9244;
                        v8 = 256;
                        v9 = 256;
                        sub_49CC5B((short*)unk_4BDC60, v4, &v5);
                        sub_475770((_WORD*)(20 * i + *(_DWORD*)(thisx + 13392)), v4);
                        sub_49DA8A((_DWORD*)unk_4BDC60, v12);
                    }
                }
            }
        }
    }
    sub_451EB5((_BYTE*)thisx, 1, 1);
    sub_452045((_BYTE*)thisx, 10, 2, 20, 4);
    sub_452045((_BYTE*)thisx, 7, 8, 27, 12);
    return sub_456D33((const CHAR*)thisx, aCharselWav_0, 1, 0);
}

 
_DWORD* sub_451EB5(_BYTE* thisx, int a2, int a3)
{
    _DWORD* result; // eax
    struct tagRECT rc; // [esp+4h] [ebp-5Ch] BYREF
    int v6; // [esp+14h] [ebp-4Ch]
    int k; // [esp+18h] [ebp-48h]
    int j; // [esp+1Ch] [ebp-44h]
    int i; // [esp+20h] [ebp-40h]
    int m; // [esp+24h] [ebp-3Ch]
    int v11; // [esp+28h] [ebp-38h] BYREF
    int v12; // [esp+2Ch] [ebp-34h]
    int v13; // [esp+30h] [ebp-30h]

    sub_49C15E((_DWORD)&v11);
    result = (_DWORD*)dword_4B91F8;
    v11 = dword_4B91F8;
    if (a2)
    {
        for (i = 0; i < 24; ++i)
        {
            v12 = 8 * ((i + 1) % 5) - 40;
            v13 = 8 * i;
            for (j = 0; j < 9; ++j)
            {
                sub_49CC5B((short*)unk_4BDC60, dword_4B9248, &v11);
                v6 = v12 / 8;
                for (k = 0; k < 5; ++k)
                {
                    if (v6 >= 0 && v6 < 40)
                        thisx[25 * v6 + 11969 + i] = k;
                    ++v6;
                }
                v12 += 40;
            }
        }
        v13 = 8 * i;
        result = (_DWORD*)dword_4B91F4 + 9;
        v11 = dword_4B91F4 + 9;
        for (m = 0; m < 40; ++m)
        {
            v12 = 8 * m;
            sub_49CC5B((short*)unk_4BDC60, dword_4B9248, &v11);
            result = (int*)thisx;
            thisx[25 * m + 11993] = 19;
        }
    }
    if (a3)
    {
        SetRect(&rc, 0, 200, 320, 240);
        return sub_4A02E9((_DWORD*)unk_4BDC60, dword_4B9248, (int)&rc, 0, dword_4B9248);
    }
    return result;
}

 
int sub_452045(_BYTE* thisx, int a2, int a3, int a4, int a5)
{
    int result; // eax
    unsigned __int8 v7; // [esp+4h] [ebp-5Ch]
    unsigned __int8 v8; // [esp+8h] [ebp-58h]
    int j; // [esp+Ch] [ebp-54h]
    int v10; // [esp+10h] [ebp-50h]
    int v11; // [esp+10h] [ebp-50h]
    int v12; // [esp+14h] [ebp-4Ch]
    int v13; // [esp+14h] [ebp-4Ch]
    int v14; // [esp+18h] [ebp-48h]
    int v15; // [esp+1Ch] [ebp-44h]
    int i; // [esp+20h] [ebp-40h]
    int m; // [esp+20h] [ebp-40h]
    int k; // [esp+24h] [ebp-3Ch]
    int v19; // [esp+28h] [ebp-38h] BYREF
    int v20; // [esp+2Ch] [ebp-34h]
    int v21; // [esp+30h] [ebp-30h]

    sub_49C15E((int)&v19);
    for (i = 0; i < a5; ++i)
    {
        v21 = 8 * (i + a3);
        v14 = i + a3;
        for (j = 0; j < a4; ++j)
        {
            v20 = 8 * (j + a2);
            if (j || i)
            {
                if (j != a4 - 1 || i)
                {
                    if (i)
                    {
                        if (j || i != a5 - 1)
                        {
                            if (j == a4 - 1 && i == a5 - 1)
                            {
                                v19 = dword_4B91F4 + 8;
                            }
                            else if (i == a5 - 1)
                            {
                                v19 = dword_4B91F4 + 7;
                            }
                            else if (j)
                            {
                                if (j == a4 - 1)
                                    v19 = dword_4B91F4 + 5;
                                else
                                    v19 = dword_4B91F4;
                            }
                            else
                            {
                                v19 = dword_4B91F4 + 4;
                            }
                        }
                        else
                        {
                            v19 = dword_4B91F4 + 6;
                        }
                    }
                    else
                    {
                        v19 = dword_4B91F4 + 2;
                    }
                }
                else
                {
                    v19 = dword_4B91F4 + 3;
                }
            }
            else
            {
                v19 = dword_4B91F4 + 1;
            }
            v15 = j + a2;
            if (j + a2 >= 0 && v15 < 40 && v14 >= 0 && v14 < 25)
                thisx[25 * v15 + 11969 + v14] = v19 - dword_4B91F4 + 10;
            sub_49CC5B((short*)unk_4BDC60, dword_4B9248, &v19);
        }
    }
    v12 = a5 + a3;
    v21 = 8 * (a5 + a3);
    for (k = 0; k < a4; ++k)
    {
        v10 = a2 + k + 1;
        if (v10 >= 0 && v10 < 40 && v12 >= 0 && v12 < 25)
        {
            v8 = thisx[25 * v10 + 11969 + v12];
            if (v8 < 5u)
            {
                v20 = 8 * v10;
                v19 = dword_4B91F8 + v8 + 1;
                sub_49CC5B((short*)unk_4BDC60, dword_4B9248, &v19);
            }
        }
    }
    v11 = a4 + a2;
    v20 = 8 * (a4 + a2);
    for (m = 0; ; ++m)
    {
        result = m;
        if (m >= a5)
            break;
        v13 = a3 + m + 1;
        if (v11 >= 0 && v11 < 40 && v13 >= 0 && v13 < 25)
        {
            v7 = thisx[25 * v11 + 11969 + v13];
            if (v7 < 5u)
            {
                v21 = 8 * v13;
                v19 = dword_4B91F8 + v7 + 1;
                sub_49CC5B((short*)unk_4BDC60, dword_4B9248, &v19);
            }
        }
    }
    return result;
} 
int sub_452368(int thisx)
{
    const CHAR* v1; // eax
    int v2; // eax
    const CHAR* v3; // eax
    int result; // eax
    int v5; // [esp+0h] [ebp-19Ch]
    int v6; // [esp+4h] [ebp-198h]
    int v7; // [esp+8h] [ebp-194h]
    int v8; // [esp+Ch] [ebp-190h]
    int v9; // [esp+10h] [ebp-18Ch]
    int v10; // [esp+14h] [ebp-188h]
    int v11; // [esp+18h] [ebp-184h]
    int v13; // [esp+20h] [ebp-17Ch]
    int v14; // [esp+24h] [ebp-178h]
    int v15; // [esp+28h] [ebp-174h]
    struct tagRECT v16; // [esp+2Ch] [ebp-170h] BYREF
    _DWORD* v17; // [esp+3Ch] [ebp-160h]
    int v18; // [esp+40h] [ebp-15Ch]
    int v19; // [esp+44h] [ebp-158h]
    int i; // [esp+48h] [ebp-154h]
    int v21; // [esp+4Ch] [ebp-150h]
    int v22; // [esp+50h] [ebp-14Ch]
    CHAR String1[256]; // [esp+54h] [ebp-148h] BYREF
    int v24; // [esp+154h] [ebp-48h] BYREF
    int v25; // [esp+158h] [ebp-44h]
    int v26; // [esp+15Ch] [ebp-40h]
    struct tagRECT rc; // [esp+18Ch] [ebp-10h] BYREF

    sub_477F0C(0);
    v19 = 0;
    v18 = 0;
    if (!*(_BYTE*)(thisx + 2516))
    {
        if (sub_476CDA(0))
        {
            v18 = 1;
        }
        else if (sub_476C8B(0))
        {
            v18 = -1;
        }
        if (sub_476D29(0))
        {
            v19 = -1;
        }
        else if (sub_476D78(0))
        {
            v19 = 1;
        }
    }
    if (!v19 || *(_DWORD*)(thisx + 2540) || *(_DWORD*)(thisx + 2532))
    {
        if (v18 && !*(_DWORD*)(thisx + 2540) && !*(_DWORD*)(thisx + 2532))
        {
            *(_DWORD*)(thisx + 2540) = 0;
            *(_DWORD*)(thisx + 2532) = v18;
            sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
        }
    }
    else
    {
        *(_DWORD*)(thisx + 2540) = v19;
        *(_DWORD*)(thisx + 2532) = 0;
        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
    }
    sub_49C15E((int)&v24);
    v24 = dword_4B9248;
    sub_49AB05((int)unk_4BDC60, &v24);
    sub_47B91A(128, 32, byte_4B1550, 0, -1);
    v17 = 0;
    if (*(_BYTE*)(thisx + 29))
        v17 = (_DWORD*)(20 * (*(unsigned __int8*)(thisx + 29) - 1) + *(_DWORD*)(thisx + 13392));
    if (*(_BYTE*)(thisx + 29))
    {
        if (unknown_libname_26(v17))
        {
            v1 = (const CHAR*)unknown_libname_26(v17);
            lstrcpyA(String1, v1);
        }
        else
        {
            wsprintfA(String1, byte_4B1574);
        }
    }
    else
    {
        wsprintfA(String1, "%s", (_DWORD*)byte_4B1564);
    }
    v2 = lstrlenA(String1);
    sub_47B91A(160 - 2 * v2, 94, String1, 0, -1);
    if (v17 && !unknown_libname_26(v17))
    {
        wsprintfA(String1, "%02d", *(unsigned __int8*)(thisx + 29));
        sub_47BC5A(168, 94, String1, 0, -1);
    }
    SetRect(&rc, 0, 200, 320, 240);
    sub_49EDC1((int)unk_4BDC60, (int)&rc, (_DWORD*)&rc, 0);
    if (*(_BYTE*)(thisx + 29))
    {
        if (unknown_libname_12(v17))
        {
            v3 = (const CHAR*)unknown_libname_12(v17);
            sub_47B91A(24, 208, v3, 0, -1);
        }
    }
    else
    {
        sub_47B91A(24, 208, byte_4B158C, 0, -1);
    }
    v21 = 0;
    v22 = 3;
    if (*(int*)(thisx + 2540) >= 0)
    {
        if (*(int*)(thisx + 2540) > 0)
            v22 = 4;
    }
    else
    {
        v21 = -1;
    }
    for (i = v21; i < v22; ++i)
    {
        v25 = (i << 6) + 80 - 8 * *(_DWORD*)(thisx + 2540);
        if (*(int*)(thisx + 2532) <= 0)
            v11 = -*(_DWORD*)(thisx + 2532);
        else
            v11 = *(_DWORD*)(thisx + 2532);
        if (v11 > 4)
        {
            if (*(int*)(thisx + 2532) <= 0)
                v10 = (*(_DWORD*)(thisx + 2532) >= 0) - 1;
            else
                v10 = 1;
            if (v10 <= 0)
            {
                if (*(int*)(thisx + 2532) <= 0)
                    v9 = (*(_DWORD*)(thisx + 2532) >= 0) - 1;
                else
                    v9 = 1;
                if (v9 < 0)
                    v26 = 112 - 8 * *(_DWORD*)(thisx + 2532) - 64;
            }
            else
            {
                v26 = 144 - 8 * *(_DWORD*)(thisx + 2532) + 32;
            }
        }
        else
        {
            v26 = 112 - 8 * *(_DWORD*)(thisx + 2532);
        }
        v15 = *(unsigned __int8*)(thisx + 29) + i - 1;
        if (v15 >= 0)
        {
            if (v15 > *(_DWORD*)(thisx + 13388))
                v15 = 0;
        }
        else
        {
            v15 = *(_DWORD*)(thisx + 13388);
        }
        v17 = 0;
        if (v15 > 0)
            v17 = (_DWORD*)(20 * (v15 - 1) + *(_DWORD*)(thisx + 13392));
        if (v15)
        {
            if (sub_475790((short*)v17) <= 0)
                v24 = dword_4B9244;
            else
                v24 = sub_475790((short*)v17);
        }
        else
        {
            v24 = dword_4B9244 + 1;
        }
        SetRect(&v16, 0, 0, 32, 32);
        if (v25 >= 88)
        {
            if (v25 + 32 > 232)
                v16.right = 232 - v25;
        }
        else
        {
            v16.left = 88 - v25;
            v16.right = 32 - (88 - v25);
            v25 = 88;
        }
        if (v26 >= 112)
        {
            if (v26 + 32 > 144)
                v16.bottom = 144 - v26;
        }
        else
        {
            v16.top = 112 - v26;
            v16.bottom = 32 - (112 - v26);
            v26 = 112;
        }
        sub_49C8A6((int)unk_4BDC60, &v24, (_DWORD*)&v16);
    }
    if (*(_DWORD*)(thisx + 2540))
    {
        if (*(int*)(thisx + 2540) <= 0)
        {
            if ((int)-- * (_DWORD*)(thisx + 2540) <= -8)
            {
                *(_DWORD*)(thisx + 2540) = 0;
                v14 = *(unsigned __int8*)(thisx + 29) - 1;
                if (v14 >= 0)
                    *(_BYTE*)(thisx + 29) = v14;
                else
                    *(_BYTE*)(thisx + 29) = *(_BYTE*)(thisx + 13388);
            }
        }
        else if ((int)++ * (_DWORD*)(thisx + 2540) >= 8)
        {
            ++* (_BYTE*)(thisx + 29);
            *(_DWORD*)(thisx + 2540) = 0;
            if (*(unsigned __int8*)(thisx + 29) >= *(_DWORD*)(thisx + 13388) + 1)
                *(_BYTE*)(thisx + 29) = 0;
        }
    }
    else if (*(_DWORD*)(thisx + 2532))
    {
        if (*(int*)(thisx + 2532) <= 0)
            v8 = (*(_DWORD*)(thisx + 2532) >= 0) - 1;
        else
            v8 = 1;
        *(_DWORD*)(thisx + 2532) += v8;
        if (*(int*)(thisx + 2532) <= 0)
            v7 = -*(_DWORD*)(thisx + 2532);
        else
            v7 = *(_DWORD*)(thisx + 2532);
        if (v7 == 4)
        {
            v13 = 10;
            if (*(_DWORD*)(thisx + 13388) + 1 < 10)
                v13 = 10 - (*(_DWORD*)(thisx + 13388) + 1);
            if (*(int*)(thisx + 2532) <= 0)
                v6 = (*(_DWORD*)(thisx + 2532) >= 0) - 1;
            else
                v6 = 1;
            *(_BYTE*)(thisx + 29) = (v13 * v6 + *(unsigned __int8*)(thisx + 29) + *(_DWORD*)(thisx + 13388) + 1)
                % (*(_DWORD*)(thisx + 13388) + 1);
        }
        if (*(int*)(thisx + 2532) <= 0)
            v5 = -*(_DWORD*)(thisx + 2532);
        else
            v5 = *(_DWORD*)(thisx + 2532);
        if (v5 >= 8)
            *(_DWORD*)(thisx + 2532) = 0;
    }
    result = sub_476DC7(0, 0);
    if (result && !*(_BYTE*)(thisx + 2516))
    {
        result = sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
        *(_DWORD*)(thisx + 108) = 11;
        *(_BYTE*)(thisx + 2516) = 2;
    }
    return result;
}

 
int sub_452D16(int thisx, double a2, double a3, double a4)
{
    int* v6; // [esp+4h] [ebp-8h]
    int i; // [esp+8h] [ebp-4h]
    int j; // [esp+8h] [ebp-4h]

    *(_DWORD*)(thisx + 104) = 10;
    *(_BYTE*)(thisx + 2516) = 1;
    *(_DWORD*)(thisx + 2520) = 0;
    *(_BYTE*)(thisx + 2544) = 0;
    *(_BYTE*)(thisx + 2545) = 0;
    sub_488CCB(thisx + 128);
    *(_DWORD*)(thisx + 11376) = 0;
    sub_456617(thisx);
    for (i = 0; i < 8; ++i)
        *(_WORD*)(thisx + 2 * i + 11404) = 0;
    for (j = 0; j < (unsigned __int8)byte_4B9985; ++j)
    {
        sub_41BF1D(thisx + 612 * j + 2628);
        sub_41D84A(thisx + 612 * j + 2628);
        sub_42371C(thisx + 612 * j + 2628);
        sub_452E9A(thisx);
        sub_417763((_WORD*)(thisx + 612 * j + 2628));
        if (sub_41BEA6((_DWORD*)(thisx + 612 * j + 2628)))
        {
            v6 = sub_41F0A9((_DWORD*)(thisx + 612 * j + 2628));
            sub_41F712(v6);
            sub_4224D9(v6);
            sub_422526(v6);
        }
    }
    sub_4647F2(thisx, a2, a3, a4);
    return sub_489C36((const CHAR*)(thisx + 128));
}

 
void sub_452E9A(int thisx)
{
    int v2[2]; // [esp+10h] [ebp-54h] BYREF
    int v3; // [esp+18h] [ebp-4Ch]
    int v4; // [esp+1Ch] [ebp-48h]
    int v5; // [esp+20h] [ebp-44h]
    int v6[2]; // [esp+24h] [ebp-40h] BYREF
    int v7; // [esp+2Ch] [ebp-38h]
    int v8; // [esp+30h] [ebp-34h]
    int v9; // [esp+34h] [ebp-30h]
    int v10[2]; // [esp+38h] [ebp-2Ch] BYREF
    int v11; // [esp+40h] [ebp-24h]
    int v12; // [esp+44h] [ebp-20h]
    int v13[2]; // [esp+48h] [ebp-1Ch] BYREF
    int v14; // [esp+50h] [ebp-14h]
    int v15; // [esp+54h] [ebp-10h]
    unsigned int NodeId; // [esp+58h] [ebp-Ch]
    int i; // [esp+60h] [ebp-4h]

    NodeId = Concurrency::details::ExecutionResource::GetNodeId((Concurrency::details::ExecutionResource*)(thisx + 128));
    if (byte_4B9985 == 2)
    {
        v15 = sub_4891BA((_DWORD*)(thisx + 128), 0);
        for (i = 0; i < 2; ++i)
        {
            v14 = (unsigned __int8)byte_4B9988[i];
            sub_4757B0((_DWORD*)(thisx + 612 * v14 + 2628), i == 0);
            v13[0] = 160 * i + 80;
            v13[1] = NodeId + v15;
            sub_48655E(thisx + 128, v13, (_DWORD*)thisx + 612 * v14 + 2628);
        }
    }
    else if ((unsigned __int8)byte_4B9985 > 4u)
    {
        if ((unsigned __int8)byte_4B9985 > 6u)
        {
            v5 = (int)(176 - NodeId) / 10;
            for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
            {
                v4 = (unsigned __int8)byte_4B9988[i];
                if (!i || i == 1 || i == 2 || i == 3)
                    sub_4757B0((_DWORD*)(thisx + 612 * v4 + 2628), 1);
                else
                    sub_4757B0((_DWORD*)(thisx + 612 * v4 + 2628), 0);
                if (i % 2)
                {
                    v2[0] = 72 * (i / 2) + 44;
                    v3 = sub_4891BA((_DWORD*)(thisx + 128), 2);
                }
                else
                {
                    v2[0] = 80 * (i / 2) + 32;
                    v3 = sub_4891BA((_DWORD*)(thisx + 128), 1);
                }
                v2[1] = NodeId + v3;
                sub_48655E(thisx + 128, v2, (_DWORD*)thisx + 612 * v4 + 2628);
            }
        }
        else
        {
            v9 = (int)(176 - NodeId) / 10;
            for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
            {
                v8 = (unsigned __int8)byte_4B9988[i];
                if (!i || i == 1 || i == 2)
                    sub_4757B0((_DWORD*)(thisx + 612 * v8 + 2628), 1);
                else
                    sub_4757B0((_DWORD*)(thisx + 612 * v8 + 2628), 0);
                if (i % 2)
                {
                    v6[0] = 96 * (i / 2) + 64;
                    v7 = sub_4891BA((_DWORD*)(thisx + 128), 2);
                }
                else
                {
                    v6[0] = 112 * (i / 2) + 48;
                    v7 = sub_4891BA((_DWORD*)(thisx + 128), 1);
                }
                v6[1] = NodeId + v7;
                sub_48655E(thisx + 128, v6, (_DWORD*)thisx + 612 * v8 + 2628);
            }
        }
    }
    else
    {
        for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
        {
            v12 = (unsigned __int8)byte_4B9988[i];
            if (!i || i == 1)
                sub_4757B0((_DWORD*)(thisx + 612 * v12 + 2628), 1);
            else
                sub_4757B0((_DWORD*)(thisx + 612 * v12 + 2628), 0);
            if (i % 2)
            {
                v10[0] = ((i / 2) << 7) + 96;
                v11 = sub_4891BA((_DWORD*)(thisx + 128), 2);
            }
            else
            {
                v10[0] = 160 * (i / 2) + 80;
                v11 = sub_4891BA((_DWORD*)(thisx + 128), 1);
            }
            v10[1] = NodeId + v11;
            sub_48655E(thisx + 128, v10, (_DWORD*)thisx + 612 * v12 + 2628);
        }
    }
}

 
_DWORD* sub_4532B9(_DWORD* thisx)
{
    _DWORD* result; // eax

    ++thisx[2273];
    result = thisx;
    if ((int)thisx[2273] >= 32)
        thisx[2273] = 0;
    return result;
}

 
void sub_4532F2(int a1, double a2, double a3, double a4)
{
    int v4; // edx
    int v5; // edx
    int v6; // edx
    int v7; // eax
    CHAR String1[264]; // [esp+10h] [ebp-12Ch] BYREF
    struct tagRECT v10; // [esp+118h] [ebp-24h] BYREF
    struct tagRECT rc; // [esp+128h] [ebp-14h] BYREF
    int v12; // [esp+138h] [ebp-4h]

    if (*(_BYTE*)(a1 + 2516))
    {
        if (*(int*)(a1 + 2512) >= 3)
        {
            if (*(int*)(a1 + 2512) <= 10)
                v12 = *(_DWORD*)(a1 + 2512) / 2 + 4;
        }
        else
        {
            v12 = 2 * *(_DWORD*)(a1 + 2512);
        }
        if (*(_BYTE*)(a1 + 2516) == 1)
        {
            SetRect(&rc, 0, 0, 160 - 20 * v12, 240);
            sub_49EDC1((int)unk_4BDC60, v4, (int*)&rc, 0);
            SetRect(&rc, 20 * v12 + 160, 0, 320, 240);
            sub_49EDC1((int)unk_4BDC60, v5, (int*)&rc, 0);
        }
        else if (*(_BYTE*)(a1 + 2516) == 2)
        {
            SetRect(&v10, 0, 0, 20 * v12, 240);
            sub_49EDC1((int)unk_4BDC60, (int)&v10, (int*)&v10, 0);
            SetRect(&v10, 320 - 20 * v12, 0, 320, 240);
            sub_49EDC1((int)unk_4BDC60, v6, (int*)&v10, 0);
        }
        if (*(_BYTE*)(a1 + 2516))
        {
            if ((int)++ * (_DWORD*)(a1 + 2512) >= 10)
            {
                if (*(_BYTE*)(a1 + 2516) == 2)
                {
                    switch (*(_DWORD*)(a1 + 104))
                    {
                    case 1:
                        sub_473F7F((_DWORD*)a1);
                        break;
                    case 8:
                    case 0x16:
                    case 0x17:
                        sub_466789((void*)a1);
                        break;
                    case 9:
                    case 0x15:
                        sub_467DE0();
                        break;
                    case 0xA:
                    case 0xB:
                    case 0xC:
                        if (*(_DWORD*)(a1 + 108) != 11 || dword_4B9974)
                            sub_44E543((_DWORD*)a1);
                        break;
                    case 0xE:
                        sub_4667AC();
                        break;
                    case 0x13:
                        if (*(_DWORD*)(a1 + 108) != 14 && *(_DWORD*)(a1 + 108) != 17 && *(_DWORD*)(a1 + 108) != 20)
                        {
                            sub_45F935(a1);
                            sub_45FD81(a1);
                            if (*(int*)(a1 + 13104) >= 0)
                                sub_49DA8A((int*)unk_4BDC60, *(_DWORD*)(a1 + 13104));
                            *(_DWORD*)(a1 + 13104) = -1;
                        }
                        break;
                    case 0x18:
                    case 0x1A:
                    case 0x1B:
                        sub_4571BB(a1);
                        sub_473F7F((_DWORD*)a1);
                        break;
                    case 0x19:
                        if (*(int*)(a1 + 2528) >= 0)
                            sub_43FED3((int*)unk_4BDB28, *(_DWORD**)(a1 + 2528));
                        v7 = sub_4757D0((int*)a1 + 736);
                        sub_49DA8A((int*)unk_4BDC60, v7);
                        break;
                    default:
                        break;
                    }
                    dword_4B99EC = 1;
                    *(_BYTE*)(a1 + 2516) = 0;
                    *(_DWORD*)(a1 + 2512) = 0;
                    *(_DWORD*)(a1 + 112) = *(_DWORD*)(a1 + 104);
                    if (*(_BYTE*)(a1 + 16140))
                    {
                        lstrcpyA(String1, (LPCSTR)(a1 + 16140));
                        sub_467AC6(a1, (const char*)(a1 + 16140));
                        if (!lstrcmpiA(String1, (LPCSTR)(a1 + 16140)))
                            memset((void*)(a1 + 16140), 0, 0x104u);
                        *(_BYTE*)(a1 + 2516) = 1;
                    }
                    else
                    {
                        switch (*(_DWORD*)(a1 + 108))
                        {
                        case 1:
                            switch (*(_DWORD*)(a1 + 120))
                            {
                            case 1:
                                sub_456F35((_DWORD*)a1);
                                break;
                            case 2:
                                sub_4624C3((_DWORD*)a1);
                                break;
                            case 3:
                                sub_46279C((_DWORD*)a1);
                                break;
                            case 4:
                                sub_462B0C(a1);
                                break;
                            case 5:
                                sub_463007(a1);
                                break;
                            case 7:
                                sub_473F53((int*)a1);
                                break;
                            default:
                                return;
                            }
                            break;
                        case 2:
                            dword_4B9974 = 0;
                            sub_453A31(a1);
                            break;
                        case 3:
                            sub_44C3D6(a1);
                            break;
                        case 4:
                            sub_47482E(a1);
                            break;
                        case 5:
                            sub_455782(a1);
                            break;
                        case 6:
                            sub_466E2D(a1);
                            break;
                        case 7:
                            sub_44FE2E(a1);
                            break;
                        case 8:
                            sub_448750(a1);
                            break;
                        case 9:
                            sub_451AF1(a1);
                            break;
                        case 0xB:
                            if (*(_DWORD*)(a1 + 104) != 12 || dword_4B9974)
                                sub_44508E(a1, a2, a3, a4);
                            else
                                sub_452D16(a1, a2, a3, a4);
                            break;
                        case 0xD:
                            sub_457930(a1);
                            break;
                        case 0xE:
                            sub_459DE1(a1);
                            break;
                        case 0xF:
                            sub_45B8F5(a1);
                            break;
                        case 0x10:
                            sub_45C3AF(a1);
                            break;
                        case 0x11:
                            sub_45CBC2(a1);
                            break;
                        case 0x12:
                            sub_45CF7B(a1);
                            break;
                        case 0x13:
                            sub_45DC7E(a1);
                            break;
                        case 0x14:
                            sub_461335(a1);
                            break;
                        case 0x15:
                            sub_472FC4(a1);
                            break;
                        case 0x16:
                            sub_4686AA(a1);
                            break;
                        case 0x17:
                            sub_46DD55(a1, a2, a3, a4);
                            break;
                        case 0x18:
                            sub_47082B(a1);
                            break;
                        case 0x19:
                            sub_4710B5(a1);
                            break;
                        case 0x1A:
                            sub_471F33(a1);
                            break;
                        case 0x1B:
                            sub_473CFA(a1);
                            break;
                        default:
                            return;
                        }
                    }
                }
                else
                {
                    *(_BYTE*)(a1 + 2516) = 0;
                    *(_DWORD*)(a1 + 2512) = 0;
                    *(_BYTE*)(a1 + 11420) = 0;
                    *(_BYTE*)(a1 + 11432) = 0;
                }
            }
        }
    }
}
 
int sub_453A31(int thisx)
{
	int v3[15]; // [esp+4h] [ebp-3Ch] BYREF

	*(_DWORD*)(thisx + 104) = 2;
	*(_BYTE*)(thisx + 2516) = 1;
	sub_49DB90(v3);
	v3[1] = 0;
	v3[2] = 0;
	v3[3] = -1;
	v3[4] = -1;
	v3[9] = -1;
	v3[0] = dword_4B9248;
	sub_49DA45((_DWORD*)unk_4BDC60, aStageNameWav, (int)v3);
	return sub_456D33((const CHAR*)thisx, aTitleWav, 1, 0);
}

 
int sub_453AAA(int thisx)
{
    int result; // eax
    int v3[14]; // [esp+4h] [ebp-38h] BYREF

    sub_49C15E((int)v3);
    v3[1] = 0;
    v3[2] = 0;
    v3[0] = dword_4B9248;
    sub_49AB05((int)unk_4BDC60, v3);
    result = *(unsigned __int8*)(thisx + 2516);
    if (!*(_BYTE*)(thisx + 2516))
    {
        sub_477F0C(0);
        if (sub_476DC7(0, 0) || sub_476DC7(0, 1) || (result = sub_476DC7(0, 2)) != 0)
        {
            *(_DWORD*)(thisx + 108) = 3;
            *(_BYTE*)(thisx + 2516) = 2;
            *(_DWORD*)(thisx + 2512) = 0;
            return sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
        }
    }
    return result;
}

 
int sub_453B66(int thisx)
{
    int result; // eax

    result = thisx;
    *(_BYTE*)(thisx + 2516) = 2;
    *(_DWORD*)(thisx + 108) = 2;
    return result;
}

 
void sub_453B85(int thisx, int a2, int a3)
{
    BOOL v4; // [esp+4h] [ebp-8h]
    int i; // [esp+8h] [ebp-4h]

    if (a2)
    {
        sub_451EB5((_BYTE*)thisx, 1, 0);
        v4 = *(_DWORD*)(thisx + 15640) != 0;
        for (i = 0; i < 4; ++i)
        {
            if (!unknown_libname_14((_DWORD*)(thisx + 36 * i + 15644)))
                (*(void(**)(int))(*(_DWORD*)(thisx + 36 * i + 15644) + 12))(thisx + 36 * i + 15644);
            if (*(_DWORD*)(thisx + 15640) == thisx + 36 * i + 15644)
                v4 = 0;
        }
        if (*(_BYTE*)(thisx + 2562) == 11)
            (*(void(**)(int))(*(_DWORD*)(thisx + 16048) + 12))(thisx + 16048);
        if (*(_BYTE*)(thisx + 2562) == 12)
        {
            (*(void(**)(int))(*(_DWORD*)(thisx + 16048) + 12))(thisx + 16048);
            (*(void(**)(int))(*(_DWORD*)(thisx + 16084) + 12))(thisx + 16084);
        }
        if (v4)
            (*(void(**)(_DWORD))(**(_DWORD**)(thisx + 15640) + 12))(*(_DWORD*)(thisx + 15640));
    }
    if (a3)
    {
        sub_451EB5((_BYTE*)thisx, 0, 1);
        if (*(_DWORD*)(thisx + 15640))
            *(_DWORD*)(thisx + 2528) = unknown_libname_13(*(_DWORD**)(thisx + 15640));
        if (*(_BYTE*)(thisx + 2562))
        {
            switch (*(_BYTE*)(thisx + 2562))
            {
            case 1:
                sub_47B91A(16, 208, (LPCSTR)dword_4ABB14, 0, dword_4B9248);
                sub_47B91A(16, 224, (LPCSTR)byte_4ABB3C, 0, dword_4B9248);
                break;
            case 2:
                sub_47B91A(16, 208, (LPCSTR)&byte_4B2D5B, 0, dword_4B9248);
                break;
            case 3:
                if (*(_DWORD*)(thisx + 2528))
                {
                    if (*(_DWORD*)(thisx + 2528) == 1)
                    {
                        sub_47B91A(16, 208, (LPCSTR)dword_4ABBE4, 0, dword_4B9248);
                    }
                    else if (*(_DWORD*)(thisx + 2528) == 2)
                    {
                        sub_47B91A(16, 208, (LPCSTR)dword_4ABC68, 0, dword_4B9248);
                    }
                }
                else
                {
                    sub_47B91A(16, 208, (LPCSTR)word_4ABB7E, 0, dword_4B9248);
                    sub_47B91A(16, 224, (LPCSTR)dword_4ABBA8, 0, dword_4B9248);
                }
                break;
            case 4:
                sub_47B91A(16, 208, (LPCSTR)word_4ABC0A, 0, dword_4B9248);
                break;
            case 5:
                sub_47B91A(16, 208, (LPCSTR)&byte_4B08F8, 0, dword_4B9248);
                sub_47B91A(16, 224, (LPCSTR)&byte_4B3438, 0, dword_4B9248);
                break;
            case 6:
                if (*(_DWORD*)(thisx + 2528))
                {
                    switch (*(_DWORD*)(thisx + 2528))
                    {
                    case 1:
                        sub_47B91A(16, 208, (LPCSTR)byte_4ABD41, 0, dword_4B9248);
                        sub_47B91A(16, 224, (LPCSTR)&byte_4ABD73, 0, dword_4B9248);
                        break;
                    case 2:
                        sub_47B91A(16, 208, (LPCSTR)byte_4ABDB1, 0, dword_4B9248);
                        break;
                    case 3:
                        sub_47B91A(16, 208, (LPCSTR)byte_4ABDFD, 0, dword_4B9248);
                        break;
                    case 4:
                        sub_47B91A(16, 208, (LPCSTR)&byte_4ABE5F, 0, dword_4B9248);
                        break;
                    case 5:
                        sub_47B91A(16, 208, (LPCSTR)dword_4ABEB8, 0, dword_4B9248);
                        break;
                    }
                }
                else
                {
                    sub_47B91A(16, 208, (LPCSTR)dword_4ABCD0, 0, dword_4B9248);
                }
                break;
            case 7:
                sub_47B91A(16, 208, (LPCSTR)&byte_4B1EC4, 0, dword_4B9248);
                break;
            case 8:
                sub_47B91A(16, 208, (LPCSTR)&byte_4B1F3E, 0, dword_4B9248);
                break;
            case 0xA:
                if (*(_DWORD*)(thisx + 2528))
                {
                    switch (*(_DWORD*)(thisx + 2528))
                    {
                    case 1:
                        sub_47B91A(16, 208, (LPCSTR)&byte_4AF95F, 0, dword_4B9248);
                        sub_47B91A(16, 224, (LPCSTR)&byte_4AF993, 0, dword_4B9248);
                        break;
                    case 2:
                        sub_47B91A(16, 208, (LPCSTR)&byte_4AF9DC, 0, dword_4B9248);
                        sub_47B91A(16, 224, (LPCSTR)byte_4AFA1A, 0, dword_4B9248);
                        break;
                    case 3:
                        sub_47B91A(16, 208, (LPCSTR)&byte_4AFA2E, 0, dword_4B9248);
                        sub_47B91A(16, 224, (LPCSTR)byte_4AFA74, 0, dword_4B9248);
                        break;
                    case 4:
                        sub_47B91A(16, 208, (LPCSTR)&byte_4AFA91, 0, dword_4B9248);
                        break;
                    case 5:
                        sub_47B91A(16, 208, (LPCSTR)&byte_4AFAE3, 0, dword_4B9248);
                        sub_47B91A(16, 224, (LPCSTR)byte_4AFB0F, 0, dword_4B9248);
                        break;
                    case 6:
                        sub_47B91A(16, 208, (LPCSTR)&byte_4AFB36, 0, dword_4B9248);
                        break;
                    case 7:
                        sub_47B91A(16, 208, (LPCSTR)&byte_4AFB82, 0, dword_4B9248);
                        sub_47B91A(16, 224, (LPCSTR)&byte_4AFBC4, 0, dword_4B9248);
                        break;
                    }
                }
                else
                {
                    sub_47B91A(16, 208, (LPCSTR)&byte_4AF917, 0, dword_4B9248);
                }
                break;
            case 0xB:
                if (*(_DWORD*)(thisx + 2528))
                {
                    switch (*(_DWORD*)(thisx + 2528))
                    {
                    case 1:
                        sub_47B91A(16, 208, (LPCSTR)&byte_4AFC64, 0, dword_4B9248);
                        break;
                    case 2:
                        sub_47B91A(16, 208, (LPCSTR)&byte_4AFCBA, 0, dword_4B9248);
                        break;
                    case 3:
                        sub_47B91A(16, 208, (LPCSTR)&byte_4AFD3D, 0, dword_4B9248);
                        sub_47B91A(16, 224, (LPCSTR)byte_4AFD6D, 0, dword_4B9248);
                        break;
                    }
                }
                else
                {
                    sub_47B91A(16, 208, (LPCSTR)&byte_4AFC32, 0, dword_4B9248);
                }
                break;
            }
        }
        else if (*(_DWORD*)(thisx + 2528))
        {
            switch (*(_DWORD*)(thisx + 2528))
            {
            case 1:
                sub_47B91A(16, 208, (LPCSTR)&byte_4AFC32, 0, dword_4B9248);
                sub_47B91A(16, 224, (LPCSTR)&byte_4B0BEC, 0, dword_4B9248);
                break;
            case 2:
                sub_47B91A(16, 208, (LPCSTR)&byte_4B15D8, 0, dword_4B9248);
                sub_47B91A(16, 224, (LPCSTR)&byte_4B0BF0, 0, dword_4B9248);
                break;
            case 3:
                sub_47B91A(16, 208, (LPCSTR)&byte_4B1616, 0, dword_4B9248);
                sub_47B91A(16, 224, (LPCSTR)&byte_4B1662, 0, dword_4B9248);
                break;
            case 4:
                sub_47B91A(16, 208, (LPCSTR)&byte_4B1698, 0, dword_4B9248);
                break;
            }
        }
        else
        {
            sub_47B91A(16, 208, (LPCSTR)&byte_4B0BA4, 0, dword_4B9248);
        }
    }
}

 
void sub_454469(_BYTE* thisx, int a2)
{
    int v2; // edx
    int v3; // eax
    char* v4; // eax
    unsigned __int8 v5; // al
    unsigned __int8 v6; // al
    unsigned __int8 v7; // al
    unsigned __int8 v8; // al
    unsigned __int8 v9; // al
    unsigned __int8 v10; // al
    unsigned __int8 v11; // al
    int v12; // [esp-4h] [ebp-1D0h]
    int v13; // [esp-4h] [ebp-1D0h]
    unsigned int v15; // [esp+4h] [ebp-1C8h]
    int v16; // [esp+4h] [ebp-1C8h]
    int v17; // [esp+4h] [ebp-1C8h]
    unsigned int v18; // [esp+8h] [ebp-1C4h]
    int v19; // [esp+8h] [ebp-1C4h]
    int m; // [esp+Ch] [ebp-1C0h]
    int v21; // [esp+10h] [ebp-1BCh]
    int v22; // [esp+10h] [ebp-1BCh]
    int v23; // [esp+10h] [ebp-1BCh]
    int yTop; // [esp+14h] [ebp-1B8h]
    int v25; // [esp+20h] [ebp-1ACh]
    int v26; // [esp+24h] [ebp-1A8h]
    _BYTE* v27; // [esp+28h] [ebp-1A4h]
    int v28; // [esp+2Ch] [ebp-1A0h]
    CHAR String[256]; // [esp+30h] [ebp-19Ch] BYREF
    struct tagRECT v30; // [esp+130h] [ebp-9Ch] BYREF
    int v31; // [esp+140h] [ebp-8Ch] BYREF
    int v32; // [esp+144h] [ebp-88h]
    int v33; // [esp+148h] [ebp-84h]
    int j; // [esp+178h] [ebp-54h]
    int k; // [esp+17Ch] [ebp-50h]
    int i; // [esp+180h] [ebp-4Ch]
    struct tagRECT rc; // [esp+184h] [ebp-48h] BYREF
    int v38; // [esp+194h] [ebp-38h] BYREF
    int v39; // [esp+198h] [ebp-34h]
    int v40; // [esp+19Ch] [ebp-30h]

    if (a2 == -1)
    {
        SetRect(&rc, 0, 0, 320, 16);
        sub_4A02E9((_DWORD*)unk_4BDC60, (int)&rc, (int)&rc, 0, dword_4B9248);
        sub_49C15E((int)&v38);
        v38 = dword_4B91F8;
        for (i = 1; i < 30; ++i)
        {
            v39 = 8 * ((i + 1) % 5) - 40;
            v40 = 8 * i + 4;
            for (j = 0; j < 9; ++j)
            {
                sub_49CC5B((short*)unk_4BDC60, dword_4B9248, &v38);
                v39 += 40;
            }
        }
        for (k = 0; k < (unsigned __int8)byte_4B9985; ++k)
            sub_454469(thisx, k);
    }
    else
    {
        yTop = 56 * (a2 % 4) + 20;
        SetRect(&v30, 160 * (a2 / 4) + 4, yTop, 160 * (a2 / 4) + 156, 56 * (a2 % 4) + 68);
        sub_4A02E9((_DWORD*)unk_4BDC60, v2, (int)&v30, 0, dword_4B9248);
        SetRect(&v30, 160 * (a2 / 4) + 8, 56 * (a2 % 4) + 40, 160 * (a2 / 4) + 32, 56 * (a2 % 4) + 64);
        v12 = dword_4B9248;
        v3 = sub_49FFEC(198, 113, 0);
        sub_4A02E9((_DWORD*)unk_4BDC60, (int)&v30, (int)&v30, v3, v12);
        v28 = (unsigned __int8)byte_4B9988[a2];
        if (thisx[a2 + 2588] == 1)
        {
            sub_47B91A(160 * (a2 / 4) + 8, 56 * (a2 % 4) + 24, byte_4B1F1C, 0, dword_4B9248);
        }
        else if (v28 >= (unsigned __int8)byte_4B9986)
        {
            sub_47B91A(160 * (a2 / 4) + 8, 56 * (a2 % 4) + 24, byte_4B1F2C, 0, dword_4B9248);
        }
        else if (!thisx[a2 + 2588])
        {
            wsprintfA(String, "%d", v28 + 1);
            sub_47BC5A(160 * (a2 / 4) + 8, 56 * (a2 % 4) + 24, String, 0, dword_4B9248);
            wsprintfA(String, byte_4B1F28);
            sub_47B91A(160 * (a2 / 4) + 16, 56 * (a2 % 4) + 24, String, 0, dword_4B9248);
        }
        if (!thisx[a2 + 2596])
        {
            v13 = dword_4B9248;
            v4 = unknown_libname_18((char*)(36 * *(unsigned __int16*)&thisx[2 * a2 + 2564] + dword_4B92E0));
            sub_47B91A(160 * (a2 / 4) + 36, 56 * (a2 % 4) + 24, v4, 0, v13);
            sub_47B91A(
                160 * (a2 / 4) + 84,
                56 * (a2 % 4) + 24,
                (LPCSTR)&byte_4B4664[18 * (unsigned __int8)thisx[a2 + 2580]],
                0,
                dword_4B9248);
        }
        sub_49C15E((int)&v31);
        v32 = 160 * (a2 / 4) + 12;
        v33 = 56 * (a2 % 4) + 40;
        sub_47900E(&v31, 1, *(unsigned __int16*)&thisx[2 * a2 + 2564], dword_4B9248);
        v32 = 160 * (a2 / 4) + 8;
        v33 = 56 * (a2 % 4) + 48;
        v25 = (unsigned __int8)sub_4575B4((unsigned char*)thisx, a2, 1);
        v26 = (unsigned __int8)sub_401710((_BYTE*)(dword_4B92E0 + 36 * *(unsigned __int16*)&thisx[2 * a2 + 2564]));
        sub_4A1307((int)word_4B9290, (Concurrency::details::HardwareAffinity*)(8 * v25 + 4952656));
        sub_485E5A((int)dword_4B93A4 + 24 * v26, (unsigned short*)word_4B9290);
        SetRect(&v30, 24 * (unsigned __int8)thisx[a2 + 2580], 0, 24, 16);
        v31 = dword_4B9234;
        sub_4A03B3((short*)unk_4BDC60, dword_4B9248, &v31, (_DWORD*)&v30);
        v27 = (_BYTE*)(36 * *(unsigned __int16*)&thisx[2 * a2 + 2564] + dword_4B92E0);
        if (thisx[a2 + 2596])
        {
            if (thisx[a2 + 2596] == 1)
            {
                sub_47B91A(160 * (a2 / 4) + 34, 56 * (a2 % 4) + 24, byte_4B0BF4, 0, dword_4B9248);
                v6 = sub_426610(v27);
                wsprintfA(String, "%3d", v6);
                sub_47BC5A(160 * (a2 / 4) + 68, 56 * (a2 % 4) + 24, String, 0, dword_4B9248);
                sub_47B91A(160 * (a2 / 4) + 34, 56 * (a2 % 4) + 40, byte_4B1559, 0, dword_4B9248);
                v7 = sub_426630(v27);
                wsprintfA(String, "%3d", v7);
                sub_47BC5A(160 * (a2 / 4) + 68, 56 * (a2 % 4) + 40, String, 0, dword_4B9248);
                sub_47B91A(160 * (a2 / 4) + 34, 56 * (a2 % 4) + 56, byte_4B1551, 0, dword_4B9248);
                v8 = sub_426670(v27);
                wsprintfA(String, "%3d", v8);
                sub_47BC5A(160 * (a2 / 4) + 68, 56 * (a2 % 4) + 56, String, 0, dword_4B9248);
                sub_47B91A(160 * (a2 / 4) + 96, 56 * (a2 % 4) + 24, byte_4B0BFA, 0, dword_4B9248);
                v9 = sub_426550(v27);
                wsprintfA(String, "%3d", v9);
                sub_47BC5A(160 * (a2 / 4) + 132, 56 * (a2 % 4) + 24, String, 0, dword_4B9248);
                sub_47B91A(160 * (a2 / 4) + 96, 56 * (a2 % 4) + 40, byte_4B0B96, 0, dword_4B9248);
                v10 = sub_426650(v27);
                wsprintfA(String, "%3d", v10);
                sub_47BC5A(160 * (a2 / 4) + 132, 56 * (a2 % 4) + 40, String, 0, dword_4B9248);
                sub_47B91A(160 * (a2 / 4) + 96, 56 * (a2 % 4) + 56, byte_4B1561, 0, dword_4B9248);
                v11 = sub_426690(v27);
                wsprintfA(String, "%3d", v11);
                sub_47BC5A(160 * (a2 / 4) + 132, 56 * (a2 % 4) + 56, String, 0, dword_4B9248);
            }
            else if (thisx[a2 + 2596] == 2)
            {
                if (thisx[a2 + 13092])
                {
                    v15 = (unsigned __int8)sub_4266B0(v27, (unsigned __int8)thisx[a2 + 13092] - 1);
                    if (v15 >= 0x49)
                    {
                        v16 = v15 - 128;
                        if (v16 >= 13)
                            sub_47B91A(160 * (a2 / 4) + 36, 56 * (a2 % 4) + 24, byte_4B1FD0, 0, dword_4B9248);
                        else
                            sub_47B91A(160 * (a2 / 4) + 36, 56 * (a2 % 4) + 24, (LPCSTR)&byte_4B4E74[21 * v16], 0, dword_4B9248);
                    }
                    else
                    {
                        sub_47B91A(160 * (a2 / 4) + 36, 56 * (a2 % 4) + 24, (LPCSTR)&byte_4B46C0[27 * v15], 0, dword_4B9248);
                    }
                    v17 = (unsigned __int8)sub_4266B0(v27, (unsigned __int8)thisx[a2 + 13092] - 1);
                    sub_47BD8E(160 * (a2 / 4) + 36, 56 * (a2 % 4) + 40, v17, dword_4B9248);
                }
                else
                {
                    for (m = 0; m < 3; ++m)
                    {
                        v18 = (unsigned __int8)sub_4266B0(v27, m);
                        if (v18 >= 0x49)
                        {
                            v19 = v18 - 128;
                            if (v19 >= 13)
                                sub_47B91A(160 * (a2 / 4) + 36, yTop + 16 * m + 4, byte_4B1FC4, 0, dword_4B9248);
                            else
                                sub_47B91A(160 * (a2 / 4) + 36, yTop + 16 * m + 4, (LPCSTR)&byte_4B4E74[21 * v19], 0, dword_4B9248);
                        }
                        else
                        {
                            sub_47B91A(160 * (a2 / 4) + 36, yTop + 16 * m + 4, (LPCSTR)&byte_4B46C0[27 * v18], 0, dword_4B9248);
                        }
                    }
                }
            }
        }
        else
        {
            sub_47B91A(160 * (a2 / 4) + 34, 56 * (a2 % 4) + 40, byte_4B1F34, 0, dword_4B9248);
            v5 = sub_4265B0(v27);
            wsprintfA(String, "%3d", v5);
            sub_47BC5A(160 * (a2 / 4) + 68, 56 * (a2 % 4) + 40, String, 0, dword_4B9248);
            sub_47B91A(160 * (a2 / 4) + 34, 56 * (a2 % 4) + 56, byte_4B0B78, 0, dword_4B9248);
            v21 = (unsigned __int8)sub_426570(v27);
            if (thisx[a2 + 2580])
            {
                if (thisx[a2 + 2580] == 1)
                    v21 += 15;
            }
            else
            {
                v21 += 5;
            }
            wsprintfA(String, "%3d", v21);
            sub_47BC5A(160 * (a2 / 4) + 68, 56 * (a2 % 4) + 56, String, 0, dword_4B9248);
            sub_47B91A(160 * (a2 / 4) + 96, 56 * (a2 % 4) + 40, byte_4B0B82, 0, dword_4B9248);
            v22 = (unsigned __int8)sub_4265D0(v27);
            if (thisx[a2 + 2580])
            {
                if (thisx[a2 + 2580] == 2)
                    v22 += 15;
            }
            else
            {
                v22 += 5;
            }
            wsprintfA(String, "%3d", v22);
            sub_47BC5A(160 * (a2 / 4) + 132, 56 * (a2 % 4) + 40, String, 0, dword_4B9248);
            sub_47B91A(160 * (a2 / 4) + 96, 56 * (a2 % 4) + 56, byte_4B0B8C, 0, dword_4B9248);
            v23 = (unsigned __int8)sub_4265F0(v27);
            if (thisx[a2 + 2580])
            {
                if (thisx[a2 + 2580] == 3)
                    v23 += 15;
            }
            else
            {
                v23 += 5;
            }
            wsprintfA(String, "%3d", v23);
            sub_47BC5A(160 * (a2 / 4) + 132, 56 * (a2 % 4) + 56, String, 0, dword_4B9248);
        }
    }
}

 
_BYTE* sub_455268(_BYTE* thisx, int a2)
{
    _BYTE* result; // eax

    if (a2 == -1)
    {
        sub_451EB5(thisx, 1, 1);
        sub_452045(thisx, 1, 1, 38, 22);
        sub_47B7ED(16, 32, aDevice, 0, dword_4B9248);
        sub_47B7ED(16, 52, aUp_2, 0, dword_4B9248);
        sub_47B7ED(16, 62, aDown_1, 0, dword_4B9248);
        sub_47B7ED(16, 72, aLeft_1, 0, dword_4B9248);
        sub_47B7ED(16, 82, aRight_1, 0, dword_4B9248);
        sub_47B7ED(16, 102, aA, 0, dword_4B9248);
        sub_47B7ED(16, 112, aB, 0, dword_4B9248);
        sub_47B7ED(16, 122, aC, 0, dword_4B9248);
        sub_47B7ED(16, 132, aAB, 0, dword_4B9248);
        sub_47B7ED(16, 142, aAC, 0, dword_4B9248);
        sub_47B7ED(16, 162, aSelect_1, 0, dword_4B9248);
        sub_47B7ED(16, 172, aStart_1, 0, dword_4B9248);
        return sub_455268(thisx, -2);
    }
    else if (a2 == -2)
    {
        sub_451EB5(thisx, 1, 1);
        if (thisx[2562])
        {
            if (thisx[2562] == 1)
            {
                return (_BYTE*)sub_47B91A(16, 208, byte_4B2078, 0, dword_4B9248);
            }
            else
            {
                result = thisx;
                if (thisx[2562] == 2)
                    return (_BYTE*)sub_47B91A(16, 208, byte_4B20A4, 0, dword_4B9248);
            }
        }
        else
        {
            return (_BYTE*)sub_47B91A(16, 208, byte_4B203C, 0, dword_4B9248);
        }
    }
    return result;
} 
int sub_4554F8(_DWORD* thisx)
{
    int result; // eax
    int i; // [esp+4h] [ebp-4h]

    result = (int)thisx;
    thisx[2273] = 0;
    for (i = 0; i < 32; ++i)
        result = sub_43F308((int)&thisx[4 * i + 2274]);
    return result;
}

 
int sub_455541(int thisx, char a2)
{
    int result; // eax
    int i; // [esp+10h] [ebp-4h]

    sub_45566E(thisx);
    *(_BYTE*)(thisx + 11364) = a2;
    *(_DWORD*)(thisx + 11368) = (_DWORD)operator new(4 * *(unsigned __int8*)(thisx + 11364));
    memset(*(void**)(thisx + 11368), 0, 4 * *(unsigned __int8*)(thisx + 11364));
    *(_BYTE*)(thisx + 11352) = a2 + 24;
    result = (int)operator new(*(unsigned __int8*)(thisx + 11352));
    *(_DWORD*)(thisx + 11356) = result;
    if (*(_DWORD*)(thisx + 11356))
    {
        *(_DWORD*)(thisx + 11360) = (_DWORD)operator new(4 * *(unsigned __int8*)(thisx + 11352));
        result = thisx;
        if (*(_DWORD*)(thisx + 11360))
        {
            for (i = 0; ; ++i)
            {
                result = *(unsigned __int8*)(thisx + 11352);
                if (i >= result)
                    break;
                *(_BYTE*)(*(_DWORD*)(thisx + 11356) + i) = 0;
                *(_DWORD*)(*(_DWORD*)(thisx + 11360) + 4 * i) = 0;
            }
        }
    }
    return result;
}

 
int sub_45566E(int thisx)
{
    int result; // eax

    if (*(_DWORD*)(thisx + 11368))
        operator delete(*(void**)(thisx + 11368));
    if (*(_DWORD*)(thisx + 11356))
        operator delete(*(void**)(thisx + 11356));
    if (*(_DWORD*)(thisx + 11360))
        operator delete(*(void**)(thisx + 11360));
    *(_BYTE*)(thisx + 11352) = 0;
    *(_BYTE*)(thisx + 11364) = 0;
    *(_DWORD*)(thisx + 11368) = 0;
    result = thisx;
    *(_DWORD*)(thisx + 11356) = 0;
    *(_DWORD*)(thisx + 11360) = 0;
    return result;
}

 
int sub_455722(int thisx, unsigned __int8 a2, int a3)
{
    int result; // eax

    result = a2;
    if (a2 < (int)*(unsigned __int8*)(thisx + 11364))
    {
        result = a2;
        *(_DWORD*)(*(_DWORD*)(thisx + 11368) + 4 * a2) = a3;
    }
    return result;
}

 
unsigned __int8* sub_45575F(unsigned __int8* thisx, int a1, int a2)
{
	return sub_488EAC(thisx + 128, a1, a2);
}

 
int sub_455782(int thisx)
{
    *(_DWORD*)(thisx + 104) = 5;
    *(_BYTE*)(thisx + 2516) = 1;
    *(_DWORD*)(thisx + 2512) = 0;
    *(_DWORD*)(thisx + 2528) = 0;
    *(_WORD*)(thisx + 2564) = 0;
    return sub_4557D1(thisx ,-1);
}

 
unsigned __int16 sub_4557D1(int thisx, int a2)
{
    unsigned __int16 result; // ax
    int v4; // [esp+4h] [ebp-110h]
    int v5; // [esp+8h] [ebp-10Ch]
    int i; // [esp+10h] [ebp-104h]
    CHAR String[256]; // [esp+14h] [ebp-100h] BYREF

    if (a2 == -1)
    {
        sub_451EB5((_BYTE*)thisx, 1, 1);
        sub_452045((_BYTE*)thisx, 13, 1, 14, 3);
        sub_47B91A(120, 16, byte_4B20CC, 0, dword_4B9248);
        sub_4557D1(thisx, 0);
        return sub_4557D1(thisx, -2);
    }
    else if (a2)
    {
        if (a2 == -2)
        {
            sub_451EB5((_BYTE*)thisx, 0, 1);
            if (*(_DWORD*)(thisx + 2528))
            {
                switch (*(_DWORD*)(thisx + 2528))
                {
                case 1:
                    return sub_47B91A(16, 208, byte_4B2250, 0, dword_4B9248);
                case 2:
                    return sub_47B91A(16, 208, byte_4B2274, 0, dword_4B9248);
                case 3:
                    return sub_47B91A(16, 208, byte_4B22A4, 0, dword_4B9248);
                case 4:
                    return sub_47B91A(16, 208, byte_4B22E4, 0, dword_4B9248);
                case 5:
                    return sub_47B91A(16, 208, byte_4B2310, 0, dword_4B9248);
                case 6:
                    return sub_47B91A(16, 208, byte_4B233C, 0, dword_4B9248);
                case 7:
                    sub_47B91A(16, 208, byte_4B2378, 0, dword_4B9248);
                    return sub_47B91A(16, 224, byte_4B23B0, 0, dword_4B9248);
                default:
                    result = thisx;
                    if (*(_DWORD*)(thisx + 2528) == 8)
                    {
                        return sub_47B91A(16, 208, byte_4B23F0, 0, dword_4B9248);
                    }
                    else if (*(_DWORD*)(thisx + 2528) == 9)
                    {
                        return sub_47B91A(16, 208, byte_4B2428, 0, dword_4B9248);
                    }
                    break;
                }
            }
            else
            {
                return sub_47B91A(16, 208, byte_4B2228, 0, dword_4B9248);
            }
        }
    }
    else
    {
        result = sub_452045((_BYTE*)thisx, 10, 5, 20, 18);
        for (i = 0; i < 7; ++i)
        {
            result = *(_WORD*)(thisx + 2564);
            v4 = result + i;
            v5 = 16 * i + 60;
            if (v4)
            {
                switch (v4)
                {
                case 1:
                    sub_47B91A(104, v5, byte_4B2100, 0, dword_4B9248);
                    switch (*(_BYTE*)(thisx + 2496))
                    {
                    case 1:
                        wsprintfA(String, a100);
                        break;
                    case 2:
                        wsprintfA(String, a50);
                        break;
                    case 3:
                        wsprintfA(String, a66);
                        break;
                    case 4:
                        wsprintfA(String, a75);
                        break;
                    case 5:
                        wsprintfA(String, a80);
                        break;
                    case 6:
                        wsprintfA(String, a83);
                        break;
                    case 7:
                        wsprintfA(String, a85);
                        break;
                    case 8:
                        wsprintfA(String, a87);
                        break;
                    case 9:
                        wsprintfA(String, a88);
                        break;
                    case 0xA:
                        wsprintfA(String, a90);
                        break;
                    }
                    result = sub_47B7ED(192, v5, String, 0, dword_4B9248);
                    break;
                case 2:
                    sub_47B91A(104, v5, byte_4B2160, 0, dword_4B9248);
                    if (*(_BYTE*)(thisx + 77))
                        result = sub_47B7ED(200, v5, aOn_0, 0, dword_4B9248);
                    else
                        result = sub_47B7ED(200, v5, (LPCSTR)off_4B2174, 0, dword_4B9248);
                    break;
                case 3:
                    sub_47B91A(104, v5, byte_4B2178, 0, dword_4B9248);
                    if (*(_BYTE*)(thisx + 81))
                        result = sub_47B7ED(200, v5, aOn_1, 0, dword_4B9248);
                    else
                        result = sub_47B7ED(200, v5, (LPCSTR)off_4B2190, 0, dword_4B9248);
                    break;
                case 4:
                    sub_47B91A(104, v5, byte_4B2194, 0, dword_4B9248);
                    if (dword_4B99F0)
                        result = sub_47B7ED(200, v5, aOn_2, 0, dword_4B9248);
                    else
                        result = sub_47B7ED(200, v5, (LPCSTR)off_4B21AC, 0, dword_4B9248);
                    break;
                case 5:
                    sub_47B91A(104, v5, byte_4B21B0, 0, dword_4B9248);
                    wsprintfA(String, "%d", *(unsigned __int8*)(thisx + 30));
                    result = sub_47B7ED(200, v5, String, 0, dword_4B9248);
                    break;
                case 6:
                    sub_47B91A(104, v5, byte_4B21C0, 0, dword_4B9248);
                    if (*(_BYTE*)(thisx + 78))
                        result = sub_47B7ED(200, v5, aOn_3, 0, dword_4B9248);
                    else
                        result = sub_47B7ED(200, v5, (LPCSTR)off_4B21DC, 0, dword_4B9248);
                    break;
                case 7:
                    sub_47B91A(104, v5, byte_4B21E0, 0, dword_4B9248);
                    if (*(_BYTE*)(thisx + 98))
                        result = sub_47B7ED(200, v5, aOn_4, 0, dword_4B9248);
                    else
                        result = sub_47B7ED(200, v5, (LPCSTR)off_4B21FC, 0, dword_4B9248);
                    break;
                case 8:
                    result = sub_47B91A(104, v5, byte_4B2200, 0, dword_4B9248);
                    break;
                case 9:
                    result = sub_47B91A(104, v5, byte_4B2218, 0, dword_4B9248);
                    break;
                }
            }
            else
            {
                sub_47B91A(104, v5, byte_4B20E4, 0, dword_4B9248);
                if (dword_4B99F4)
                    result = sub_47B7ED(200, v5, aOn, 0, dword_4B9248);
                else
                    result = sub_47B7ED(200, v5, (LPCSTR)off_4B20FC, 0, dword_4B9248);
            }
        }
    }
    return result;
}

 
_UnrealizedChore* sub_45612D(_DWORD* thisx, char a2, char a3, int a4, int a5, int a6)
{
	thisx[4100] = 1;
	return sub_488FA2(thisx + 32, a2, a3, a4, a5, a6);
}

 
int sub_456169(void* thisx)
{
    int result; // eax
    int i; // [esp+4h] [ebp-4h]

    for (i = 0; i < 32; ++i)
    {
        sub_442815((int)thisx + 36 * i + 9608);
        result = i + 1;
    }
    return result;
}

 
void sub_4561A5(char* thisx, int a2)
{
    int i; // [esp+4h] [ebp-4h]

    for (i = 0; i < 32; ++i)
    {
        if (!(unsigned __int8)MarkedForDetachment(&thisx[36 * i + 9608]))
        {
            sub_441980((int)&thisx[36 * i + 9608], a2);
            return;
        }
    }
}

 
int sub_456207()
{
    int m; // [esp+4h] [ebp-960h]
    DWORD v2; // [esp+8h] [ebp-95Ch] BYREF
    int k; // [esp+Ch] [ebp-958h]
    int v4; // [esp+10h] [ebp-954h]
    int i; // [esp+14h] [ebp-950h]
    DWORD NumberOfBytesRead; // [esp+18h] [ebp-94Ch] BYREF
    _DWORD v7[256]; // [esp+1Ch] [ebp-948h] BYREF
    HANDLE hFile; // [esp+41Ch] [ebp-548h]
    int j; // [esp+420h] [ebp-544h]
    _DWORD Buffer[256]; // [esp+424h] [ebp-540h] BYREF
    int v11; // [esp+824h] [ebp-140h] BYREF
    int v12; // [esp+828h] [ebp-13Ch]
    int v13; // [esp+82Ch] [ebp-138h]
    int v14; // [esp+830h] [ebp-134h]
    int v15; // [esp+834h] [ebp-130h]
    int v16; // [esp+838h] [ebp-12Ch]
    int v17; // [esp+848h] [ebp-11Ch]
    _DWORD* v18; // [esp+850h] [ebp-114h]
    CHAR FileName[260]; // [esp+860h] [ebp-104h] BYREF

    memset(v7, 0, sizeof(v7));
    memset(Buffer, 0, sizeof(Buffer));
    sub_49DB90(&v11);
    wsprintfA(FileName, aGraphic02ppale);
    hFile = CreateFileA(FileName, 0x80000000, 0, 0, 3u, 0x80u, 0);
    if (hFile != (HANDLE)-1)
    {
        for (i = 0; i < 256; ++i)
            ReadFile(hFile, &Buffer[i], 3u, (LPDWORD)&NumberOfBytesRead, 0);
        CloseHandle(hFile);
    }
    v18 = v7;
    for (j = 0; j < 4; ++j)
    {
        v4 = 1;
        for (k = 0; k < (int)dword_4B93A0; ++k)
        {
            if (*((__int16*)dword_4B9394 + k) >= 0 && *((__int16*)*(&dword_4B9370 + j) + k) >= 0)
            {
                memcpy(v7, Buffer, sizeof(v7));
                sub_485DFD((int)dword_4B93A4 + 24 * k, (int)v7);
                v12 = 0;
                v13 = 0;
                v14 = -1;
                v15 = -1;
                v16 = 1;
                v17 = 0;
                v11 = -1;
                wsprintfA(FileName, "Graphic\\Body%02d.bmp", j + 1);
                if (!sub_49DA45((_DWORD*)unk_4BDC60, FileName, (int)&v11))
                    return 0;
                if (v4)
                {
                    dword_4B9220[j] = v11;
                    v4 = 0;
                }
            }
        }
    }
    wsprintfA(FileName, aGraphic01ppale);
    hFile = CreateFileA(FileName, 0x80000000, 0, 0, 3u, 0x80u, 0);
    if (hFile != (HANDLE)-1)
    {
        for (m = 0; m < 256; ++m)
            ReadFile(hFile, &v7[m], 3u, (LPDWORD)&v2, 0);
        v18 = v7;
        CloseHandle(hFile);
    }
    j = 4;
    v12 = 0;
    v13 = 0;
    v14 = -1;
    v15 = -1;
    v16 = 1;
    v17 = 0;
    v11 = -1;
    wsprintfA(FileName, "Graphic\\Body%02d.bmp", 5);
    if (!sub_49DA45((_DWORD*)unk_4BDC60, FileName, (int)&v11))
        return 0;
    dword_4B9220[j] = v11;
    return 1;
}

 
__int16 sub_4565CF(int thisx)
{
    ++* (_DWORD*)(thisx + 11376);
    sub_456617(thisx);
    return sub_41D7FC((unsigned __int16*)(thisx + 2628), *(_DWORD*)(thisx + 11376) / 10);
}

 
int sub_456617(int thisx)
{
    int result; // eax

    if (*(_BYTE*)(thisx + 11372))
    {
        switch (*(_BYTE*)(thisx + 11372))
        {
        case 1:
            *(_DWORD*)(thisx + 11400) = 8 * ((*(_DWORD*)(thisx + 11376) + 10) / 10);
            break;
        case 2:
            *(_DWORD*)(thisx + 11400) = 10 * ((*(_DWORD*)(thisx + 11376) + 10) / 10);
            break;
        case 3:
            *(_DWORD*)(thisx + 11400) = 12 * ((*(_DWORD*)(thisx + 11376) + 10) / 10);
            break;
        case 4:
            *(_DWORD*)(thisx + 11400) = 15 * ((*(_DWORD*)(thisx + 11376) + 10) / 10);
            break;
        }
    }
    else
    {
        *(_DWORD*)(thisx + 11400) = 5 * ((*(_DWORD*)(thisx + 11376) + 10) / 10);
    }
    result = thisx;
    if (*(int*)(thisx + 11400) <= 0)
        *(_DWORD*)(thisx + 11400) = 1;
    return result;
}

 
__int16 sub_456738(int thisx, unsigned __int8 a2)
{
    int v2; // eax

    *(_WORD*)(thisx + 2 * a2 + 11404) = 60 * (*(_DWORD*)(thisx + 11376) + 10) / 20;
    if (*(_BYTE*)(thisx + 11372))
    {
        if (*(_BYTE*)(thisx + 11372) == 1)
        {
            v2 = 15 * *(__int16*)(thisx + 2 * a2 + 11404) / 10;
            *(_WORD*)(thisx + 2 * a2 + 11404) = v2;
        }
        else if (*(_BYTE*)(thisx + 11372) == 3)
        {
            v2 = 75 * *(__int16*)(thisx + 2 * a2 + 11404) / 100;
            *(_WORD*)(thisx + 2 * a2 + 11404) = v2;
        }
        else
        {
            v2 = *(unsigned __int8*)(thisx + 11372);
            if (v2 == 4)
            {
                LOWORD(v2) = *(__int16*)(thisx + 2 * a2 + 11404) / 2;
                *(_WORD*)(thisx + 2 * a2 + 11404) = v2;
            }
        }
    }
    else
    {
        LOWORD(v2) = 2 * *(_WORD*)(thisx + 2 * a2 + 11404);
        *(_WORD*)(thisx + 2 * a2 + 11404) = v2;
    }
    return v2;
}

 
int sub_456879(_DWORD* thisx, unsigned __int8 a2)
{
    char v2; // al
    unsigned __int8 v3; // al
    int v4; // eax
    int i; // [esp+4h] [ebp-8h]
    int v8; // [esp+8h] [ebp-4h]

    v8 = rand() % (int)Size;
    while (!byte_4B99CD)
    {
        for (i = 0;
            i < 8
            && (a2 == i
                || !unknown_libname_7(&thisx[153 * i + 657])
                || Concurrency::details::SchedulerBase::GetSchedulerProxy((Concurrency::details::SchedulerBase*)&thisx[153 * i + 657]) == (struct Concurrency::ISchedulerProxy*)80
                || v8 != (unsigned __int16)sub_43E600((short*)&thisx[153 * i + 657]));
            ++i)
        {
            ;
        }
        if (i == 8)
            break;
        if (++v8 == Size)
            v8 = 0;
    }
    sub_475010((short*)&thisx[153 * a2 + 657], v8);
    v2 = MarkedForDetachment((_BYTE*)(36 * v8 + dword_4B92E0));
    sub_474FF0((char*)&thisx[153 * a2 + 657], v2);
    v3 =  MarkedForDetachment((_BYTE*)(36 * v8 + dword_4B92E0));
    sub_474FD0(&thisx[153 * a2 + 657], dword_4B9220[v3]);
    sub_41D84A((_DWORD)&thisx[153 * a2 + 657]);
    sub_42371C((_DWORD)&thisx[153 * a2 + 657]);
    v4 = (_DWORD)sub_41F0A9(&thisx[153 * a2 + 657]);
    sub_41F712((_DWORD*)v4);
    return sub_41D697((_DWORD)&thisx[153 * a2 + 657]);
} 
void sub_456A74(char* thisx, int a2)
{
    int i; // [esp+4h] [ebp-4h]

    for (i = 0; i < 8; ++i)
    {
        if (!sub_426290((unsigned char*)&thisx[40 * i + 10760]))
        {
            sub_47EFF2((int)&thisx[40 * i + 10760], a2);
            return;
        }
    }
}

 
int sub_456AD1(char* thisx)
{
    int result; // eax
    int i; // [esp+4h] [ebp-4h]

    for (i = 0; i < 8; ++i)
    {
        sub_47F138(&thisx[40 * i + 10760]);
        result = i + 1;
    }
    return result;
}

 
int sub_456B0D(unsigned __int8* thisx, _DWORD* a2, int a3)
{
    int v4; // [esp+0h] [ebp-3Ch]
    int v5; // [esp+4h] [ebp-38h]
    int v6; // [esp+8h] [ebp-34h]
    int v8; // [esp+1Ch] [ebp-20h]
    int v9; // [esp+20h] [ebp-1Ch]
    int v10; // [esp+24h] [ebp-18h]
    int v11; // [esp+28h] [ebp-14h]
    int v12; // [esp+2Ch] [ebp-10h]
    int v13; // [esp+30h] [ebp-Ch]
    int i; // [esp+34h] [ebp-8h]
    int v15; // [esp+38h] [ebp-4h]

    v10 = sub_426090(a2) / 100;
    v8 = sub_4260B0(a2) / 100;
    v11 = -sub_4260D0(a2) / 100;
    v12 = 0;
    v9 = 0;
    v13 = 0;
    v15 = 0;
    for (i = 0; i < 8; ++i)
    {
        if (sub_426290(&thisx[40 * i + 10760]))
        {
            if (unknown_libname_22((int*)&thisx[40 * i + 10760]) - v10 <= 0)
                v6 = v10 - unknown_libname_22((int*)&thisx[40 * i + 10760]);
            else
                v6 = unknown_libname_22((int*)&thisx[40 * i + 10760]) - v10;
            if (unknown_libname_26((int*)&thisx[40 * i + 10760]) - v8 <= 0)
                v5 = v8 - unknown_libname_26((int*)&thisx[40 * i + 10760]);
            else
                v5 = unknown_libname_26((int*)&thisx[40 * i + 10760]) - v8;
            if (unknown_libname_12((int*)&thisx[40 * i + 10760]) - v11 <= 0)
                v4 = v11 - unknown_libname_12((int*)&thisx[40 * i + 10760]);
            else
                v4 = unknown_libname_12((int*)&thisx[40 * i + 10760]) - v11;
            if (a3)
            {
                if (v6 <= 16 && v5 <= 5 && v4 <= 4)
                    return (int)&thisx[40 * i + 10760];
            }
            else if (!v15 || v13 + v9 + v12 > v4 + v5 + v6)
            {
                v12 = v6;
                v9 = v5;
                v13 = v4;
                v15 = (int)&thisx[40 * i + 10760];
            }
        }
    }
    return v15;
}

 
int sub_456D33(const CHAR* thisx, LPCSTR lpString2, int a3, int a4)
{
    int v5; // eax
    CHAR String1[256]; // [esp+Ch] [ebp-224h] BYREF
    int v8[4]; // [esp+10Ch] [ebp-124h] BYREF
    int v9; // [esp+11Ch] [ebp-114h]
    CHAR String[260]; // [esp+120h] [ebp-110h] BYREF
    int v11; // [esp+22Ch] [ebp-4h]

    if (sub_475810((_DWORD*)unk_4BDB28) && !a4 && (!lpString2 || !lstrcmpiA(thisx + 13125, lpString2)))
        return 1;
    sub_440C04((_DWORD*)unk_4BDB28, 0);
    wsprintfA(String, "BGM\\%s", lpString2);
    v9 = lstrlenA(String);
    String[v9 - 3] = 116;
    String[v9 - 2] = 120;
    String[v9 - 1] = 116;
    sub_482BF0(v8);
    v11 = 0;
    if (sub_482C74((int)v8, String))
    {
        while (sub_482D44(v8, String1))
        {
            if (!lstrcmpiA(String1, aLooppos))
            {
                sub_482D44(v8, String1);
                v5 = atol(String1);
                sub_440C04((_DWORD*)unk_4BDB28, v5);
            }
        }
    }
    String[v9 - 3] = 119;
    String[v9 - 2] = 97;
    String[v9 - 1] = 118;
    if (sub_4404CB((_DWORD*)unk_4BDB28, String, a3))
    {
        lstrcpyA((LPSTR)thisx + 13125, lpString2);
        v11 = -1;
        sub_482C2F(v8);
        return 1;
    }
    else
    {
        v11 = -1;
        sub_482C2F(v8);
        return 0;
    }
} 
int sub_456F35(_DWORD* thisx)
{
    thisx[26] = 1;
    thisx[31] = 1;
    thisx[324] = 0;
    thisx[632] = 0;
    thisx[633] = 0;
    thisx[622] = 100;
    thisx[623] = 0;
    dword_4B93AC = 0;
    sub_4891E4(thisx + 32, aDemoOpeningTxt);
    sub_47F958(thisx + 184);
    return sub_456169(thisx);
}

 
void sub_456FC8(int thisx)
{
    int v2; // [esp+4h] [ebp-8h]
    int i; // [esp+8h] [ebp-4h]
    int j; // [esp+8h] [ebp-4h]
    int k; // [esp+8h] [ebp-4h]

    if (*(int*)(thisx + 2488) > 100)
        dword_4B99EC = 1;
    *(_DWORD*)(thisx + 2492) += *(_DWORD*)(thisx + 2488);
    while (*(int*)(thisx + 2492) >= 100)
    {
        *(_DWORD*)(thisx + 2492) -= 100;
        v2 = 1;
        if (dword_4B91D4 && !byte_4B91D1 || *(int*)(thisx + 2528) > 0)
            v2 = 0;
        if (v2)
        {
            sub_488981((int*)thisx + 128);
            for (i = 0; i < 32; ++i)
                sub_4419F6(thisx + 36 * i + 9608);
            for (j = 0; j < 8; ++j)
                sub_47F04A(thisx + 40 * j + 10760);
            if (*(_DWORD*)(thisx + 1292))
                sub_47F211(thisx + 736);
            byte_4B91D1 = 0;
            ++dword_4B93AC;
        }
    }
    sub_486476((_DWORD*)(thisx + 128));
    if (*(_BYTE*)(thisx + 11364))
        sub_44325C(thisx);
    for (k = 0; k < 32; ++k)
        sub_441DB3(thisx + 36 * k + 9608);
    if (*(_DWORD*)(thisx + 1292))
        sub_47F98B((_DWORD*)(thisx + 736));
    sub_477F0C(0);
    if (sub_476DC7(0, 0))
        *(_DWORD*)(thisx + 1296) = 1;
    if (*(_DWORD*)(thisx + 1296) && *(_BYTE*)(thisx + 2516) != 2)
        sub_4571BB(thisx);
}

 
void sub_4571BB(int thisx)
{
    int v1; // esi

    *(_BYTE*)(thisx + 2516) = 2;
    if (*(_DWORD*)(thisx + 108) != 2 && *(_DWORD*)(thisx + 104) == 1 && !*(_BYTE*)(thisx + 16140))
    {
        switch (*(_DWORD*)(thisx + 124))
        {
        case 1:
            *(_DWORD*)(thisx + 108) = 2;
            break;
        case 2:
            *(_DWORD*)(thisx + 108) = 17;
            break;
        case 3:
            ++ * (_BYTE*)(thisx + 11690);
            if (*(unsigned __int8*)(thisx + 11691) > 6u)
                sub_462869((_DWORD*)thisx);
            else
                sub_462BA9(thisx, 3);
            *(_DWORD*)(thisx + 108) = 11;
            break;
        case 4:
            *(_DWORD*)(thisx + 108) = 11;
            if (dword_4B9B08 == 1)
            {
                *(_BYTE*)(thisx + 11690) += 2;
                sub_462BA9(thisx, 4);
            }
            else if (dword_4B9AF8 < 0)
            {
                *(_DWORD*)(thisx + 108) = 1;
                *(_DWORD*)(thisx + 120) = 5;
            }
            else
            {
                ++* (_BYTE*)(thisx + 11690);
                sub_462BA9(thisx, 2);
            }
            break;
        case 5:
        case 7:
            if (*(unsigned __int8*)(thisx + 11806) != 255)
                ++* (_BYTE*)(thisx + 11806);
            *(_BYTE*)(thisx + 11690) = 0;
            v1 = (unsigned __int16)sub_4750D0((void*)(thisx + 11816));
            *(_WORD*)(thisx + 11814) = (v1 + (unsigned __int16)sub_4750D0((void*)(thisx + 11892)) / 2);
            *(_DWORD*)(thisx + 124) = 5;
            *(_DWORD*)(thisx + 112) = 1;
            *(_DWORD*)(thisx + 108) = 20;
            *(_BYTE*)(thisx + 2562) = 1;
            break;
        case 6:
            *(_DWORD*)(thisx + 108) = 1;
            *(_DWORD*)(thisx + 120) = 5;
            break;
        default:
            return;
        }
    }
} 

int sub_4573CB(int thisx, char a2, int a3, char a4)
{
    int result; // eax

    *(_BYTE*)(thisx + 11420) = a2;
    *(_DWORD*)(thisx + 11424) = a3;
    *(_DWORD*)(thisx + 11428) = a3;
    result = thisx;
    *(_BYTE*)(thisx + 11421) = a4;
    return result;
}

 
int __fastcall sub_457408(int a1)
{
    int result; // eax
    int v2; // eax
    int v3; // edx
    struct tagRECT rc; // [esp+4h] [ebp-14h] BYREF
    int v6; // [esp+14h] [ebp-4h]

    if (*(int*)(a1 + 11424) > 0)
        --* (_DWORD*)(a1 + 11424);
    LOBYTE(v6) = 0;
    if (*(int*)(a1 + 11428) > 0)
        LOBYTE(v6) = (*(_DWORD*)(a1 + 11424) << 6) / *(_DWORD*)(a1 + 11428);
    if (*(_BYTE*)(a1 + 11420) == 1)
    {
        *(_BYTE*)(a1 + 11432) = 64 - v6;
    }
    else if (*(_BYTE*)(a1 + 11420) == 2)
    {
        *(_BYTE*)(a1 + 11432) = v6;
    }
    if (!*(_DWORD*)(a1 + 11424))
        *(_BYTE*)(a1 + 11420) = 0;
    if (*(_BYTE*)(a1 + 11432) && *(unsigned __int8*)(a1 + 11432) < 0x40u)
    {
        SetRect(&rc, 0, 0, 320, 240);
        if (*(_BYTE*)(a1 + 11421))
            return sub_49EF70((int)unk_4BDC60, (_DWORD*)&rc, 0xFFu, 0xFFu, 0xFFu, *(_BYTE*)(a1 + 11432));
        else
            return sub_49EF70((int)unk_4BDC60, (_DWORD*)&rc, 0, 0, 0, *(_BYTE*)(a1 + 11432));
    }
    else
    {
        result = *(unsigned __int8*)(a1 + 11432);
        if (result == 64)
        {
            if (*(_BYTE*)(a1 + 11421))
            {
                result = a1;
                if (*(_BYTE*)(a1 + 11421) == 1)
                {
                    v2 = sub_49FFEC(255, 255, 255);
                    return (int)sub_49EDC1((int)unk_4BDC60, v3, 0, v2);
                }
            }
            else
            {
                return (int)sub_49EDC1((int)unk_4BDC60, *(unsigned __int8*)(a1 + 11421), 0, 0);
            }
        }
    }
    return result;
} 
char sub_4575B4(unsigned __int8* thisx, int a2, int a3)
{
    int v5; // [esp+4h] [ebp-10h]
    char v6; // [esp+8h] [ebp-Ch]
    int v7; // [esp+Ch] [ebp-8h]
    int i; // [esp+10h] [ebp-4h]

    if (a2 < 0 || a2 >= 8)
        return 0;
    if (a3)
        v5 = a2;
    else
        v5 = sub_4576F0(a2);
    v6 = 0;
    v7 = 0;
    for (i = 0; i < (unsigned __int8)byte_4B9990; ++i)
    {
        v7 += thisx[i + 2546];
        ++v6;
        if (v7 > v5)
            return v6 - 1;
    }
    return 0;
}

 
char sub_457659(unsigned __int8* thisx, int a2, int a3)
{
    char v5; // [esp+4h] [ebp-10h]
    int v6; // [esp+8h] [ebp-Ch]
    int i; // [esp+Ch] [ebp-8h]
    char v8; // [esp+10h] [ebp-4h]

    if (a2 < 0 || a2 >= 8)
        return 0;
    v8 = sub_4575B4(thisx, a2, a3);
    v6 = a2;
    if (a3)
        v6 = (unsigned __int8)byte_4B9988[a2];
    v5 = 0;
    for (i = 0; i < v6; ++i)
    {
        if (sub_4575B4(thisx, i, 0) == v8)
            ++v5;
    }
    return v5;
}

 
int __stdcall sub_4576F0(int a1)
{
    int i; // [esp+4h] [ebp-4h]

    for (i = 0; i < 8; ++i)
    {
        if ((unsigned __int8)byte_4B9988[i] == a1)
            return i;
    }
    return -1;
}

 
int sub_457731(_DWORD* thisx, _DWORD* a2)
{
    int v3; // [esp+4h] [ebp-3Ch]
    int v4; // [esp+8h] [ebp-38h]
    int v5; // [esp+Ch] [ebp-34h]
    int v7; // [esp+14h] [ebp-2Ch]
    int v8; // [esp+18h] [ebp-28h]
    int v9; // [esp+1Ch] [ebp-24h]
    int v10; // [esp+20h] [ebp-20h]
    int v11; // [esp+24h] [ebp-1Ch]
    int v12; // [esp+28h] [ebp-18h]
    int i; // [esp+2Ch] [ebp-14h]
    unsigned __int8 v14; // [esp+30h] [ebp-10h]
    int v15; // [esp+34h] [ebp-Ch]
    char v16; // [esp+38h] [ebp-8h]
    int v17; // [esp+3Ch] [ebp-4h]

    if (!a2)
        return 0;
    v12 = sub_426090(a2);
    v11 = sub_4260B0(a2);
    v14 = sub_425EF0((char*)a2);
    v16 = sub_426070((char*)a2);
    v17 = sub_425D70(a2);
    v10 = 0;
    v15 = -1;
    for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
    {
        if (i != v14
            && v16 != sub_426070((char*)&thisx[153 * i + 657])
            && unknown_libname_7(&thisx[153 * i + 657])
            && !sub_4263D0((unsigned __int8*)&thisx[153 * i + 657])
            && !sub_41BE56(&thisx[153 * i + 657]))
        {
            v9 = sub_426090(&thisx[153 * i + 657]);
            v8 = sub_4260B0(&thisx[153 * i + 657]);
            v5 = v11 - v8 <= 0 ? v8 - v11 : v11 - v8;
            if (v5 <= 500)
            {
                if ((v7 = v12 - v9, !v17) && v7 > 0 || v17 && v7 < 0)
                {
                    if (!v10 || (v7 <= 0 ? (v4 = v9 - v12) : (v4 = v12 - v9), v15 > v4))
                    {
                        v10 = (int)&thisx[153 * i + 657];
                        if (v7 <= 0)
                            v3 = v9 - v12;
                        else
                            v3 = v12 - v9;
                        v15 = v3;
                    }
                }
            }
        }
    }
    return v10;
}

 
int sub_457930(int thisx)
{
    *(_DWORD*)(thisx + 104) = 13;
    *(_BYTE*)(thisx + 2516) = 1;
    *(_DWORD*)(thisx + 2528) = 0;
    *(_DWORD*)(thisx + 2532) = 0;
    *(_WORD*)(thisx + 2564) = 0;
    *(_WORD*)(thisx + 2566) = 4;
    *(_WORD*)(thisx + 2570) = 0;
    if (*(_DWORD*)(thisx + 112) == 14)
    {
        sub_45938D((_BYTE*)(thisx + 76 * *(unsigned __int16*)(thisx + 2568) + 11816));
    }
    else
    {
        *(_WORD*)(thisx + 2568) = 0;
        sub_45938D((_BYTE*)(thisx + 11816));
        sub_45938D((_BYTE*)(thisx + 11892));
    }
    return sub_4579E8(thisx, -1);
}

 
int sub_4579E8(int thisx, int a2)
{
    int result; // eax
    CHAR v4[256]; // [esp+4h] [ebp-214h] BYREF
    CHAR String[256]; // [esp+104h] [ebp-114h] BYREF
    int v6; // [esp+204h] [ebp-14h]
    int j; // [esp+208h] [ebp-10h]
    int v8; // [esp+20Ch] [ebp-Ch]
    int v9; // [esp+210h] [ebp-8h]
    int i; // [esp+214h] [ebp-4h]

    if (a2 == -1)
    {
        sub_451EB5((_BYTE*)thisx, 1, 0);
        sub_4579E8(thisx, 1);
        sub_4579E8(thisx, 0);
        return sub_4579E8(thisx, 2);
    }
    else if (a2)
    {
        if (a2 == 1)
        {
            sub_452045((_BYTE*)thisx, 6, 0, 28, 7);
            sub_47B91A(72, 40, byte_4B2510, 0, dword_4B9248);
            sub_47B91A(136, 40, byte_4B2518, 0, dword_4B9248);
            sub_47B91A(160, 40, byte_4B251C, 0, dword_4B9248);
            sub_47B91A(184, 40, byte_4B2520, 0, dword_4B9248);
            sub_47B91A(184, 16, byte_4B2530, 0, dword_4B9248);
            return sub_47B91A(240, 24, byte_4B253C, 0, dword_4B9248);
        }
        else if (a2 == 2)
        {
            sub_451EB5((_BYTE*)thisx, 0, 1);
            LOBYTE(v6) = *(_BYTE*)(thisx + 2566);
            if ((_BYTE)v6)
            {
                if ((unsigned __int8)v6 == 1)
                {
                    return sub_47B91A(16, 208, byte_4B2570, 0, dword_4B9248);
                }
                else
                {
                    result = (unsigned __int8)v6;
                    switch ((unsigned __int8)v6)
                    {
                    case 2u:
                        return sub_47B91A(16, 208, byte_4B259C, 0, dword_4B9248);
                    case 3u:
                        sub_47B91A(16, 208, byte_4B25C8, 0, dword_4B9248);
                        return sub_47B91A(16, 224, byte_4B25E0, 0, dword_4B9248);
                    case 4u:
                        wsprintfA(v4, "%dP", *(unsigned __int16*)(thisx + 2568) + 1);
                        sub_47B7ED(16, 208, v4, 0, dword_4B9248);
                        sub_47B91A(32, 208, byte_4B260C, 0, dword_4B9248);
                        return sub_47B91A(128, 224, byte_4B2640, 0, dword_4B9248);
                    }
                }
            }
            else
            {
                wsprintfA(String, "%dP", *(unsigned __int16*)(thisx + 2568) + 1);
                sub_47B7ED(16, 208, String, 0, dword_4B9248);
                return sub_47B91A(32, 208, byte_4B2544, 0, dword_4B9248);
            }
        }
    }
    else
    {
        sub_452045((_BYTE*)thisx, 6, 8, 28, 15);
        v9 = 64;
        v8 = 80;
        for (i = 0; i < 6; ++i)
        {
            for (j = 0; j < 10; ++j)
                sub_47B91A(
                    16 * j + v9 + 8 * (j >= 5),
                    16 * i + v8,
                    (LPCSTR)&byte_4B0710[180 * *(unsigned __int16*)(thisx + 2564) + 30 * i + 3 * j],
                    0,
                    dword_4B9248);
        }
        sub_47B91A(v9 + 164, v8 - 5, byte_4B24D4, 0, dword_4B9248);
        sub_47B91A(v9 + 182, v8 - 3, byte_4B24D8, 0, dword_4B9248);
        sub_47B91A(v9 + 168, v8 + 16, byte_4B24DC, 0, dword_4B9248);
        if (*(_WORD*)(thisx + 2564))
            sub_47B91A(v9 + 168, v8 + 32, byte_4B24EC, 0, dword_4B9248);
        else
            sub_47B91A(v9 + 168, v8 + 32, byte_4B24E0, 0, dword_4B9248);
        sub_47B91A(v9 + 168, v8 + 48, byte_4B24F8, 0, dword_4B9248);
        sub_47B91A(v9 + 168, v8 + 64, byte_4B2500, 0, dword_4B9248);
        return sub_47B91A(v9 + 168, v8 + 80, byte_4B2508, 0, dword_4B9248);
    }
    return result;
} 
int sub_457F11(int thisx)
{
    int v1; // ecx
    int v2; // esi
    int v3; // edx
    int v4; // eax
    int v5; // esi
    int v6; // ecx
    int v7; // eax
    int v8; // ecx
    int result; // eax
    char* v10; // eax
    char v11; // al
    CHAR v13[256]; // [esp+Ch] [ebp-424h] BYREF
    CHAR v14[256]; // [esp+10Ch] [ebp-324h] BYREF
    CHAR v15[256]; // [esp+214h] [ebp-21Ch] BYREF
    int v16; // [esp+314h] [ebp-11Ch]
    CHAR v17[64]; // [esp+318h] [ebp-118h] BYREF
    int v18; // [esp+358h] [ebp-D8h]
    CHAR String[64]; // [esp+35Ch] [ebp-D4h] BYREF
    _BYTE v20[4]; // [esp+39Ch] [ebp-94h]
    int j; // [esp+3A0h] [ebp-90h]
    CHAR v22[4]; // [esp+3A4h] [ebp-8Ch] BYREF
    int m; // [esp+3A8h] [ebp-88h]
    int k; // [esp+3ACh] [ebp-84h]
    CHAR String1; // [esp+3B0h] [ebp-80h] BYREF
    char v26; // [esp+3B1h] [ebp-7Fh]
    char v27; // [esp+3B2h] [ebp-7Eh]
    BOOL v28; // [esp+3B4h] [ebp-7Ch]
    BOOL v29; // [esp+3B8h] [ebp-78h]
    char* v30; // [esp+3BCh] [ebp-74h]
    int v31; // [esp+3C0h] [ebp-70h]
    int v32; // [esp+3C4h] [ebp-6Ch]
    int v33; // [esp+3C8h] [ebp-68h]
    int v34; // [esp+3CCh] [ebp-64h]
    int i; // [esp+3D0h] [ebp-60h]
    unsigned __int8 v36; // [esp+3D4h] [ebp-5Ch]
    unsigned __int8 v37; // [esp+3D5h] [ebp-5Bh]
    int v38; // [esp+3D8h] [ebp-58h]
    int v39; // [esp+3DCh] [ebp-54h]
    int v40; // [esp+3E0h] [ebp-50h]
    int v41; // [esp+3E4h] [ebp-4Ch]
    int n; // [esp+3E8h] [ebp-48h]
    int v43; // [esp+3ECh] [ebp-44h]
    int v44; // [esp+3F0h] [ebp-40h]
    int v45; // [esp+3F4h] [ebp-3Ch]
    int v46[14]; // [esp+3F8h] [ebp-38h] BYREF

    LOBYTE(v44) = *(_BYTE*)(thisx + 2568);
    LOBYTE(v45) = *(_BYTE*)(thisx + 2566);
    sub_477F0C(v44);
    v41 = 0;
    v40 = 0;
    if (!*(_BYTE*)(thisx + 2516))
    {
        LOBYTE(v1) = v44;
        v2 = sub_476D78(v1);
        LOBYTE(v3) = v44;
        v4 = sub_476D29(v3);
        v41 = v2 - v4;
        LOBYTE(v4) = v44;
        v5 = sub_476CDA(v4);
        LOBYTE(v6) = v44;
        v40 = v5 - sub_476C8B(v6);
    }
    v7 = *(unsigned __int8*)(thisx + 2516);
    if (!*(_BYTE*)(thisx + 2516))
    {
        if (v41 || v40)
        {
            sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
            if ((_BYTE)v45)
            {
                if ((unsigned __int8)v45 == 1)
                {
                    for (i = 0; i < 2; ++i)
                        *(&v36 + i) = sub_45943B((_BYTE*)(thisx + 76 * (unsigned __int8)v44 + 11816), i) - 1;
                    if (*(_DWORD*)(thisx + 2528))
                    {
                        if (*(_DWORD*)(thisx + 2528) == 1)
                        {
                            v34 = 31;
                            LOBYTE(v33) = v36 + 1;
                            if ((unsigned __int8)(v36 + 1) == 2)
                            {
                                v34 = 29;
                            }
                            else if ((unsigned __int8)v33 == 4
                                || (unsigned __int8)v33 == 6
                                || (unsigned __int8)v33 == 9
                                || (unsigned __int8)v33 == 11)
                            {
                                v34 = 30;
                            }
                            v37 = (v34 + v40 + v37) % v34;
                        }
                    }
                    else
                    {
                        v36 = (v36 + v40 + 12) % 12;
                    }
                    sub_459461((_BYTE*)(thisx + 76 * (unsigned __int8)v44 + 11816), v36 + 1, v37 + 1);
                }
                else if ((unsigned __int8)v45 == 2)
                {
                    LOBYTE(v32) = ((unsigned __int8)sub_475EB0((char*)thisx + 76 * (unsigned __int8)v44 + 11816) + v40 + 4) % 4;
                    sub_475830((_BYTE*)(thisx + 76 * (unsigned __int8)v44 + 11816), v32);
                }
                else if ((unsigned __int8)v45 == 3 && v41)
                {
                    *(_DWORD*)(thisx + 2528) = *(_DWORD*)(thisx + 2528) == 0;
                }
                else if ((unsigned __int8)v45 == 4 && v41)
                {
                    *(_DWORD*)(thisx + 2528) = *(_DWORD*)(thisx + 2528) == 0;
                }
            }
            else
            {
                v39 = v41 + *(_DWORD*)(thisx + 2528);
                v38 = v40 + *(_DWORD*)(thisx + 2532);
                if (v39 < 0)
                {
                    if (v38)
                        v39 = 10;
                    else
                        v39 = 11;
                }
                if (v38 < 0)
                    v38 = 5;
                if (v39 <= 11 || v38)
                {
                    if (v39 > 10 && v38 > 0 && v38 < 6)
                    {
                        if (v40)
                            v39 = 10;
                        if (v41)
                            v39 = 0;
                    }
                }
                else
                {
                    v39 = 0;
                }
                if (v38 > 5)
                    v38 = 0;
                *(_DWORD*)(thisx + 2528) = v39;
                *(_DWORD*)(thisx + 2532) = v38;
            }
        }
        else
        {
            LOBYTE(v7) = v44;
            if (sub_476DC7(v7, 0))
            {
                sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
                if ((_BYTE)v45)
                {
                    switch ((unsigned __int8)v45)
                    {
                    case 1u:
                        if (++ * (_DWORD*)(thisx + 2528) == 2)
                        {
                            ++* (_WORD*)(thisx + 2566);
                            sub_4579E8(thisx, 2);
                        }
                        break;
                    case 2u:
                        ++ * (_WORD*)(thisx + 2566);
                        *(_DWORD*)(thisx + 2528) = 0;
                        sub_4579E8(thisx, 2);
                        break;
                    case 3u:
                        if (!*(_DWORD*)(thisx + 2528))
                        {
                            sub_45948C(thisx + 76 * *(unsigned __int16*)(thisx + 2568) + 11816);
                            *(_DWORD*)(thisx + 108) = 14;
                            *(_BYTE*)(thisx + 2516) = 2;
                            *(_BYTE*)(thisx + 2562) = 0;
                            result = thisx;
                            *(_WORD*)(thisx + 2566) = 0;
                            return result;
                        }
                        if (*(_DWORD*)(thisx + 2528) == 1)
                        {
                            --* (_WORD*)(thisx + 2566);
                            *(_DWORD*)(thisx + 2528) = 0;
                            sub_4579E8(thisx, -1);
                        }
                        break;
                    case 4u:
                        if (*(_DWORD*)(thisx + 2528))
                        {
                            if (*(_DWORD*)(thisx + 2528) == 1)
                            {
                                *(_BYTE*)(thisx + 2562) = 3;
                                *(_DWORD*)(thisx + 108) = 14;
                                result = thisx;
                                *(_BYTE*)(thisx + 2516) = 2;
                                return result;
                            }
                        }
                        else
                        {
                            *(_WORD*)(thisx + 2566) = 0;
                            sub_4579E8(thisx, -1);
                        }
                        break;
                    }
                }
                else
                {
                    v30 = sub_4266D0((char*)(thisx + 76 * (unsigned __int8)v44 + 11816));
                    LOBYTE(v31) = 2 * *(_WORD*)(thisx + 2570);
                    if (*(int*)(thisx + 2528) >= 10 || *(int*)(thisx + 2532) >= 6)
                    {
                        if (*(int*)(thisx + 2528) < 10 || *(_DWORD*)(thisx + 2532))
                        {
                            if (*(_DWORD*)(thisx + 2528) == 10 && *(_DWORD*)(thisx + 2532) == 1)
                            {
                                memcpy(&v30[(unsigned __int8)v31], &unk_4B265C, 2u);
                                if (++ * (_WORD*)(thisx + 2570) == 5)
                                    *(_WORD*)(thisx + 2570) = 4;
                            }
                            else if (*(_DWORD*)(thisx + 2528) == 10 && *(_DWORD*)(thisx + 2532) == 2)
                            {
                                *(_WORD*)(thisx + 2564) = *(_WORD*)(thisx + 2564) == 0;
                                sub_4579E8(thisx, 0);
                            }
                            else if (*(_DWORD*)(thisx + 2528) == 10 && *(_DWORD*)(thisx + 2532) == 3)
                            {
                                if (*(unsigned __int16*)(thisx + 2570) < 4u)
                                    ++* (_WORD*)(thisx + 2570);
                            }
                            else if (*(_DWORD*)(thisx + 2528) == 10 && *(_DWORD*)(thisx + 2532) == 4)
                            {
                                if (*(_WORD*)(thisx + 2570))
                                    --* (_WORD*)(thisx + 2570);
                            }
                            else if (*(_DWORD*)(thisx + 2528) == 10 && *(_DWORD*)(thisx + 2532) == 5)
                            {
                                wsprintfA(v22, byte_4B2660);
                                for (j = 0; j < 5 && v30[2 * j] == v22[0] && v30[2 * j + 1] == v22[1]; ++j)
                                    ;
                                if (j < 5)
                                {
                                    ++* (_WORD*)(thisx + 2566);
                                    *(_DWORD*)(thisx + 2528) = 0;
                                    sub_4579E8(thisx, 2);
                                }
                            }
                        }
                        else
                        {
                            v28 = *(_DWORD*)(thisx + 2528) == 10;
                            v29 = *(_DWORD*)(thisx + 2528) == 11;
                            String1 = v30[(unsigned __int8)v31];
                            v26 = v30[(unsigned __int8)v31 + 1];
                            v27 = 0;
                            if (!lstrcmpiA(&String1, byte_4B2658) && (unsigned __int8)v31 > 1u)
                            {
                                LOBYTE(v31) = v31 - 2;
                                String1 = v30[(unsigned __int8)v31];
                                v26 = v30[(unsigned __int8)v31 + 1];
                                v27 = 0;
                            }
                            if (v28)
                            {
                                for (k = 0; k < 81 && (byte_4B4530[3 * k] != String1 || byte_4B4531[3 * k] != v26); ++k)
                                    ;
                                if (k < 81)
                                {
                                    memcpy(&v30[(unsigned __int8)v31], &byte_4B443C[3 * k], 2u);
                                    if ((unsigned __int8)v31 / 2 == *(_WORD*)(thisx + 2570))
                                        ++* (_WORD*)(thisx + 2570);
                                    if (*(_WORD*)(thisx + 2570) == 5)
                                        *(_WORD*)(thisx + 2570) = 4;
                                }
                            }
                            else if (v29)
                            {
                                for (m = 0; m < 10 && (byte_4B4644[3 * m] != String1 || byte_4B4645[3 * m] != v26); ++m)
                                    ;
                                if (m < 10)
                                {
                                    memcpy(&v30[(unsigned __int8)v31], &byte_4B4624[3 * m], 2u);
                                    if ((unsigned __int8)v31 / 2 == *(_WORD*)(thisx + 2570))
                                        ++* (_WORD*)(thisx + 2570);
                                    if (*(_WORD*)(thisx + 2570) == 5)
                                        *(_WORD*)(thisx + 2570) = 4;
                                }
                            }
                        }
                    }
                    else
                    {
                        memcpy(
                            &v30[(unsigned __int8)v31],
                            &byte_4B0710[180 * *(unsigned __int16*)(thisx + 2564)
                            + 30 * *(_DWORD*)(thisx + 2532)
                            + 3 * *(_DWORD*)(thisx + 2528)],
                            2u);
                        if (++ * (_WORD*)(thisx + 2570) == 5)
                            *(_WORD*)(thisx + 2570) = 4;
                    }
                }
            }
            else
            {
                LOBYTE(v8) = v44;
                if (sub_476DC7(v8, 1))
                {
                    sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
                    if ((_BYTE)v45)
                    {
                        switch ((unsigned __int8)v45)
                        {
                        case 1u:
                            if (*(_DWORD*)(thisx + 2528))
                            {
                                *(_DWORD*)(thisx + 2528) = 0;
                                sub_459461((_BYTE*)(thisx + 76 * (unsigned __int8)v44 + 11816), -1, 1);
                            }
                            else
                            {
                                *(_WORD*)(thisx + 2566) = 0;
                                *(_WORD*)(thisx + 2570) = 0;
                                *(_DWORD*)(thisx + 2528) = 0;
                                *(_DWORD*)(thisx + 2532) = 0;
                                sub_4579E8(thisx, -1);
                            }
                            break;
                        case 2u:
                            -- * (_WORD*)(thisx + 2566);
                            *(_DWORD*)(thisx + 2528) = 1;
                            sub_4579E8(thisx, -1);
                            break;
                        case 3u:
                            -- * (_WORD*)(thisx + 2566);
                            *(_DWORD*)(thisx + 2528) = 0;
                            sub_4579E8(thisx, -1);
                            break;
                        }
                    }
                    else if (*(_WORD*)(thisx + 2570))
                    {
                        --* (_WORD*)(thisx + 2570);
                    }
                    else
                    {
                        *(_WORD*)(thisx + 2566) = 4;
                        *(_DWORD*)(thisx + 2528) = 0;
                        *(_DWORD*)(thisx + 2532) = 0;
                        sub_4579E8(thisx, -1);
                    }
                }
            }
        }
    }
    LOBYTE(v45) = *(_BYTE*)(thisx + 2566);
    sub_49C15E((int)v46);
    v46[1] = 0;
    v46[2] = 0;
    v46[0] = dword_4B9248;
    sub_49AB05((int)unk_4BDC60, v46);
    v10 = sub_4266D0((char*)(thisx + 76 * (unsigned __int8)v44 + 11816));
    sub_47B91A(72, 16, v10, 0, -1);
    LOBYTE(v43) = *(_BYTE*)(thisx + 2570);
    for (n = 0; n < 5; ++n)
    {
        if ((_BYTE)v45 || (unsigned __int8)v43 != n || ((unsigned int)dword_4B93B0 >> 1) % 2)
            sub_47B91A(8 * n + 72, 22, byte_4B2664, 0, -1);
    }
    if ((_BYTE)v45 && (unsigned __int8)v45 < 4u)
    {
        for (n = 0; n < 2; ++n)
        {
            v11 = sub_45943B((_BYTE*)(thisx + 76 * (unsigned __int8)v44 + 11816), n);
            v20[n] = v11;
        }
        for (n = 0; n < 2; ++n)
        {
            if ((unsigned __int8)v45 != 1 || *(_DWORD*)(thisx + 2528) != n || ((unsigned int)dword_4B93B0 >> 1) % 4)
            {
                wsprintfA(String, "%2d", (unsigned __int8)v20[n]);
                sub_47B7ED(24 * n + 120, 40, String, 0, -1);
            }
        }
        if ((unsigned __int8)v45 > 1u)
        {
            v18 = v20[1] + 100 * v20[0];
            if (v18 > 119)
            {
                if (v18 > 218)
                {
                    if (v18 > 320)
                    {
                        if (v18 > 419)
                        {
                            if (v18 > 520)
                            {
                                if (v18 > 621)
                                {
                                    if (v18 > 722)
                                    {
                                        if (v18 > 822)
                                        {
                                            if (v18 > 922)
                                            {
                                                if (v18 > 1023)
                                                {
                                                    if (v18 > 1121)
                                                    {
                                                        if (v18 > 1221)
                                                            wsprintfA(String, byte_4B26FC);
                                                        else
                                                            wsprintfA(String, byte_4B26F0);
                                                    }
                                                    else
                                                    {
                                                        wsprintfA(String, byte_4B26E4);
                                                    }
                                                }
                                                else
                                                {
                                                    wsprintfA(String, byte_4B26D8);
                                                }
                                            }
                                            else
                                            {
                                                wsprintfA(String, byte_4B26CC);
                                            }
                                        }
                                        else
                                        {
                                            wsprintfA(String, byte_4B26C0);
                                        }
                                    }
                                    else
                                    {
                                        wsprintfA(String, byte_4B26B4);
                                    }
                                }
                                else
                                {
                                    wsprintfA(String, byte_4B26A8);
                                }
                            }
                            else
                            {
                                wsprintfA(String, byte_4B269C);
                            }
                        }
                        else
                        {
                            wsprintfA(String, byte_4B2690);
                        }
                    }
                    else
                    {
                        wsprintfA(String, byte_4B2684);
                    }
                }
                else
                {
                    wsprintfA(String, byte_4B2678);
                }
            }
            else
            {
                wsprintfA(String, byte_4B266C);
            }
            sub_47B91A(192, 40, String, 0, -1);
        }
    }
    if ((unsigned __int8)v45 > 1u
        && (unsigned __int8)v45 < 4u
        && ((unsigned __int8)v45 != 2 || ((unsigned int)dword_4B93B0 >> 1) % 4))
    {
        LOBYTE(v16) = sub_475EB0((char*)thisx + 76 * (unsigned __int8)v44 + 11816);
        switch ((char)v16)
        {
        case 0:
            wsprintfA(v17, aA_0);
            break;
        case 1:
            wsprintfA(v17, aB_0);
            break;
        case 2:
            wsprintfA(v17, aAb);
            break;
        case 3:
            wsprintfA(v17, aO);
            break;
        default:
            break;
        }
        sub_47B7ED(224, 24, v17, 0, -1);
    }
    if ((_BYTE)v45)
    {
        if ((unsigned __int8)v45 == 3)
        {
            wsprintfA(v14, "%d>", (unsigned __int8)v44 + 1);
            return sub_47B91A(48 * *(_DWORD*)(thisx + 2528) + 70, 224, v14, 0, -1);
        }
        else
        {
            result = (unsigned __int8)v45;
            if ((unsigned __int8)v45 == 4)
            {
                wsprintfA(v13, "%d>", (unsigned __int8)v44 + 1);
                return sub_47B91A(48 * *(_DWORD*)(thisx + 2528) + 116, 224, v13, 0, -1);
            }
        }
    }
    else
    {
        wsprintfA(v15, "%d>", (unsigned __int8)v44 + 1);
        return sub_47B91A(
            16 * *(_DWORD*)(thisx + 2528) + 56 + 8 * (*(_DWORD*)(thisx + 2528) >= 5),
            16 * *(_DWORD*)(thisx + 2532) + 80,
            v15,
            0,
            -1);
    }
    return result;
}

 
_BYTE* sub_45938D(_BYTE* thisx)
{
    _BYTE* result; // eax
    int i; // [esp+4h] [ebp-4h]

    memset(thisx + 2, 0, 0xBu);
    memcpy(thisx + 2, &unk_4B2724, 0xBu);
    thisx[13] = 1;
    thisx[14] = 1;
    thisx[15] = 0;
    thisx[27] = 0;
    thisx[58] = 0;
    thisx[59] = 0;
    thisx[60] = 0;
    thisx[63] = 0;
    thisx[64] = 0;
    thisx[65] = 0;
    result = thisx;
    thisx[66] = 0;
    thisx[67] = 0;
    for (i = 0; i < 5; ++i)
    {
        result = &thisx[i];
        thisx[i + 71] = 0;
    }
    return result;
}

 
char sub_45943B(_BYTE* thisx, int a2)
{
    if (a2 >= 0 && a2 <= 1)
        return thisx[a2 + 13];
    else
        return 0;
}

 
char sub_459461(_BYTE* thisx, int a2, int a3)
{
    char result; // al

    if (a2 > 0)
    {
        result = (char)thisx;
        thisx[13] = a2;
    }
    if (a3 > 0)
    {
        result = a3;
        thisx[14] = a3;
    }
    return result;
}

 
int __fastcall sub_45948C(int a1)
{
    int v1; // edx
    int result; // eax
    int v3; // ecx
    int v4; // ecx
    int m; // [esp+10h] [ebp-28h]
    int v7; // [esp+14h] [ebp-24h]
    int v8; // [esp+1Ch] [ebp-1Ch]
    int v9; // [esp+1Ch] [ebp-1Ch]
    int v10; // [esp+20h] [ebp-18h]
    int v11; // [esp+24h] [ebp-14h]
    int i; // [esp+28h] [ebp-10h]
    int j; // [esp+28h] [ebp-10h]
    int k; // [esp+28h] [ebp-10h]
    int v15; // [esp+30h] [ebp-8h]
    unsigned __int8 v16; // [esp+34h] [ebp-4h]
    unsigned __int8 v17; // [esp+35h] [ebp-3h]
    unsigned __int8 v18; // [esp+36h] [ebp-2h]
    unsigned __int8 v19; // [esp+37h] [ebp-1h]

    for (i = 4; i >= 0 && *(char*)(a1 + 2 * i + 2) == -127 && *(_BYTE*)(a1 + 2 * i + 3) == 64; --i)
    {
        *(_BYTE*)(a1 + 2 * i + 2) = 0;
        *(_BYTE*)(a1 + 2 * i + 3) = 0;
    }
    HIWORD(v1) = HIWORD(a1);
    *(_WORD*)a1 = 1;
    *(_WORD*)(a1 + 24) = 0;
    LOWORD(v1) = *(_WORD*)(a1 + 24);
    *(_BYTE*)(a1 + 26) = sub_47C20C(v1);
    *(_WORD*)(a1 + 18) = 0;
    *(_BYTE*)(a1 + 22) = 0;
    if (lstrcmpiA((LPCSTR)(a1 + 2), byte_4B2730))
    {
        v10 = lstrlenA((LPCSTR)(a1 + 2));
        v8 = 0;
        v15 = 1;
        for (j = 0; j < v10; ++j)
        {
            v8 += *(unsigned __int8*)(a1 + 15) + v15 * *(unsigned __int8*)(j + a1 + 2);
            v15 *= 10;
        }
        if (v8 < 0)
            v8 = -v8;
        *(_WORD*)(a1 + 28) = v8 % 40 + 168;
        *(_WORD*)(a1 + 30) = v8 % 10 + 25;
        *(_WORD*)(a1 + 32) = v8 / 2 % 10 + 25;
        *(_WORD*)(a1 + 34) = v8 / 3 % 10 + 25;
        *(_WORD*)(a1 + 36) = v8 / 18 % 10 + 35;
        *(_WORD*)(a1 + 38) = v8 / 19 % 10 + 35;
        *(_WORD*)(a1 + 40) = v8 / 4 % 15 + 35;
        *(_WORD*)(a1 + 42) = v8 / 5 % 10 + 80;
        *(_WORD*)(a1 + 44) = v8 / 6 % 18 + 50;
        *(_WORD*)(a1 + 46) = v8 / 7 % 50 + 30;
        *(_BYTE*)(a1 + 48) = v8 / 8 % 6 + 10;
        *(_BYTE*)(a1 + 49) = v8 / 9 % 6 + 10;
        *(_BYTE*)(a1 + 50) = v8 / 10 % 6 + 10;
        *(_BYTE*)(a1 + 51) = v8 / 11 % 6 + 10;
        *(_BYTE*)(a1 + 52) = v8 / 20 % 6 + 15;
        *(_BYTE*)(a1 + 53) = v8 / 21 % 6 + 15;
        *(_BYTE*)(a1 + 54) = v8 / 12 % 3 + 8;
        *(_BYTE*)(a1 + 55) = v8 / 13 % 5 + 8;
        *(_BYTE*)(a1 + 56) = v8 / 14 % 5 + 8;
        *(_BYTE*)(a1 + 57) = v8 / 15 % 5 + 8;
        *(_BYTE*)(a1 + 16) = v8 / 16 % 4;
        if (*(_BYTE*)(a1 + 16))
        {
            switch (*(_BYTE*)(a1 + 16))
            {
            case 1:
                *(_WORD*)(a1 + 30) += 30;
                *(_BYTE*)(a1 + 49) += 10;
                *(_BYTE*)(a1 + 57) += 2;
                break;
            case 2:
                *(_WORD*)(a1 + 32) += 30;
                *(_BYTE*)(a1 + 50) += 10;
                *(_BYTE*)(a1 + 55) += 2;
                break;
            case 3:
                *(_WORD*)(a1 + 34) += 30;
                *(_BYTE*)(a1 + 51) += 10;
                *(_BYTE*)(a1 + 54) += 2;
                break;
            }
        }
        else
        {
            *(_WORD*)(a1 + 30) += 10;
            *(_WORD*)(a1 + 32) += 10;
            *(_WORD*)(a1 + 34) += 10;
            *(_BYTE*)(a1 + 49) += 5;
            *(_BYTE*)(a1 + 50) += 5;
            *(_BYTE*)(a1 + 51) += 5;
        }
        *(_WORD*)(a1 + 20) = v8 / 17 % 4 + 19;
        if (*(_WORD*)(a1 + 20) == 22)
            *(_BYTE*)(a1 + 22) = 1;
        v16 = *(unsigned __int8*)(a1 + 13) / 10 + *(_BYTE*)(a1 + 15) + 1;
        v17 = *(unsigned __int8*)(a1 + 13) % 10 + *(_BYTE*)(a1 + 15) + 1;
        v18 = *(unsigned __int8*)(a1 + 14) / 10 + *(_BYTE*)(a1 + 15) + 1;
        v19 = *(unsigned __int8*)(a1 + 14) % 10 + *(_BYTE*)(a1 + 15) + 1;
        result = v18;
        v3 = (v19 + v18 + v17 + v16) % 4;
        v11 = v3;
        if (v3 >= 2)
        {
            if (v3 == 2)
            {
                v11 = 1;
            }
            else if (v3 == 3)
            {
                v11 = 3;
            }
        }
        else
        {
            v11 = 2;
        }
        if (v11 < 3)
        {
            v7 = 10;
            if (v11 == 2)
                v7 = 5;
            *(_WORD*)(a1 + 28) += v7;
            *(_WORD*)(a1 + 30) += v7;
            *(_WORD*)(a1 + 32) += v7;
            *(_WORD*)(a1 + 34) += v7;
            *(_WORD*)(a1 + 40) += v7;
            *(_WORD*)(a1 + 42) += v7 / 2;
            *(_WORD*)(a1 + 44) += v7 / 2;
            result = a1;
            *(_WORD*)(a1 + 46) += v7 / 2;
        }
        for (k = 0; k < v11; ++k)
        {
            v9 = 0;
            if (k)
            {
                if (k == 1)
                {
                    v9 = v19 + 10 * v18 + 100 * v17 + 1000 * v16;
                }
                else if (k == 2)
                {
                    v9 = 11 * v19 + 7 * v18 + 5 * v17 + 3 * v16;
                }
            }
            else
            {
                v9 = 3 * v18 + v16 + 2 * v17 + 4 * v19;
            }
            *(_BYTE*)(k + a1 + 68) = v9 % 72 + 1;
            while (1)
            {
                for (m = 0; ; ++m)
                {
                    result = m;
                    if (m >= k)
                        break;
                    result = *(unsigned __int8*)(k + a1 + 68);
                    v4 = m + a1;
                    if (result == *(unsigned __int8*)(m + a1 + 68))
                        break;
                    LOBYTE(result) = *(_BYTE*)(m + a1 + 68);
                    LOBYTE(v4) = *(_BYTE*)(k + a1 + 68);
                    result = sub_47744C(v4, result);
                    if (result)
                        break;
                }
                if (m == k)
                    break;
                if ((unsigned __int8)++ * (_BYTE*)(k + a1 + 68) >= 0x49u)
                    *(_BYTE*)(k + a1 + 68) = 1;
            }
        }
        while (k < 3)
        {
            *(_BYTE*)(k + a1 + 68) = 0;
            result = ++k;
        }
    }
    else
    {
        *(_WORD*)a1 = 19;
        *(_WORD*)(a1 + 28) = 255;
        *(_WORD*)(a1 + 30) = 99;
        *(_WORD*)(a1 + 32) = 99;
        *(_WORD*)(a1 + 34) = 99;
        *(_WORD*)(a1 + 36) = 99;
        *(_WORD*)(a1 + 38) = 99;
        *(_WORD*)(a1 + 40) = 99;
        *(_WORD*)(a1 + 42) = 99;
        *(_WORD*)(a1 + 44) = 99;
        *(_WORD*)(a1 + 46) = 99;
        *(_BYTE*)(a1 + 48) = 15;
        *(_BYTE*)(a1 + 49) = 15;
        *(_BYTE*)(a1 + 50) = 15;
        *(_BYTE*)(a1 + 51) = 15;
        *(_BYTE*)(a1 + 52) = 15;
        *(_BYTE*)(a1 + 53) = 15;
        *(_BYTE*)(a1 + 54) = 15;
        *(_BYTE*)(a1 + 55) = 13;
        *(_BYTE*)(a1 + 56) = 13;
        *(_BYTE*)(a1 + 57) = 13;
        *(_BYTE*)(a1 + 16) = 0;
        *(_WORD*)(a1 + 20) = 19;
        *(_BYTE*)(a1 + 68) = 1;
        *(_BYTE*)(a1 + 69) = 3;
        result = a1;
        *(_BYTE*)(a1 + 70) = 0;
    }
    return result;
}

 
int sub_459DE1(int thisx)
{
    int result; // eax

    *(_DWORD*)(thisx + 104) = 14;
    *(_BYTE*)(thisx + 2516) = 1;
    sub_47C25B(0);
    *(_WORD*)(thisx + 2564) = 0;
    *(_WORD*)(thisx + 2566) = 0;
    if ((*(_BYTE*)(thisx + 2562) == 1 || *(_BYTE*)(thisx + 2562) == 3) && (unsigned __int16)sub_475850((short*)thisx + 11816) == 1)
        *(_WORD*)(thisx + 2564) = 1;
    sub_459E91(thisx, -1);
    result = thisx;
    if (*(_BYTE*)(thisx + 2562) == 2)
        return sub_456D33((const CHAR*)thisx, aMenuWav_0, 1, 0);
    return result;
}

 
void sub_459E91(int thisx, int a2)
{
    int v2; // eax
    int v3; // edx
    bool RuntimeOwnsLifetime; // al
    char* v5; // eax
    unsigned __int16 v6; // ax
    bool v7; // al
    char* v8; // eax
    char* v9; // eax
    int v10; // [esp-4h] [ebp-494h]
    int v11; // [esp-4h] [ebp-494h]
    int v12; // [esp-4h] [ebp-494h]
    CHAR v14[256]; // [esp+Ch] [ebp-484h] BYREF
    CHAR v15[256]; // [esp+10Ch] [ebp-384h] BYREF
    int v16; // [esp+20Ch] [ebp-284h]
    int v17; // [esp+210h] [ebp-280h]
    int v18; // [esp+214h] [ebp-27Ch]
    int v19; // [esp+218h] [ebp-278h]
    int v20; // [esp+21Ch] [ebp-274h]
    int j; // [esp+220h] [ebp-270h]
    Concurrency::details::_UnrealizedChore* v22; // [esp+224h] [ebp-26Ch]
    int v23; // [esp+228h] [ebp-268h]
    CHAR String[256]; // [esp+22Ch] [ebp-264h] BYREF
    int v25; // [esp+32Ch] [ebp-164h] BYREF
    int v26; // [esp+330h] [ebp-160h]
    int v27; // [esp+334h] [ebp-15Ch]
    struct tagRECT rc; // [esp+364h] [ebp-12Ch] BYREF
    CHAR v29[256]; // [esp+374h] [ebp-11Ch] BYREF
    int v30; // [esp+474h] [ebp-1Ch]
    int v31; // [esp+478h] [ebp-18h]
    int i; // [esp+47Ch] [ebp-14h]
    int v33[4]; // [esp+480h] [ebp-10h] BYREF

    switch (a2)
    {
    case -1:
        sub_451EB5((_BYTE*)thisx, 1, 0);
        sub_459E91(thisx, 0);
        sub_459E91(thisx, 1);
        sub_459E91(thisx, 2);
        return;
    case 0:
        sub_452045((_BYTE*)thisx, 3, 1, 7, 7);
        v33[0] = 28;
        v33[1] = 12;
        v33[2] = 76;
        v33[3] = 60;
        v10 = dword_4B9248;
        v2 = sub_49FFEC(197, 113, 0);
        sub_4A02E9((_DWORD*)unk_4BDC60, v3, (int)v33, v2, v10);
        sub_452045((_BYTE*)thisx, 13, 1, 24, 7);
        sub_452045((_BYTE*)thisx, 1, 9, 21, 14);
        sub_452045((_BYTE*)thisx, 23, 9, 15, 11);
        sub_47B91A(200, 78, byte_4B2748, 0, dword_4B9248);
        v31 = 20;
        v30 = 84;
        for (i = 0; i < 10; ++i)
        {
            switch (i)
            {
            case 0:
                wsprintfA(v29, dword_4B0A31);
                break;
            case 1:
                wsprintfA(v29, byte_4B0B78);
                break;
            case 2:
                wsprintfA(v29, byte_4B0B82);
                break;
            case 3:
                wsprintfA(v29, byte_4B0B8C);
                break;
            case 4:
                wsprintfA(v29, byte_4B0B96);
                break;
            case 5:
                wsprintfA(v29, byte_4B0BF4);
                break;
            case 6:
                wsprintfA(v29, byte_4B0BFA);
                break;
            case 7:
                wsprintfA(v29, byte_4B1551);
                break;
            case 8:
                wsprintfA(v29, byte_4B1559);
                break;
            case 9:
                wsprintfA(v29, byte_4B1561);
                break;
            default:
                break;
            }
            sub_47B91A(80 * (i / 5) + v31, 20 * (i % 5) + v30, v29, 0, dword_4B9248);
        }
        return;
    case 1:
        v23 = *(unsigned __int16*)(thisx + 2564);
        if (!*(_BYTE*)(thisx + 2562) || *(_BYTE*)(thisx + 2562) == 3)
            v23 = *(unsigned __int16*)(thisx + 2568);
        if (*(_BYTE*)(thisx + 2562))
        {
            if (*(_BYTE*)(thisx + 2562) == 1 || *(_BYTE*)(thisx + 2562) == 3)
            {
                if (*(_BYTE*)(thisx + 2562) == 3)
                {
                    sub_45B346(
                        (_WORD*)(thisx + 76 * v23 + 11816),
                        (char*)(36 * *(unsigned __int16*)(thisx + 2564) + dword_4B92E0));
                    v22 = (Concurrency::details::_UnrealizedChore*)(thisx + 76 * v23 + 11816);
                }
                else
                {
                    sub_45B346((_WORD*)(thisx + 11892), (char*)(36 * *(unsigned __int16*)(thisx + 2564) + dword_4B92E0));
                    v22 = (Concurrency::details::_UnrealizedChore*)(thisx + 11892);
                }
            }
            else if (*(_BYTE*)(thisx + 2562) == 2)
            {
                v22 = (Concurrency::details::_UnrealizedChore*)(thisx + 76 * *(unsigned __int16*)(thisx + 2564) + 11816);
            }
        }
        else
        {
            v22 = (Concurrency::details::_UnrealizedChore*)(thisx + 76 * *(unsigned __int16*)(thisx + 2568) + 11816);
        }
        v20 = 0;
        v19 = 0;
        sub_49C15E((int)&v25);
        v26 = 40;
        v27 = 28;
        v25 = *((__int16*)Src + (unsigned __int8)sub_426550((char*)v22)) + dword_4B9234;
        RuntimeOwnsLifetime = Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime(v22);
        SetRect(&rc, 24 * RuntimeOwnsLifetime, 0, 24, 24);
        sub_4A03B3((short*)unk_4BDC60, dword_4B9248, &v25, (_DWORD*)&rc);
        v26 += 4;
        v27 -= 8;
        if (*(_BYTE*)(thisx + 2562))
        {
            if (*(_BYTE*)(thisx + 2562) == 1 || *(_BYTE*)(thisx + 2562) == 3)
            {
                sub_47900E(&v25, 1, *(unsigned __int16*)(thisx + 2564), dword_4B9248);
            LABEL_38:
                v20 = 144;
                v19 = 20;
                if (*(_BYTE*)(thisx + 2562) != 3
                    && (*(_BYTE*)(thisx + 2562) == 1 || *(unsigned __int8*)(thisx + 11968) <= v23))
                {
                    wsprintfA(String, aCpu);
                }
                else
                {
                    wsprintfA(String, " %dP", v23 + 1);
                }
                sub_47B7ED(v20 - 8, v19, String, 0, dword_4B9248);
                v11 = dword_4B9248;
                v5 = sub_4266D0((char*)v22);
                sub_47B91A(v20 + 24, v19, v5, 0, v11);
                v6 = sub_4750D0(v22);
                wsprintfA(String, "LV%2d", v6);
                sub_47B7ED(v20 + 80, v19, String, 0, dword_4B9248);
                v12 = dword_4B9248;
                v7 = Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime(v22);
                sub_47B91A(v20, v19 + 24, (LPCSTR)&byte_4B4664[18 * v7], 0, v12);
                v20 = 52;
                v19 = 84;
                for (j = 0; j < 10; ++j)
                {
                    v18 = 0;
                    switch (j)
                    {
                    case 0:
                        v18 = (unsigned __int16)sub_426710((short*)v22);
                        break;
                    case 1:
                        v18 = (unsigned __int16)sub_426730((short*)v22);
                        break;
                    case 2:
                        v18 = (unsigned __int16)sub_426750((short*)v22);
                        break;
                    case 3:
                        v18 = (unsigned __int16)sub_426770((short*)v22);
                        break;
                    case 4:
                        v18 = (unsigned __int16)sub_426810((short*)v22);
                        break;
                    case 5:
                        v18 = (unsigned __int16)sub_426790((short*)v22);
                        break;
                    case 6:
                        v18 = (unsigned __int16)sub_4267B0((short*)v22);
                        break;
                    case 7:
                        v18 = (unsigned __int16)sub_4267D0((short*)v22);
                        break;
                    case 8:
                        v18 = (unsigned __int16)sub_4267F0((short*)v22);
                        break;
                    case 9:
                        v18 = (unsigned __int16)sub_426830((short*)v22);
                        break;
                    default:
                        break;
                    }
                    wsprintfA(String, "%4d", v18);
                    sub_47B7ED(80 * (j / 5) + v20, 20 * (j % 5) + v19, String, 0, dword_4B9248);
                }
                v20 = 192;
                v19 = 96;
                for (j = 0; j < 3; ++j)
                {
                    LOBYTE(v17) = sub_426850((char*)v22, j);
                    if ((unsigned __int8)v17 >= 0x49u)
                    {
                        v16 = (unsigned __int8)v17 - 128;
                        if (v16 >= 13)
                            sub_47B91A(v20, 24 * j + v19, byte_4B27D8, 0, dword_4B9248);
                        else
                            sub_47B91A(v20, 24 * j + v19, (LPCSTR)&byte_4B4E74[21 * v16], 0, dword_4B9248);
                    }
                    else
                    {
                        sub_47B91A(v20, 24 * j + v19, (LPCSTR)&byte_4B46C0[27 * (unsigned __int8)v17], 0, dword_4B9248);
                    }
                }
                return;
            }
            if (*(_BYTE*)(thisx + 2562) != 2)
                goto LABEL_38;
        }
        sub_47900E(&v25, 1, -(v23 + 1), dword_4B9248);
        goto LABEL_38;
    case 2:
        sub_451EB5((_BYTE*)thisx, 0, 1);
        if (*(_BYTE*)(thisx + 2562))
        {
            switch (*(_BYTE*)(thisx + 2562))
            {
            case 1:
                if (*(_WORD*)(thisx + 2566))
                {
                    if (*(_WORD*)(thisx + 2566) == 1)
                    {
                        sub_47B91A(16, 208, byte_4B2858, 0, dword_4B9248);
                        sub_47B91A(80, 224, byte_4B2878, 0, dword_4B9248);
                    }
                }
                else
                {
                    sub_47B91A(16, 208, byte_4B2838, 0, dword_4B9248);
                }
                break;
            case 2:
                v9 = sub_4266D0((char*)(thisx + 76 * *(unsigned __int16*)(thisx + 2564) + 11816));
                wsprintfA(v14, aS_5, v9);
                sub_47B91A(16, 208, v14, 0, dword_4B9248);
                break;
            case 3:
                if (*(_WORD*)(thisx + 2566))
                {
                    if (*(_WORD*)(thisx + 2566) == 1)
                    {
                        sub_47B91A(16, 208, byte_4B28D4, 0, dword_4B9248);
                        sub_47B91A(80, 224, byte_4B28F4, 0, dword_4B9248);
                    }
                }
                else
                {
                    sub_47B91A(16, 208, byte_4B28AC, 0, dword_4B9248);
                }
                break;
            }
        }
        else
        {
            v8 = sub_4266D0((char*)(thisx + 76 * *(unsigned __int16*)(thisx + 2568) + 11816));
            wsprintfA(v15, aS_4, v8);
            sub_47B91A(16, 208, v15, 0, dword_4B9248);
            sub_47B91A(120, 224, byte_4B2820, 0, dword_4B9248);
        }
        break;
    }
}

 
int  sub_45AB5E(int thisx)
{
    int v1; // eax
    int v2; // ecx
    int v3; // esi
    int v4; // edx
    int v5; // ecx
    int v6; // ecx
    int result; // eax
    int v8; // eax
    int v9; // ecx
    int v10; // esi
    int v11; // edx
    int v12; // eax
    int v13; // ecx
    int v14; // edx
    int v15; // eax
    int v16; // edx
    char v18; // [esp+8h] [ebp-54h]
    int v19; // [esp+Ch] [ebp-50h]
    int v20; // [esp+10h] [ebp-4Ch]
    __int16 v21; // [esp+14h] [ebp-48h]
    int v22; // [esp+18h] [ebp-44h]
    int v23; // [esp+20h] [ebp-3Ch]
    int v24[14]; // [esp+24h] [ebp-38h] BYREF

    if (!*(_BYTE*)(thisx + 2516))
    {
        v1 = *(unsigned __int8*)(thisx + 2562);
        if (*(_BYTE*)(thisx + 2562))
        {
            if (*(_BYTE*)(thisx + 2562) == 1 || *(_BYTE*)(thisx + 2562) == 3)
            {
                LOBYTE(v21) = 0;
                v8 = *(unsigned __int8*)(thisx + 2562);
                if (v8 == 3)
                    v21 = *(_WORD*)(thisx + 2568);
                LOBYTE(v8) = v21;
                sub_477F0C(v8);
                LOBYTE(v9) = v21;
                v10 = sub_476D78(v9);
                LOBYTE(v11) = v21;
                v12 = sub_476D29(v11);
                v20 = v10 - v12;
                if (v10 == v12)
                {
                    LOBYTE(v12) = v21;
                    if (sub_476DC7(v12, 0))
                    {
                        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
                        if (*(_WORD*)(thisx + 2566))
                        {
                            if (*(_WORD*)(thisx + 2566) == 1)
                            {
                                if (*(_DWORD*)(thisx + 2528))
                                {
                                    if (*(_DWORD*)(thisx + 2528) == 1)
                                    {
                                        *(_WORD*)(thisx + 2566) = 0;
                                        sub_459E91(thisx, 2);
                                    }
                                }
                                else
                                {
                                    if (*(_BYTE*)(thisx + 2562) == 1)
                                    {
                                        sub_475730((_WORD*)(thisx + 11892), *(_WORD*)(thisx + 2564) + 1);
                                        result = sub_45B65A(thisx);
                                        *(_DWORD*)(thisx + 108) = 15;
                                        *(_BYTE*)(thisx + 2516) = 2;
                                        return result;
                                    }
                                    if (*(_BYTE*)(thisx + 2562) == 3)
                                    {
                                        sub_475730(
                                            (_WORD*)(thisx + 76 * *(unsigned __int16*)(thisx + 2568) + 11816),
                                            *(_WORD*)(thisx + 2564) + 1);
                                        if (*(unsigned __int16*)(thisx + 2568) + 1 < *(unsigned __int8*)(thisx + 11968))
                                        {
                                            ++* (_WORD*)(thisx + 2568);
                                            result = thisx;
                                            *(_DWORD*)(thisx + 108) = 13;
                                            *(_BYTE*)(thisx + 2516) = 2;
                                            return result;
                                        }
                                        if (*(_BYTE*)(thisx + 11968) == 1)
                                        {
                                            *(_BYTE*)(thisx + 2562) = 1;
                                            *(_WORD*)(thisx + 2564) = 0;
                                            if ((unsigned __int16)sub_475850((short*)thisx + 11816) == 1)
                                                *(_WORD*)(thisx + 2564) = 1;
                                            *(_WORD*)(thisx + 2566) = 0;
                                            sub_459E91(thisx, -1);
                                        }
                                        else if (*(_BYTE*)(thisx + 11968) == 2)
                                        {
                                            result = sub_45B65A(thisx);
                                            *(_DWORD*)(thisx + 108) = 15;
                                            *(_BYTE*)(thisx + 2516) = 2;
                                            return result;
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            *(_DWORD*)(thisx + 2528) = 0;
                            *(_WORD*)(thisx + 2566) = 1;
                            sub_459E91(thisx, 2);
                        }
                    }
                    else
                    {
                        LOBYTE(v13) = v21;
                        if (sub_476DC7(v13, 1) && *(_WORD*)(thisx + 2566) == 1)
                        {
                            *(_WORD*)(thisx + 2566) = 0;
                            sub_459E91(thisx, 2);
                        }
                    }
                }
                else
                {
                    sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
                    if (*(_WORD*)(thisx + 2566))
                    {
                        if (*(_WORD*)(thisx + 2566) == 1)
                            *(_DWORD*)(thisx + 2528) = *(_DWORD*)(thisx + 2528) == 0;
                    }
                    else
                    {
                        do
                        {
                            do
                            {
                                v19 = (int)(Size + v20 + *(unsigned __int16*)(thisx + 2564)) % (int)Size;
                                *(_WORD*)(thisx + 2564) = v19;
                            } while (v19 >= 16 && v19 <= 21);
                        } while ((unsigned __int16)sub_475850((short*)thisx + 11816) && (unsigned __int16)sub_475850((short*)thisx + 11816) - 1 == v19);
                        *(_WORD*)(thisx + 2564) = v19;
                        sub_459E91(thisx, 0);
                        sub_459E91(thisx, 1);
                    }
                }
            }
            else
            {
                v14 = thisx;
                if (*(_BYTE*)(thisx + 2562) == 2)
                {
                    v18 = *(_BYTE*)(thisx + 2564);
                    if (*(_BYTE*)(thisx + 11968) == 1)
                        v18 = 0;
                    LOBYTE(v14) = v18;
                    v15 = sub_477F0C(v14);
                    LOBYTE(v15) = v18;
                    if (sub_476DC7(v15, 0))
                    {
                        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
                        if (*(_WORD*)(thisx + 2564))
                        {
                            if (*(_WORD*)(thisx + 2564) == 1)
                            {
                                *(_DWORD*)(thisx + 108) = 19;
                                *(_BYTE*)(thisx + 2516) = 2;
                            }
                        }
                        else
                        {
                            ++* (_WORD*)(thisx + 2564);
                            sub_459E91(thisx, -1);
                        }
                    }
                    else
                    {
                        LOBYTE(v16) = v18;
                        if (sub_476DC7(v16, 1))
                        {
                            sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
                            if (*(_WORD*)(thisx + 2564))
                            {
                                --* (_WORD*)(thisx + 2564);
                                sub_459E91(thisx, -1);
                            }
                            else
                            {
                                *(_DWORD*)(thisx + 108) = 19;
                                *(_BYTE*)(thisx + 2516) = 2;
                            }
                        }
                    }
                }
            }
        }
        else
        {
            v23 = *(unsigned __int16*)(thisx + 2568);
            LOBYTE(v1) = *(_WORD*)(thisx + 2568);
            sub_477F0C(v1);
            LOBYTE(v2) = v23;
            v3 = sub_476D78(v2);
            LOBYTE(v4) = v23;
            if (v3 != sub_476D29(v4))
            {
                *(_DWORD*)(thisx + 2528) = *(_DWORD*)(thisx + 2528) == 0;
                sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
            }
            v22 = 0;
            LOBYTE(v5) = v23;
            if (sub_476DC7(v5, 0))
            {
                sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
                if (*(_DWORD*)(thisx + 2528) == 1)
                {
                    v22 = 1;
                }
                else
                {
                    if (*(unsigned __int8*)(thisx + 11968) - 1 != v23)
                    {
                        *(_DWORD*)(thisx + 108) = 13;
                        *(_BYTE*)(thisx + 2516) = 2;
                        result = thisx;
                        ++* (_WORD*)(thisx + 2568);
                        return result;
                    }
                    if (*(_BYTE*)(thisx + 11968) == 1)
                    {
                        *(_BYTE*)(thisx + 2562) = 1;
                        *(_WORD*)(thisx + 2564) = 0;
                        sub_459E91(thisx, -1);
                    }
                    else
                    {
                        v6 = thisx;
                        if (*(_BYTE*)(thisx + 11968) == 2)
                        {
                            sub_45B65A(thisx);
                            result = thisx;
                            *(_DWORD*)(thisx + 108) = 15;
                            *(_BYTE*)(thisx + 2516) = 2;
                            return result;
                        }
                    }
                }
            }
            LOBYTE(v6) = v23;
            if (sub_476DC7(v6, 1))
                v22 = 1;
            if (v22)
            {
                *(_DWORD*)(thisx + 108) = 13;
                result = thisx;
                *(_BYTE*)(thisx + 2516) = 2;
                return result;
            }
        }
    }
    sub_49C15E((int)v24);
    v24[1] = 0;
    v24[2] = 0;
    v24[0] = dword_4B9248;
    sub_49AB05((int)unk_4BDC60, v24);
    if (!*(_BYTE*)(thisx + 2562))
        return sub_47B91A(56 * *(_DWORD*)(thisx + 2528) + 108, 224, asc_4B2918, 0, -1);
    if (*(_BYTE*)(thisx + 2562) == 1 && *(_WORD*)(thisx + 2566) == 1)
        return sub_47B91A(56 * *(_DWORD*)(thisx + 2528) + 68, 224, asc_4B291C, 0, -1);
    result = *(unsigned __int8*)(thisx + 2562);
    if (result == 3 && *(_WORD*)(thisx + 2566) == 1)
        return sub_47B91A(72 * *(_DWORD*)(thisx + 2528) + 68, 224, asc_4B2920, 0, -1);
    return result;
}

 
void sub_45B346(_WORD* thisx, _BYTE* a2)
{
    const void* v2; // eax
    int i; // [esp+4h] [ebp-4h]

    if (a2)
    {
        v2 = (const void*)unknown_libname_18(a2);
        memcpy(thisx + 1, v2, 0xBu);
        *thisx = 1;
        thisx[10] = sub_475CB0((short*)a2);
        *((_BYTE*)thisx + 22) = sub_4016F0(a2);
        *((_BYTE*)thisx + 26) = sub_401710(a2);
        thisx[12] = unknown_libname_22((_DWORD*)(char*)dword_4B93A4 + 24 * *((unsigned __int8*)thisx + 26));
        *((_BYTE*)thisx + 16) = MarkedForDetachment(a2);
        thisx[14] = 825 * (unsigned __int8)sub_4265B0(a2) / 1000;
        thisx[15] = (unsigned __int8)sub_426570(a2);
        thisx[16] = (unsigned __int8)sub_4265D0(a2);
        thisx[17] = (unsigned __int8)sub_4265F0(a2);
        thisx[18] = (unsigned __int8)sub_426610(a2);
        thisx[19] = (unsigned __int8)sub_426550(a2);
        thisx[20] = (unsigned __int8)sub_426670(a2);
        thisx[21] = (unsigned __int8)sub_426630(a2);
        thisx[22] = (unsigned __int8)sub_426650(a2);
        thisx[23] = 8 * (unsigned __int8)sub_426690(a2) / 10;
        *((_BYTE*)thisx + 48) = 12;
        *((_BYTE*)thisx + 49) = 12;
        *((_BYTE*)thisx + 50) = 12;
        *((_BYTE*)thisx + 51) = 12;
        *((_BYTE*)thisx + 52) = 12;
        *((_BYTE*)thisx + 53) = 12;
        *((_BYTE*)thisx + 54) = 9;
        *((_BYTE*)thisx + 55) = 12;
        *((_BYTE*)thisx + 56) = 12;
        *((_BYTE*)thisx + 57) = 12;
        if (*((_BYTE*)thisx + 16))
        {
            switch (*((_BYTE*)thisx + 16))
            {
            case 1:
                thisx[15] += 15;
                *((_BYTE*)thisx + 49) += 10;
                *((_BYTE*)thisx + 57) += 5;
                break;
            case 2:
                thisx[16] += 15;
                *((_BYTE*)thisx + 50) += 10;
                *((_BYTE*)thisx + 55) += 5;
                break;
            case 3:
                thisx[17] += 15;
                *((_BYTE*)thisx + 51) += 10;
                *((_BYTE*)thisx + 54) += 2;
                break;
            }
        }
        else
        {
            thisx[15] += 5;
            thisx[16] += 5;
            thisx[17] += 5;
            *((_BYTE*)thisx + 49) += 5;
            *((_BYTE*)thisx + 50) += 5;
            *((_BYTE*)thisx + 51) += 5;
        }
        for (i = 0; i < 3; ++i)
            *((_BYTE*)thisx + i + 68) = sub_4266B0(a2, i);
    }
}

 
int sub_45B65A(int thisx)
{
    DWORD Time; // eax
    int ii; // [esp+4h] [ebp-28h]
    int n; // [esp+8h] [ebp-24h]
    int v6; // [esp+Ch] [ebp-20h]
    int m; // [esp+10h] [ebp-1Ch]
    int k; // [esp+14h] [ebp-18h]
    unsigned __int16 v9; // [esp+18h] [ebp-14h]
    unsigned __int8 v10; // [esp+1Ch] [ebp-10h]
    int i; // [esp+20h] [ebp-Ch]
    int j; // [esp+20h] [ebp-Ch]
    int v13; // [esp+24h] [ebp-8h]
    unsigned __int16 v14; // [esp+28h] [ebp-4h]

    v10 = *(_BYTE*)(thisx + 11688);
    for (i = 0; i < v10; ++i)
        *(_WORD*)(thisx + 2 * i + 11692) = 0;
    *(_BYTE*)(thisx + 11691) = 0;
    *(_WORD*)(thisx + 11724) = 0;
    *(_WORD*)(thisx + 11726) = 1;
    v13 = 1;
    if (!*(_BYTE*)(thisx + 11807))
        v13 = sub_4631F8((unsigned char*)thisx) + 1;
    v14 = sub_475850((short*)thisx + 11816);
    v9 = sub_475850((short*)thisx + 11892);
    Time = timeGetTime();
    sub_4A2B56(Time);
    rand();
    for (j = v13; j < v10; ++j)
    {
        *(_BYTE*)(j + thisx + 11788) = rand() % word_4B99E4;
        for (k = 0; k < 2; ++k)
        {
            for (m = rand() % (int)Size; ; m = (int)(m + Size + 1) % (int)Size)
            {
                v6 = 1;
                if (m >= 16 && m <= 21)
                    v6 = 0;
                if (v6 && v14 && v14 - 1 == m)
                    v6 = 0;
                if (v6 && v9 && v9 - 1 == m)
                    v6 = 0;
                if (v6 && k == 1 && *(unsigned __int16*)(thisx + 4 * j + 11724) - 2 == m)
                    v6 = 0;
                if (v6)
                {
                    for (n = 1; n < j; ++n)
                    {
                        for (ii = 0; ii < 2; ++ii)
                        {
                            if (*(unsigned __int16*)(thisx + 4 * n + 11724 + 2 * ii) - 2 == m)
                            {
                                v6 = 0;
                                break;
                            }
                        }
                        if (ii < 2)
                            break;
                    }
                }
                if (v6)
                    break;
            }
            *(_WORD*)(thisx + 4 * j + 11724 + 2 * k) = m + 2;
        }
    }
    *(_BYTE*)(thisx + 11690) = 1;
    return sub_461D3E((unsigned char*)thisx);
}

 
int sub_45B8F5(int thisx)
{
    if (*(_DWORD*)(thisx + 104) == 19)
    {
        sub_49DA8A((_DWORD*)unk_4BDC60, *(_DWORD*)(thisx + 13104));
        *(_DWORD*)(thisx + 13104) = -1;
        sub_45F935(thisx);
        sub_45FD81(thisx);
    }
    *(_DWORD*)(thisx + 104) = 15;
    *(_BYTE*)(thisx + 2516) = 1;
    *(_WORD*)(thisx + 2564) = 0;
    *(_WORD*)(thisx + 2566) = *(unsigned __int8*)(thisx + 12969);
    sub_45B98A(thisx, -1);
    return sub_456D33((const CHAR*)thisx, aMenuWav_1, 1, 0);
}

 
int sub_45B98A(int thisx, int a2)
{
    const CHAR* v2; // eax
    int v4; // [esp-4h] [ebp-13Ch]
    int k; // [esp+Ch] [ebp-12Ch]
    int v7; // [esp+10h] [ebp-128h]
    int v8; // [esp+14h] [ebp-124h]
    unsigned __int8 v9; // [esp+18h] [ebp-120h]
    int v10; // [esp+1Ch] [ebp-11Ch]
    int j; // [esp+24h] [ebp-114h]
    int i; // [esp+28h] [ebp-110h]
    int v13; // [esp+2Ch] [ebp-10Ch]
    int v14; // [esp+30h] [ebp-108h]
    CHAR String[256]; // [esp+34h] [ebp-104h] BYREF
    char v16; // [esp+134h] [ebp-4h]

    sub_451EB5((_BYTE*)thisx, 1, 1);
    sub_452045((_BYTE*)thisx, 5, 1, 30, 3);
    sub_47B91A(64, 16, a1_1, 0, dword_4B9248);
    wsprintfA(String, "%2d", *(unsigned __int8*)(thisx + 11690));
    sub_47B7ED(120, 16, String, 0, dword_4B9248);
    v16 = *(unsigned __int8*)(thisx + 11688) / (__int16)*(unsigned __int8*)(thisx + 11812);
    if (*(unsigned __int8*)(thisx + 11688) % (int)*(unsigned __int8*)(thisx + 11812))
        ++v16;
    v14 = 2;
    v13 = 8;
    if (*(_BYTE*)(thisx + 11812) == 2)
    {
        v14 = 3;
        v13 = 5;
    }
    *(_DWORD*)(thisx + 2532) = -1;
    *(_DWORD*)(thisx + 2528) = -1;
    for (i = 0; i < v14; ++i)
    {
        sub_452045((_BYTE*)thisx, 5, (v13 + 1) * i + 6, 30, v13);
        v10 = 8 * (v13 + 1) * i + 48;
        sub_47B91A(148, v10 + 4 * v13 - 4, (LPCSTR)&byte_4B25F6, 0, dword_4B9248);
        for (j = 0; j < *(unsigned __int8*)(thisx + i + *(unsigned __int16*)(thisx + 2564) + 13002); ++j)
        {
            v8 = 112 * (j % 2) + 56;
            v7 = v10 + 28 * (j / 2) + 12;
            v9 = *(_BYTE*)(thisx + j + 4 * (i + *(unsigned __int16*)(thisx + 2564)) + 12970);
            wsprintfA(String, "%3d POINT", *(unsigned __int16*)(thisx + 2 * v9 + 11692));
            sub_47B7ED(112 * (j % 2) + 72, v10 + 28 * (j / 2) + 22, String, 0, dword_4B9248);
            if (v9)
            {
                for (k = 0; k < 2; ++k)
                {
                    v4 = dword_4B9248;
                    v2 = (const CHAR*)unknown_libname_18(36 * (unsigned __int16)(*(_WORD*)(thisx + 4 * v9 + 11724 + 2 * k) - 2) + (char*)dword_4B92E0);
                    sub_47B91A(48 * k + v8, v7, v2, 0, v4);
                }
                sub_47B91A(112 * (j % 2) + 96, v7, (LPCSTR)&byte_4B2654, 0, dword_4B9248);
            }
            else
            {
                *(_DWORD*)(thisx + 2528) = v8;
                *(_DWORD*)(thisx + 2532) = v7;
            }
        }
    }
    sub_47B91A(16, 208, (LPCSTR)&byte_4B2850, 0, dword_4B9248);
    return sub_47B91A(16, 224, (LPCSTR)&byte_4B2930, 0, dword_4B9248);
}

 
int sub_45BDE8(int thisx)
{
    char* v1; // eax
    int result; // eax
    int v3; // esi
    int v5; // [esp+8h] [ebp-48h]
    int v6; // [esp+Ch] [ebp-44h]
    int i; // [esp+10h] [ebp-40h]
    int v8; // [esp+14h] [ebp-3Ch]
    int v9[14]; // [esp+18h] [ebp-38h] BYREF

    sub_49C15E((_DWORD)v9);
    v9[1] = 0;
    v9[2] = 0;
    v9[0] = dword_4B9248;
    sub_49AB05((int)unk_4BDC60, v9);
    if (!(dword_4B93B0 / 5u % 2) && *(int*)(thisx + 2528) >= 0)
    {
        for (i = 0; i < 2; ++i)
        {
            v1 = sub_4266D0((char*)(thisx + 76 * i + 11816));
            sub_47B91A(48 * i + *(_DWORD*)(thisx + 2528), *(_DWORD*)(thisx + 2532), v1, 0, -1);
        }
        sub_47B91A(*(_DWORD*)(thisx + 2528) + 40, *(_DWORD*)(thisx + 2532), byte_4B29BC, 0, -1);
    }
    v8 = 2;
    if (*(_BYTE*)(thisx + 11812) == 2)
        v8 = 3;
    if (!(dword_4B93B0 / 5u % 2))
    {
        if (*(_WORD*)(thisx + 2564))
            sub_47B91A(156, 48, byte_4B29C0, 0, -1);
        if (v8 + *(unsigned __int16*)(thisx + 2564) < *(unsigned __int16*)(thisx + 2566))
            sub_47B91A(156, 172, byte_4B29C4, 0, -1);
    }
    result = *(unsigned __int8*)(thisx + 2516);
    if (!*(_BYTE*)(thisx + 2516))
    {
        sub_477F0C(0);
        v3 = sub_476CDA(0);
        v6 = v3 - sub_476C8B(0);
        if (v6)
        {
            sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
            v5 = v6 + *(unsigned __int16*)(thisx + 2564);
            if (v8 + v5 > *(unsigned __int16*)(thisx + 2566))
                v5 = *(unsigned __int16*)(thisx + 2566) - v8;
            if (v5 < 0)
                LOWORD(v5) = 0;
            *(_WORD*)(thisx + 2564) = v5;
            sub_45B98A(thisx, -1);
        }
        result = sub_476DC7(0, 0);
        if (result)
        {
            sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
            return sub_45C064(thisx);
        }
    }
    return result;
}

 
int sub_45C064(int thisx)
{
    char v1; // dl
    int result; // eax
    int ii; // [esp+4h] [ebp-1Ch]
    unsigned __int8 v5; // [esp+8h] [ebp-18h]
    int j; // [esp+Ch] [ebp-14h]
    unsigned __int8 v7; // [esp+10h] [ebp-10h]
    int i; // [esp+14h] [ebp-Ch]
    int k; // [esp+14h] [ebp-Ch]
    int m; // [esp+14h] [ebp-Ch]
    int n; // [esp+14h] [ebp-Ch]
    int v12; // [esp+1Ch] [ebp-4h]

    memset((void*)(thisx + 2620), 0, 8u);
    for (i = 0; i < *(unsigned __int8*)(thisx + 12969); ++i)
    {
        for (j = 0; j < *(unsigned __int8*)(i + thisx + 13002) && *(_BYTE*)(thisx + j + 4 * i + 12970); ++j)
            ;
        if (j < *(unsigned __int8*)(i + thisx + 13002))
            break;
    }
    v7 = i;
    byte_4B9985 = 2 * *(_BYTE*)(thisx + (unsigned __int8)i + 13002);
    byte_4B9986 = *(_BYTE*)(thisx + 11968);
    byte_4B9987 = byte_4B9985 - *(_BYTE*)(thisx + 11968);
    byte_4B9990 = *(_BYTE*)(thisx + (unsigned __int8)i + 13002);
    for (k = 0; k < (unsigned __int8)byte_4B9990; ++k)
        *(_BYTE*)(k + thisx + 2546) = 2;
    for (m = 0; m < (unsigned __int8)byte_4B9985; ++m)
        byte_4B9988[m] = m;
    *(_WORD*)(thisx + 2564) = 0;
    *(_BYTE*)(thisx + 2580) = Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime((_UnrealizedChore*)(thisx + 11816));
    *(_WORD*)(thisx + 2566) = 1;
    *(_BYTE*)(thisx + 2581) = Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime((_UnrealizedChore*)(thisx + 11892));
    *(_BYTE*)(thisx + 2612) = *(_BYTE*)(thisx + 11788);
    *(_BYTE*)(thisx + 2613) = *(_BYTE*)(thisx + 2612);
    v12 = 2;
    for (n = 1; n < (unsigned __int8)byte_4B9990; ++n)
    {
        v5 = *(_BYTE*)(thisx + n + 4 * v7 + 12970);
        for (ii = 0; ii < 2; ++ii)
        {
            *(_WORD*)(thisx + 2 * v12 + 2564) = *(_WORD*)(thisx + 4 * v5 + 11724 + 2 * ii) - 2;
            *(_BYTE*)(v12 + thisx + 2612) = *(_BYTE*)(thisx + v5 + 11788);
            *(_BYTE*)(v12 + thisx + 2580) = MarkedForDetachment(36 * *(unsigned __int16*)(thisx + 2 * v12 + 2564) + (char*)dword_4B92E0);
            ++v12;
        }
    }
    if (*(int*)(thisx + 13388) <= 8)
    {
        result = thisx;
        if (*(_BYTE*)(thisx + 11690) == 17)
        {
            *(_BYTE*)(thisx + 29) = 7;
        }
        else
        {
            result = thisx;
            *(_BYTE*)(thisx + 29) = (*(unsigned __int8*)(thisx + 11690) - 1) % 6 + 1;
        }
    }
    else
    {
        v1 = rand() % (*(_DWORD*)(thisx + 13388) - 1) + 1;
        result = thisx;
        *(_BYTE*)(thisx + 29) = v1;
        if (*(unsigned __int8*)(thisx + 29) > 7u)
        {
            result = thisx;
            ++* (_BYTE*)(thisx + 29);
        }
    }
    *(_DWORD*)(thisx + 108) = 11;
    *(_BYTE*)(thisx + 2516) = 2;
    return result;
}

 
int sub_45C3AF(int thisx)
{
    int result; // eax
    int nn; // [esp+8h] [ebp-2Ch]
    unsigned __int8 v4; // [esp+Ch] [ebp-28h]
    unsigned __int8 mm; // [esp+10h] [ebp-24h]
    int kk; // [esp+14h] [ebp-20h]
    int ii; // [esp+18h] [ebp-1Ch]
    int m; // [esp+1Ch] [ebp-18h]
    int j; // [esp+20h] [ebp-14h]
    int v10; // [esp+24h] [ebp-10h]
    unsigned __int8 v11; // [esp+28h] [ebp-Ch]
    int i; // [esp+2Ch] [ebp-8h]
    int k; // [esp+2Ch] [ebp-8h]
    int n; // [esp+2Ch] [ebp-8h]
    int jj; // [esp+2Ch] [ebp-8h]

    if (*(_BYTE*)(thisx + 11690) == 18 || *(_BYTE*)(thisx + 11690) == 19 || *(_BYTE*)(thisx + 11690) == 20)
    {
        if (*(_BYTE*)(thisx + 13044) == 1)
        {
            if (*(_BYTE*)(thisx + 11690) == 18)
            {
                if (sub_425E70((_BYTE*)(thisx + 3852)) == 1)
                    return sub_467B8F((_DWORD*)thisx);
                else
                    return sub_462B0C(thisx);
            }
            else if (*(_BYTE*)(thisx + 11690) == 19)
            {
                return sub_463007(thisx);
            }
            else
            {
                result = thisx;
                if (*(_BYTE*)(thisx + 11690) == 20)
                    return sub_473F53((_DWORD*)thisx);
            }
        }
        else
        {
            if (*(_BYTE*)(thisx + 13044) == 2)
                *(_BYTE*)(thisx + 13044) = 4;
            sub_46287E((char*)thisx);
            if (*(_WORD*)(thisx + 2566) || *(_WORD*)(thisx + 2568))
            {
                return sub_45CF7B(thisx);
            }
            else
            {
                *(_BYTE*)(thisx + 13100) = 0;
                return sub_45DC7E(thisx);
            }
        }
    }
    else
    {
        *(_DWORD*)(thisx + 104) = 16;
        *(_BYTE*)(thisx + 2516) = 1;
        for (i = 0; i < 8; ++i)
        {
            for (j = 0; j < 4; ++j)
                *(_BYTE*)(thisx + j + 4 * i + 13010) = -1;
        }
        for (k = 0; k < *(unsigned __int8*)(thisx + 12969); ++k)
        {
            for (m = 0; m < *(unsigned __int8*)(k + thisx + 13002) && *(_BYTE*)(thisx + m + 4 * k + 12970); ++m)
                ;
            if (m < *(unsigned __int8*)(k + thisx + 13002))
                break;
        }
        v11 = k;
        memset((void*)(thisx + 2564), 0, 0x10u);
        *(_WORD*)(thisx + 2574) = (unsigned __int8)k;
        v10 = 0;
        for (n = 0; n < *(unsigned __int8*)(thisx + v11 + 13002); ++n)
        {
            for (ii = 0; ii < (unsigned __int8)byte_4B9990; ++ii)
            {
                if (*(unsigned __int8*)(ii + thisx + 13044) == n + 1)
                {
                    *(_BYTE*)(thisx + v10 + 4 * v11 + 13010) = *(_BYTE*)(thisx + ii + 4 * v11 + 12970);
                    *(_WORD*)(thisx + 2 * v10++ + 2566) = n;
                }
                if (v10 >= 4)
                    break;
            }
            if (v10 >= 4)
                break;
        }
        for (jj = 0; jj < *(unsigned __int8*)(thisx + 12969); ++jj)
        {
            if (v11 != jj)
            {
                for (kk = 0; kk < *(unsigned __int8*)(jj + thisx + 13002); ++kk)
                {
                    for (mm = rand() % *(unsigned __int8*)(jj + thisx + 13002);
                        ;
                        mm = (mm + 1) % *(unsigned __int8*)(jj + thisx + 13002))
                    {
                        v4 = *(_BYTE*)(thisx + 4 * jj + 12970 + mm);
                        for (nn = 0; nn < kk && *(unsigned __int8*)(thisx + nn + 4 * jj + 13010) != v4; ++nn)
                            ;
                        if (nn == kk)
                            break;
                    }
                    *(_BYTE*)(thisx + kk + 4 * jj + 13010) = v4;
                }
            }
        }
        *(_WORD*)(thisx + 2564) = 0;
        sub_464C88(thisx);
        return sub_456D33((const CHAR*)thisx, aMenuWav_2, 1, 0);
    }
    return result;
}

 
int sub_45C809(int thisx)
{
    char* v1; // eax
    int result; // eax
    int v3; // esi
    __int16 v4; // ax
    __int16 v6; // [esp+8h] [ebp-54h]
    unsigned __int8 v7; // [esp+Ch] [ebp-50h]
    int k; // [esp+10h] [ebp-4Ch]
    int j; // [esp+14h] [ebp-48h]
    int v10; // [esp+18h] [ebp-44h]
    int v11; // [esp+1Ch] [ebp-40h]
    int i; // [esp+20h] [ebp-3Ch]
    int v13[14]; // [esp+24h] [ebp-38h] BYREF

    sub_49C15E((_DWORD)v13);
    v13[1] = 0;
    v13[2] = 0;
    v13[0] = dword_4B9248;
    sub_49AB05((int)unk_4BDC60, v13);
    if (!(dword_4B93B0 / 5u % 2) && *(int*)(thisx + 2528) >= 0 && *(int*)(thisx + 2532) >= 0)
    {
        for (i = 0; i < 2; ++i)
        {
            v1 = sub_4266D0((char*)(thisx + 76 * i + 11816));
            sub_47B91A(48 * i + *(_DWORD*)(thisx + 2528), *(_DWORD*)(thisx + 2532), v1, 0, -1);
        }
        sub_47B91A(*(_DWORD*)(thisx + 2528) + 40, *(_DWORD*)(thisx + 2532), byte_4B29D4, 0, -1);
    }
    if (!(dword_4B93B0 / 5u % 2))
    {
        if (*(_WORD*)(thisx + 2564))
            sub_47B91A(24, 108, asc_4B29D8, 0, -1);
        if (*(unsigned __int16*)(thisx + 2564) + 2 < *(unsigned __int8*)(thisx + 12969))
            sub_47B91A(288, 108, asc_4B29DC, 0, -1);
    }
    result = *(unsigned __int8*)(thisx + 2516);
    if (!*(_BYTE*)(thisx + 2516))
    {
        sub_477F0C(0);
        v3 = sub_476D78(0);
        v11 = v3 - sub_476D29(0);
        if (v11)
        {
            v10 = v11 + *(unsigned __int16*)(thisx + 2564);
            if (v10 + 2 >= *(unsigned __int8*)(thisx + 12969))
                v10 = *(unsigned __int8*)(thisx + 12969) - 2;
            if (v10 < 0)
                LOWORD(v10) = 0;
            *(_WORD*)(thisx + 2564) = v10;
            sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
            sub_464C88(thisx);
        }
        result = sub_476DC7(0, 0);
        if (result)
        {
            for (j = 0; j < *(unsigned __int8*)(thisx + 12969); ++j)
            {
                for (k = 0; k < *(unsigned __int8*)(j + thisx + 13002); ++k)
                {
                    v6 = k;
                    if (*(unsigned __int16*)(thisx + 2574) == j)
                        v6 = *(_WORD*)(thisx + 2 * k + 2566);
                    v7 = *(_BYTE*)(thisx + k + 4 * j + 13010);
                    if (*(_BYTE*)(j + thisx + 13002) == 2)
                        v4 = 4 - 2 * v6 + *(_WORD*)(thisx + 2 * v7 + 11692);
                    else
                        v4 = 4 - v6 + *(_WORD*)(thisx + 2 * v7 + 11692);
                    *(_WORD*)(thisx + 2 * v7 + 11692) = v4;
                }
            }
            sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
            *(_BYTE*)(thisx + 2562) = 0;
            if (*(unsigned __int8*)(thisx + 11690) % 5)
            {
                *(_DWORD*)(thisx + 108) = 17;
                result = thisx;
            }
            else
            {
                *(_DWORD*)(thisx + 108) = 1;
                result = thisx;
                *(_DWORD*)(thisx + 120) = 2;
            }
            *(_BYTE*)(thisx + 2516) = 2;
        }
    }
    return result;
}

 
int sub_45CBC2(int thisx)
{
    *(_DWORD*)(thisx + 104) = 17;
    *(_BYTE*)(thisx + 2516) = 1;
    sub_45FF40((unsigned char*)thisx);
    *(_WORD*)(thisx + 2564) = 0;
    *(_WORD*)(thisx + 2566) = ((*(_BYTE*)(thisx + 11688) & 3) != 0) + *(unsigned __int8*)(thisx + 11688) / 4;
    sub_465102(thisx);
    return sub_456D33((const CHAR*)thisx, aMenuWav_3, 1, 0);
}

 
int sub_45CC4E(int thisx)
{
    char* v1; // eax
    int result; // eax
    int v3; // esi
    int v5; // [esp+8h] [ebp-44h]
    int v6; // [esp+Ch] [ebp-40h]
    int i; // [esp+10h] [ebp-3Ch]
    int v8[14]; // [esp+14h] [ebp-38h] BYREF

    sub_49C15E((_DWORD)v8);
    v8[1] = 0;
    v8[2] = 0;
    v8[0] = dword_4B9248;
    sub_49AB05((int)unk_4BDC60, v8);
    if (!(dword_4B93B0 / 5u % 2) && *(int*)(thisx + 2528) > 0 && *(int*)(thisx + 2532) > 0)
    {
        for (i = 0; i < 2; ++i)
        {
            v1 = sub_4266D0((char*)(thisx + 76 * i + 11816));
            sub_47B91A(48 * i + *(_DWORD*)(thisx + 2528), *(_DWORD*)(thisx + 2532), v1, 0, -1);
        }
        sub_47B91A(*(_DWORD*)(thisx + 2528) + 40, *(_DWORD*)(thisx + 2532), byte_4B29EC, 0, -1);
    }
    if (!(dword_4B93B0 / 5u % 2))
    {
        if (*(_WORD*)(thisx + 2564))
            sub_47B91A(24, 108, asc_4B29F0, 0, -1);
        if (*(unsigned __int16*)(thisx + 2564) + 2 < *(unsigned __int16*)(thisx + 2566))
            sub_47B91A(288, 108, asc_4B29F4, 0, -1);
    }
    sub_477F0C(0);
    result = *(unsigned __int8*)(thisx + 2516);
    if (!*(_BYTE*)(thisx + 2516))
    {
        v3 = sub_476D78(0);
        v6 = v3 - sub_476D29(0);
        if (v6)
        {
            v5 = v6 + *(unsigned __int16*)(thisx + 2564);
            if (v5 + 2 > *(unsigned __int16*)(thisx + 2566))
                v5 = *(unsigned __int16*)(thisx + 2566) - 2;
            if (v5 < 0)
                LOWORD(v5) = 0;
            *(_WORD*)(thisx + 2564) = v5;
            sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
            sub_465102(thisx);
        }
        result = sub_476DC7(0, 0);
        if (result)
        {
            sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
            if (*(_BYTE*)(thisx + 2562))
            {
                result = *(unsigned __int8*)(thisx + 2562);
                if (result == 1)
                {
                    *(_DWORD*)(thisx + 108) = 19;
                    *(_BYTE*)(thisx + 2516) = 2;
                }
            }
            else
            {
                sub_46287E((char*)thisx);
                if (*(_WORD*)(thisx + 2566) || *(_WORD*)(thisx + 2568))
                {
                    result = thisx;
                    *(_DWORD*)(thisx + 108) = 18;
                    *(_BYTE*)(thisx + 2516) = 2;
                }
                else
                {
                    *(_DWORD*)(thisx + 108) = 19;
                    result = thisx;
                    *(_BYTE*)(thisx + 2516) = 2;
                    *(_BYTE*)(thisx + 13100) = 0;
                }
            }
        }
    }
    return result;
}

 
int sub_45CF31(unsigned __int8* thisx, int a2)
{
    int v3; // [esp+4h] [ebp-8h]
    int v4; // [esp+8h] [ebp-4h]

    v3 = a2 + thisx[27];
    v4 = 0;
    while (v3 >= 100)
    {
        ++v4;
        v3 -= 100;
    }
    thisx[27] = v3;
    return v4;
}

 
int sub_45CF7B(int thisx)
{
    int v1; // eax
    __int16 v2; // ax
    __int16 v3; // ax
    __int16 v4; // ax
    __int16 v5; // ax
    __int16 v6; // ax
    __int16 v7; // ax
    __int16 v8; // ax
    __int16 v9; // ax
    __int16 v10; // ax
    __int16 v11; // ax
    __int16 v12; // ax
    char* v13; // eax
    unsigned __int8 v14; // al
    int v16; // [esp-4h] [ebp-1F0h]
    int v17; // [esp-4h] [ebp-1F0h]
    char v19[8]; // [esp+8h] [ebp-1E4h]
    char v20[8]; // [esp+10h] [ebp-1DCh]
    int v21; // [esp+18h] [ebp-1D4h]
    int v22; // [esp+1Ch] [ebp-1D0h]
    int j; // [esp+20h] [ebp-1CCh]
    char* v24; // [esp+24h] [ebp-1C8h]
    __int16 v25[11]; // [esp+28h] [ebp-1C4h]
    __int16 v26[11]; // [esp+3Eh] [ebp-1AEh]
    int v27; // [esp+54h] [ebp-198h]
    int i; // [esp+58h] [ebp-194h]
    CHAR v29[4]; // [esp+5Ch] [ebp-190h] BYREF
    char v30; // [esp+60h] [ebp-18Ch]
    int v31; // [esp+61h] [ebp-18Bh]
    int v32; // [esp+65h] [ebp-187h]
    int v33; // [esp+69h] [ebp-183h]
    char v34; // [esp+6Dh] [ebp-17Fh]
    int v35; // [esp+6Eh] [ebp-17Eh]
    int v36; // [esp+72h] [ebp-17Ah]
    int v37; // [esp+76h] [ebp-176h]
    __int16 v38; // [esp+7Ah] [ebp-172h]
    char v39; // [esp+7Ch] [ebp-170h]
    int v40; // [esp+7Dh] [ebp-16Fh]
    __int16 v41; // [esp+81h] [ebp-16Bh]
    int v42; // [esp+83h] [ebp-169h]
    int v43; // [esp+87h] [ebp-165h]
    char v44; // [esp+8Bh] [ebp-161h]
    int v45; // [esp+8Ch] [ebp-160h]
    int v46; // [esp+90h] [ebp-15Ch]
    int v47; // [esp+94h] [ebp-158h]
    char v48; // [esp+98h] [ebp-154h]
    int v49; // [esp+99h] [ebp-153h]
    int v50; // [esp+9Dh] [ebp-14Fh]
    char v51; // [esp+A1h] [ebp-14Bh]
    int v52; // [esp+A2h] [ebp-14Ah]
    int v53; // [esp+A6h] [ebp-146h]
    int v54; // [esp+AAh] [ebp-142h]
    char v55; // [esp+AEh] [ebp-13Eh]
    int v56; // [esp+AFh] [ebp-13Dh]
    int v57; // [esp+B3h] [ebp-139h]
    int v58; // [esp+B7h] [ebp-135h]
    int v59; // [esp+BBh] [ebp-131h]
    char v60; // [esp+BFh] [ebp-12Dh]
    int v61; // [esp+C0h] [ebp-12Ch]
    int v62; // [esp+C4h] [ebp-128h]
    int v63; // [esp+C8h] [ebp-124h]
    char v64; // [esp+CCh] [ebp-120h]
    int v65; // [esp+CDh] [ebp-11Fh]
    int v66; // [esp+D1h] [ebp-11Bh]
    int v67; // [esp+D5h] [ebp-117h]
    char v68; // [esp+D9h] [ebp-113h]
    int v69; // [esp+DAh] [ebp-112h]
    int v70; // [esp+DEh] [ebp-10Eh]
    int v71; // [esp+E2h] [ebp-10Ah]
    char v72; // [esp+E6h] [ebp-106h]
    int v73; // [esp+E7h] [ebp-105h]
    CHAR String[256]; // [esp+ECh] [ebp-100h] BYREF

    *(_DWORD*)(thisx + 104) = 18;
    *(_BYTE*)(thisx + 2516) = 1;
    sub_451EB5((_BYTE*)thisx, 1, 1);
    sub_452045((_BYTE*)thisx, 5, 1, 30, 3);
    wsprintfA(String, a1);
    v16 = dword_4B9248;
    v1 = lstrlenA(String);
    sub_47B91A(160 - 2 * v1, 16, String, 0, v16);
    *(_DWORD*)v29 = dword_4B2A18;
    v30 = byte_4B2A1C;
    v31 = 0;
    v32 = 0;
    v33 = dword_4B2A20;
    v34 = byte_4B2A24;
    v35 = 0;
    v36 = 0;
    v37 = dword_4B2A28;
    v38 = word_4B2A2C;
    v39 = byte_4B2A2E;
    v40 = 0;
    v41 = 0;
    v42 = dword_4B2A30;
    v43 = dword_4B2A34;
    v44 = byte_4B2A38;
    v45 = 0;
    v46 = dword_4B2A3C;
    v47 = dword_4B2A40;
    v48 = byte_4B2A44;
    v49 = 0;
    v50 = dword_4B2A48;
    v51 = byte_4B2A4C;
    v52 = 0;
    v53 = 0;
    v54 = dword_4B2A50;
    v55 = byte_4B2A54;
    v56 = 0;
    v57 = 0;
    v58 = dword_4B2A58;
    v59 = dword_4B2A5C;
    v60 = byte_4B2A60;
    v61 = 0;
    v62 = dword_4B2A64;
    v63 = dword_4B2A68;
    v64 = byte_4B2A6C;
    v65 = 0;
    v66 = dword_4B2A70;
    v67 = dword_4B2A74;
    v68 = byte_4B2A78;
    v69 = 0;
    v70 = dword_4B2A7C;
    v71 = dword_4B2A80;
    v72 = byte_4B2A84;
    v73 = 0;
    for (i = 0; i < 2; ++i)
    {
        sub_452045((_BYTE*)thisx, 20 * i, 5, 20, 15);
        v22 = 160 * i + 8;
        v21 = 48;
        v24 = (char*)(thisx + 76 * i + 11816);
        for (j = 0; j < 2; ++j)
        {
            v2 = sub_4750D0(v24);
            v25[11 * j] = v2;
            v3 = sub_426710((short*)v24);
            v25[11 * j + 1] = v3;
            v4 = sub_426730((short*)v24);
            v25[11 * j + 2] = v4;
            v5 = sub_426750((short*)v24);
            v25[11 * j + 3] = v5;
            v6 = sub_426770((short*)v24);
            v25[11 * j + 4] = v6;
            v7 = sub_426810((short*)v24);
            v25[11 * j + 5] = v7;
            v8 = sub_426790((short*)v24);
            v25[11 * j + 6] = v8;
            v9 = sub_4267B0((short*)v24);
            v25[11 * j + 7] = v9;
            v10 = sub_4267D0((short*)v24);
            v25[11 * j + 8] = v10;
            v11 = sub_4267F0((short*)v24);
            v25[11 * j + 9] = v11;
            v12 = sub_426830((short*)v24);
            v25[11 * j + 10] = v12;
            if (!j)
                sub_45D835((short*)v24, *(unsigned __int16*)(thisx + 2 * i + 2566));
        }
        for (j = 0; j < 11; ++j)
            v26[j] -= v25[j];
        v17 = dword_4B9248;
        v13 = sub_4266D0(v24);
        sub_47B91A(v22 + 8, v21, v13, 0, v17);
        sub_47B91A(v22, v21 + 16, v29, 0, dword_4B9248);
        if (v26[0])
            wsprintfA(String, "+%2d", (unsigned __int16)v26[0]);
        else
            wsprintfA(String, asc_4B2A88);
        sub_47B7ED(v22 + 40, v21 + 16, String, 0, dword_4B9248);
        for (j = 1; j < 11; ++j)
        {
            sub_47B91A(80 * ((j - 1) / 5) + v22, v21 + 16 * ((j - 1) % 5) + 32, &v29[13 * j], 0, dword_4B9248);
            if (v26[j])
                wsprintfA(String, "+%2d", (unsigned __int16)v26[j]);
            else
                wsprintfA(String, asc_4B2A94);
            sub_47B7ED(v22 + 80 * ((j - 1) / 5) + 40, v21 + 16 * ((j - 1) % 5) + 32, String, 0, dword_4B9248);
        }
        LOBYTE(v27) = sub_4684DD(v24);
        if ((unsigned __int8)v27 < 3u
            && Concurrency::details::SchedulerBase::GetSchedulerProxy((Concurrency::details::SchedulerBase*)(thisx + 612 * i + 2628)) != (struct Concurrency::ISchedulerProxy*)80)
        {
            v19[0] = 34;
            v19[1] = 17;
            v19[2] = 17;
            v19[3] = 17;
            v19[4] = 17;
            v20[0] = 0x80;
            v20[1] = -125;
            v20[2] = -124;
            v20[3] = -123;
            v20[4] = -122;
            for (j = 0; j < 5; ++j)
            {
                v14 = sub_4758B0(v24, j);
                if (v14 >= (int)(unsigned __int8)v19[j] && !sub_467E11(v24, (unsigned __int8)v20[j]))
                {
                    sub_475890(v24, j, 0);
                    sub_468529(v24, v20[j]);
                    sub_43FFC3((_DWORD*)unk_4BDB28, (_DWORD)dword_4B9AD4, -1, 100, 100, 0);
                }
            }
        }
    }
    return sub_47B91A(16, 208, byte_4B2AA0, 0, dword_4B9248);
} 
int sub_45D7AB(int thisx)
{
    int result; // eax
    int v3[14]; // [esp+4h] [ebp-38h] BYREF

    sub_49C15E((int)v3);
    v3[1] = 0;
    v3[2] = 0;
    v3[0] = dword_4B9248;
    sub_49AB05((int)unk_4BDC60, v3);
    sub_477F0C(0);
    result = sub_476DC7(0, 0);
    if (result)
    {
        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
        result = thisx;
        *(_DWORD*)(thisx + 108) = 19;
        *(_BYTE*)(thisx + 2516) = 2;
        *(_BYTE*)(thisx + 13100) = 0;
    }
    return result;
}

 
_WORD* sub_45D835(_WORD* thisx, int a2)
{
    _WORD* result; // eax
    int v3; // [esp+8h] [ebp-2Ch]
    int v4; // [esp+Ch] [ebp-28h]
    int v5; // [esp+10h] [ebp-24h]
    int v6; // [esp+14h] [ebp-20h]
    int v7; // [esp+18h] [ebp-1Ch]
    int v8; // [esp+1Ch] [ebp-18h]
    int v9; // [esp+20h] [ebp-14h]
    int v10; // [esp+24h] [ebp-10h]
    int v11; // [esp+28h] [ebp-Ch]
    int v12; // [esp+2Ch] [ebp-8h]
    int i; // [esp+30h] [ebp-4h]

    if (a2)
    {
        *thisx += a2;
        v3 = a2 * *((unsigned __int8*)thisx + 48) + *((unsigned __int8*)thisx + 58);
        v4 = a2 * *((unsigned __int8*)thisx + 49) + *((unsigned __int8*)thisx + 59);
        v5 = a2 * *((unsigned __int8*)thisx + 50) + *((unsigned __int8*)thisx + 60);
        v6 = a2 * *((unsigned __int8*)thisx + 51) + *((unsigned __int8*)thisx + 63);
        v7 = a2 * *((unsigned __int8*)thisx + 52) + *((unsigned __int8*)thisx + 61);
        v8 = a2 * *((unsigned __int8*)thisx + 53) + *((unsigned __int8*)thisx + 62);
        v9 = a2 * *((unsigned __int8*)thisx + 54) + *((unsigned __int8*)thisx + 64);
        v10 = a2 * *((unsigned __int8*)thisx + 55) + *((unsigned __int8*)thisx + 65);
        v11 = a2 * *((unsigned __int8*)thisx + 56) + *((unsigned __int8*)thisx + 66);
        v12 = a2 * *((unsigned __int8*)thisx + 57) + *((unsigned __int8*)thisx + 67);
        for (i = 0; i < 10; ++i)
        {
            while (i < 7 && *(&v3 + i) >= 10 || i >= 7 && *(&v3 + i) >= 100)
            {
                switch (i)
                {
                case 0:
                    if ((unsigned __int16)thisx[14] + 3 <= 0xFFFF)
                        thisx[14] += 3;
                    else
                        thisx[14] = -1;
                    break;
                case 1:
                    if ((unsigned __int16)thisx[15] + 1 <= 0xFFFF)
                        ++thisx[15];
                    else
                        thisx[15] = -1;
                    break;
                case 2:
                    if ((unsigned __int16)thisx[16] + 1 <= 0xFFFF)
                        ++thisx[16];
                    else
                        thisx[16] = -1;
                    break;
                case 3:
                    if ((unsigned __int16)thisx[17] + 1 <= 0xFFFF)
                        ++thisx[17];
                    else
                        thisx[17] = -1;
                    break;
                case 4:
                    if ((unsigned __int16)thisx[18] + 1 <= 0xFFFF)
                        ++thisx[18];
                    else
                        thisx[18] = -1;
                    break;
                case 5:
                    if ((unsigned __int16)thisx[19] + 1 <= 0xFFFF)
                        ++thisx[19];
                    else
                        thisx[19] = -1;
                    break;
                case 6:
                    if ((unsigned __int16)thisx[20] + 1 <= 0xFFFF)
                        ++thisx[20];
                    else
                        thisx[20] = -1;
                    break;
                case 7:
                    if ((unsigned __int16)thisx[21] + 1 <= 0xFFFF)
                        ++thisx[21];
                    else
                        thisx[21] = -1;
                    break;
                case 8:
                    if ((unsigned __int16)thisx[22] + 1 <= 0xFFFF)
                        ++thisx[22];
                    else
                        thisx[22] = -1;
                    break;
                case 9:
                    if ((unsigned __int16)thisx[23] + 1 <= 0xFFFF)
                        ++thisx[23];
                    else
                        thisx[23] = -1;
                    break;
                default:
                    break;
                }
                if (i >= 7)
                    *(&v3 + i) -= 100;
                else
                    *(&v3 + i) -= 10;
            }
        }
        *((_BYTE*)thisx + 58) = v3;
        *((_BYTE*)thisx + 59) = v4;
        *((_BYTE*)thisx + 60) = v5;
        *((_BYTE*)thisx + 63) = v6;
        *((_BYTE*)thisx + 61) = v7;
        *((_BYTE*)thisx + 62) = v8;
        *((_BYTE*)thisx + 64) = v9;
        *((_BYTE*)thisx + 65) = v10;
        *((_BYTE*)thisx + 66) = v11;
        result = thisx;
        *((_BYTE*)thisx + 67) = v12;
    }
    return result;
}

 
int sub_45DC7E(int thisxx)
{
    unsigned __int8 v1; // al
    int v2; // ebx
    int v5; // [esp+8h] [ebp-114h]
    bool RuntimeOwnsLifetime; // [esp+Ch] [ebp-110h]
    signed int j; // [esp+10h] [ebp-10Ch]
    int i; // [esp+14h] [ebp-108h]
    int k; // [esp+14h] [ebp-108h]
    CHAR FileName[260]; // [esp+18h] [ebp-104h] BYREF

    *(_DWORD*)(thisxx + 104) = 19;
    *(_BYTE*)(thisxx + 2516) = 1;
    *(_DWORD*)(thisxx + 2528) = 0;
    *(_DWORD*)(thisxx + 2532) = 0;
    *(_BYTE*)(thisxx + 13101) = 0;
    *(_WORD*)(thisxx + 2564) = 0;
    *(_WORD*)(thisxx + 2566) = 1;
    *(_WORD*)(thisxx + 2568) = 1;
    *(_WORD*)(thisxx + 2570) = 0;
    if (*(_BYTE*)(thisxx + 11690) == 17 && *(unsigned __int8*)(thisxx + 13060) > 1u)
    {
        *(_WORD*)(thisxx + 2566) = 0;
        *(_DWORD*)(thisxx + 2528) = 1;
    }
    if (*(unsigned __int8*)(thisxx + 11690) >= 0x11u)
        *(_WORD*)(thisxx + 2568) = 0;
    if (!*(_BYTE*)(thisxx + 13100))
    {
        for (i = 0; i < dword_4B9368; ++i)
        {
            for (j = 0; j < (int)dword_4B93A0; ++j)
                *(_DWORD*)(*((_DWORD*)dword_4B9360 + i) + 4 * j) = 0;
        }
        for (k = 0; k < 2; ++k)
        {
            RuntimeOwnsLifetime = Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime((_UnrealizedChore*)(thisxx + 76 * k + 11816));
            if ((unsigned __int8)RuntimeOwnsLifetime >= 4u)
                RuntimeOwnsLifetime = 0;
            wsprintfA(FileName, "Graphic\\AnteroomBody%02d.bmp", RuntimeOwnsLifetime + 1);
            v1 = sub_426550((_BYTE*)(thisxx + 76 * k + 11816));
            v5 = sub_478523(FileName, 0, v1);
            if (!k)
                *(_DWORD*)(thisxx + 13104) = v5;
            v2 = (unsigned __int8)sub_426570((_BYTE*)(thisxx + 76 * k + 11816));
            *(_DWORD*)(*((_DWORD*)dword_4B9360 + v2) + 4 * (unsigned __int8)sub_426550((_BYTE*)(thisxx + 76 * k + 11816))) = 1;
        }
        sub_4680EF();
        sub_45FDE4((_DWORD*)thisxx, aDataAnteroomti);
        sub_45F998((_DWORD*)thisxx, aDataAnteroomcg);
        if (*(_BYTE*)(thisxx + 11808) || *(_BYTE*)(thisxx + 11809))
        {
            *(_BYTE*)(thisxx + 13100) = 4;
        }
        else if (*(unsigned __int8*)(thisxx + 13044) < 3u && *(unsigned __int8*)(thisxx + 11812) > 2u
            || *(_BYTE*)(thisxx + 13044) == 1)
        {
            *(_BYTE*)(thisxx + 13100) = rand() % 3 + 1;
        }
        else
        {
            *(_BYTE*)(thisxx + 13100) = rand() % 4 + 100;
        }
        if (*(_DWORD*)(thisxx + 112) != 20 && *(_DWORD*)(thisxx + 112) != 4)
        {
            if (*(_BYTE*)(thisxx + 11690) == 17)
            {
                if (*(_BYTE*)(thisxx + 13060) == 1)
                    *(_BYTE*)(thisxx + 13101) = 1;
                else
                    *(_BYTE*)(thisxx + 13101) = 2;
            }
            else if (*(unsigned __int8*)(thisxx + 11690) > 0x11u)
            {
                if (sub_425E70((_BYTE*)(thisxx + 3852)) == 1)
                {
                    *(_BYTE*)(thisxx + 13101) = 4;
                    *(_BYTE*)(thisxx + 11691) = 7;
                    *(_BYTE*)(thisxx + 11690) = 17;
                }
                else
                {
                    *(_BYTE*)(thisxx + 13101) = 3;
                }
            }
        }
        if (*(_BYTE*)(thisxx + 13101))
            *(_WORD*)(thisxx + 2564) = 1;
        else
            *(_WORD*)(thisxx + 2564) = 0;
    }
    *(_DWORD*)(thisxx + 2540) = 0;
    sub_45E15F(thisxx,-1);
    if (*(unsigned __int8*)(thisxx + 13044) >= 3u)
        return sub_456D33((const CHAR*)thisxx, aLoserWav, 1, 0);
    else
        return sub_456D33((const CHAR*)thisxx, aWinnerWav, 1, 0);
}

 
void sub_45E15F(int thisx, int a2)
{
    int v2; // eax
    int v3; // [esp-4h] [ebp-1C0h]
    int v4; // [esp+0h] [ebp-1BCh]
    int i; // [esp+10h] [ebp-1ACh]
    int v7[15]; // [esp+14h] [ebp-1A8h] BYREF
    CHAR String[256]; // [esp+50h] [ebp-16Ch] BYREF
    CHAR v9[4]; // [esp+150h] [ebp-6Ch] BYREF
    int v10; // [esp+154h] [ebp-68h]
    int v11; // [esp+158h] [ebp-64h]
    char v12; // [esp+15Ch] [ebp-60h]
    int v13; // [esp+15Dh] [ebp-5Fh]
    int v14; // [esp+161h] [ebp-5Bh]
    __int16 v15; // [esp+165h] [ebp-57h]
    char v16; // [esp+167h] [ebp-55h]
    __int16 v17; // [esp+168h] [ebp-54h]
    int v18; // [esp+16Ah] [ebp-52h]
    int v19; // [esp+16Eh] [ebp-4Eh]
    __int16 v20; // [esp+172h] [ebp-4Ah]
    char v21; // [esp+174h] [ebp-48h]
    __int16 v22; // [esp+175h] [ebp-47h]
    int v23; // [esp+177h] [ebp-45h]
    __int16 v24; // [esp+17Bh] [ebp-41h]
    char v25; // [esp+17Dh] [ebp-3Fh]
    int v26; // [esp+17Eh] [ebp-3Eh]
    __int16 v27; // [esp+182h] [ebp-3Ah]
    int v28[14]; // [esp+184h] [ebp-38h] BYREF

    if (a2 == -1)
    {
        sub_451EB5((_BYTE*)thisx, 1, 1);
        sub_45E15F(thisx, 0);
        sub_45E15F(thisx, 1);
    }
    else if (a2)
    {
        if (a2 == 1)
        {
            sub_451EB5((_BYTE*)thisx, 0, 1);
            switch (*(_BYTE*)(thisx + 13101))
            {
            case 1:
                switch (*(_WORD*)(thisx + 2564))
                {
                case 1:
                    sub_47B91A(16, 208, byte_4B2B9C, 0, dword_4B9248);
                    break;
                case 2:
                    sub_47B91A(16, 208, byte_4B2BBC, 0, dword_4B9248);
                    sub_47B91A(16, 224, byte_4B2C00, 0, dword_4B9248);
                    break;
                case 3:
                    sub_47B91A(16, 208, byte_4B2C18, 0, dword_4B9248);
                    break;
                }
                break;
            case 2:
                if (*(_WORD*)(thisx + 2564) == 1)
                {
                    sub_47B91A(16, 208, byte_4B2C44, 0, dword_4B9248);
                }
                else if (*(_WORD*)(thisx + 2564) == 2)
                {
                    sub_47B91A(16, 208, byte_4B2C7C, 0, dword_4B9248);
                }
                break;
            case 3:
                if (*(_WORD*)(thisx + 2564) == 1)
                {
                    sub_47B91A(16, 208, byte_4B2CA8, 0, dword_4B9248);
                }
                else if (*(_WORD*)(thisx + 2564) == 2)
                {
                    sub_47B91A(16, 208, byte_4B2CE8, 0, dword_4B9248);
                }
                break;
            case 4:
                v4 = *(unsigned __int16*)(thisx + 2564);
                if (v4 == 1)
                {
                    sub_47B91A(16, 208, byte_4B2D20, 0, dword_4B9248);
                }
                else if (v4 == 2)
                {
                    sub_47B91A(16, 208, byte_4B2D50, 0, dword_4B9248);
                }
                break;
            }
            if (!*(_WORD*)(thisx + 2564))
            {
                if (*(_DWORD*)(thisx + 2528))
                {
                    switch (*(_DWORD*)(thisx + 2528))
                    {
                    case 1:
                        sub_47B91A(16, 208, byte_4B2DA0, 0, dword_4B9248);
                        break;
                    case 2:
                        sub_47B91A(16, 208, byte_4B2DD0, 0, dword_4B9248);
                        break;
                    case 3:
                        sub_47B91A(16, 208, byte_4B2E00, 0, dword_4B9248);
                        break;
                    }
                }
                else
                {
                    sub_47B91A(16, 208, byte_4B2D84, 0, dword_4B9248);
                }
            }
        }
    }
    else
    {
        sub_452045((_BYTE*)thisx, 9, 3, 22, 14);
        sub_452045((_BYTE*)thisx, 11, 1, 18, 4);
        wsprintfA(String, byte_4B2B30);
        v3 = dword_4B9248;
        v2 = lstrlenA(String);
        sub_47B91A(160 - 2 * v2, 20, String, 0, v3);
        sub_49DB90(v7);
        v7[1] = 0;
        v7[2] = 0;
        v7[3] = 110;
        v7[4] = 78;
        v7[9] = -1;
        v7[5] = 1;
        v7[0] = -1;
        sub_49DA45((_DWORD*)unk_4BDC60, aGraphicAnteroo_0, (int)v7);
        sub_49C15E((int)v28);
        v28[1] = 104;
        v28[2] = 48;
        v28[0] = v7[0];
        sub_49CC5B((short*)unk_4BDC60, dword_4B9248, v28);
        sub_49DA8A((_DWORD*)unk_4BDC60, v28[0]);
        sub_452045((_BYTE*)thisx, 8, 18, 24, 5);
        *(_DWORD*)v9 = dword_4B2B6C;
        v10 = dword_4B2B70;
        v11 = dword_4B2B74;
        v12 = byte_4B2B78;
        v13 = dword_4B2B7C;
        v14 = dword_4B2B80;
        v15 = word_4B2B84;
        v16 = byte_4B2B86;
        v17 = 0;
        v18 = dword_4B2B88;
        v19 = dword_4B2B8C;
        v20 = word_4B2B90;
        v21 = byte_4B2B92;
        v22 = 0;
        v23 = dword_4B2B94;
        v24 = word_4B2B98;
        v25 = byte_4B2B9A;
        v26 = 0;
        v27 = 0;
        for (i = 0; i < 4; ++i)
        {
            if ((i || *(_WORD*)(thisx + 2566)) && (i != 2 || *(_WORD*)(thisx + 2568)))
                sub_47B91A(72 * (i % 2) + 96, 16 * (i / 2) + 152, &v9[13 * i], 0, dword_4B9248);
        }
    }
}

 
int sub_45E773(int thisx)
{
    int v1; // esi
    int v2; // esi
    int result; // eax
    int v5; // [esp+8h] [ebp-274h]
    char* v6; // [esp+Ch] [ebp-270h]
    int v7; // [esp+10h] [ebp-26Ch]
    int kk; // [esp+14h] [ebp-268h]
    int v9[14]; // [esp+18h] [ebp-264h] BYREF
    int v10; // [esp+50h] [ebp-22Ch]
    char* v11; // [esp+54h] [ebp-228h]
    int v12; // [esp+58h] [ebp-224h]
    int jj; // [esp+5Ch] [ebp-220h]
    int v14[14]; // [esp+60h] [ebp-21Ch] BYREF
    char* v15; // [esp+98h] [ebp-1E4h]
    int v16; // [esp+9Ch] [ebp-1E0h]
    int ii; // [esp+A0h] [ebp-1DCh]
    int v18[14]; // [esp+A4h] [ebp-1D8h] BYREF
    char* v19; // [esp+DCh] [ebp-1A0h]
    int v20; // [esp+E0h] [ebp-19Ch]
    int n; // [esp+E4h] [ebp-198h]
    int v22[14]; // [esp+E8h] [ebp-194h] BYREF
    int v23; // [esp+120h] [ebp-15Ch]
    char* v24; // [esp+124h] [ebp-158h]
    int v25; // [esp+128h] [ebp-154h]
    int m; // [esp+12Ch] [ebp-150h]
    int v27[14]; // [esp+130h] [ebp-14Ch] BYREF
    char* v28; // [esp+168h] [ebp-114h]
    int v29; // [esp+16Ch] [ebp-110h]
    int k; // [esp+170h] [ebp-10Ch]
    int v31[14]; // [esp+174h] [ebp-108h] BYREF
    char* v32; // [esp+1ACh] [ebp-D0h]
    int v33; // [esp+1B0h] [ebp-CCh]
    int j; // [esp+1B4h] [ebp-C8h]
    int v35; // [esp+1B8h] [ebp-C4h] BYREF
    int v36; // [esp+1BCh] [ebp-C0h]
    unsigned int v37; // [esp+1C0h] [ebp-BCh]
    BOOL v38; // [esp+1D0h] [ebp-ACh]
    char* v39; // [esp+1F0h] [ebp-8Ch]
    int v40; // [esp+1F4h] [ebp-88h]
    int i; // [esp+1F8h] [ebp-84h]
    int v42[15]; // [esp+1FCh] [ebp-80h] BYREF
    int v43; // [esp+238h] [ebp-44h]
    int v44; // [esp+23Ch] [ebp-40h]
    int v45; // [esp+240h] [ebp-3Ch]
    int v46[14]; // [esp+244h] [ebp-38h] BYREF

    sub_477F0C(0);
    if (!*(_BYTE*)(thisx + 2516))
    {
        v1 = sub_476D78(0);
        v45 = v1 - sub_476D29(0);
        v2 = sub_476CDA(0);
        v44 = v2 - sub_476C8B(0);
        if (!*(_WORD*)(thisx + 2564))
        {
            if (v45)
            {
                v43 = *(_DWORD*)(thisx + 2528) / 2;
                *(_DWORD*)(thisx + 2528) = (*(_DWORD*)(thisx + 2528) + v45 + 2) % 2 + 2 * v43;
                sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
            }
            else if (v44)
            {
                *(_DWORD*)(thisx + 2528) = (*(_DWORD*)(thisx + 2528) + 2 * v44 + 4) % 4;
                sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
            }
            if (*(_DWORD*)(thisx + 2528) == 2 && !*(_WORD*)(thisx + 2568))
                *(_DWORD*)(thisx + 2528) = 0;
            if (!*(_DWORD*)(thisx + 2528) && !*(_WORD*)(thisx + 2566))
                *(_DWORD*)(thisx + 2528) = 1;
            if (v45 || v44)
                sub_45E15F(thisx, 1);
        }
        if (sub_476DC7(0, 0))
        {
            sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
            if (*(_WORD*)(thisx + 2564))
            {
                if (++ * (_WORD*)(thisx + 2564) == 4 && *(_BYTE*)(thisx + 13101) == 1)
                {
                    *(_WORD*)(thisx + 2564) = 0;
                }
                else if (*(_WORD*)(thisx + 2564) == 3
                    && (*(_BYTE*)(thisx + 13101) == 2 || *(_BYTE*)(thisx + 13101) == 3 || *(_BYTE*)(thisx + 13101) == 4))
                {
                    *(_WORD*)(thisx + 2564) = 0;
                }
                sub_45E15F(thisx, 1);
            }
            else if (!*(_WORD*)(thisx + 2566) || *(_DWORD*)(thisx + 2528))
            {
                if (*(_DWORD*)(thisx + 2528) == 1)
                {
                    *(_DWORD*)(thisx + 108) = 14;
                    *(_BYTE*)(thisx + 2562) = 2;
                    *(_BYTE*)(thisx + 2516) = 2;
                    *(_WORD*)(thisx + 2564) = 0;
                }
                else if (*(_WORD*)(thisx + 2568) && *(_DWORD*)(thisx + 2528) == 2)
                {
                    *(_DWORD*)(thisx + 108) = 17;
                    *(_BYTE*)(thisx + 2562) = 1;
                    *(_BYTE*)(thisx + 2516) = 2;
                }
                else if (*(_DWORD*)(thisx + 2528) == 3)
                {
                    *(_DWORD*)(thisx + 108) = 20;
                    *(_BYTE*)(thisx + 2562) = 1;
                    *(_BYTE*)(thisx + 2516) = 2;
                }
            }
            else
            {
                byte_4B99CC = *(_BYTE*)(thisx + 11664);
                byte_4B99CB = 1;
                switch (*(_BYTE*)(thisx + 11690))
                {
                case 0x11:
                    *(_DWORD*)(thisx + 108) = 1;
                    *(_DWORD*)(thisx + 120) = 3;
                    *(_BYTE*)(thisx + 2516) = 2;
                    break;
                case 0x12:
                    sub_462869((_DWORD*)thisx);
                    *(_DWORD*)(thisx + 108) = 11;
                    *(_BYTE*)(thisx + 2516) = 2;
                    break;
                case 0x13:
                    sub_462BA9(thisx, 2);
                    *(_DWORD*)(thisx + 108) = 11;
                    *(_BYTE*)(thisx + 2516) = 2;
                    break;
                case 0x14:
                    sub_462BA9(thisx, 4);
                    *(_DWORD*)(thisx + 108) = 11;
                    *(_BYTE*)(thisx + 2516) = 2;
                    break;
                default:
                    if (*(unsigned __int8*)(thisx + 11690) < 0x11u)
                    {
                        ++* (_BYTE*)(thisx + 11690);
                        sub_461D3E((unsigned char*)thisx);
                        *(_DWORD*)(thisx + 108) = 15;
                        *(_BYTE*)(thisx + 2516) = 2;
                    }
                    break;
                }
            }
        }
    }
    sub_49C15E((int)v46);
    v46[1] = 0;
    v46[2] = 0;
    v46[0] = dword_4B9248;
    sub_49AB05((int)unk_4BDC60, v46);
    if (*(_WORD*)(thisx + 2564))
    {
        if (!(dword_4B93B0 / 5u % 2))
            sub_47B91A(156, 232, byte_4B2E2C, 0, -1);
    }
    else
    {
        sub_47B91A(72 * (*(_DWORD*)(thisx + 2528) % 2) + 86, 16 * (*(_DWORD*)(thisx + 2528) / 2) + 152, asc_4B2E28, 0, -1);
    }
    switch (*(_BYTE*)(thisx + 13100))
    {
    case 1:
        result = sub_49C15E((int)v42);
        for (i = 0; i < 2; ++i)
        {
            result = Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime((Concurrency::details::_UnrealizedChore*)(thisx + 76 * i + 11816));
            if (result < 4)
            {
                v42[1] = 32 * i + 144;
                v42[2] = 112;
                v42[6] = i == 1;
                v42[0] = i + *(_DWORD*)(thisx + 13104);
                v39 = (char*)(152 * (((unsigned int)dword_4B93B0 >> 1) % 0xA > 5) + *(_DWORD*)(thisx + 13112));
                v40 = (unsigned __int16)sub_4266F0((short*)thisx + 76 * i + 11816);
                result = sub_4788FA(v42, v39, *(_DWORD*)(thisx + 13120), v40, 0, 0);
            }
        }
        break;
    case 2:
        result = sub_49C15E((int)&v35);
        for (j = 0; j < 2; ++j)
        {
            result = Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime((Concurrency::details::_UnrealizedChore*)(thisx + 76 * j + 11816));
            if (result < 4)
            {
                v36 = 15 * j + 152;
                v37 = 112;
                v38 = j == 0;
                v35 = j + *(_DWORD*)(thisx + 13104);
                v32 = (char*)(152 * (dword_4B93B0 / 0xAu % 2 + 2) + *(_DWORD*)(thisx + 13112));
                v33 = (unsigned __int16)sub_4266F0((short*)thisx + 76 * j + 11816);
                result = sub_4788FA(&v35, v32, *(_DWORD*)(thisx + 13120), v33, 0, 0);
            }
        }
        for (j = 0; j < 2; ++j)
        {
            if ((unsigned __int8)Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime((Concurrency::details::_UnrealizedChore*)(thisx + 76 * j + 11816)) < 4u)
            {
                v36 = 168 - 17 * j;
                v37 = 2 * (dword_4B93B0 / 0xAu % 2) + 112;
                v38 = j == 1;
                v35 = j + *(_DWORD*)(thisx + 13104);
                v32 = (char*)(*(_DWORD*)(thisx + 13112) + 608);
                sub_4788FA(&v35, v32, *(_DWORD*)(thisx + 13120), v33, 0, 0);
            }
            result = j + 1;
        }
        break;
    case 3:
        result = sub_49C15E((int)v31);
        for (k = 0; k < 2; ++k)
        {
            if ((unsigned __int8)Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime((Concurrency::details::_UnrealizedChore*)(thisx + 76 * k + 11816)) < 4u)
            {
                v31[1] = 32 * k + 144;
                v31[2] = 112;
                v31[6] = k == 1;
                v31[0] = k + *(_DWORD*)(thisx + 13104);
                v28 = (char*)(152 * ((((unsigned int)dword_4B93B0 >> 1) % 0xA > 5) + 5) + *(_DWORD*)(thisx + 13112));
                v29 = (unsigned __int16)sub_4266F0((short*)thisx + 76 * k + 11816);
                sub_4788FA(v31, v28, *(_DWORD*)(thisx + 13120), v29, 0, 0);
            }
            result = k + 1;
        }
        break;
    case 4:
        result = sub_49C15E((int)v27);
        for (m = 0; m < 2; ++m)
        {
            result = Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime((Concurrency::details::_UnrealizedChore*)(thisx + 76 * m + 11816));
            if (result < 4)
            {
                v27[1] = 32 * m + 144;
                v27[2] = 112;
                v27[6] = m == 1;
                v27[0] = m + *(_DWORD*)(thisx + 13104);
                v24 = (char*)(152 * ((((unsigned int)dword_4B93B0 >> 1) % 0xA > 5) + 13) + *(_DWORD*)(thisx + 13112));
                v25 = (unsigned __int16)sub_4266F0((short*)thisx + 76 * m + 11816);
                result = sub_4788FA(v27, v24, *(_DWORD*)(thisx + 13120), v25, 0, *(_BYTE*)(m + thisx + 11808));
            }
        }
        break;
    case 0x64:
        result = sub_49C15E((int)v22);
        for (n = 0; n < 2; ++n)
        {
            if ((unsigned __int8)Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime((Concurrency::details::_UnrealizedChore*)(thisx + 76 * n + 11816)) < 4u)
            {
                v22[1] = 160;
                v22[2] = 112 - 3 * n;
                v22[6] = n == 0;
                v22[0] = n + *(_DWORD*)(thisx + 13104);
                v19 = (char*)(152 * ((((unsigned int)dword_4B93B0 >> 1) % 0xA > 5) + 9 - 2 * (n == 1))
                    + *(_DWORD*)(thisx + 13112));
                v20 = (unsigned __int16)sub_4266F0((short*)thisx + 76 * n + 11816);
                v23 = sub_4682AC((unsigned char*)thisx + 76 * n + 11816);
                sub_4788FA(v22, v19, *(_DWORD*)(thisx + 13120), v20, v23, 0);
            }
            result = n + 1;
        }
        break;
    case 0x65:
        result = sub_49C15E((int)v18);
        for (ii = 0; ii < 2; ++ii)
        {
            if ((unsigned __int8)Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime((Concurrency::details::_UnrealizedChore*)(thisx + 76 * ii + 11816)) < 4u)
            {
                v18[1] = 32 * ii + 144;
                v18[2] = 112;
                v18[6] = ii == 1;
                v18[0] = ii + *(_DWORD*)(thisx + 13104);
                v15 = (char*)(152 * ((dword_4B93B0 / 3u % 0xA > 5) + 11) + *(_DWORD*)(thisx + 13112));
                v16 = (unsigned __int16)sub_4266F0((short*)thisx + 76 * ii + 11816);
                sub_4788FA(v18, v15, *(_DWORD*)(thisx + 13120), v16, 0, 0);
            }
            result = ii + 1;
        }
        break;
    case 0x66:
        result = sub_49C15E((int)v14);
        for (jj = 0; jj < 2; ++jj)
        {
            result = Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime((Concurrency::details::_UnrealizedChore*)(thisx + 76 * jj + 11816));
            if (result < 4)
            {
                v14[1] = 32 * jj + 144;
                v14[2] = 112;
                v14[6] = jj == 0;
                v14[0] = jj + *(_DWORD*)(thisx + 13104);
                v11 = (char*)(152 * (dword_4B93B0 / 0xCu % 2 + 15) + *(_DWORD*)(thisx + 13112));
                v12 = (unsigned __int16)sub_4266F0((short*)thisx + 76 * jj + 11816);
                result = sub_4788FA(v14, v11, *(_DWORD*)(thisx + 13120), v12, 0, 0);
            }
        }
        break;
    default:
        result = thisx;
        if (*(_BYTE*)(thisx + 13100) == 103)
        {
            result = sub_49C15E((int)v9);
            for (kk = 0; kk < 2; ++kk)
            {
                v5 = 1 - kk;
                result = Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime((Concurrency::details::_UnrealizedChore*)(thisx + 76 * (1 - kk) + 11816));
                if (result < 4)
                {
                    v9[1] = 160;
                    v9[2] = 112 - 3 * kk;
                    v9[6] = kk == 0;
                    v9[0] = v5 + *(_DWORD*)(thisx + 13104);
                    v6 = (char*)(152 * ((((unsigned int)dword_4B93B0 >> 1) % 0xA > 5) + 9 - 2 * (kk == 1))
                        + *(_DWORD*)(thisx + 13112));
                    v7 = (unsigned __int16)sub_4266F0((short*)thisx + 76 * v5 + 11816);
                    v10 = sub_4682AC((unsigned char*)thisx + 76 * v5 + 11816);
                    result = sub_4788FA(v9, v6, *(_DWORD*)(thisx + 13120), v7, v10, 0);
                }
            }
        }
        break;
    }
    return result;
}

 
int sub_45F935(int thisx)
{
    int result; // eax

    if (*(_DWORD*)(thisx + 13112))
        (***(void(****)(_DWORD, int))(thisx + 13112))(*(_DWORD*)(thisx + 13112), 3);
    result = thisx;
    *(_DWORD*)(thisx + 13112) = 0;
    *(_DWORD*)(thisx + 13108) = 0;
    return result;
}

 
int sub_45F998(_DWORD* thisx, LPCSTR lpFileName)
{
    unsigned __int16 v3; // ax
    unsigned __int16 v4; // ax
    char v5; // al
    char v6; // al
    int* v7; // eax
    int* v8; // eax
    char v9; // al
    char v10; // al
    char* v11; // [esp+0h] [ebp-8Ch]
    int v13[4]; // [esp+8h] [ebp-84h] BYREF
    int v14[4]; // [esp+18h] [ebp-74h] BYREF
    void* Block; // [esp+28h] [ebp-64h]
    char* v16; // [esp+2Ch] [ebp-60h]
    int v17; // [esp+30h] [ebp-5Ch]
    int v18; // [esp+34h] [ebp-58h]
    struct tagRECT rc; // [esp+38h] [ebp-54h] BYREF
    int v20; // [esp+48h] [ebp-44h]
    int yTop; // [esp+4Ch] [ebp-40h]
    int v22; // [esp+50h] [ebp-3Ch]
    int yBottom; // [esp+54h] [ebp-38h]
    int v24; // [esp+58h] [ebp-34h]
    int v25; // [esp+5Ch] [ebp-30h]
    char* v26; // [esp+60h] [ebp-2Ch]
    int j; // [esp+64h] [ebp-28h]
    int v28; // [esp+68h] [ebp-24h]
    HANDLE hFile; // [esp+6Ch] [ebp-20h]
    unsigned int i; // [esp+70h] [ebp-1Ch]
    int Buffer; // [esp+74h] [ebp-18h] BYREF
    DWORD NumberOfBytesRead; // [esp+78h] [ebp-14h] BYREF
    int v33; // [esp+7Ch] [ebp-10h]
    int v34; // [esp+88h] [ebp-4h]

    sub_45F935((int)thisx);
    hFile = CreateFileA(lpFileName, 0x80000000, 0, 0, 3u, 0x80u, 0);
    if (hFile == (HANDLE)-1)
        return 0;
    SetFilePointer(hFile, 12, 0, 0);
    ReadFile(hFile, &Buffer, 1u, (LPDWORD)&NumberOfBytesRead, 0);
    ReadFile(hFile, thisx + 3277, 2u, (LPDWORD)&NumberOfBytesRead, 0);
    v33 = thisx[3277];
    Block = operator new(152 * v33 + 4);
    v34 = 0;
    if (Block)
    {
        *(_DWORD*)Block = v33;
        eh_vector_constructor_iterator((char *)Block + 4, 0x98u, v33, sub_401870, sub_401927);
            v11 = (char*)Block + 4;
    }
    else
    {
        v11 = 0;
    }
    v16 = v11;
    v34 = -1;
    thisx[3278] = (_DWORD)v11;
    for (i = 0; i < thisx[3277]; ++i)
        sub_40197E((_BYTE*)(152 * i + thisx[3278]), hFile, (unsigned __int8)Buffer, 0);
    for (i = 0; i < thisx[3277]; ++i)
    {
        v26 = (char*)(152 * i + thisx[3278]);
        LOBYTE(v28) = sub_401DFE(v26);
        v28 = (unsigned __int8)v28;
        for (j = 0; j < v28; ++j)
        {
            v3 = sub_401BEF((_DWORD*)v26, j);
            LOBYTE(v25) = sub_425F50((_BYTE*)(12 * v3 + thisx[3280]));
            v25 = (unsigned __int8)v25;
            v4 = sub_401BEF((_DWORD*)v26, j);
            LOBYTE(v24) = sub_425F90((_BYTE*)(12 * v4 + thisx[3280]));
            v24 = (unsigned __int8)v24;
            v5 = sub_401C1E((_DWORD*)v26, j, 0);
            v17 = -v5 - 8 * v25;
            v6 = sub_401C5B((_DWORD*)v26, j, 0);
            v18 = -v6 - 8 * v24;
            sub_401D24((_DWORD*)v26, j, v17, 1);
            sub_401D62((_DWORD*)v26, j, v18, 1);
            v7 = sub_425B90(v26, v14, 0, 0);
            v20 = *v7;
            yTop = v7[1];
            v22 = v7[2];
            yBottom = v7[3];
            SetRect(&rc, -v22, yTop, -v20, yBottom);
            sub_475910(v26, rc.left, rc.top, rc.right, rc.bottom, 1, 0);
            v8 = sub_425BD0(v26, v13, 0, 0);
            v20 = *v8;
            yTop = v8[1];
            v22 = v8[2];
            yBottom = v8[3];
            SetRect(&rc, -v22, yTop, -v20, yBottom);
            sub_475950(v26, rc.left, rc.top, rc.right, rc.bottom, 1, 0);
            v9 = sub_4758D0(v26, 0);
            sub_475990(v26, -v9, 1);
            v10 = sub_4758F0(v26, 0);
            sub_4759B0(v26, -v10, 1);
        }
    }
    CloseHandle(hFile);
    return 1;
}

 
int sub_45FD81(int thisx)
{
    int result; // eax

    if (*(_DWORD*)(thisx + 13120))
        (***(void(****)(_DWORD, int))(thisx + 13120))(*(_DWORD*)(thisx + 13120), 3);
    result = thisx;
    *(_DWORD*)(thisx + 13120) = 0;
    *(_DWORD*)(thisx + 13116) = 0;
    return result;
}

 
int sub_45FDE4(_DWORD* thisx, LPCSTR lpFileName)
{
    _DWORD* v3; // [esp+0h] [ebp-30h]
    int* Block; // [esp+8h] [ebp-28h]
    HANDLE hFile; // [esp+10h] [ebp-20h]
    unsigned int i; // [esp+14h] [ebp-1Ch]
    char Buffer[4]; // [esp+18h] [ebp-18h] BYREF
    int v9; // [esp+1Ch] [ebp-14h]
    DWORD NumberOfBytesRead; // [esp+20h] [ebp-10h] BYREF
    int v11; // [esp+2Ch] [ebp-4h]

    sub_45FD81((int)thisx);
    hFile = CreateFileA(lpFileName, 0x80000000, 0, 0, 3u, 0x80u, 0);
    if (hFile == (HANDLE)-1)
        return 0;
    ReadFile(hFile, Buffer, 2u, (LPDWORD)&NumberOfBytesRead, 0);
    ReadFile(hFile, thisx + 3279, 2u, (LPDWORD)&NumberOfBytesRead, 0);
    v9 = thisx[3279];
    Block = (int*)operator new(12 * v9 + 4);
    v11 = 0;
    if (Block)
    {
        *Block = v9;
        eh_vector_constructor_iterator(Block + 1, 0xCu, v9, sub_48F630, sub_48F666);
            v3 = Block + 1;
    }
    else
    {
        v3 = 0;
    }
    v11 = -1;
    thisx[3280] = (_DWORD)v3;
    for (i = 0; i < thisx[3279]; ++i)
        sub_48F6C5((LPVOID*)(thisx[3280] + 12 * i), hFile);
    CloseHandle(hFile);
    return 1;
}

 
int sub_45FF40(unsigned __int8* thisx)
{
    int result; // eax
    int m; // [esp+8h] [ebp-18h]
    int j; // [esp+Ch] [ebp-14h]
    char v4; // [esp+10h] [ebp-10h]
    int i; // [esp+18h] [ebp-8h]
    int k; // [esp+18h] [ebp-8h]
    int v7; // [esp+1Ch] [ebp-4h]

    for (i = 0; i < thisx[11688]; ++i)
    {
        v4 = 1;
        for (j = 0; j < thisx[11688]; ++j)
        {
            if (i != j && *(unsigned __int16*)&thisx[2 * i + 11692] < (int)*(unsigned __int16*)&thisx[2 * j + 11692])
                ++v4;
        }
        thisx[i + 13060] = v4;
    }
    v7 = 0;
    for (k = 0; ; ++k)
    {
        result = thisx[11688];
        if (k >= result)
            break;
        for (m = 0; m < thisx[11688]; ++m)
        {
            if (k + 1 == thisx[m + 13060])
            {
                thisx[v7 + 13076] = m;
                if (++v7 >= thisx[11688])
                {
                    k = v7;
                    break;
                }
            }
        }
    }
    return result;
}

 
int sub_460089(int thisx, HANDLE hFile)
{
    DWORD NumberOfBytesWritten; // [esp+4h] [ebp-80h] BYREF
    LPCVOID v5[10]; // [esp+8h] [ebp-7Ch]
    int i; // [esp+30h] [ebp-54h]
    LPCVOID v7[10]; // [esp+34h] [ebp-50h]
    LPCVOID v8[10]; // [esp+5Ch] [ebp-28h]

    WriteFile(hFile, (LPCVOID)(thisx + 2), 0xBu, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, (LPCVOID)(thisx + 13), 2u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, (LPCVOID)(thisx + 15), 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, (LPCVOID)(thisx + 20), 2u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, (LPCVOID)(thisx + 22), 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, (LPCVOID)(thisx + 24), 2u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, (LPCVOID)(thisx + 16), 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, (LPCVOID)(thisx + 18), 2u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, (LPCVOID)thisx, 2u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, (LPCVOID)(thisx + 27), 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    v7[0] = (LPCVOID)(thisx + 28);
    v7[1] = (LPCVOID)(thisx + 30);
    v7[2] = (LPCVOID)(thisx + 32);
    v7[3] = (LPCVOID)(thisx + 34);
    v7[4] = (LPCVOID)(thisx + 36);
    v7[5] = (LPCVOID)(thisx + 38);
    v7[6] = (LPCVOID)(thisx + 40);
    v7[7] = (LPCVOID)(thisx + 42);
    v7[8] = (LPCVOID)(thisx + 44);
    v7[9] = (LPCVOID)(thisx + 46);
    for (i = 0; i < 10; ++i)
        WriteFile(hFile, v7[i], 2u, (LPDWORD)&NumberOfBytesWritten, 0);
    v5[0] = (LPCVOID)(thisx + 48);
    v5[1] = (LPCVOID)(thisx + 49);
    v5[2] = (LPCVOID)(thisx + 50);
    v5[3] = (LPCVOID)(thisx + 51);
    v5[4] = (LPCVOID)(thisx + 52);
    v5[5] = (LPCVOID)(thisx + 53);
    v5[6] = (LPCVOID)(thisx + 54);
    v5[7] = (LPCVOID)(thisx + 55);
    v5[8] = (LPCVOID)(thisx + 56);
    v5[9] = (LPCVOID)(thisx + 57);
    for (i = 0; i < 10; ++i)
        WriteFile(hFile, v5[i], 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    v8[0] = (LPCVOID)(thisx + 58);
    v8[1] = (LPCVOID)(thisx + 59);
    v8[2] = (LPCVOID)(thisx + 60);
    v8[3] = (LPCVOID)(thisx + 63);
    v8[4] = (LPCVOID)(thisx + 61);
    v8[5] = (LPCVOID)(thisx + 62);
    v8[6] = (LPCVOID)(thisx + 64);
    v8[7] = (LPCVOID)(thisx + 65);
    v8[8] = (LPCVOID)(thisx + 66);
    v8[9] = (LPCVOID)(thisx + 67);
    for (i = 0; i < 10; ++i)
        WriteFile(hFile, v8[i], 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    for (i = 0; i < 5; ++i)
        WriteFile(hFile, (LPCVOID)(thisx + i + 71), 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, (LPCVOID)(thisx + 68), 3u, (LPDWORD)&NumberOfBytesWritten, 0);
    return 1;
}

 
int sub_460412(unsigned __int8* thisx, HANDLE hFile)
{
    BOOL v3; // [esp+0h] [ebp-18h]
    int j; // [esp+8h] [ebp-10h]
    DWORD NumberOfBytesWritten; // [esp+Ch] [ebp-Ch] BYREF
    int i; // [esp+10h] [ebp-8h]
    BOOL v8; // [esp+14h] [ebp-4h]

    WriteFile(hFile, thisx + 11968, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, thisx + 13044, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    v3 = thisx[11690] == 17 && thisx[13060] >= 2u;
    v8 = v3;
    if (v3)
        thisx[11690] = 0;
    WriteFile(hFile, thisx + 11690, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    if (v8)
        thisx[11690] = 17;
    WriteFile(hFile, thisx + 11691, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, thisx + 11806, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, thisx + 11805, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, thisx + 11814, 2u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, thisx + 11664, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, thisx + 11807, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, thisx + 11614, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, thisx + 11812, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, thisx + 11660, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, thisx + 11683, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, thisx + 11684, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    for (i = 0; i < 2; ++i)
    {
        WriteFile(hFile, &thisx[i + 11808], 1u, (LPDWORD)&NumberOfBytesWritten, 0);
        WriteFile(hFile, &thisx[i + 11810], 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    }
    WriteFile(hFile, thisx + 11688, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    for (i = 0; i < thisx[11688]; ++i)
    {
        for (j = 0; j < 2; ++j)
            WriteFile(hFile, &thisx[4 * i + 11724 + 2 * j], 2u, (LPDWORD)&NumberOfBytesWritten, 0);
        WriteFile(hFile, &thisx[2 * i + 11692], 2u, (LPDWORD)&NumberOfBytesWritten, 0);
        WriteFile(hFile, &thisx[i + 11788], 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    }
    for (i = 0; i < 2; ++i)
        sub_460089((int)&thisx[76 * i + 11816], hFile);
    return 1;
}

 
int sub_460758(unsigned __int8* thisx, int a2)
{
    HANDLE hFile; // [esp+4h] [ebp-110h]
    CHAR FileName[260]; // [esp+8h] [ebp-10Ch] BYREF
    DWORD NumberOfBytesWritten; // [esp+10Ch] [ebp-8h] BYREF
    char Buffer[4]; // [esp+110h] [ebp-4h] BYREF

    wsprintfA(FileName, "Save%02d.dat", a2);
    hFile = CreateFileA(FileName, 0x40000000u, 0, 0, 4u, 0x80u, 0);
    if (hFile == (HANDLE)-1)
        return 0;
    WriteFile(hFile, aKdsavedata, 0xAu, (LPDWORD)&NumberOfBytesWritten, 0);
    Buffer[0] = 7;
    WriteFile(hFile, Buffer, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    sub_460412(thisx, hFile);
    CloseHandle(hFile);
    return 1;
}

 
int sub_460813(int thisx, HANDLE hFile, int a3)
{
    int v3; // edx
    LPVOID v6[10]; // [esp+4h] [ebp-80h]
    int i; // [esp+2Ch] [ebp-58h]
    LPVOID v8[10]; // [esp+30h] [ebp-54h]
    LPVOID v9[10]; // [esp+58h] [ebp-2Ch]
    DWORD NumberOfBytesRead; // [esp+80h] [ebp-4h] BYREF

    ReadFile(hFile, (LPVOID)(thisx + 2), 0xBu, (LPDWORD)&NumberOfBytesRead, 0);
    ReadFile(hFile, (LPVOID)(thisx + 13), 2u, (LPDWORD)&NumberOfBytesRead, 0);
    ReadFile(hFile, (LPVOID)(thisx + 15), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    ReadFile(hFile, (LPVOID)(thisx + 20), 2u, (LPDWORD)&NumberOfBytesRead, 0);
    if ((unsigned __int8)a3 >= 6u)
        ReadFile(hFile, (LPVOID)(thisx + 22), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    else
        *(_BYTE*)(thisx + 22) = *(unsigned __int16*)(thisx + 20) == 22;
    v3 = (unsigned __int8)a3;
    if ((unsigned __int8)a3 < 3u)
        *(_WORD*)(thisx + 24) = 0;
    else
        ReadFile(hFile, (LPVOID)(thisx + 24), 2u, (LPDWORD)&NumberOfBytesRead, 0);
    LOWORD(v3) = *(_WORD*)(thisx + 24);
    *(_BYTE*)(thisx + 26) = sub_47C20C(v3);
    ReadFile(hFile, (LPVOID)(thisx + 16), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    ReadFile(hFile, (LPVOID)(thisx + 18), 2u, (LPDWORD)&NumberOfBytesRead, 0);
    ReadFile(hFile, (LPVOID)thisx, 2u, (LPDWORD)&NumberOfBytesRead, 0);
    ReadFile(hFile, (LPVOID)(thisx + 27), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    v8[0] = (LPVOID)(thisx + 28);
    v8[1] = (LPVOID)(thisx + 30);
    v8[2] = (LPVOID)(thisx + 32);
    v8[3] = (LPVOID)(thisx + 34);
    v8[4] = (LPVOID)(thisx + 36);
    v8[5] = (LPVOID)(thisx + 38);
    v8[6] = (LPVOID)(thisx + 40);
    v8[7] = (LPVOID)(thisx + 42);
    v8[8] = (LPVOID)(thisx + 44);
    v8[9] = (LPVOID)(thisx + 46);
    for (i = 0; i < 10; ++i)
    {
        if ((unsigned __int8)a3 != 1 || i < 4 || i > 5)
            ReadFile(hFile, v8[i], 2u, (LPDWORD)&NumberOfBytesRead, 0);
    }
    v6[0] = (LPVOID)(thisx + 48);
    v6[1] = (LPVOID)(thisx + 49);
    v6[2] = (LPVOID)(thisx + 50);
    v6[3] = (LPVOID)(thisx + 51);
    v6[4] = (LPVOID)(thisx + 52);
    v6[5] = (LPVOID)(thisx + 53);
    v6[6] = (LPVOID)(thisx + 54);
    v6[7] = (LPVOID)(thisx + 55);
    v6[8] = (LPVOID)(thisx + 56);
    v6[9] = (LPVOID)(thisx + 57);
    for (i = 0; i < 10; ++i)
    {
        if ((unsigned __int8)a3 != 1 || i < 4 || i > 5)
            ReadFile(hFile, v6[i], 1u, (LPDWORD)&NumberOfBytesRead, 0);
    }
    v9[0] = (LPVOID)(thisx + 58);
    v9[1] = (LPVOID)(thisx + 59);
    v9[2] = (LPVOID)(thisx + 60);
    v9[3] = (LPVOID)(thisx + 63);
    v9[4] = (LPVOID)(thisx + 61);
    v9[5] = (LPVOID)(thisx + 62);
    v9[6] = (LPVOID)(thisx + 64);
    v9[7] = (LPVOID)(thisx + 65);
    v9[8] = (LPVOID)(thisx + 66);
    v9[9] = (LPVOID)(thisx + 67);
    for (i = 0; i < 10; ++i)
    {
        if ((unsigned __int8)a3 != 1 || i < 4 || i > 5)
            ReadFile(hFile, v9[i], 1u, (LPDWORD)&NumberOfBytesRead, 0);
    }
    for (i = 0; i < 5; ++i)
    {
        if ((unsigned __int8)a3 >= 6u)
            ReadFile(hFile, (LPVOID)(thisx + i + 71), 1u, (LPDWORD)&NumberOfBytesRead, 0);
        else
            *(_BYTE*)(i + thisx + 71) = 0;
    }
    ReadFile(hFile, (LPVOID)(thisx + 68), 3u, (LPDWORD)&NumberOfBytesRead, 0);
    if ((unsigned __int8)a3 == 1)
    {
        *(_WORD*)(thisx + 36) = (*(unsigned __int16*)(thisx + 34)
            + *(unsigned __int16*)(thisx + 30)
            + *(unsigned __int16*)(thisx + 32))
            / 3;
        *(_WORD*)(thisx + 38) = (*(unsigned __int16*)(thisx + 34)
            + *(unsigned __int16*)(thisx + 30)
            + *(unsigned __int16*)(thisx + 32))
            / 3;
        *(_BYTE*)(thisx + 52) = (*(unsigned __int8*)(thisx + 51)
            + *(unsigned __int8*)(thisx + 49)
            + *(unsigned __int8*)(thisx + 50))
            / 3;
        *(_BYTE*)(thisx + 53) = *(_BYTE*)(thisx + 52);
        *(_BYTE*)(thisx + 61) = 0;
        *(_BYTE*)(thisx + 62) = 0;
    }
    return 1;
}

 
int sub_460D5F(void* thisx, HANDLE hFile, int a3, int a4, int a5)
{
    int v5; // eax
    int v6; // ecx
    int m; // [esp+4h] [ebp-14h]
    int i; // [esp+8h] [ebp-10h]
    int j; // [esp+Ch] [ebp-Ch]
    int k; // [esp+10h] [ebp-8h]
    int n; // [esp+10h] [ebp-8h]
    DWORD NumberOfBytesRead; // [esp+14h] [ebp-4h] BYREF

    ReadFile(hFile, (LPVOID)(a4 + 253), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    ReadFile(hFile, (LPVOID)(a4 + 368), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    ReadFile(hFile, (LPVOID)(a4 + 254), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    if ((unsigned __int8)a3 < 5u)
        *(_BYTE*)(a4 + 255) = *(unsigned __int8*)(a4 + 254) / 2;
    else
        ReadFile(hFile, (LPVOID)(a4 + 255), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    ReadFile(hFile, (LPVOID)(a4 + 370), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    ReadFile(hFile, (LPVOID)(a4 + 369), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    if ((unsigned __int8)a3 < 5u)
        *(_WORD*)(a4 + 378) = 30 * *(unsigned __int8*)(a4 + 370);
    else
        ReadFile(hFile, (LPVOID)(a4 + 378), 2u, (LPDWORD)&NumberOfBytesRead, 0);
    ReadFile(hFile, (LPVOID)(a4 + 228), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    ReadFile(hFile, (LPVOID)(a4 + 371), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    if ((unsigned __int8)a3 < 2u)
        *(_BYTE*)(a4 + 178) = 4;
    else
        ReadFile(hFile, (LPVOID)(a4 + 178), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    if ((unsigned __int8)a3 < 3u)
        *(_BYTE*)(a4 + 376) = 4;
    else
        ReadFile(hFile, (LPVOID)(a4 + 376), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    if ((unsigned __int8)a3 < 4u)
        *(_BYTE*)(a4 + 224) = 1;
    else
        ReadFile(hFile, (LPVOID)(a4 + 224), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    if ((unsigned __int8)a3 < 7u)
    {
        *(_BYTE*)(a4 + 247) = 1;
        *(_BYTE*)(a4 + 248) = 0;
    }
    else
    {
        ReadFile(hFile, (LPVOID)(a4 + 247), 1u, (LPDWORD)&NumberOfBytesRead, 0);
        ReadFile(hFile, (LPVOID)(a4 + 248), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    }
    if ((unsigned __int8)a3 < 2u)
    {
        for (i = 0; i < 2; ++i)
        {
            *(_BYTE*)(i + a4 + 372) = 0;
            *(_BYTE*)(i + a4 + 374) = 0;
        }
        *(_BYTE*)(a4 + 252) = 8;
    }
    else
    {
        for (j = 0; j < 2; ++j)
        {
            ReadFile(hFile, (LPVOID)(a4 + j + 372), 1u, (LPDWORD)&NumberOfBytesRead, 0);
            ReadFile(hFile, (LPVOID)(a4 + j + 374), 1u, (LPDWORD)&NumberOfBytesRead, 0);
        }
        ReadFile(hFile, (LPVOID)(a4 + 252), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    }
    for (k = 0; ; ++k)
    {
        v5 = a4;
        v6 = *(unsigned __int8*)(a4 + 252);
        if (k >= v6)
            break;
        for (m = 0; m < 2; ++m)
            ReadFile(hFile, (LPVOID)(a4 + 4 * k + 288 + 2 * m), 2u, (LPDWORD)&NumberOfBytesRead, 0);
        ReadFile(hFile, (LPVOID)(a4 + 2 * k + 256), 2u, (LPDWORD)&NumberOfBytesRead, 0);
        if ((unsigned __int8)a3 < 3u)
            *(_BYTE*)(k + a4 + 352) = k % 8;
        else
            ReadFile(hFile, (LPVOID)(a4 + k + 352), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    }
    for (n = 0; n < 2; ++n)
    {
        if (a5)
        {
            LOBYTE(v5) = a3;
            v5 = sub_460813((int)thisx + 76 * n + 11816, hFile, v5);
        }
        else
        {
            LOBYTE(v6) = a3;
            v5 = sub_460813(76 * n + a4, hFile, v6);
        }
    }
    return 1;
}

 
int sub_4611A8(_BYTE* thisx, int a2, int a3)
{
    int v4; // eax
    int v6; // [esp+4h] [ebp-124h]
    HANDLE hFile; // [esp+8h] [ebp-120h]
    CHAR FileName[260]; // [esp+Ch] [ebp-11Ch] BYREF
    char v9[4]; // [esp+110h] [ebp-18h] BYREF
    int v10; // [esp+114h] [ebp-14h]
    DWORD NumberOfBytesRead; // [esp+118h] [ebp-10h] BYREF
    CHAR Buffer[12]; // [esp+11Ch] [ebp-Ch] BYREF

    wsprintfA(FileName, "Save%02d.dat", a2);
    hFile = CreateFileA(FileName, 0x80000000, 0, 0, 3u, 0x80u, 0);
    if (hFile == (HANDLE)-1)
        return 0;
    Buffer[10] = 0;
    ReadFile(hFile, Buffer, 0xAu, (LPDWORD)&NumberOfBytesRead, 0);
    if (lstrcmpiA(Buffer, aKdsavedata_0))
    {
        CloseHandle(hFile);
        return 0;
    }
    else
    {
        v9[0] = 1;
        v4 = ReadFile(hFile, v9, 1u, (LPDWORD)&NumberOfBytesRead, 0);
        v10 = (int)(thisx + 11436);
        v6 = 1;
        if (a3)
        {
            v4 = a3;
            v10 = a3;
            v6 = 0;
        }
        LOBYTE(v4) = v9[0];
        sub_460D5F(thisx, hFile, v4, v10, v6);
        if (v6)
        {
            if (*(_BYTE*)(v10 + 254))
            {
                thisx[11968] = *(_BYTE*)(v10 + 253);
                thisx[13044] = *(_BYTE*)(v10 + 368);
                thisx[13100] = 0;
                sub_45FF40((unsigned char*)thisx);
                sub_466901((_DWORD*)thisx);
            }
        }
        CloseHandle(hFile);
        return 1;
    }
}

 
int sub_461335(int thisx)
{
    char* v1; // eax
    char* v2; // eax
    unsigned __int16 v3; // ax
    unsigned __int16 v4; // ax
    int result; // eax
    int v6; // [esp-4h] [ebp-290h]
    int v7; // [esp-4h] [ebp-290h]
    int v9; // [esp+4h] [ebp-288h]
    int v10; // [esp+8h] [ebp-284h]
    int i; // [esp+Ch] [ebp-280h]
    char v12[76]; // [esp+10h] [ebp-27Ch] BYREF
    char v13[178]; // [esp+5Ch] [ebp-230h] BYREF
    unsigned __int8 v14; // [esp+10Eh] [ebp-17Eh]
    unsigned __int16 v15; // [esp+110h] [ebp-17Ch]
    CHAR String[256]; // [esp+18Ch] [ebp-100h] BYREF

    *(_DWORD*)(thisx + 104) = 20;
    if (*(unsigned __int8*)(thisx + 2562) < 2u)
        *(_BYTE*)(thisx + 2516) = 1;
    *(_DWORD*)(thisx + 2528) = *(unsigned __int8*)(thisx + 13124);
    sub_451EB5((_BYTE*)thisx, 1, 1);
    sub_463E60((int)v12);
    for (i = 0; i < 6; ++i)
    {
        sub_452045((_BYTE*)thisx, 19 * (i / 3) + 1, 7 * (i % 3) + 1, 18, 6);
        v10 = 8 * (19 * (i / 3) + 1);
        v9 = 8 * (7 * (i % 3) + 1);
        wsprintfA(String, "NO%d", i + 1);
        sub_47B7ED(v10 + 16, v9 + 8, String, 0, dword_4B9248);
        if (sub_4611A8((_BYTE*)thisx, i, (int)v12))
        {
            *(_WORD*)(thisx + 2 * i + 2564) = 1;
            v6 = dword_4B9248;
            v1 = sub_4266D0(v12);
            sub_47B91A(v10 + 48, v9 + 8, v1, 0, v6);
            sub_47B91A(v10 + 88, v9 + 8, (LPCSTR)&byte_4B2654, 0, dword_4B9248);
            v7 = dword_4B9248;
            v2 = sub_4266D0(v13);
            sub_47B91A(v10 + 96, v9 + 8, v2, 0, v7);
            if (v14)
            {
                if (v14 < 0x11u)
                {
                    wsprintfA(String, (LPCSTR)&byte_4B1F22, v14 + 1);
                    sub_47B7ED(v10 + 8, v9 + 20, String, 0, dword_4B9248);
                    sub_47B91A(v10 + 24, v9 + 20, a2d_5, 0, dword_4B9248);
                }
                else
                {
                    sub_47B91A(v10 + 8, v9 + 20, (LPCSTR)&byte_4B1B38, 0, dword_4B9248);
                }
            }
            else
            {
                sub_47B91A(v10 + 8, v9 + 20, byte_4B1B2C, 0, dword_4B9248);
            }
            wsprintfA(String, "%2dPOINT", v15);
            sub_47B7ED(v10 + 8, v9 + 32, String, 0, dword_4B9248);
            v3 = sub_4750D0(v12);
            wsprintfA(String, "LV%2d", v3);
            sub_47B7ED(v10 + 88, v9 + 20, String, 0, dword_4B9248);
            v4 = sub_4750D0(v13);
            wsprintfA(String, "LV%2d", v4);
            sub_47B7ED(v10 + 88, v9 + 32, String, 0, dword_4B9248);
        }
        else
        {
            *(_WORD*)(thisx + 2 * i + 2564) = 0;
            sub_47B91A(v10 + 48, v9 + 8, (LPCSTR)&byte_4B0C10, 0, dword_4B9248);
        }
    }
    if (*(_BYTE*)(thisx + 2562))
        result = sub_47B91A(16, 208, (LPCSTR)&byte_4B2DB2, 0, dword_4B9248);
    else
        result = sub_47B91A(16, 208, (LPCSTR)&byte_4B1B52, 0, dword_4B9248);
    if (*(_DWORD*)(thisx + 112) == 19)
        return sub_456D33((const CHAR*)thisx, aMenuWav_4, 1, 0);
    return result;
}

 
int sub_4617E5(int thisx)
{
    int v1; // esi
    int v2; // esi
    int result; // eax
    int v5; // [esp+Ch] [ebp-40h]
    int v6; // [esp+10h] [ebp-3Ch]
    int v7[14]; // [esp+14h] [ebp-38h] BYREF

    if (!*(_BYTE*)(thisx + 2516))
    {
        sub_477F0C(0);
        v1 = sub_476D78(0);
        v6 = v1 - sub_476D29(0);
        v2 = sub_476CDA(0);
        v5 = v2 - sub_476C8B(0);
        if (*(unsigned __int8*)(thisx + 2562) >= 2u)
        {
            if (*(_BYTE*)(thisx + 2562) == 2 && v6)
            {
                sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
                *(_DWORD*)(thisx + 2532) = *(_DWORD*)(thisx + 2532) == 0;
            }
        }
        else if (v6)
        {
            sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
            *(_DWORD*)(thisx + 2528) = (*(_DWORD*)(thisx + 2528) + 3 * v6 + 6) % 6;
        }
        else if (v5)
        {
            sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
            *(_DWORD*)(thisx + 2528) = 3 * (*(_DWORD*)(thisx + 2528) / 3) + (*(_DWORD*)(thisx + 2528) % 3 + v5 + 3) % 3;
        }
        if (sub_476DC7(0, 0))
        {
            sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
            if (*(_BYTE*)(thisx + 2562) || !*(_WORD*)(thisx + 2 * *(_DWORD*)(thisx + 2528) + 2564))
            {
                switch (*(_BYTE*)(thisx + 2562))
                {
                case 1:
                    *(_BYTE*)(thisx + 2562) = 2;
                    *(_DWORD*)(thisx + 2532) = 0;
                    sub_451EB5((_BYTE*)thisx, 0, 1);
                    sub_47B91A(16, 208, byte_4B2F38, 0, dword_4B9248);
                    sub_47B91A(16, 224, byte_4B2F64, 0, dword_4B9248);
                    break;
                case 2:
                    if (*(_DWORD*)(thisx + 2532))
                    {
                        sub_451EB5((_BYTE*)thisx, 0, 1);
                        sub_47B91A(16, 208, byte_4B2FA4, 0, dword_4B9248);
                        *(_BYTE*)(thisx + 2562) = 1;
                    }
                    else
                    {
                        sub_460758((unsigned __int8*)thisx, *(_DWORD*)(thisx + 2528));
                        *(_BYTE*)(thisx + 13124) = *(_BYTE*)(thisx + 2528);
                        sub_461335(thisx);
                        sub_451EB5((_BYTE*)thisx, 0, 1);
                        sub_47B91A(16, 208, byte_4B2F84, 0, dword_4B9248);
                        *(_BYTE*)(thisx + 2562) = 3;
                    }
                    break;
                case 3:
                    if (*(_DWORD*)(thisx + 112) == 1 && *(_DWORD*)(thisx + 124) == 5)
                    {
                        *(_DWORD*)(thisx + 108) = 1;
                        *(_DWORD*)(thisx + 120) = 1;
                        *(_BYTE*)(thisx + 2516) = 2;
                    }
                    else
                    {
                        *(_DWORD*)(thisx + 108) = 19;
                        *(_BYTE*)(thisx + 2562) = 1;
                        *(_BYTE*)(thisx + 2516) = 2;
                    }
                    break;
                }
            }
            else
            {
                *(_DWORD*)(thisx + 16404) = 1;
                *(_BYTE*)(thisx + 13124) = *(_BYTE*)(thisx + 2528);
                sub_4611A8((_BYTE*)thisx, *(_DWORD*)(thisx + 2528), 0);
                *(_BYTE*)(thisx + 2562) = 0;
                if (*(_BYTE*)(thisx + 11690))
                    *(_DWORD*)(thisx + 108) = 19;
                else
                    *(_DWORD*)(thisx + 108) = 4;
                *(_BYTE*)(thisx + 2516) = 2;
            }
        }
        else if (sub_476DC7(0, 1))
        {
            if (*(_BYTE*)(thisx + 2562))
            {
                if (*(_BYTE*)(thisx + 2562) == 1)
                {
                    if (*(_DWORD*)(thisx + 112) == 1 && *(_DWORD*)(thisx + 124) == 5)
                    {
                        *(_DWORD*)(thisx + 108) = 1;
                        *(_DWORD*)(thisx + 120) = 1;
                        *(_BYTE*)(thisx + 2516) = 2;
                    }
                    else
                    {
                        *(_DWORD*)(thisx + 108) = 19;
                        *(_BYTE*)(thisx + 2562) = 1;
                        *(_BYTE*)(thisx + 2516) = 2;
                    }
                }
                else if (*(_BYTE*)(thisx + 2562) == 2)
                {
                    sub_451EB5((_BYTE*)thisx, 0, 1);
                    sub_47B91A(16, 208, byte_4B2FD0, 0, dword_4B9248);
                    *(_BYTE*)(thisx + 2562) = 1;
                }
            }
            else
            {
                *(_DWORD*)(thisx + 16404) = 0;
                *(_DWORD*)(thisx + 108) = 3;
                *(_BYTE*)(thisx + 2516) = 2;
            }
        }
    }
    sub_49C15E((int)v7);
    v7[1] = 0;
    v7[2] = 0;
    v7[0] = dword_4B9248;
    sub_49AB05((int)unk_4BDC60, v7);
    sub_47B91A(152 * (*(_DWORD*)(thisx + 2528) / 3) + 12, 56 * (*(_DWORD*)(thisx + 2528) % 3) + 16, asc_4B2FFC, 0, -1);
    result = thisx;
    if (*(_BYTE*)(thisx + 2562) == 2)
        return sub_47B91A(48 * *(_DWORD*)(thisx + 2532) + 44, 224, asc_4B3000, 0, -1);
    return result;
}

 
int sub_461D3E(unsigned __int8* thisx)
{
    int result; // eax
    unsigned __int8 v3; // [esp+4h] [ebp-54h]
    int jj; // [esp+8h] [ebp-50h]
    int v5; // [esp+Ch] [ebp-4Ch]
    unsigned __int8 m; // [esp+10h] [ebp-48h]
    int j; // [esp+14h] [ebp-44h]
    int v8; // [esp+18h] [ebp-40h]
    int v9; // [esp+1Ch] [ebp-3Ch]
    int v10; // [esp+20h] [ebp-38h]
    unsigned __int8 v11; // [esp+24h] [ebp-34h]
    int i; // [esp+28h] [ebp-30h]
    int k; // [esp+28h] [ebp-30h]
    int n; // [esp+28h] [ebp-30h]
    int ii; // [esp+28h] [ebp-30h]
    char v16[16]; // [esp+2Ch] [ebp-2Ch]
    int v17; // [esp+3Ch] [ebp-1Ch]
    int v18; // [esp+40h] [ebp-18h]
    int v19; // [esp+44h] [ebp-14h]
    int v20; // [esp+48h] [ebp-10h]
    int v21; // [esp+4Ch] [ebp-Ch]
    int v22; // [esp+50h] [ebp-8h]
    unsigned __int8 v23; // [esp+54h] [ebp-4h]

    byte_4B9984 = 0;
    sub_45FF40(thisx);
    v18 = 0;
    for (i = 0; i < thisx[11688]; ++i)
    {
        for (j = 0; j < thisx[11688]; ++j)
        {
            if (thisx[j + 13060] == i + 1)
                v16[v18++] = j;
        }
    }
    LOBYTE(v17) = thisx[11812];
    LOBYTE(v22) = thisx[11688] / (__int16)(unsigned __int8)v17;
    LOBYTE(v20) = thisx[11688] % (__int16)(unsigned __int8)v17;
    for (k = 0; k < (unsigned __int8)v22; ++k)
        thisx[k + 13002] = v17;
    if ((_BYTE)v20)
        thisx[k + 13002] = v20;
    if ((_BYTE)v22 && (_BYTE)v20 && (unsigned __int8)v20 < 3u)
    {
        for (m = 3 - v20; (unsigned __int8)v22 < (int)m; --m)
            ;
        for (n = 0; n < m; ++n)
        {
            --thisx[(unsigned __int8)v22 - n + 13001];
            ++thisx[(unsigned __int8)v22 + 13002];
        }
    }
    if ((_BYTE)v20)
        LOBYTE(v22) = v22 + 1;
    thisx[12969] = v22;
    v8 = 0;
    v19 = thisx[11690] % (int)thisx[11688] + 1;
    v9 = 1;
    v10 = thisx[11688] % v19;
    for (ii = 0; ii < (unsigned __int8)v22; ++ii)
    {
        v5 = thisx[ii + 13002];
        for (jj = 0; jj < v5; ++jj)
        {
            v3 = v8;
            v8 += v19;
            if (v10)
            {
                if (v8 == thisx[11688] + v9 - 1)
                {
                    v8 = v9++;
                }
                else if (v8 > thisx[11688])
                {
                    v8 -= thisx[11688];
                }
            }
            else if (v8 >= thisx[11688])
            {
                v8 = v9++;
            }
            thisx[4 * ii + 12970 + jj] = v16[v3];
            if (!v16[v3])
            {
                LOBYTE(v21) = ii;
                v11 = jj;
            }
        }
    }
    v23 = thisx[4 * (unsigned __int8)v21 + 12970];
    thisx[4 * (unsigned __int8)v21 + 12970] = 0;
    result = v11;
    thisx[4 * (unsigned __int8)v21 + 12970 + v11] = v23;
    return result;
}

 
int sub_462234(_DWORD* thisx, int a2, int a3)
{
    int v4; // [esp+4h] [ebp-10h]
    int v5; // [esp+10h] [ebp-4h]

    if (a2)
    {
        if (a2 < 1 || a2 > 4)
        {
            return 0;
        }
        else
        {
            v5 = (unsigned __int8)sub_4264F0((char*)&thisx[153 * ((a2 - 1) % 2) + 657]);
            v4 = (a2 - 1) / 2;
            if (v4 == 1)
                v4 = v5 + 1;
            if (a3 >= 0 && a3 < (unsigned __int16)word_4B9318[v4])
                return 152 * a3 + dword_4B9324[v4];
            else
                return 0;
        }
    }
    else if (a3 >= 0 && (unsigned int)a3 < thisx[3277])
    {
        return 152 * a3 + thisx[3278];
    }
    else
    {
        return 0;
    }
}

 
int sub_46231F(_DWORD* thisx, int a2)
{
    int v3; // [esp+4h] [ebp-10h]
    int v4; // [esp+10h] [ebp-4h]

    if (!a2)
        return thisx[3280];
    if (a2 < 0)
        return 0;
    v4 = (unsigned __int8)sub_4264F0((char*)&thisx[153 * ((a2 - 1) % 2) + 657]);
    v3 = (a2 - 1) / 2;
    if (v3)
        v3 = v4 + 1;
    return dword_4B9348[v3];
}

 
void sub_4623AC(int thisx, int a2, int a3)
{
    if (a2 >= 0 && a2 < 8)
    {
        if (a3)
        {
            switch (a3)
            {
            case 1:
                dword_4B9AEC[a2] = (unsigned __int16)sub_475850((short*)thisx + 11892);
                break;
            case 2:
            case 3:
                dword_4B9AEC[a2] = Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime((_UnrealizedChore*)(thisx + 76 * (a3 - 2) + 11816));
                break;
            case 4:
                dword_4B9AEC[a2] = (unsigned __int16)sub_475850((short*)thisx + 11816);
                break;
            case 5:
                dword_4B9AEC[a2] = *(unsigned __int8*)(thisx + 11691);
                break;
            case 6:
                dword_4B9AEC[a2] = (unsigned __int8)sub_425E70((_BYTE*)(thisx + 3852));
                break;
            }
        }
        else
        {
            dword_4B9AEC[a2] = 100 * *(unsigned __int16*)(thisx + 11692) / (4 * *(unsigned __int8*)(thisx + 11690));
        }
    }
}

 
int sub_4624C3(_DWORD* thisx)
{
	thisx[26] = 1;
	thisx[31] = 2;
	thisx[324] = 0;
	thisx[632] = 0;
	thisx[633] = 0;
	thisx[622] = 100;
	thisx[623] = 0;
	dword_4B93AC = 0;
	sub_4891E4(thisx + 32, aDemoTigerdemo0);
	sub_47F958(thisx + 184);
	return sub_456169(thisx);
}

 
int sub_462556(_DWORD* thisx, int a2)
{
    if (a2 < 0 || a2 >= 3)
        return 0;
    if (a2)
        return sub_475AC0(&thisx[153 * a2 + 504]);
    return thisx[3276];
}

 
int sub_46259F(_BYTE* thisx)
{
    char RuntimeOwnsLifetime; // al
    BOOL v2; // ebx
    unsigned __int8 v3; // cl
    int v4; // ebx
    signed int n; // [esp+8h] [ebp-10h]
    int m; // [esp+Ch] [ebp-Ch]
    signed int j; // [esp+10h] [ebp-8h]
    int i; // [esp+14h] [ebp-4h]
    int k; // [esp+14h] [ebp-4h]

    for (i = 0; i < dword_4B9368; ++i)
    {
        for (j = 0; j < (int)dword_4B93A0; ++j)
            *(_DWORD*)(*((_DWORD*)dword_4B9360 + i) + 4 * j) = 0;
    }
    for (k = 0; k < 2; ++k)
    {
        sub_475050(&thisx[612 * k + 2628], 0);
        RuntimeOwnsLifetime = Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime((Concurrency::details::_UnrealizedChore*)&thisx[76 * k + 11816]);
        sub_474FF0(&thisx[612 * k + 2628], RuntimeOwnsLifetime);
        for (m = 0; m < 4; ++m)
        {
            for (n = 0; n < (int)dword_4B93A0; ++n)
                *((_WORD*)*(&dword_4B9370 + m) + n) = -1;
        }
        v2 = Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime((Concurrency::details::_UnrealizedChore*)&thisx[76 * k + 11816]);
        *((_WORD*)*(&dword_4B9370 + v2) + (unsigned __int8)sub_426550(&thisx[76 * k + 11816])) = 0;
        v3 = sub_426550(&thisx[76 * k + 11816]);
        sub_475AE0((short*) & thisx[612 * k + 2628], v3);
        sub_41C48F((int)&thisx[612 * k + 2628], -1);
        v4 = (unsigned __int8)sub_426570(&thisx[76 * k + 11816]);
        *(_DWORD*)(*((_DWORD*)dword_4B9360 + v4) + 4 * (unsigned __int8)sub_426550(&thisx[76 * k + 11816])) = 1;
    }
    sub_4680EF();
    return 1;
}

 
int sub_46279C(_DWORD* thisx)
{
    if (thisx[26] == 19)
    {
        sub_49DA8A((_DWORD*)unk_4BDC60, thisx[3276]);
        thisx[3276] = -1;
        sub_45F935((_DWORD)thisx);
        sub_45FD81((_DWORD)thisx);
    }
    thisx[26] = 1;
    thisx[31] = 3;
    thisx[324] = 0;
    thisx[632] = 0;
    thisx[633] = 0;
    thisx[622] = 100;
    thisx[623] = 0;
    dword_4B93AC = 0;
    sub_4891E4(thisx + 32, aDemoTigerdemo0_0);
    sub_47F958(thisx + 184);
    return sub_456169(thisx);
}

 
void sub_462869(_DWORD* thisx)
{
	sub_462BA9((int)thisx, 1);
}

 
void sub_46287E(_BYTE* thisx)
{
    int v1; // esi
    int v2; // esi
    int v3; // esi
    int v4; // esi
    Concurrency::details::SchedulerBase* v6; // [esp+8h] [ebp-10h]
    _BYTE* v7; // [esp+Ch] [ebp-Ch]
    unsigned __int8 v8; // [esp+10h] [ebp-8h]
    int i; // [esp+14h] [ebp-4h]

    for (i = 0; i < 2; ++i)
    {
        v8 = 100;
        v6 = (Concurrency::details::SchedulerBase*)&thisx[612 * i + 2628];
        v7 = &thisx[76 * i + 11816];
        if (Concurrency::details::SchedulerBase::GetSchedulerProxy(v6) == (struct Concurrency::ISchedulerProxy*)80)
            ++thisx[11691];
        else
            v8 = 125;
        v1 = (unsigned __int16)sub_474EB0((short*)&thisx[612 * i + 2628]);
        if (v1 == sub_41D61F((int)&thisx[612 * i + 2628]))
            v8 += 15;
        if (Concurrency::details::SchedulerBase::GetSchedulerProxy((Concurrency::details::SchedulerBase*)&thisx[612 * (1 - i) + 2628]) != (struct Concurrency::ISchedulerProxy*)80)
            v8 += 15;
        v2 = (unsigned __int16)sub_474EB0((short*)&thisx[612 * (1 - i) + 2628]);
        if (v2 == sub_41D61F((int)&thisx[612 * (1 - i) + 2628]))
            v8 += 5;
        switch (thisx[13044])
        {
        case 1:
            v8 += 30;
            break;
        case 2:
            v8 += 20;
            break;
        case 3:
            v8 += 10;
            break;
        }
        *(_WORD*)&thisx[2 * i + 2566] = sub_45CF31((unsigned char*)&thisx[76 * i + 11816], v8);
        if (Concurrency::details::SchedulerBase::GetSchedulerProxy(v6) != (struct Concurrency::ISchedulerProxy*)80)
        {
            v3 = sub_475B00((_DWORD*)v6);
            if (v3 < sub_475B20((_DWORD*)v6))
                sub_468591(v7, 0, 1);
            v4 = 100 * (unsigned __int16)sub_474EB0((short*)v6);
            if (v4 / sub_41D61F((_DWORD)v6) <= 10)
                sub_468591(v7, 1, 1);
            if (sub_475B60((_DWORD*)v6) >= 10)
                sub_468591(v7, 2, 1);
            if (thisx[i + 11808] == 12)
                sub_468591(v7, 3, 1);
            if (sub_475B40((_DWORD*)v6) >= 10)
                sub_468591(v7, 4, 1);
        }
    }
}

 
int sub_462B0C(int thisx)
{
    *(_DWORD*)(thisx + 104) = 1;
    *(_DWORD*)(thisx + 124) = 4;
    *(_DWORD*)(thisx + 1296) = 0;
    *(_DWORD*)(thisx + 2528) = 0;
    *(_DWORD*)(thisx + 2532) = 0;
    *(_DWORD*)(thisx + 2488) = 100;
    *(_DWORD*)(thisx + 2492) = 0;
    dword_4B93AC = 0;
    sub_4891E4((_DWORD*)(thisx + 128), aDemoTigerdemo0_1);
    sub_47F958((_DWORD*)thisx + 736);
    *(_BYTE*)(thisx + 2516) = 1;
    return sub_456169((void*)thisx);
}

 
void sub_462BA9(int thisx, int a2)
{
    int n; // [esp+4h] [ebp-10h]
    int m; // [esp+8h] [ebp-Ch]
    int k; // [esp+Ch] [ebp-8h]
    int i; // [esp+10h] [ebp-4h]
    int j; // [esp+10h] [ebp-4h]

    for (i = 0; i < 8; ++i)
    {
        *(_BYTE*)(i + thisx + 2620) = 0;
        byte_4B9988[i] = i;
    }
    byte_4B9984 = a2;
    switch (a2)
    {
    case 1:
        byte_4B9985 = 4;
        byte_4B9986 = *(_BYTE*)(thisx + 11968);
        byte_4B9987 = 4 - *(_BYTE*)(thisx + 11968);
        byte_4B9990 = 2;
        for (j = 0; j < 2; ++j)
            *(_BYTE*)(j + thisx + 2546) = 2;
        *(_WORD*)(thisx + 2564) = 0;
        *(_BYTE*)(thisx + 2580) = Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime((_UnrealizedChore*)(thisx + 11816));
        *(_WORD*)(thisx + 2566) = 1;
        *(_BYTE*)(thisx + 2581) = Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime((_UnrealizedChore*)(thisx + 11892));
        *(_WORD*)(thisx + 2568) = 16;
        *(_BYTE*)(thisx + 2582) = 4;
        *(_WORD*)(thisx + 2570) = 17;
        *(_BYTE*)(thisx + 2583) = 4;
        *(_BYTE*)(thisx + 29) = 8;
        break;
    case 2:
        byte_4B9985 = 6;
        byte_4B9986 = *(_BYTE*)(thisx + 11968);
        byte_4B9987 = 6 - *(_BYTE*)(thisx + 11968);
        byte_4B9990 = 2;
        *(_BYTE*)(thisx + 2546) = 2;
        *(_BYTE*)(thisx + 2547) = 4;
        *(_WORD*)(thisx + 2564) = 0;
        *(_BYTE*)(thisx + 2580) = Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime((_UnrealizedChore*)(thisx + 11816));
        *(_WORD*)(thisx + 2566) = 1;
        *(_BYTE*)(thisx + 2581) = Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime((_UnrealizedChore*)(thisx + 11892));
        *(_WORD*)(thisx + 2568) = 18;
        *(_BYTE*)(thisx + 2582) = 2;
        *(_WORD*)(thisx + 2570) = 19;
        *(_BYTE*)(thisx + 2583) = 1;
        *(_WORD*)(thisx + 2572) = 20;
        *(_BYTE*)(thisx + 2584) = 0;
        *(_WORD*)(thisx + 2574) = 21;
        *(_BYTE*)(thisx + 2585) = 3;
        for (k = 2; k < 6; ++k)
            *(_BYTE*)(k + thisx + 2612) = 2;
        *(_BYTE*)(thisx + 29) = 8;
        break;
    case 3:
        byte_4B9985 = 3;
        byte_4B9986 = *(_BYTE*)(thisx + 11968);
        byte_4B9987 = 3 - *(_BYTE*)(thisx + 11968);
        byte_4B9990 = 2;
        *(_BYTE*)(thisx + 2546) = 2;
        *(_BYTE*)(thisx + 2547) = 1;
        for (m = 0; m < 8; ++m)
            byte_4B9988[m] = m;
        *(_WORD*)(thisx + 2564) = 0;
        *(_BYTE*)(thisx + 2580) = Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime((_UnrealizedChore*)(thisx + 11816));
        *(_WORD*)(thisx + 2566) = 1;
        *(_BYTE*)(thisx + 2581) = Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime((_UnrealizedChore*)(thisx + 11892));
        if (*(unsigned __int8*)(thisx + 11691) > 3u)
            *(_BYTE*)(thisx + 2622) = 1;
        else
            *(_BYTE*)(thisx + 2622) = 2;
        *(_WORD*)(thisx + 2568) = 0;
        *(_BYTE*)(thisx + 2582) = 0;
        *(_BYTE*)(thisx + 29) = 8;
        break;
    case 4:
        byte_4B9985 = 4;
        byte_4B9986 = *(_BYTE*)(thisx + 11968);
        byte_4B9987 = 4 - *(_BYTE*)(thisx + 11968);
        byte_4B9990 = 2;
        *(_BYTE*)(thisx + 2546) = 2;
        *(_BYTE*)(thisx + 2547) = 2;
        for (n = 0; n < 8; ++n)
            byte_4B9988[n] = n;
        *(_WORD*)(thisx + 2564) = 0;
        *(_BYTE*)(thisx + 2580) = Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime((_UnrealizedChore*)(thisx + 11816));
        *(_WORD*)(thisx + 2566) = 1;
        *(_BYTE*)(thisx + 2581) = Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime((_UnrealizedChore*)(thisx + 11892));
        *(_BYTE*)(thisx + 2622) = 3;
        *(_WORD*)(thisx + 2568) = 0;
        *(_BYTE*)(thisx + 2582) = 0;
        *(_BYTE*)(thisx + 2623) = 4;
        *(_WORD*)(thisx + 2570) = 0;
        *(_BYTE*)(thisx + 2583) = 0;
        *(_BYTE*)(thisx + 29) = 8;
        break;
    }
}

 
int sub_463007(int thisx)
{
	*(_DWORD*)(thisx + 104) = 1;
	*(_DWORD*)(thisx + 124) = 5;
	*(_DWORD*)(thisx + 1296) = 0;
	*(_DWORD*)(thisx + 2528) = 0;
	*(_DWORD*)(thisx + 2532) = 0;
	*(_DWORD*)(thisx + 2488) = 100;
	*(_DWORD*)(thisx + 2492) = 0;
	dword_4B93AC = 0;
	sub_4891E4((_DWORD*)(thisx + 128), aDemoEnding01Tx);
	sub_47F958((_DWORD*)(thisx + 736));
	*(_BYTE*)(thisx + 2516) = 1;
	return sub_456169((void*)thisx);
}

 
int sub_4630A4(unsigned __int8* thisx)
{
    return thisx[13042] - 1;
}

 
BOOL sub_4630BF(unsigned __int8* thisx, int a1, int a2)
{
	Concurrency::details::SchedulerBase* v4; // [esp+4h] [ebp-4h]

	v4 = (Concurrency::details::SchedulerBase*)sub_463101(thisx, a1, a2);
	return v4 && Concurrency::details::SchedulerBase::GetSchedulerProxy(v4) != (struct Concurrency::ISchedulerProxy*)80;
}

 
unsigned __int8*  sub_463101(unsigned __int8* thisx, int a2, int a3)
{
    int v4; // [esp+4h] [ebp-10h]
    int i; // [esp+8h] [ebp-Ch]

    if (a2 < 0 || a2 >(unsigned __int8)byte_4B9990 || a3 < 0 || a3 > thisx[a2 + 2546])
        return 0;
    v4 = 0;
    for (i = 0; i < a2; ++i)
        v4 += thisx[i + 2546];
    return &thisx[612 * (unsigned __int8)byte_4B9988[a3 + v4] + 2628];
}

 
char* sub_4631A8(_BYTE* thisx, int a2)
{
    char* result; // eax

    result = &thisx[a2];
    --thisx[a2 + 13092];
    return result;
}

 
char* sub_4631D0(_BYTE* thisx, int a2)
{
    char* result; // eax

    result = &thisx[a2];
    ++thisx[a2 + 13092];
    return result;
}

 
int  sub_4631F8(unsigned __int8* thisx)
{
    char v2; // al
    char* v3; // eax
    int v5; // [esp+4h] [ebp-204h]
    int jj; // [esp+68h] [ebp-1A0h]
    int ii; // [esp+6Ch] [ebp-19Ch]
    int v8; // [esp+70h] [ebp-198h]
    int v9; // [esp+74h] [ebp-194h]
    int v10; // [esp+78h] [ebp-190h]
    int n; // [esp+80h] [ebp-188h]
    int v12; // [esp+84h] [ebp-184h]
    int v13; // [esp+88h] [ebp-180h]
    int v14; // [esp+8Ch] [ebp-17Ch]
    int v15; // [esp+90h] [ebp-178h]
    int k; // [esp+94h] [ebp-174h]
    int v17; // [esp+98h] [ebp-170h]
    int v18; // [esp+9Ch] [ebp-16Ch]
    int m; // [esp+A0h] [ebp-168h]
    int v20; // [esp+A4h] [ebp-164h]
    int v21; // [esp+A8h] [ebp-160h]
    int v22; // [esp+ACh] [ebp-15Ch]
    int v23; // [esp+B0h] [ebp-158h]
    int j; // [esp+B4h] [ebp-154h]
    int v25; // [esp+B8h] [ebp-150h]
    int v26[4]; // [esp+BCh] [ebp-14Ch] BYREF
    size_t Size; // [esp+CCh] [ebp-13Ch]
    int i; // [esp+D0h] [ebp-138h]
    int v29; // [esp+D4h] [ebp-134h]
    int v30; // [esp+D8h] [ebp-130h]
    _DWORD* v31; // [esp+DCh] [ebp-12Ch]
    _DWORD* v32; // [esp+E0h] [ebp-128h]
    int v33; // [esp+E4h] [ebp-124h]
    int v34; // [esp+E8h] [ebp-120h]
    CHAR String1[260]; // [esp+ECh] [ebp-11Ch] BYREF
    _BYTE* v36; // [esp+1F0h] [ebp-18h]
    int v37; // [esp+1F4h] [ebp-14h]
    int v38; // [esp+1F8h] [ebp-10h]
    int v39; // [esp+204h] [ebp-4h]

    sub_482BF0(v26);
    v39 = 0;
    if (sub_482C74((int)v26, aPairTxt))
    {
        v34 = word_4B99E4;
        Size = 0;
        LOBYTE(v38) = 0;
        while (sub_482D44(v26, String1))
        {
            if (lstrcmpiA(String1, aStart_2))
            {
                if (!lstrcmpiA(String1, aEnd))
                {
                    if ((unsigned __int8)v38 != 1 || !Size)
                        break;
                    sub_48314A(v26);
                    v32 = (_DWORD*)operator new(44 * Size);
                    if (v32)
                    {
                        for (i = 0; i < (int)(11 * Size); ++i)
                            v32[i] = -1;
                        v31 = (_DWORD*)operator new(4 * Size);
                        if (v31)
                        {
                            v36 = (char*)operator new(Size);
                            if (v36)
                            {
                                while (1)
                                {
                                    if (!sub_482D44(v26, String1))
                                        goto LABEL_25;
                                    if (!lstrcmpiA(String1, aStart_3))
                                        break;
                                    sub_482FAA(v26);
                                }
                                sub_482FAA(v26);
                                i = 0;
                            LABEL_30:
                                if (i < (int)Size)
                                {
                                    v31[i] = 0;
                                    v25 = 0;
                                    while (sub_482D44(v26, String1))
                                    {
                                        if (String1[0] == 110)
                                            goto LABEL_29;
                                        if (v25)
                                        {
                                            v32[11 * i - 1 + v25] = -1;
                                            if (lstrcmpiA(String1, byte_4B3084) || v25 >= 3)
                                            {
                                                for (j = 0; j < (int)::Size; ++j)
                                                {
                                                    v3 = unknown_libname_18((char*)(36 * j + dword_4B92E0));
                                                    if (!lstrcmpiA(String1, v3))
                                                    {
                                                        v32[11 * i - 1 + v25] = j;
                                                        break;
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                v32[11 * i - 1 + v25] = -2;
                                            }
                                            ++v25;
                                        }
                                        else
                                        {
                                            v2 = atoi(String1);
                                            v36[i] = v2;
                                            ++v25;
                                        }
                                        if (v25 == 12)
                                        {
                                            sub_482FAA(v26);
                                        LABEL_29:
                                            ++i;
                                            goto LABEL_30;
                                        }
                                    }
                                LABEL_25:
                                    operator delete(v32);
                                    operator delete(v31);
                                    operator delete(v36);
                                    v39 = -1;
                                    sub_482C2F(v26);
                                    return 0;
                                }
                                v29 = thisx[11688] - 1;
                                if ((int)Size < v29)
                                    v29 = Size;
                                v30 = Size;
                                v37 = (unsigned __int16)sub_475850((short*)thisx + 11816) - 1;
                                v33 = (unsigned __int16)sub_475850((short*)thisx + 11892) - 1;
                                for (i = 0; i < v29 && v30; ++i)
                                {
                                    v15 = rand() % v30 + 1;
                                    v20 = -1;
                                    for (k = 0; k < v15; ++k)
                                    {
                                        ++v20;
                                        while (v20 < (int)Size && v31[v20])
                                            ++v20;
                                    }
                                    v14 = 0;
                                    for (m = 0; m < 3; ++m)
                                    {
                                        v13 = v32[11 * v20 + m];
                                        *(&v21 + m) = 0;
                                        if (v13 == -1)
                                        {
                                            *(&v21 + m) = 1;
                                        }
                                        else if (v13 == -2)
                                        {
                                            v12 = 0;
                                            for (n = 3; n < 11; ++n)
                                            {
                                                if (!sub_4667C7((char*)thisx, v32[11 * v20 + n], i, v14))
                                                    ++v12;
                                            }
                                            if (v12)
                                            {
                                                v10 = rand() % v12;
                                                v8 = 0;
                                                while (v10 >= 0)
                                                {
                                                    v9 = v32[11 * v20 + 3 + v8];
                                                    if (!sub_4667C7((char*)thisx, v9, i, v14))
                                                        --v10;
                                                    ++v8;
                                                }
                                                v32[11 * v20 + m] = v9;
                                                v13 = v9;
                                            }
                                            else
                                            {
                                                *(&v21 + m) = 1;
                                            }
                                        }
                                        else if (sub_4667C7((char*)thisx, v13, i, v14))
                                        {
                                            *(&v21 + m) = 1;
                                        }
                                        if (!*(&v21 + m) && v13 >= 0 && v14 < 2)
                                            *(_WORD*)&thisx[4 * i + 11728 + 2 * v14++] = v13 + 2;
                                    }
                                    v17 = -1;
                                    v18 = -1;
                                    if (v21 || v22)
                                    {
                                        if (!v21 || v22 || v23)
                                        {
                                            if (!v21 && v22 && !v23)
                                            {
                                                v17 = v32[11 * v20];
                                                v18 = v32[11 * v20 + 2];
                                            }
                                        }
                                        else
                                        {
                                            v17 = v32[11 * v20 + 1];
                                            v18 = v32[11 * v20 + 2];
                                        }
                                    }
                                    else
                                    {
                                        for (ii = 0; ii < 2; ++ii)
                                            *(&v17 + ii) = v32[11 * v20 + ii];
                                    }
                                    v31[v20] = 1;
                                    --v30;
                                    if (v17 < 0 || v18 < 0)
                                    {
                                        --i;
                                    }
                                    else
                                    {
                                        for (jj = 0; jj < 2; ++jj)
                                            *(_WORD*)&thisx[4 * i + 11728 + 2 * jj] = *(&v17 + jj) + 2;
                                        if (v36[v20])
                                            thisx[i + 11789] = v36[v20] - 1;
                                        else
                                            thisx[i + 11789] = rand() % v34;
                                    }
                                }
                                operator delete(v32);
                                operator delete(v31);
                                operator delete(v36);
                                v5 = i;
                                v39 = -1;
                                sub_482C2F(v26);
                                return v5;
                            }
                            else
                            {
                                operator delete(v32);
                                operator delete(v31);
                                v39 = -1;
                                sub_482C2F(v26);
                                return -1;
                            }
                        }
                        else
                        {
                            operator delete(v32);
                            v39 = -1;
                            sub_482C2F(v26);
                            return -1;
                        }
                    }
                    else
                    {
                        v39 = -1;
                        sub_482C2F(v26);
                        return -1;
                    }
                }
                if ((unsigned __int8)v38 == 1)
                {
                    sub_482FAA(v26);
                    ++Size;
                }
            }
            else
            {
                sub_482FAA(v26);
                LOBYTE(v38) = 1;
            }
        }
    }
    v39 = -1;
    sub_482C2F(v26);
    return 0;
}

 
int sub_463E60(int thisx)
{
    sub_402080(thisx, 76, 2, (void(*)(int))sub_463EF0);
    *(_BYTE*)(thisx + 228) = 0;
    *(_BYTE*)(thisx + 370) = 0;
    *(_WORD*)(thisx + 378) = 0;
    *(_BYTE*)(thisx + 369) = 2;
    *(_BYTE*)(thisx + 371) = 0;
    *(_BYTE*)(thisx + 178) = 4;
    *(_BYTE*)(thisx + 252) = 8;
    *(_BYTE*)(thisx + 376) = 4;
    *(_BYTE*)(thisx + 224) = 1;
    *(_BYTE*)(thisx + 247) = 1;
    *(_BYTE*)(thisx + 248) = 0;
    return thisx;
}

 
_BYTE* sub_463EF0(_BYTE* thisx)
{
    thisx[16] = 0;
    return thisx;
}

 
int sub_463F05(int thisx)
{
    int result; // eax
    int i; // [esp+4h] [ebp-4h]

    result = thisx;
    *(_BYTE*)(thisx + 370) = 0;
    *(_BYTE*)(thisx + 255) = 0;
    *(_WORD*)(thisx + 378) = 0;
    for (i = 0; i < 2; ++i)
    {
        *(_BYTE*)(i + thisx + 372) = 0;
        *(_BYTE*)(i + thisx + 374) = 0;
        result = i + 1;
    }
    return result;
}

 
int sub_463F66(char* thisx, _BYTE* a2)
{
    int v3; // [esp+4h] [ebp-40h]
    int v4; // [esp+8h] [ebp-3Ch]
    int v5; // [esp+Ch] [ebp-38h]
    bool v6; // [esp+10h] [ebp-34h]
    int v8; // [esp+18h] [ebp-2Ch]
    int v9; // [esp+1Ch] [ebp-28h]
    int v10; // [esp+20h] [ebp-24h]
    int v11; // [esp+24h] [ebp-20h]
    char* v12; // [esp+28h] [ebp-1Ch]
    int v13; // [esp+2Ch] [ebp-18h]
    int v14; // [esp+30h] [ebp-14h]
    int i; // [esp+34h] [ebp-10h]
    int v16; // [esp+38h] [ebp-Ch]
    unsigned __int8 v17; // [esp+3Ch] [ebp-8h]
    char v18; // [esp+40h] [ebp-4h]

    v18 = sub_426070(a2);
    v17 = sub_425EF0(a2);
    v14 = sub_426090((_DWORD*)a2);
    v13 = sub_4260B0((_DWORD*)a2);
    v16 = sub_4260D0((_DWORD*)a2);
    for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
    {
        v12 = &thisx[612 * i + 2628];
        if (v17 != (unsigned __int8)sub_425EF0(v12)
            && (byte_4B99CC || v18 != sub_426070(v12) || (unsigned __int8)sub_4752F0(v12)))
        {
            v6 = sub_426070(v12) && (unsigned __int8)sub_4752F0(v12) == 2;
            v18 = v6;
            if (!v6)
            {
                v9 = v14 - sub_426090((_DWORD*)v12);
                v11 = v13 - sub_4260B0((_DWORD*)v12);
                v10 = v16 - sub_4260D0((_DWORD*)v12);
                v8 = 3200;
                if (v9 > 0 && !sub_425D70((_DWORD*)v12) || v9 < 0 && sub_425D70((_DWORD*)v12))
                    v8 = 800;
                v5 = v9 <= 0 ? -v9 : v9;
                if (v5 <= v8)
                {
                    v4 = v11 <= 0 ? -v11 : v11;
                    if (v4 <= 100 * (unsigned __int8)sub_4264B0(v12))
                    {
                        v3 = v10 <= 0 ? -v10 : v10;
                        if (v3 <= 2400 && (unsigned __int8)sub_4264D0(v12) == 1 && !sub_4753D0(v12, v17))
                            return 1;
                    }
                }
            }
        }
    }
    return 0;
}

 
void sub_464194(_DWORD* thisx, double st5_0, double a3, double a4, int a5)
{
    int i; // [esp+4h] [ebp-4h]

    for (i = 0; i < (unsigned __int8)byte_4B999A; ++i)
    {
        if (!unknown_libname_22(&thisx[49 * i + 1881]))
        {
            sub_490BDC((int)&thisx[49 * i + 1881], st5_0, a3, a4, a5);
            return;
        }
    }
}

 
_DWORD* sub_4641FE(_DWORD* thisx, int a1, int a2, int a3, int a4)
{
	return sub_48977D(thisx + 32, a1, a2, a3, (_DWORD*)a4);
}

 
int sub_464229(_BYTE* thisx, SchedulerBase* a2)
{
    int v3; // [esp+0h] [ebp-5Ch]
    int v4; // [esp+4h] [ebp-58h]
    int v5; // [esp+8h] [ebp-54h]
    BOOL v6; // [esp+Ch] [ebp-50h]
    int v8; // [esp+1Ch] [ebp-40h]
    int v9; // [esp+2Ch] [ebp-30h]
    int v10; // [esp+34h] [ebp-28h]
    int v11; // [esp+38h] [ebp-24h]
    int v12; // [esp+3Ch] [ebp-20h]
    int v13; // [esp+40h] [ebp-1Ch]
    int i; // [esp+44h] [ebp-18h]
    int v15; // [esp+4Ch] [ebp-10h]
    int v16; // [esp+50h] [ebp-Ch]
    int v17; // [esp+54h] [ebp-8h]
    int v18; // [esp+58h] [ebp-4h]

    v12 = sub_426090((_DWORD*)a2);
    v11 = sub_4260B0((_DWORD*)a2);
    v13 = sub_4260D0((_DWORD*)a2);
    v15 = sub_425D30((_DWORD*)a2);
    SchedulerBase::GetSchedulerProxy(a2);
    v16 = 0;
    v17 = 0;
    v10 = 0;
    v18 = 0;
    for (i = 0; i < (unsigned __int8)byte_4B999A; ++i)
    {
        v9 = unknown_libname_12((_DWORD*)&thisx[196 * i + 7524]);
        if (sub_425CB0(&thisx[196 * i + 7524]) == 12)
        {
            if (unknown_libname_15((_DWORD*)&thisx[196 * i + 7524]) == 1)
            {
                v9 = 0;
            }
            else if (v9 == 3)
            {
                v9 = 2;
            }
        }
        v6 = v9 == 2 || v9 == 5;
        if (unknown_libname_22((_DWORD*)&thisx[196 * i + 7524])
            && (!v9 || v9 == 2 || v9 == 5)
            && (v9 || !v15)
            && (!v6 || sub_475530((_DWORD*)&thisx[196 * i + 7524])))
        {
            v5 = sub_426470((_DWORD*)&thisx[196 * i + 7524]) - v12 <= 0 ? v12 - sub_426470((_DWORD*)&thisx[196 * i + 7524]) : sub_426470((_DWORD*)&thisx[196 * i + 7524]) - v12;
            v4 = sub_426530((_DWORD*)&thisx[196 * i + 7524]) - v11 <= 0 ? v11 - sub_426530((_DWORD*)&thisx[196 * i + 7524]) : sub_426530((_DWORD*)&thisx[196 * i + 7524]) - v11;
            v8 = (int)UMSFreeVirtualProcessorRoot::GetExecutingProxy((UMSFreeVirtualProcessorRoot*)&thisx[196 * i + 7524])
                - v13;
            if (!v6 || v8 <= 0)
            {
                if (v8 <= 0)
                    v3 = -v8;
                else
                    v3 = v8;
                if (v5 <= 800 * v6 + 800 && v4 <= 500 && v3 <= 1800 * v6 + 600 && (!v16 || v17 > v5 && v10 > v4 && v18 > v3))
                {
                    v16 = (int)&thisx[196 * i + 7524];
                    v17 = v5;
                    v10 = v4;
                    v18 = v3;
                }
            }
        }
    }
    return v16;
}

 
int __stdcall sub_464550(Concurrency::details::UMSFreeVirtualProcessorRoot* a1, int a2)
{
    int v3; // eax
    int* v4; // eax
    int v5; // eax
    int v6; // eax
    int v7; // eax
    int v8; // eax
    int v9; // esi
    int v10; // esi
    int v11; // esi
    int v12; // eax
    int v13; // eax
    int v14; // eax
    int v15; // [esp+4h] [ebp-60h]
    char v16[16]; // [esp+Ch] [ebp-58h] BYREF
    int v17[4]; // [esp+1Ch] [ebp-48h] BYREF
    _DWORD* v18; // [esp+2Ch] [ebp-38h]
    struct tagRECT v19; // [esp+30h] [ebp-34h]
    int v20; // [esp+40h] [ebp-24h]
    int v21; // [esp+44h] [ebp-20h]
    int v22; // [esp+48h] [ebp-1Ch]
    char* v23; // [esp+4Ch] [ebp-18h]
    int v24; // [esp+50h] [ebp-14h]
    int v25; // [esp+54h] [ebp-10h]
    int v26; // [esp+58h] [ebp-Ch]
    int v27; // [esp+5Ch] [ebp-8h]
    int i; // [esp+60h] [ebp-4h]

    v23 = (char*)sub_41C915(a2);
    if (!v23)
        return 0;
    v3 = sub_425D70((_DWORD*)a2);
    v4 = sub_425BD0(v23, v17, v3, 0);
    v24 = *v4;
    v25 = v4[1];
    v26 = v4[2];
    v27 = v4[3];
    if (!v24 && !v25 && !v26 && !v27)
        return 0;
    v5 = sub_426090((_DWORD*)a2);
    v24 += v5 / 100;
    v6 = sub_4260D0((_DWORD*)a2);
    v25 += v6 / 100;
    v7 = sub_426090((_DWORD*)a2);
    v26 += v7 / 100;
    v8 = sub_4260D0((_DWORD*)a2);
    v27 += v8 / 100;
    for (i = 0; i < 3; ++i)
    {
        v19 = *sub_491709((int)a1, (struct tagRECT*)v16, i);
        if (*(_QWORD*)&v19.left || v19.right || v19.bottom)
        {
            v9 = sub_426470((_DWORD*)a1) / 100;
            v21 = sub_48A0E0((_DWORD*)a1) + v9;
            v10 = sub_426530((_DWORD*)a1) / 100;
            v20 = unknown_libname_16((_DWORD*)a1) + v10;
            v11 = (int)Concurrency::details::UMSFreeVirtualProcessorRoot::GetExecutingProxy(a1) / 100;
            v22 = sub_475BE0((_DWORD*)a1) + v11;
            if (i > 0)
            {
                v18 = (_DWORD*)sub_475BA0(a1, i - 1);
                v21 += v18[1];
                v20 += v18[2];
                v22 += v18[3];
            }
            v12 = sub_4260B0((_DWORD*)a2);
            if (v20 - v12 / 100 <= 0)
            {
                v14 = sub_4260B0((_DWORD*)a2);
                v15 = v14 / 100 - v20;
            }
            else
            {
                v13 = sub_4260B0((_DWORD*)a2);
                v15 = v20 - v13 / 100;
            }
            if (v15 <= (unsigned __int8)sub_4264F0((char*)a1))
            {
                v19.left += v21;
                v19.top += v22;
                v19.right += v21;
                v19.bottom += v22;
                if (v19.left - v24 <= v26 - v24
                    && v24 - v19.left <= v19.right - v19.left
                    && v19.top - v25 <= v27 - v25
                    && v25 - v19.top <= v19.bottom - v19.top)
                {
                    return 1;
                }
            }
        }
    }
    return 0;
} 
int sub_4647F2(int thisx, double a2, double a3, double a4)
{
    int result; // eax
    double v5; // st7
    char v6; // al
    char v8[4]; // [esp+4h] [ebp-40h] BYREF
    int v9; // [esp+8h] [ebp-3Ch] BYREF
    _DWORD v10[5]; // [esp+Ch] [ebp-38h] BYREF
    char v11[20]; // [esp+20h] [ebp-24h] BYREF
    __int16 v12; // [esp+34h] [ebp-10h]
    int v13; // [esp+38h] [ebp-Ch]
    int v14; // [esp+3Ch] [ebp-8h]
    int i; // [esp+40h] [ebp-4h]

    sub_4554F8((int*)thisx);
    sub_456AD1((char*)thisx);
    sub_456169((int*)thisx);
    sub_464A8A((char*)thisx);
    dword_4B93AC = 0;
    *(_DWORD*)(thisx + 2488) = 100;
    *(_DWORD*)(thisx + 2492) = 0;
    *(_DWORD*)(thisx + 16136) = 0;
    memset((void*)(thisx + 16120), 0, 8u);
    memset((void*)(thisx + 16128), 0, 8u);
    *(_DWORD*)(thisx + 11376) = 0;
    sub_456617(thisx);
    for (i = 0; i < 8; ++i)
        *(_WORD*)(thisx + 2 * i + 11404) = 0;
    *(_BYTE*)(thisx + 13042) = byte_4B9990 + 1;
    *(_BYTE*)(thisx + 13043) = byte_4B9985 + 1;
    for (i = 0; i < 8; ++i)
    {
        *(_BYTE*)(i + thisx + 13044) = 0;
        *(_BYTE*)(i + thisx + 13052) = 0;
        *(_BYTE*)(i + thisx + 13092) = *(_BYTE*)(i + thisx + 2546);
    }
    if (!dword_4B9974)
        dword_4B9980 = timeGetTime();
    sub_4A2B56(dword_4B9980);
    if (dword_4B9978 && !dword_4B9974)
        sub_483B1D(thisx + 13400, FileName);
    v14 = 0;
    for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
    {
        if (byte_4B999B[i])
        {
            v11[0] = byte_4B999B[i];
            v12 = (unsigned __int8)byte_4B99A3[i];
            v13 = 0;
            sub_464194((_DWORD*)thisx, a2, a3, a4, (int)v11);
            sub_41F24C(thisx + 612 * i + 2628, (Concurrency::details::SchedulerProxy*)(thisx + 196 * v14++ + 7524));
        }
    }
    result = (unsigned __int8)byte_4B999A;
    if (v14 > (unsigned __int8)byte_4B999A)
        byte_4B999A = v14;
    for (i = v14; i < (unsigned __int8)byte_4B999A; ++i)
    {
        sub_4654DA((char*)thisx, &v9, v10);
        v10[2] = 1;
        v5 = sub_477148();
        v8[0] = v6;
        v10[4] = 1;
        sub_464194((_DWORD*)thisx, a2, a3, v5, (int)v8);
        result = i + 1;
    }
    return result;
}
 
int sub_464A8A(char* thisx)
{
    int result; // eax
    int i; // [esp+4h] [ebp-4h]

    for (i = 0; i < 8; ++i)
    {
        sub_494AC9((_DWORD)&thisx[196 * i + 7524]);
        result = i + 1;
    }
    return result;
}

 
int sub_464AC9(char* thisx, _BYTE* a2, unsigned __int8* a3, int a4)
{
    int v4; // esi
    int v5; // esi
    unsigned __int8* v8; // [esp+8h] [ebp-20h]
    char v9[8]; // [esp+Ch] [ebp-1Ch]
    int i; // [esp+14h] [ebp-14h]
    int v11; // [esp+18h] [ebp-10h]
    int v12; // [esp+1Ch] [ebp-Ch]
    int v13; // [esp+20h] [ebp-8h]
    int v14; // [esp+24h] [ebp-4h]

    LOBYTE(v11) = sub_425EF0(a2);
    LOBYTE(v13) = sub_426070(a2);
    LOBYTE(v14) = 0;
    for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
    {
        v8 = (unsigned __int8*)&thisx[612 * i + 2628];
        if (v8 != a3)
        {
            v4 = (unsigned __int8)v11;
            if (v4 != (unsigned __int8)sub_425EF0((char*)v8) && unknown_libname_7((_DWORD*)v8) && !sub_41BE56((_DWORD*)v8) && !sub_4263D0(v8))
            {
                if (byte_4B99CC && !a4 || (v5 = (unsigned __int8)v13, v5 != (unsigned __int8)sub_426070((char*)v8)))
                {
                    v9[(unsigned __int8)v14] = i;
                    LOBYTE(v14) = v14 + 1;
                }
            }
        }
    }
    if (!(_BYTE)v14)
        return 0;
    v12 = rand() % (unsigned __int8)v14;
    return (int)&thisx[612 * (unsigned __int8)v9[v12] + 2628];
}

 
int sub_464C06(char* thisx, char a2, int a3)
{
    int result; // eax
    int v5; // [esp+4h] [ebp-8h]
    int i; // [esp+8h] [ebp-4h]

    result = (unsigned __int16)sub_41F52F(a3, 1);
    v5 = result;
    for (i = 0; i < (unsigned __int8)byte_4B999A; ++i)
    {
        if (unknown_libname_22((_DWORD*)&thisx[196 * i + 7524]))
            sub_494D01((int)&thisx[196 * i + 7524], (int)thisx, a2, (char*)a3, v5);
        result = i + 1;
    }
    return result;
}

 
int sub_464C88(int thisx)
{
    int v1; // eax
    const CHAR* v2; // eax
    int v4; // [esp-4h] [ebp-134h]
    int v5; // [esp-4h] [ebp-134h]
    int v7; // [esp+8h] [ebp-128h]
    int v8; // [esp+Ch] [ebp-124h]
    int v9; // [esp+10h] [ebp-120h]
    int k; // [esp+14h] [ebp-11Ch]
    unsigned __int8 v11; // [esp+18h] [ebp-118h]
    int j; // [esp+1Ch] [ebp-114h]
    unsigned __int8 v13; // [esp+20h] [ebp-110h]
    int v14; // [esp+24h] [ebp-10Ch]
    int v15; // [esp+28h] [ebp-108h]
    int i; // [esp+2Ch] [ebp-104h]
    CHAR String[256]; // [esp+30h] [ebp-100h] BYREF

    sub_451EB5((_BYTE*)thisx, 1, 1);
    sub_452045((_BYTE*)thisx, 5, 1, 30, 3);
    wsprintfA(String, a1_0);
    v4 = dword_4B9248;
    v1 = lstrlenA(String);
    sub_47B91A(160 - 2 * v1, 16, String, 0, v4);
    *(_DWORD*)(thisx + 2532) = -1;
    *(_DWORD*)(thisx + 2528) = -1;
    v15 = 2;
    if (*(unsigned __int8*)(thisx + 12969) < 2u)
        v15 = *(unsigned __int8*)(thisx + 12969);
    for (i = 0; i < v15; ++i)
    {
        sub_452045((_BYTE*)thisx, 18 * i + 3, 5, 16, 18);
        v13 = i + *(_WORD*)(thisx + 2564);
        v14 = 128 / *(unsigned __int8*)(thisx + v13 + 13002);
        for (j = 0; j < *(unsigned __int8*)(thisx + v13 + 13002); ++j)
        {
            v9 = j;
            if (v13 == *(unsigned __int16*)(thisx + 2574))
                v9 = *(unsigned __int16*)(thisx + 2 * j + 2566);
            v8 = 144 * i + 32;
            v7 = v14 * j + 56;
            wsprintfA(String, "%d", v9 + 1);
            sub_47B7ED(v8, v7, String, 0, dword_4B9248);
            sub_47B91A(144 * i + 40, v7, (LPCSTR)&byte_4B2884, 0, dword_4B9248);
            if (*(_BYTE*)(thisx + v13 + 13002) == 2)
                wsprintfA(String, "+%d POINT", 4 - 2 * v9);
            else
                wsprintfA(String, "+%d POINT", 4 - v9);
            sub_47B7ED(144 * i + 56, v14 * j + 68, String, 0, dword_4B9248);
            v11 = *(_BYTE*)(thisx + j + 4 * v13 + 13010);
            if (v11)
            {
                for (k = 0; k < 2; ++k)
                {
                    v5 = dword_4B9248;
                    v2 = (const CHAR*)unknown_libname_18((char*)(36 * (unsigned __int8)(*(_WORD*)(thisx + 4 * v11 + 11724 + 2 * k) - 2) + dword_4B92E0));
                    sub_47B91A(v8 + 48 * k + 24, v7, v2, 0, v5);
                }
                sub_47B91A(144 * i + 96, v7, (LPCSTR)&byte_4B2654, 0, dword_4B9248);
            }
            else
            {
                *(_DWORD*)(thisx + 2528) = 144 * i + 56;
                *(_DWORD*)(thisx + 2532) = v7;
            }
        }
    }
    sub_47B91A(16, 208, (LPCSTR)&byte_4B2973, 0, dword_4B9248);
    return sub_47B91A(16, 224, (LPCSTR)&byte_4B309C, 0, dword_4B9248);
}

 
int sub_465102(int thisx)
{
    int v1; // eax
    const CHAR* v2; // eax
    int v4; // [esp-4h] [ebp-124h]
    int v5; // [esp-4h] [ebp-124h]
    int v7; // [esp+8h] [ebp-118h]
    int v8; // [esp+Ch] [ebp-114h]
    int k; // [esp+10h] [ebp-110h]
    unsigned __int8 v10; // [esp+14h] [ebp-10Ch]
    int i; // [esp+18h] [ebp-108h]
    int j; // [esp+18h] [ebp-108h]
    int v13; // [esp+1Ch] [ebp-104h]
    CHAR String[256]; // [esp+20h] [ebp-100h] BYREF

    sub_451EB5((_BYTE*)thisx, 1, 1);
    sub_452045((_BYTE*)thisx, 5, 1, 30, 3);
    wsprintfA(String, (LPCSTR)&byte_4B299F);
    v4 = dword_4B9248;
    v1 = lstrlenA(String);
    sub_47B91A(160 - 2 * v1, 16, String, 0, v4);
    for (i = 0; i < 2; ++i)
        sub_452045((_BYTE*)thisx, 18 * i + 3, 5, 16, 18);
    v13 = 0;
    *(_DWORD*)(thisx + 2532) = -1;
    *(_DWORD*)(thisx + 2528) = -1;
    for (j = 0; j < 8; ++j)
    {
        v8 = 144 * (v13 / 4) + 32;
        v7 = 32 * (v13 % 4) + 56;
        if (j + 4 * *(unsigned __int16*)(thisx + 2564) >= *(unsigned __int8*)(thisx + 11688))
            break;
        v10 = *(_BYTE*)(thisx + j + 4 * *(unsigned __int16*)(thisx + 2564) + 13076);
        wsprintfA(String, "%2d", *(unsigned __int8*)(thisx + v10 + 13060));
        sub_47B7ED(144 * (v13 / 4) + 28, v7, String, 0, dword_4B9248);
        sub_47B91A(144 * (v13 / 4) + 44, v7, (LPCSTR)&byte_4B288C, 0, dword_4B9248);
        wsprintfA(String, "%3d POINT", *(unsigned __int16*)(thisx + 2 * v10 + 11692));
        sub_47B7ED(144 * (v13 / 4) + 56, 32 * (v13 % 4) + 68, String, 0, dword_4B9248);
        ++v13;
        if (v10)
        {
            for (k = 0; k < 2; ++k)
            {
                v5 = dword_4B9248;
                v2 = (const CHAR*)unknown_libname_18((char*)(36 * (unsigned __int16)(*(_WORD*)(thisx + 4 * v10 + 11724 + 2 * k) - 2) + dword_4B92E0));
                sub_47B91A(v8 + 48 * k + 24, v7, v2, 0, v5);
            }
            sub_47B91A(v8 + 64, v7, (LPCSTR)&byte_4B2654, 0, dword_4B9248);
        }
        else
        {
            *(_DWORD*)(thisx + 2528) = v8 + 24;
            *(_DWORD*)(thisx + 2532) = v7;
        }
    }
    sub_47B91A(16, 208, (LPCSTR)&byte_4B30C6, 0, dword_4B9248);
    return sub_47B91A(16, 224, (LPCSTR)&byte_4B3104, 0, dword_4B9248);
}

 
_DWORD* sub_4654DA(char* thisx, _DWORD* a2, _DWORD* a3)
{
    int i; // eax
    _DWORD* result; // eax
    int v6; // [esp+4h] [ebp-14h]
    int v7; // [esp+8h] [ebp-10h]
    int v8; // [esp+Ch] [ebp-Ch]
    int v9; // [esp+10h] [ebp-8h]
    int v10; // [esp+14h] [ebp-4h]

    v10 = sub_4897D0(thisx + 128);
    v7 = 8 * sub_4261D0(thisx + 128);
    v9 = rand() % (v10 - 16) + 8;
    v8 = rand() % v7;
    for (i = sub_486633((_DWORD*)thisx + 32, v9, v8); ; i = sub_486633((_DWORD*)thisx + 32, v9, v8))
    {
        v6 = i;
        if (sub_4773CC(v9 / 8, v8 / 8))
        {
            if (v6 < 1020)
                break;
        }
        v9 = rand() % (v10 - 16) + 8;
        v8 = rand() % v7;
    }
    result = a2;
    *a2 = 100 * v9;
    *a3 = 100 * v8;
    return result;
}

 
int sub_4655B9(void* thisx, int a2)
{
    if (a2 >= 0 && (unsigned __int8)byte_4B999A > a2)
        return (int)thisx + 196 * a2 + 7524;
    else
        return 0;
}

 
int sub_4655EF(_DWORD* thisx, _DWORD* a2, int a3, int a4)
{
    unsigned __int64 v4; // rax
    int v6; // [esp+4h] [ebp-3Ch]
    int v7; // [esp+8h] [ebp-38h]
    int v8; // [esp+Ch] [ebp-34h]
    int v10; // [esp+14h] [ebp-2Ch]
    int v11; // [esp+18h] [ebp-28h]
    int v12; // [esp+20h] [ebp-20h]
    int i; // [esp+24h] [ebp-1Ch]
    int v14; // [esp+28h] [ebp-18h]
    int v15; // [esp+2Ch] [ebp-14h]
    int v16; // [esp+30h] [ebp-10h]
    int v17; // [esp+34h] [ebp-Ch]
    char v18; // [esp+38h] [ebp-8h]
    int v19; // [esp+3Ch] [ebp-4h]

    v15 = sub_426090(a2) / 100;
    v14 = sub_4260B0(a2) / 100;
    v16 = sub_4260D0(a2) / 100;
    v18 = sub_426070((char*)a2);
    v19 = sub_425D70(a2);
    v17 = (unsigned __int8)sub_425EF0((char*)a2);
    for (i = 0; i < 8; ++i)
    {
        if (i != v17
            && unknown_libname_7(&thisx[153 * i + 657])
            && !sub_41BE56(&thisx[153 * i + 657])
            && v18 != sub_426070((char*)&thisx[153 * i + 657]))
        {
            if ((v4 = __PAIR64__(i, sub_426090(&thisx[153 * i + 657]) / 100),
                v12 = v4,
                v10 = sub_4260B0(&thisx[153 * HIDWORD(v4) + 657]) / 100,
                v11 = sub_4260D0(&thisx[153 * i + 657]) / 100,
                !a4)
                || v19 && v15 < v12
                || !v19 && v15 > v12)
            {
                v8 = v15 - v12 <= 0 ? v12 - v15 : v15 - v12;
                if (v8 < a3)
                {
                    v7 = v14 - v10 <= 0 ? v10 - v14 : v14 - v10;
                    if (v7 <= 5)
                    {
                        v6 = v16 - v11 <= 0 ? v11 - v16 : v16 - v11;
                        if (v6 <= 16)
                            return 1;
                    }
                }
            }
        }
    }
    return 0;
}

 
int sub_465804(_DWORD* thisx, _DWORD* a2)
{
    int i; // [esp+4h] [ebp-4h]

    if (!a2)
        return 0;
    for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
    {
        if (a2 != &thisx[153 * i + 657] && a2 == (_DWORD*)sub_426430(&thisx[153 * i + 657]))
            return (int)&thisx[153 * i + 657];
    }
    return 0;
}

 
int sub_46588C(char* thisx, _BYTE* a2)
{
    int v2; // esi
    char* v5; // [esp+8h] [ebp-1Ch]
    char v6[8]; // [esp+Ch] [ebp-18h]
    int i; // [esp+14h] [ebp-10h]
    int v8; // [esp+18h] [ebp-Ch]
    int v9; // [esp+1Ch] [ebp-8h]
    int v10; // [esp+20h] [ebp-4h]

    LOBYTE(v8) = sub_425EF0(a2);
    LOBYTE(v10) = 0;
    for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
    {
        v5 = &thisx[612 * i + 2628];
        v2 = (unsigned __int8)v8;
        if (v2 != (unsigned __int8)sub_425EF0(v5) && unknown_libname_7((_DWORD*)v5) && !sub_41BE56((_DWORD*)v5) && !sub_425E70(v5))
        {
            v6[(unsigned __int8)v10] = i;
            LOBYTE(v10) = v10 + 1;
        }
    }
    if (!(_BYTE)v10)
        return 0;
    v9 = rand() % (unsigned __int8)v10;
    return (int)&thisx[612 * (unsigned __int8)v6[v9] + 2628];
}

 
_BYTE* sub_465986(_BYTE* thisx)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[2544] = 1;
    thisx[2545] = 0;
    return result;
}

 
void sub_4659A5(_DWORD* thisx, _BYTE* a2)
{
    unsigned __int8 v2; // al
    char v4[8]; // [esp+4h] [ebp-1Ch]
    int v5; // [esp+Ch] [ebp-14h]
    int i; // [esp+10h] [ebp-10h]
    int v7; // [esp+14h] [ebp-Ch]
    int v8; // [esp+18h] [ebp-8h]
    int v9; // [esp+1Ch] [ebp-4h]

    if (a2)
    {
        LOBYTE(v7) = sub_425EF0(a2);
        LOBYTE(v8) = sub_426070(a2);
        LOBYTE(v5) = 0;
        for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
        {
            if (i != (unsigned __int8)v7)
            {
                v2 = sub_426070((char*)&thisx[153 * i + 657]);
                if (v2 == (unsigned __int8)v8
                    && SchedulerBase::GetSchedulerProxy((SchedulerBase*)&thisx[153 * i + 657]) == (struct Concurrency::ISchedulerProxy*)80)
                {
                    v4[(unsigned __int8)v5] = i;
                    LOBYTE(v5) = v5 + 1;
                }
            }
        }
        if ((_BYTE)v5)
        {
            LOBYTE(v9) = v4[rand() % (unsigned __int8)v5];
            sub_41D697((int)&thisx[153 * (unsigned __int8)v9 + 657]);
            if (!sub_41BEA6(&thisx[153 * (unsigned __int8)v9 + 657]) && !dword_4B9974)
            {
                thisx[622] = 100;
                thisx[623] = 0;
            }
        }
    }
}


int sub_465AFA(unsigned __int8* thisx)
{
    int i; // [esp+4h] [ebp-4h]

    for (i = 0; i < (unsigned __int8)byte_4B9990; ++i)
    {
        if (thisx[i + 2546] >= 2u)
            return 1;
    }
    return 0;
} 
_DWORD* sub_465B44(_DWORD* thisx, SchedulerBase* a2)
{
    int v3; // [esp+4h] [ebp-40h]
    int v4; // [esp+8h] [ebp-3Ch]
    BOOL v5; // [esp+Ch] [ebp-38h]
    int v7; // [esp+14h] [ebp-30h]
    struct Concurrency::ISchedulerProxy* SchedulerProxy; // [esp+18h] [ebp-2Ch]
    int v9; // [esp+20h] [ebp-24h]
    int v10; // [esp+24h] [ebp-20h]
    int v11; // [esp+2Ch] [ebp-18h]
    int i; // [esp+30h] [ebp-14h]
    int v13; // [esp+34h] [ebp-10h]
    char v14; // [esp+38h] [ebp-Ch]
    int v15; // [esp+3Ch] [ebp-8h]
    unsigned __int8 v16; // [esp+40h] [ebp-4h]

    v11 = sub_426090((int*)a2);
    v13 = sub_4260B0((int*)a2);
    v15 = sub_4260D0((int*)a2);
    v16 = sub_425EF0((char*)a2);
    v14 = sub_426070((char*)a2);
    v5 = sub_41BA53((int)a2, 0x2Bu, 0)
        && SchedulerBase::GetSchedulerProxy(a2) == (struct Concurrency::ISchedulerProxy*)8;
    for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
    {
        if (i != v16
            && unknown_libname_7(&thisx[153 * i + 657])
            && !sub_426410(&thisx[153 * i + 657])
            && !sub_425D50(&thisx[153 * i + 657])
            && !sub_425FF0(&thisx[153 * i + 657])
            && !sub_425D30(&thisx[153 * i + 657])
            && !sub_426430(&thisx[153 * i + 657])
            && !sub_425E70((char*) & thisx[153 * i + 657])
            && (!v5 || v14 == sub_426070((char*) & thisx[153 * i + 657])))
        {
            v9 = sub_426090(&thisx[153 * i + 657]);
            v10 = sub_4260B0(&thisx[153 * i + 657]);
            v7 = sub_4260D0(&thisx[153 * i + 657]) - v15;
            v4 = v11 - v9 <= 0 ? v9 - v11 : v11 - v9;
            if (v4 <= 400)
            {
                v3 = v13 - v10 <= 0 ? v10 - v13 : v13 - v10;
                if (v3 <= 500 && v7 >= 3000 && v7 <= 3400)
                {
                    SchedulerProxy = SchedulerBase::GetSchedulerProxy((SchedulerBase*)&thisx[153 * i + 657]);
                    if (SchedulerProxy == (struct Concurrency::ISchedulerProxy*)3
                        || SchedulerProxy == (struct Concurrency::ISchedulerProxy*)4
                        || SchedulerProxy == (struct Concurrency::ISchedulerProxy*)6)
                    {
                        return &thisx[153 * i + 657];
                    }
                }
            }
        }
    }
    return 0;
}

 
int sub_465E0A(char* thisx, int a2, char a3)
{
    int i; // [esp+8h] [ebp-4h]

    for (i = 0; i < 4 && sub_475C00((_DWORD*)&thisx[24 * i + 11080]); ++i)
        ;
    if (i == 4)
        return 0;
    sub_43EF5D((int)&thisx[24 * i + 11080], a2, a3);
    return (int)&thisx[24 * i + 11080];
}

 
int sub_465E7E(char* thisx, _DWORD* a2)
{
    int v3; // [esp+0h] [ebp-60h]
    int v4; // [esp+4h] [ebp-5Ch]
    int v5; // [esp+8h] [ebp-58h]
    int v6; // [esp+Ch] [ebp-54h]
    int v7; // [esp+10h] [ebp-50h]
    int v8; // [esp+14h] [ebp-4Ch]
    int v9; // [esp+18h] [ebp-48h]
    int v10; // [esp+1Ch] [ebp-44h]
    int v12; // [esp+24h] [ebp-3Ch]
    int v13; // [esp+28h] [ebp-38h]
    int v14; // [esp+2Ch] [ebp-34h]
    SchedulerBase* v15; // [esp+30h] [ebp-30h]
    struct Concurrency::ISchedulerProxy* SchedulerProxy; // [esp+34h] [ebp-2Ch]
    int v17; // [esp+3Ch] [ebp-24h]
    int v18; // [esp+40h] [ebp-20h]
    int v19; // [esp+44h] [ebp-1Ch]
    int v20; // [esp+48h] [ebp-18h]
    int v21; // [esp+4Ch] [ebp-14h]
    int i; // [esp+50h] [ebp-10h]
    unsigned __int8 v23; // [esp+54h] [ebp-Ch]
    char v24; // [esp+58h] [ebp-8h]
    int v25; // [esp+5Ch] [ebp-4h]

    if (!byte_4B99C8 || !a2 || sub_426410(a2) || sub_425D50(a2))
        return 0;
    v18 = sub_426090(a2);
    v17 = sub_4260B0(a2);
    v19 = sub_4260D0(a2);
    v24 = sub_426070((char*)a2);
    v23 = sub_425EF0((char*)a2);
    v25 = sub_425D70(a2);
    v21 = 0;
    v20 = 0;
    for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
    {
        v15 = (SchedulerBase*)&thisx[612 * i + 2628];
        if (!sub_41BE56((_DWORD*)v15)
            && sub_426070((char*)v15) == v24
            && v23 != i
            && !sub_426410((_DWORD*)v15)
            && !sub_425D50((_DWORD*)v15)
            && !sub_425FF0((_DWORD*)v15))
        {
            SchedulerProxy = SchedulerBase::GetSchedulerProxy(v15);
            if ((SchedulerProxy == (struct Concurrency::ISchedulerProxy*)3
                || SchedulerProxy == (struct Concurrency::ISchedulerProxy*)4
                || SchedulerProxy == (struct Concurrency::ISchedulerProxy*)6)
                && v25 != sub_425D70((_DWORD*)v15))
            {
                v12 = sub_426090((_DWORD*)v15) - v18;
                v14 = sub_4260B0((_DWORD*)v15) - v17;
                v13 = sub_4260D0((_DWORD*)v15) - v19;
                v10 = v12 <= 0 ? -v12 : v12;
                if (v10 >= 800)
                {
                    v9 = v12 <= 0 ? -v12 : v12;
                    if (v9 <= 1600)
                    {
                        v8 = v14 <= 0 ? -v14 : v14;
                        if (v8 <= 500)
                        {
                            v7 = v13 <= 0 ? -v13 : v13;
                            if (v7 <= 800 && (v12 < 0 && !v25 || v12 > 0 && v25))
                            {
                                if (!v21 || (v12 <= 0 ? (v6 = -v12) : (v6 = v12), v14 <= 0 ? (v5 = -v14) : (v5 = v14), v20 > v5 + v6))
                                {
                                    v21 = (int)&thisx[612 * i + 2628];
                                    if (v12 <= 0)
                                        v4 = -v12;
                                    else
                                        v4 = v12;
                                    if (v14 <= 0)
                                        v3 = -v14;
                                    else
                                        v3 = v14;
                                    v20 = v3 + v4;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return v21;
}

 
int sub_466127(char* thisx, _BYTE* a2, int a3)
{
    unsigned __int8 v3; // al
    unsigned __int8* v6; // [esp+4h] [ebp-1Ch]
    int i; // [esp+Ch] [ebp-14h]
    char v8[8]; // [esp+10h] [ebp-10h]
    int v9; // [esp+18h] [ebp-8h]
    int v10; // [esp+1Ch] [ebp-4h]

    LOBYTE(v9) = 0;
    LOBYTE(v10) = sub_426070(a2);
    for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
    {
        v6 = (unsigned __int8*)&thisx[612 * i + 2628];
        if (unknown_libname_7((_DWORD*)v6))
        {
            if (!sub_41BE56((_DWORD*)v6))
            {
                v3 = sub_426070((char*)v6);
                if (v3 != (unsigned __int8)v10 && !sub_4263D0(v6) && !*(_BYTE*)(i + a3))
                {
                    v8[(unsigned __int8)v9] = i;
                    LOBYTE(v9) = v9 + 1;
                }
            }
        }
    }
    if ((_BYTE)v9)
        return (int)&thisx[612 * (unsigned __int8)v8[rand() % (unsigned __int8)v9] + 2628];
    else
        return 0;
}

 
int sub_46622B(char* thisx, _BYTE* a2, unsigned __int8 a3)
{
    char v3; // al
    unsigned __int8 v5; // al
    int v6; // eax
    int v7; // eax
    int v8; // eax
    int v9; // edx
    char v10; // al
    char v11; // al
    char v12; // al
    int v13; // [esp+0h] [ebp-7Ch]
    int v14; // [esp+4h] [ebp-78h]
    int v16; // [esp+Ch] [ebp-70h]
    SchedulerBase* v17; // [esp+10h] [ebp-6Ch]
    struct Concurrency::ISchedulerProxy* SchedulerProxy; // [esp+14h] [ebp-68h]
    _DWORD* v19; // [esp+18h] [ebp-64h]
    int m; // [esp+1Ch] [ebp-60h]
    int v21; // [esp+20h] [ebp-5Ch]
    int k; // [esp+24h] [ebp-58h]
    char* v23; // [esp+28h] [ebp-54h]
    int v24; // [esp+2Ch] [ebp-50h]
    char* v25; // [esp+30h] [ebp-4Ch]
    _DWORD* v26; // [esp+34h] [ebp-48h]
    int i; // [esp+38h] [ebp-44h]
    int v28; // [esp+3Ch] [ebp-40h]
    int v29; // [esp+40h] [ebp-3Ch]
    int v30[8]; // [esp+44h] [ebp-38h] BYREF
    int j; // [esp+64h] [ebp-18h]
    unsigned __int8 v32; // [esp+68h] [ebp-14h]
    _BYTE v33[9]; // [esp+6Bh] [ebp-11h]
    int v34; // [esp+74h] [ebp-8h]
    int v35; // [esp+78h] [ebp-4h]

    v32 = sub_425EF0(a2);
    LOBYTE(v35) = sub_426070(a2);
    if (a3 == 3)
    {
        for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
        {
            if (v32 != i)
            {
                v25 = &thisx[612 * i + 2628];
                if (unknown_libname_7((_DWORD*)v25))
                {
                    if (!sub_41BE56((_DWORD*)v25) && (unsigned __int8)sub_426070(v25) == (unsigned __int8)v35)
                    {
                        if (sub_41BEA6((_DWORD*)v25))
                        {
                            v26 = sub_41F0A9((_DWORD*)v25);
                            v24 = unknown_libname_30(v26);
                            if ((_BYTE*)v26[32] == a2 && (v24 == 6 || v24 == 7))
                            {
                                sub_4210E3(v26, (int)a2, (int)a2, a3);
                                v3 = rand() % 2;
                                sub_4210A8(v25, v3 + 0x80);
                            }
                        }
                    }
                }
            }
        }
        return 0;
    }
    else
    {
        memset(v30, 0, sizeof(v30));
        LOBYTE(v34) = 0;
        v29 = sub_426090((_DWORD*)a2);
        v28 = sub_4260B0((_DWORD*)a2);
        for (j = 0; j < (unsigned __int8)byte_4B9985; ++j)
        {
            if (j != v32)
            {
                v23 = &thisx[612 * j + 2628];
                if (unknown_libname_7((_DWORD*)v23))
                {
                    if (!sub_41BE56((_DWORD*)v23))
                    {
                        v5 = sub_426070(v23);
                        if (v5 == (unsigned __int8)v35)
                        {
                            if (sub_41BEA6((_DWORD*)v23))
                            {
                                v6 = sub_426090((_DWORD*)v23);
                                if (v6 - v29 <= 0)
                                {
                                    v8 = sub_426090((_DWORD*)v23);
                                    v14 = v29 - v8;
                                }
                                else
                                {
                                    v7 = sub_426090((_DWORD*)v23);
                                    v14 = v7 - v29;
                                }
                                if (sub_4260B0((_DWORD*)v23) - v28 <= 0)
                                    v13 = v28 - sub_4260B0((_DWORD*)v23);
                                else
                                    v13 = sub_4260B0((_DWORD*)v23) - v28;
                                v21 = v13 + v14;
                                for (k = 0; k < (unsigned __int8)v34 + 1; ++k)
                                {
                                    if (!v30[k] || v30[k] > v21)
                                    {
                                        for (m = (unsigned __int8)v34; m > k; --m)
                                        {
                                            v30[m] = v30[m - 1];
                                            v33[m + 1] = v33[m];
                                        }
                                        v30[k] = v21 + 1;
                                        v33[k + 1] = j;
                                        LOBYTE(v34) = v34 + 1;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if ((_BYTE)v34)
        {
            for (j = 0; j < (unsigned __int8)v34; ++j)
            {
                v17 = (SchedulerBase*)&thisx[612 * (unsigned __int8)v33[j + 1] + 2628];
                SchedulerProxy = SchedulerBase::GetSchedulerProxy(v17);
                if (sub_425FF0((_DWORD*)v17)
                    || sub_426410((_DWORD*)v17)
                    || sub_425D50((_DWORD*)v17)
                    || sub_426430((_DWORD*)v17)
                    || SchedulerProxy == (struct Concurrency::ISchedulerProxy*)82
                    || SchedulerProxy == (struct Concurrency::ISchedulerProxy*)84
                    || SchedulerProxy == (struct Concurrency::ISchedulerProxy*)85
                    || SchedulerProxy == (struct Concurrency::ISchedulerProxy*)94)
                {
                    sub_4210A8((char*)v17, 130);
                }
                else
                {
                    v19 = sub_41F0A9((_DWORD*)v17);
                    v16 = unknown_libname_30(v19);
                    if (v16 != 6 && v16 != 7 && v16 != 8)
                        goto LABEL_67;
                    if (a2 == (_BYTE*)v19[32])
                    {
                        if (a3 == 1 && v16 == 6 || (v9 = a3, a3 == 2) && v16 == 7)
                        {
                            v10 = rand() % 2;
                            sub_4210A8((char*)v17, v10 - 124);
                            break;
                        }
                    LABEL_67:
                        sub_4210E3(v19, v9, (int)a2, a3);
                        v12 = rand() % 2;
                        sub_4210A8((char*)v17, v12 + 0x80);
                        break;
                    }
                    v11 = rand() % 2;
                    sub_4210A8((char*)v17, v11 - 126);
                }
            }
            if (j == (unsigned __int8)v34)
                return 0;
            else
                return (int)&thisx[612 * (unsigned __int8)v33[j + 1] + 2628];
        }
        else
        {
            return 0;
        }
    }
}

 
int sub_4666C5(char* thisx, _BYTE* a2)
{
    char* v4; // [esp+4h] [ebp-14h]
    int i; // [esp+8h] [ebp-10h]
    unsigned __int8 v6; // [esp+Ch] [ebp-Ch]
    unsigned __int8 v7; // [esp+10h] [ebp-8h]
    char v8; // [esp+14h] [ebp-4h]

    v8 = sub_426070(a2);
    v6 = sub_425EF0(a2);
    v7 = 0;
    for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
    {
        if (i != v6)
        {
            v4 = &thisx[612 * i + 2628];
            if (unknown_libname_7((_DWORD*)v4))
            {
                if (!sub_41BE56((_DWORD*)v4) && sub_426070(v4) == v8)
                {
                    if (sub_41BEA6((_DWORD*)v4))
                        ++v7;
                }
            }
        }
    }
    return v7;
}

 
int sub_466789(void* thisx)
{
    sub_49DA8A((_DWORD*)unk_4BDC60, dword_4B9234);
    return sub_46D6CB((_DWORD)thisx);
}

 
_DWORD* sub_4667AC()
{
	return sub_49DA8A((int*)unk_4BDC60, dword_4B9234);
}

 
int sub_4667C7(char* thisx, int a2, int a3, int a4)
{
    int v6; // [esp+4h] [ebp-1Ch]
    int v7; // [esp+8h] [ebp-18h]
    int j; // [esp+Ch] [ebp-14h]
    int k; // [esp+10h] [ebp-10h]
    int i; // [esp+14h] [ebp-Ch]
    int v11; // [esp+18h] [ebp-8h]
    int v12; // [esp+1Ch] [ebp-4h]

    if (a2 < 0)
        return 1;
    v12 = (unsigned __int16)sub_475850((short*)thisx + 11816) - 1;
    v11 = (unsigned __int16)sub_475850((short*)thisx + 11892) - 1;
    if (v12 >= 0 && v12 == a2 || v11 >= 0 && v11 == a2)
        return 1;
    for (i = 0; i < a3; ++i)
    {
        for (j = 0; j < 2; ++j)
        {
            v7 = *(unsigned __int16*)&thisx[4 * i + 11728 + 2 * j] - 2;
            if (v7 >= 0 && a2 == v7)
                return 1;
        }
    }
    if (a4 >= 3)
        a4 = 2;
    for (k = 0; k < a4; ++k)
    {
        v6 = *(unsigned __int16*)&thisx[4 * i + 11728 + 2 * k] - 2;
        if (v6 >= 0 && a2 == v6)
            return 1;
    }
    return 0;
}

 
void* sub_466901(_DWORD* thisx)
{
    unsigned __int8 v1; // al
    void* result; // eax
    unsigned __int8 v3; // al
    int v5; // [esp+4h] [ebp-8h]
    signed int i; // [esp+8h] [ebp-4h]
    signed int j; // [esp+8h] [ebp-4h]
    int k; // [esp+8h] [ebp-4h]
    signed int m; // [esp+8h] [ebp-4h]

    for (i = 0; i < (int)dword_4B93A0; ++i)
        streambuf::unbuffered((streambuf*)((char*)dword_4B93A4 + 24 * i), 0);
    for (j = 0; j < (int)Size; ++j)
    {
        v1 = sub_401710((_BYTE*)(36 * j + dword_4B92E0));
        streambuf::unbuffered((streambuf*)((char*)dword_4B93A4 + 24 * v1), 1);
    }
    result = thisx;
    if (!thisx[29])
    {
        for (k = 0; k < 2; ++k)
        {
            v3 = sub_426550((char*) & thisx[19 * k + 2954]);
            streambuf::unbuffered((streambuf*)((char*)dword_4B93A4 + 24 * v3), 1);
        }
    }
    v5 = 0;
    for (m = 0; m < (int)dword_4B93A0; ++m)
    {
        result = (void*)unknown_libname_17((_DWORD*)(char*)dword_4B93A4 + 24 * m);
        if (result)
        {
            LOWORD(result) = v5;
            *((_WORD*)Src + m) = v5++;
        }
        else
        {
            result = (void*)Src;
            *((_WORD*)Src + m) = -1;
        }
    }
    return result;
}

 
int sub_466A41()
{
    char* v0; // eax
    char v2[1024]; // [esp+4h] [ebp-840h] BYREF
    int i; // [esp+404h] [ebp-440h]
    char Src[1024]; // [esp+408h] [ebp-43Ch] BYREF
    int v5; // [esp+808h] [ebp-3Ch] BYREF
    int v6; // [esp+80Ch] [ebp-38h]
    int v7; // [esp+810h] [ebp-34h]
    int v8; // [esp+814h] [ebp-30h]
    int v9; // [esp+818h] [ebp-2Ch]
    int v10; // [esp+81Ch] [ebp-28h]
    int v11; // [esp+82Ch] [ebp-18h]
    char* v12; // [esp+834h] [ebp-10h]

    sub_49B9E0((int*)unk_4BDC60, aGraphicSystem0);
    v0 = sub_49CE7F((char**)unk_4BDC60);
    memcpy(Src, v0, sizeof(Src));
    sub_49DB90(&v5);
    v6 = 64;
    v7 = 8;
    v8 = 16;
    v9 = 16;
    v10 = 1;
    v11 = 0;
    v5 = -1;
    if (sub_49DA45((int*)unk_4BDC60, aGraphicSystem0_0, (int)&v5))
    {
        dword_4B9204 = v5;
        for (i = 0; i < (int)dword_4B93A0; ++i)
        {
            if (*((__int16*)dword_4B9394 + i) >= 0)
            {
                memcpy(v2, Src, sizeof(v2));
                sub_485DFD((int)dword_4B93A4 + 24 * i, (int)v2);
                v6 = 0;
                v7 = 8;
                v8 = 64;
                v9 = 16;
                v10 = 1;
                v11 = 0;
                v5 = -1;
                v12 = v2;
                if (!sub_49DA45((int*)unk_4BDC60, aGraphicSystem0_1, (int)&v5))
                {
                    MessageBoxA(hWnd, byte_4B3214, aError_12, 0);
                    return 0;
                }
            }
        }
        return 1;
    }
    else
    {
        MessageBoxA(hWnd, byte_4B31C0, aError_11, 0);
        return 0;
    }
}

 
BOOL __stdcall sub_466BEC(int a1, Concurrency::details::UMSFreeVirtualProcessorRoot* a2)
{
    int v3; // eax
    int* v4; // eax
    int* v5; // eax
    int v6; // esi
    int v7; // esi
    int v8; // esi
    int v9; // eax
    int v10; // eax
    int v11; // eax
    int v12; // eax
    int v13; // eax
    int v14; // eax
    int v15; // eax
    int v16; // [esp+4h] [ebp-58h]
    char v17[16]; // [esp+Ch] [ebp-50h] BYREF
    int v18[4]; // [esp+1Ch] [ebp-40h] BYREF
    char* v19; // [esp+2Ch] [ebp-30h]
    int v20; // [esp+30h] [ebp-2Ch]
    int v21; // [esp+34h] [ebp-28h]
    int v22; // [esp+38h] [ebp-24h]
    int v23; // [esp+3Ch] [ebp-20h]
    int v24; // [esp+40h] [ebp-1Ch]
    int v25; // [esp+44h] [ebp-18h]
    int v26; // [esp+48h] [ebp-14h]
    int v27; // [esp+4Ch] [ebp-10h]
    int v28; // [esp+50h] [ebp-Ch]
    int v29; // [esp+54h] [ebp-8h]
    int v30; // [esp+58h] [ebp-4h]

    v19 = (char*)sub_41C915(a1);
    if (!v19)
        return 0;
    v3 = sub_425D70((_DWORD*)a1);
    v4 = sub_425B90(v19, v18, v3, 0);
    v24 = *v4;
    v25 = v4[1];
    v26 = v4[2];
    v27 = v4[3];
    v5 = sub_49530B((int)a2, (_DWORD*)v17);
    v20 = *v5;
    v21 = v5[1];
    v22 = v5[2];
    v23 = v5[3];
    if (!v24 && !v25 && !v26 && !v27 || !v20 && !v21 && !v22 && !v23)
        return 0;
    v6 = sub_426470((_DWORD*)a2) / 100;
    v29 = sub_48A0E0((_DWORD*)a2) + v6;
    v7 = sub_426530((_DWORD*)a2) / 100;
    v28 = unknown_libname_16((_DWORD*)a2) + v7;
    v8 = (int)Concurrency::details::UMSFreeVirtualProcessorRoot::GetExecutingProxy(a2) / 100;
    v30 = sub_475BE0((_DWORD*)a2) + v8;
    v9 = sub_4260B0((_DWORD*)a1);
    if (v28 - v9 / 100 <= 0)
    {
        v11 = sub_4260B0((_DWORD*)a1);
        v16 = v11 / 100 - v28;
    }
    else
    {
        v10 = sub_4260B0((_DWORD*)a1);
        v16 = v28 - v10 / 100;
    }
    if (v16 > (unsigned __int8)sub_4264B0((char*)a1))
        return 0;
    v12 = sub_426090((_DWORD*)a1);
    v24 += v12 / 100;
    v13 = sub_4260D0((_DWORD*)a1);
    v25 += v13 / 100;
    v14 = sub_426090((_DWORD*)a1);
    v26 += v14 / 100;
    v15 = sub_4260D0((_DWORD*)a1);
    v27 += v15 / 100;
    v20 += v29;
    v21 += v30;
    v22 += v29;
    v23 += v30;
    return v24 - v20 <= v22 - v20 && v20 - v24 <= v26 - v24 && v25 - v21 <= v23 - v21 && v21 - v25 <= v27 - v25;
}

 
void sub_466E2D(int thisx)
{
    int i; // [esp+4h] [ebp-4h]
    int j; // [esp+4h] [ebp-4h]

    *(_DWORD*)(thisx + 104) = 6;
    *(_BYTE*)(thisx + 2516) = 1;
    *(_DWORD*)(thisx + 2512) = 0;
    *(_BYTE*)(thisx + 2562) = 0;
    *(_DWORD*)(thisx + 2528) = 0;
    *(_DWORD*)(thisx + 2532) = 0;
    *(_WORD*)(thisx + 2564) = 0;
    *(_WORD*)(thisx + 2566) = 140;
    for (i = 0; i < 14; ++i)
        *(_WORD*)(thisx + 2566) -= *(_WORD*)(thisx + 2 * i + 48);
    if (*(unsigned __int16*)(thisx + 2566) > 0x8Cu)
    {
        for (j = 0; j < 14; ++j)
            *(_WORD*)(thisx + 2 * j + 48) = 10;
        *(_WORD*)(thisx + 2566) = 0;
    }
    sub_466F20(thisx, -1);
}

 
void sub_466F20(int thisx, int a2)
{
    int v2; // edx
    int v3; // eax
    int v4; // edx
    int v5; // [esp-4h] [ebp-170h]
    int yTop; // [esp+4h] [ebp-168h]
    int xLeft; // [esp+8h] [ebp-164h]
    int v9; // [esp+Ch] [ebp-160h]
    int Src[14]; // [esp+10h] [ebp-15Ch] BYREF
    int v11; // [esp+48h] [ebp-124h]
    int j; // [esp+4Ch] [ebp-120h]
    struct tagRECT rc; // [esp+50h] [ebp-11Ch] BYREF
    int i; // [esp+68h] [ebp-104h]
    CHAR String[256]; // [esp+6Ch] [ebp-100h] BYREF

    if (a2 == -1)
    {
        sub_451EB5((_BYTE*)thisx, 1, 1);
        sub_452045((_BYTE*)thisx, 2, 1, 25, 3);
        sub_47B91A(24, 18, byte_4B3248, 0, dword_4B9248);
        sub_452045((_BYTE*)thisx, 2, 4, 36, 19);
        for (i = 0; i < 8; ++i)
        {
            sub_47B91A(136 * (i / 4) + 76, 34 * (i % 4) + 48, byte_4B3258, 0, dword_4B9248);
            sub_47B91A(136 * (i / 4) + 68, 34 * (i % 4) + 60, byte_4B3264, 0, dword_4B9248);
        }
        sub_466F20(thisx, 0);
        sub_466F20(thisx, 1);
    }
    else if (a2)
    {
        if (a2 == 1)
        {
            sub_451EB5((_BYTE*)thisx, 0, 1);
            if (*(_BYTE*)(thisx + 2562))
            {
                if (*(_BYTE*)(thisx + 2562) == 1)
                {
                    sub_47B91A(16, 208, byte_4B3330, 0, dword_4B9248);
                    sub_47B91A(16, 224, aLeri, 0, dword_4B9248);
                }
            }
            else
            {
                sub_47B91A(16, 208, byte_4B329C, 0, dword_4B9248);
                if (*(_WORD*)(thisx + 2566))
                    sub_47B91A(16, 224, byte_4B32F8, 0, dword_4B9248);
                else
                    sub_47B91A(16, 224, byte_4B32C4, 0, dword_4B9248);
            }
        }
    }
    else
    {
        SetRect(&rc, 96, 18, 204, 26);
        sub_4A02E9((_DWORD*)unk_4BDC60, (int)&rc, (int)&rc, 0, dword_4B9248);
        v11 = 10000 * *(unsigned __int16*)(thisx + 2566) / 140;
        wsprintfA(String, "%4dP(%3d.%02d%%)", *(unsigned __int16*)(thisx + 2566), v11 / 100, v11 % 100);
        sub_47B7ED(96, 18, String, 0, dword_4B9248);
        for (j = 0; j < 8; ++j)
        {
            xLeft = 136 * (j % 2) + 36;
            yTop = 34 * (j / 2) + 44;
            sub_49C15E((int)Src);
            SetRect(&rc, xLeft + 40, yTop + 4, xLeft + 64, yTop + 12);
            sub_4A02E9((_DWORD*)unk_4BDC60, dword_4B9248, (int)&rc, 0, dword_4B9248);
            SetRect(&rc, xLeft + 40, yTop + 16, xLeft + 88, yTop + 24);
            sub_4A02E9((_DWORD*)unk_4BDC60, v2, (int)&rc, 0, dword_4B9248);
            v9 = j + 2 * *(unsigned __int16*)(thisx + 2564);
            SetRect(&rc, xLeft, yTop, xLeft + 24, yTop + 24);
            v5 = dword_4B9248;
            v3 = sub_49FFEC(198, 113, 0);
            sub_4A02E9((_DWORD*)unk_4BDC60, v4, (int)&rc, v3, v5);
            if (v9 < 14)
            {
                Src[1] = xLeft + 12;
                Src[2] = yTop + 20;
                Src[0] = dword_4B91E8;
                Src[9] = dword_4B9248;
                sub_490A5B((void*)(140 * dword_4B719C[11 * v9] + dword_4B92E8), Src);
                wsprintfA(String, "%3d", *(unsigned __int16*)(thisx + 2 * v9 + 48));
                sub_47B7ED(xLeft + 40, yTop + 4, String, 0, dword_4B9248);
                v11 = 10000 * *(unsigned __int16*)(thisx + 2 * v9 + 48) / 140;
                wsprintfA(String, "%3d.%02d", v11 / 100, v11 % 100);
                sub_47B7ED(xLeft + 40, yTop + 16, String, 0, dword_4B9248);
            }
        }
    }
}
 
unsigned int sub_46753B(int thisx)
{
    unsigned int result; // eax
    int k; // [esp+8h] [ebp-74h]
    int m; // [esp+Ch] [ebp-70h]
    int v5; // [esp+10h] [ebp-6Ch]
    int v6; // [esp+14h] [ebp-68h]
    int v7; // [esp+18h] [ebp-64h]
    int v8; // [esp+18h] [ebp-64h]
    int v9; // [esp+1Ch] [ebp-60h]
    int v10; // [esp+20h] [ebp-5Ch]
    int v11; // [esp+24h] [ebp-58h]
    int v12; // [esp+28h] [ebp-54h]
    int v13; // [esp+28h] [ebp-54h]
    int i; // [esp+2Ch] [ebp-50h]
    int j; // [esp+2Ch] [ebp-50h]
    int v16; // [esp+30h] [ebp-4Ch]
    int v17; // [esp+34h] [ebp-48h]
    int v18[3]; // [esp+38h] [ebp-44h]
    int v19[14]; // [esp+44h] [ebp-38h] BYREF

    sub_477F0C(0);
    v11 = 0;
    v10 = 0;
    v9 = 0;
    for (i = 0; i < 3; ++i)
        v18[i] = 0;
    if (!*(_BYTE*)(thisx + 2516))
    {
        if (sub_476CDA(0))
        {
            v10 = 1;
        }
        else if (sub_476C8B(0))
        {
            v10 = -1;
        }
        if (sub_476D29(0))
        {
            v11 = -1;
        }
        else if (sub_476D78(0))
        {
            v11 = 1;
        }
        for (j = 0; j < 3; ++j)
            v18[j] = sub_476DC7(0, j);
        v9 = sub_476DC7(0, 5);
    }
    v12 = *(unsigned __int16*)(thisx + 2564);
    v16 = 0;
    v17 = 0;
    if (v11 || v10)
    {
        v16 = 1;
        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
        if (*(_BYTE*)(thisx + 2562))
        {
            if (*(_BYTE*)(thisx + 2562) == 1)
            {
                v5 = *(_DWORD*)(thisx + 2528) + 2 * *(_DWORD*)(thisx + 2532);
                v6 = 5 * v10 + v11;
                if (v6 > 0 && v6 > *(unsigned __int16*)(thisx + 2566))
                    v6 = *(unsigned __int16*)(thisx + 2566);
                if (v6 < 0 && -v6 > *(unsigned __int16*)(thisx + 2 * v5 + 48))
                    v6 = -*(unsigned __int16*)(thisx + 2 * v5 + 48);
                *(_WORD*)(thisx + 2 * v5 + 48) += v6;
                *(_WORD*)(thisx + 2566) -= v6;
            }
        }
        else
        {
            if (v11)
                *(_DWORD*)(thisx + 2528) = *(_DWORD*)(thisx + 2528) == 0;
            if (v10)
            {
                v7 = v10 + *(_DWORD*)(thisx + 2532);
                if (v7 < 0)
                    v7 = 0;
                if (v7 >= 7)
                    v7 = 6;
                *(_DWORD*)(thisx + 2532) = v7;
                v8 = *(_DWORD*)(thisx + 2532) - v12;
                if (v8 < 0 || v8 > 3)
                    *(_WORD*)(thisx + 2564) += v10;
            }
            if (*(_DWORD*)(thisx + 2528) + 2 * *(_DWORD*)(thisx + 2532) >= 14)
            {
                *(_DWORD*)(thisx + 2528) = 0;
                *(_DWORD*)(thisx + 2532) = 6;
            }
        }
    }
    if (v18[0])
    {
        v17 = 1;
        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
        if (*(_BYTE*)(thisx + 2562))
        {
            if (*(_BYTE*)(thisx + 2562) == 1)
                *(_BYTE*)(thisx + 2562) = 0;
        }
        else
        {
            *(_BYTE*)(thisx + 2562) = 1;
        }
    }
    if (v18[1])
    {
        if (*(_BYTE*)(thisx + 2562))
        {
            if (*(_BYTE*)(thisx + 2562) == 1)
            {
                *(_BYTE*)(thisx + 2562) = 0;
                v17 = 1;
            }
        }
        else
        {
            *(_DWORD*)(thisx + 108) = 5;
            *(_BYTE*)(thisx + 2516) = 2;
        }
    }
    if (v9)
    {
        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
        v16 = 1;
        v17 = 1;
        if (*(_WORD*)(thisx + 2566))
        {
            *(_WORD*)(thisx + 2566) = 0;
            for (k = 0; k < 14; ++k)
                *(_WORD*)(thisx + 2 * k + 48) = 10;
        }
        else
        {
            *(_WORD*)(thisx + 2566) = 140;
            for (m = 0; m < 14; ++m)
                *(_WORD*)(thisx + 2 * m + 48) = 0;
        }
    }
    if (v16)
        sub_466F20(thisx, 0);
    if (v17)
        sub_466F20(thisx, 1);
    sub_49C15E((int)v19);
    v19[1] = 0;
    v19[2] = 0;
    v19[0] = dword_4B9248;
    sub_49AB05((int)unk_4BDC60, v19);
    v13 = *(unsigned __int16*)(thisx + 2564);
    if (*(_BYTE*)(thisx + 2562))
    {
        if (*(_BYTE*)(thisx + 2562) == 1)
            sub_47B91A(136 * *(_DWORD*)(thisx + 2528) + 64, 34 * (*(_DWORD*)(thisx + 2532) - v13) + 48, asc_4B3388, 0, -1);
    }
    else
    {
        sub_47B91A(136 * *(_DWORD*)(thisx + 2528) + 24, 34 * (*(_DWORD*)(thisx + 2532) - v13) + 52, asc_4B3384, 0, -1);
    }
    result = dword_4B93B0 / 5u / 2;
    if (!(dword_4B93B0 / 5u % 2))
    {
        if (v13 > 0)
            result = sub_47B91A(160, 32, byte_4B338C, 0, -1);
        if (v13 + 4 < 7)
            return sub_47B91A(160, 172, byte_4B3390, 0, -1);
    }
    return result;
}

 
int sub_467AC6(int thisx, const char* a2)
{
	CHAR FileName[256]; // [esp+4h] [ebp-100h] BYREF

	*(_DWORD*)(thisx + 1296) = 0;
	*(_DWORD*)(thisx + 2528) = 0;
	*(_DWORD*)(thisx + 2532) = 0;
	*(_DWORD*)(thisx + 2488) = 100;
	*(_DWORD*)(thisx + 2492) = 0;
	dword_4B93AC = 0;
	wsprintfA(FileName, "Demo\\%s", a2);
	sub_4891E4((_DWORD*)(thisx + 128), FileName);
	sub_47F958((_DWORD*)(thisx + 736));
	*(_BYTE*)(thisx + 2516) = 1;
	return sub_456169((void*)thisx);
}

 
int sub_467B8F(_DWORD* thisx)
{
    thisx[26] = 1;
    thisx[31] = 6;
    return sub_467AC6((int)thisx, aMisuzuEndTxt);
}

 
HANDLE sub_467BBB(_DWORD* thisx)
{
    HANDLE result; // eax
    CHAR FileName[256]; // [esp+8h] [ebp-100h] BYREF

    for (thisx[3347] = 0; ; ++thisx[3347])
    {
        wsprintfA(FileName, "Stage\\Stage%02d.dat", thisx[3347] + 1);
        result = CreateFileA(FileName, 0x80000000, 0, 0, 3u, 0x80u, 0);
        if (result == (HANDLE)-1)
            break;
        CloseHandle(result);
    }
    return result;
}

 
int sub_467C6D(int thisx)
{
    int result; // eax

    if (*(_DWORD*)(thisx + 13392))
    {
        int* f = (int*)*(_DWORD*)(thisx + 13392);
        f = (int*)*f;
        ((void(*)(_DWORD, int))f)(*(_DWORD*)(thisx + 13392), 3);//±¾Ó¦¸Ã²»»á±»Ö´ÐÐ
        //(***(void(****)(_DWORD, int))(thisx + 13392))            (*(_DWORD*)(thisx + 13392), 3);//±¾Ó¦¸Ã²»»á±»Ö´ÐÐ,ÎªÊ²Ã´²»ÄÜ³¬¹ý¶þ¼¶Ö¸Õë¡£¡££¿£¿
    }
    result = thisx;
    *(_DWORD*)(thisx + 13392) = 0;
    *(_DWORD*)(thisx + 13388) = 0;
    return result;
}

 
int sub_467CD0(_DWORD* thisx)
{
    _DWORD* v2; // [esp+0h] [ebp-24h]
    int* Block; // [esp+8h] [ebp-1Ch]
    int i; // [esp+10h] [ebp-14h]
    int v6; // [esp+14h] [ebp-10h]

    sub_467C6D((int)thisx);
    sub_467BBB(thisx);
    if ((int)thisx[3347] <= 0)
        return 0;
    v6 = thisx[3347];
    Block = (int*)operator new(20 * v6 + 4);
    if (Block)
    {
        *Block = v6;
        eh_vector_constructor_iterator(Block + 1, 20, v6, sub_48A100, sub_48A134);
            v2 = Block + 1;
    }
    else
    {
        v2 = 0;
    }
    thisx[3348] = (_DWORD)v2;//???±¾Ó¦¸Ã²»»á±»Ö´ÐÐµÄ
    for (i = 0; i < thisx[3347]; ++i)
        sub_48A1AD((void**)(thisx[3348] + 20 * i), i + 1);
    return 1;
}

 
_DWORD* sub_467DE0()
{
    _DWORD* result; // eax

    if (dword_4B9244)
        return sub_49DA8A((int*)unk_4BDC60, dword_4B9244);
    return result;
}


 
BOOL sub_467E11(_BYTE* thisx, int a2)
{
    int i; // [esp+4h] [ebp-4h]

    if (thisx[16] == 4)
        return a2 <= 10 || a2 == 16 || a2 == 23;
    for (i = 0; i < 3; ++i)
    {
        if (a2 == (unsigned __int8)thisx[i + 68])
            return 1;
    }
    return 0;
}

 
__int16 sub_467E7D(int thisx, _BYTE* a2)
{
    int v2; // esi
    unsigned __int8 v3; // al
    __int16 result; // ax
    int v6[2]; // [esp+8h] [ebp-24h] BYREF
    char v7; // [esp+10h] [ebp-1Ch]
    int v8; // [esp+14h] [ebp-18h]
    char* v9; // [esp+18h] [ebp-14h]
    char* v10; // [esp+1Ch] [ebp-10h]
    int v11; // [esp+20h] [ebp-Ch]
    int i; // [esp+24h] [ebp-8h]
    int v13; // [esp+28h] [ebp-4h]

    for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
    {
        v10 = (char*)(thisx + 612 * i + 2628);
        if (v10 != a2 && !sub_41BE56((_DWORD*)v10))
        {
            LOBYTE(v11) = sub_426070(v10);
            v2 = (unsigned __int8)v11;
            if (v2 == (unsigned __int8)sub_426070(a2) && (!(_BYTE)v11 || *(_DWORD*)(thisx + 116) != 3))
            {
                if (sub_41BA53((int)v10, 0x82u, 0))
                {
                    sub_42511B(v10, *(unsigned __int8*)(thisx + (unsigned __int8)v11 + 2546));
                    sub_442863(v6);
                    v6[0] = 0;
                    v6[1] = -24;
                    v9 = v10;
                    v8 = 0;
                    v7 = 15;
                    sub_4561A5((_BYTE*)thisx, (int)v6);
                    sub_43FFC3((_DWORD*)unk_4BDB28, (_DWORD)dword_4B9AD4, -1, 100, 100, 0);
                }
            }
        }
    }
    LOBYTE(v13) = sub_425EF0(a2);
    if (*(_DWORD*)(thisx + 104) == 11 || *(_DWORD*)(thisx + 104) == 10)
        *(_BYTE*)(thisx + (unsigned __int8)v13 + 13052) = -1;
    v3 = sub_426070(a2);
    sub_4631A8((_BYTE*)thisx, v3);
    result = thisx;
    if (*(_DWORD*)(thisx + 116) == 3 && (_BYTE)v13)
    {
        sub_4565CF(thisx);
        return sub_456738(thisx, v13);
    }
    return result;
} 
char sub_468011(_BYTE* thisx, _BYTE* a2)
{
    unsigned __int8 v2; // al
    char result; // al
    int i; // [esp+8h] [ebp-8h]
    unsigned __int8 v6; // [esp+Ch] [ebp-4h]

    v2 = sub_426070(a2);
    sub_4631D0(thisx, v2);
    v6 = sub_425EF0(a2);
    for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
    {
        if (i != v6 && thisx[i + 13052] && (unsigned __int8)thisx[i + 13052] <= (int)(unsigned __int8)thisx[v6 + 13052])
            ++thisx[i + 13052];
    }
    thisx[v6 + 13052] = 0;
    result = thisx[13043] + 1;
    thisx[13043] = result;
    return result;
}

 
int sub_4680EF()
{
    const void* v0; // eax
    signed int j; // [esp+4h] [ebp-844h]
    char Src[1024]; // [esp+8h] [ebp-840h] BYREF
    int i; // [esp+408h] [ebp-440h]
    char v5[1024]; // [esp+40Ch] [ebp-43Ch] BYREF
    int v6[15]; // [esp+80Ch] [ebp-3Ch] BYREF

    memset(Src, 0, sizeof(Src));
    memset(v5, 0, sizeof(v5));
    sub_49DB90(v6);
    sub_49B9E0((_DWORD*)unk_4BDC60, aGraphicHeadBmp);
    v0 = (const void*)sub_49CE7F((char**)unk_4BDC60);
    memcpy(Src, v0, sizeof(Src));
    memcpy(v5, Src, sizeof(v5));
    v6[11] = (int)Src;
    for (i = 0; i < dword_4B9368; ++i)
    {
        for (j = 0; j < (int)dword_4B93A0; ++j)
        {
            if (*(_DWORD*)(*((_DWORD*)dword_4B9360 + i) + 4 * j))
            {
                memcpy(Src, v5, sizeof(Src));
                sub_485DFD((int)dword_4B93A4 + 24 * j, (int)Src);
                v6[1] = 0;
                v6[2] = 8 * i;
                v6[3] = -1;
                v6[4] = 8;
                v6[5] = 1;
                v6[9] = 0;
                v6[0] = -1;
                if (!sub_49D318((int)unk_4BDC60, (int)v6))
                    return 0;
                *(_DWORD*)(*((_DWORD*)dword_4B9360 + i) + 4 * j) = v6[0];
            }
        }
    }
    return 1;
}

 
int sub_4682AC(unsigned __int8* thisx)
{
    return *(_DWORD*)(*((_DWORD*)dword_4B9360 + thisx[22]) + 4 * thisx[26]);
}

 
int sub_4682D3(char* thisx, _DWORD* a2, char a3)
{
    int v4; // [esp+4h] [ebp-4Ch]
    int v5; // [esp+8h] [ebp-48h]
    int v6; // [esp+Ch] [ebp-44h]
    int v7; // [esp+10h] [ebp-40h]
    char* v9; // [esp+18h] [ebp-38h]
    int v10; // [esp+1Ch] [ebp-34h]
    int v11; // [esp+24h] [ebp-2Ch]
    int v12; // [esp+28h] [ebp-28h]
    int v13; // [esp+2Ch] [ebp-24h]
    int i; // [esp+30h] [ebp-20h]
    int v15; // [esp+34h] [ebp-1Ch]
    int v16; // [esp+38h] [ebp-18h]
    int v17; // [esp+3Ch] [ebp-14h]
    int v18; // [esp+40h] [ebp-10h]
    char v19; // [esp+44h] [ebp-Ch]
    int v20; // [esp+48h] [ebp-8h]
    int v21; // [esp+4Ch] [ebp-4h]

    v16 = sub_426090(a2) / 100;
    v15 = sub_4260B0(a2) / 100;
    v19 = sub_426070((char*)a2);
    v20 = sub_425D70(a2);
    v17 = (unsigned __int8)sub_425EF0((char*)a2);
    v21 = 0;
    for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
    {
        v9 = &thisx[612 * i + 2628];
        if (i != v17 && unknown_libname_7((_DWORD*)v9) && !sub_41BE56((_DWORD*)v9) && v19 != sub_426070(v9))
        {
            if ((v13 = sub_426090((_DWORD*)v9) / 100, v12 = sub_4260B0((_DWORD*)v9) / 100, v20) && v16 - v13 <= -32 || !v20 && v16 - v13 >= 32)
            {
                v10 = v13 - v16;
                v11 = v12 - v15;
                if (a3 != 1 || v11 <= 0)
                {
                    if (a3 != 2
                        || (v10 <= 0 ? (v7 = v16 - v13) : (v7 = v13 - v16),
                            v11 <= 0 ? (v6 = v15 - v12) : (v6 = v12 - v15),
                            v7 >= 2 * v6))
                    {
                        if (a3 != 3 || v11 >= 0)
                        {
                            if (v10 <= 0)
                                v5 = v16 - v13;
                            else
                                v5 = v13 - v16;
                            if (v11 <= 0)
                                v4 = v15 - v12;
                            else
                                v4 = v12 - v15;
                            if (!v21 || v4 + v5 < v18)
                            {
                                v21 = (int)&thisx[612 * i + 2628];
                                v18 = v4 + v5;
                            }
                        }
                    }
                }
            }
        }
    }
    return v21;
}

 
char sub_4684DD(_BYTE* thisx)
{
    char v3; // [esp+4h] [ebp-8h]
    int i; // [esp+8h] [ebp-4h]

    v3 = 0;
    for (i = 0; i < 3; ++i)
    {
        if (sub_426850(thisx, i))
            ++v3;
    }
    return v3;
}

 
int sub_468529(_BYTE* thisx, char a2)
{
    int i; // [esp+4h] [ebp-4h]

    for (i = 0; i < 3; ++i)
    {
        if (thisx[i + 68] == a2)
            return 0;
        if (!thisx[i + 68])
        {
            thisx[i + 68] = a2;
            return 1;
        }
    }
    return 0;
}

 
char sub_468591(_BYTE* thisx, int a2, int a3)
{
    char result; // al
    int v4; // [esp+4h] [ebp-4h]

    v4 = a3 + (unsigned __int8)thisx[a2 + 71];
    if (v4 < 0 || v4 > 255)
        LOBYTE(v4) = 0;
    result = v4;
    thisx[a2 + 71] = v4;
    return result;
}

 
int sub_4685D3(void* thisx, wchar_t* Source, int a3)
{
	return sub_48E8B8((int)thisx + 1300, Source, a3);
}

 
int sub_4685F6(_DWORD* thisx)
{
    if (thisx[26] == 11 || thisx[26] == 10 || thisx[26] == 12)
        return sub_4685D3(thisx, (wchar_t*)&word_4B342C, 120);
    dword_4B9978 = dword_4B9978 == 0;
    if (dword_4B9978)
        return sub_4685D3(thisx, (wchar_t*)&word_4B33D4, 120);
    else
        return sub_4685D3(thisx, (wchar_t*)&word_4B3400, 120);
}

 
int sub_468667(int thisx)
{
    int result; // eax

    result = thisx;
    if (*(_DWORD*)(thisx + 104) != 2)
        return sub_4685D3((void*)thisx, (wchar_t*)&word_4B3450, 120);
    dword_4B9974 = 1;
    *(_DWORD*)(thisx + 108) = 11;
    *(_BYTE*)(thisx + 2516) = 2;
    return result;
}
 
void sub_4686AA(int thisx)
{
    int i; // [esp+4h] [ebp-4h]

    *(_DWORD*)(thisx + 104) = 22;
    *(_DWORD*)(thisx + 2540) = 0;
    *(_BYTE*)(thisx + 2516) = 1;
    *(_BYTE*)(thisx + 2562) = 0;
    sub_46D747(thisx);
    sub_47C427();
    sub_46D3E1();
    sub_46D387((char*)thisx + 1392);
    memset((void*)dword_4B92DC, 0, Size);
    memset((void*)(thisx + 2580), 0, 8u);
    memset((void*)(thisx + 2596), 0, 8u);
    memset((void*)(thisx + 2564), 0, 0x10u);
    memset((void*)(thisx + 2554), 0, 8u);
    memset((void*)(thisx + 2604), 0, 8u);
    memset((void*)(thisx + 13092), 0, 8u);
    for (i = 0; i < 4; ++i)
    {
        *(_WORD*)(thisx + 2 * i + 2572) = (unsigned __int8)byte_4B9988[(*(_DWORD*)(thisx + 2368) + 1) * i] + 1;
        if (*(unsigned __int16*)(thisx + 2 * i + 2572) > (int)(unsigned __int8)byte_4B9986)
            *(_WORD*)(thisx + 2 * i + 2572) = 0;
    }
    sub_46B8AE((_BYTE*)thisx, -1);
}

 
unsigned __int16* sub_46881A(int thisx)
{
    unsigned __int16 v1; // cx
    int v2; // ecx
    int v3; // esi
    int v4; // edx
    int v5; // eax
    int v6; // esi
    int v7; // ecx
    int v8; // edx
    int v9; // eax
    int v10; // ecx
    int v11; // edx
    int v12; // eax
    int v13; // eax
    char v14; // al
    __int16 v15; // ax
    char v16; // al
    char v17; // al
    int v18; // eax
    char v19; // al
    char* v20; // eax
    char* v21; // eax
    int v22; // eax
    unsigned __int16* result; // eax
    unsigned __int16 v24; // cx
    int v26; // [esp+Ch] [ebp-2B0h]
    int v27; // [esp+10h] [ebp-2ACh]
    int v28; // [esp+14h] [ebp-2A8h]
    int v29; // [esp+1Ch] [ebp-2A0h]
    int v30; // [esp+20h] [ebp-29Ch]
    int v31; // [esp+24h] [ebp-298h]
    int i10; // [esp+28h] [ebp-294h]
    CHAR v33[64]; // [esp+2Ch] [ebp-290h] BYREF
    int i9; // [esp+6Ch] [ebp-250h]
    CHAR v35[4]; // [esp+70h] [ebp-24Ch] BYREF
    int v36; // [esp+74h] [ebp-248h]
    int v37; // [esp+78h] [ebp-244h]
    int v38; // [esp+7Ch] [ebp-240h]
    char String1[64]; // [esp+80h] [ebp-23Ch] BYREF
    int v40; // [esp+C0h] [ebp-1FCh]
    __int16 v41; // [esp+C4h] [ebp-1F8h]
    char v42; // [esp+C6h] [ebp-1F6h]
    __int16 v43; // [esp+C7h] [ebp-1F5h]
    char v44; // [esp+C9h] [ebp-1F3h]
    __int16 v45; // [esp+CAh] [ebp-1F2h]
    char v46; // [esp+CCh] [ebp-1F0h]
    __int16 v47; // [esp+CDh] [ebp-1EFh]
    char v48; // [esp+CFh] [ebp-1EDh]
    int v49[4]; // [esp+D0h] [ebp-1ECh]
    int i8; // [esp+E0h] [ebp-1DCh]
    int v51; // [esp+E4h] [ebp-1D8h]
    int i7; // [esp+E8h] [ebp-1D4h]
    int v53; // [esp+ECh] [ebp-1D0h]
    int v54[4]; // [esp+F0h] [ebp-1CCh]
    int v55; // [esp+100h] [ebp-1BCh]
    int v56; // [esp+104h] [ebp-1B8h]
    int i6; // [esp+108h] [ebp-1B4h]
    int v58; // [esp+10Ch] [ebp-1B0h]
    int i5; // [esp+110h] [ebp-1ACh]
    int v60; // [esp+114h] [ebp-1A8h]
    int v61; // [esp+118h] [ebp-1A4h]
    int v62[4]; // [esp+11Ch] [ebp-1A0h]
    int i4; // [esp+12Ch] [ebp-190h]
    int v64; // [esp+130h] [ebp-18Ch]
    int v65; // [esp+134h] [ebp-188h]
    int i3; // [esp+138h] [ebp-184h]
    int v67; // [esp+13Ch] [ebp-180h]
    int v68; // [esp+140h] [ebp-17Ch]
    int v69; // [esp+144h] [ebp-178h]
    int v70; // [esp+148h] [ebp-174h]
    int v71; // [esp+14Ch] [ebp-170h]
    int i2; // [esp+150h] [ebp-16Ch]
    int v73; // [esp+154h] [ebp-168h]
    int v74; // [esp+158h] [ebp-164h]
    int v75; // [esp+15Ch] [ebp-160h]
    int v76; // [esp+160h] [ebp-15Ch]
    int v77; // [esp+164h] [ebp-158h]
    int i1; // [esp+168h] [ebp-154h]
    int v79; // [esp+16Ch] [ebp-150h]
    int v80; // [esp+170h] [ebp-14Ch]
    int v81; // [esp+174h] [ebp-148h]
    int v82; // [esp+178h] [ebp-144h]
    int v83; // [esp+17Ch] [ebp-140h]
    int nn; // [esp+180h] [ebp-13Ch]
    int v85; // [esp+184h] [ebp-138h]
    int mm; // [esp+188h] [ebp-134h]
    int v87; // [esp+18Ch] [ebp-130h]
    int v88; // [esp+190h] [ebp-12Ch]
    int v89; // [esp+194h] [ebp-128h]
    int v90; // [esp+198h] [ebp-124h]
    int kk; // [esp+19Ch] [ebp-120h]
    int v92; // [esp+1A0h] [ebp-11Ch]
    int v93; // [esp+1A4h] [ebp-118h]
    int v94; // [esp+1A8h] [ebp-114h]
    int v95; // [esp+1ACh] [ebp-110h]
    int v96; // [esp+1B0h] [ebp-10Ch]
    int v97; // [esp+1B4h] [ebp-108h]
    int jj; // [esp+1B8h] [ebp-104h]
    int v99; // [esp+1BCh] [ebp-100h]
    int m; // [esp+1C0h] [ebp-FCh]
    int v101; // [esp+1C4h] [ebp-F8h]
    int k; // [esp+1C8h] [ebp-F4h]
    int v103; // [esp+1CCh] [ebp-F0h]
    int v104[4]; // [esp+1D0h] [ebp-ECh]
    int v105; // [esp+1E0h] [ebp-DCh]
    int v106; // [esp+1E4h] [ebp-D8h]
    int j; // [esp+1E8h] [ebp-D4h]
    int v108; // [esp+1ECh] [ebp-D0h]
    int v109; // [esp+1F0h] [ebp-CCh]
    int ii; // [esp+1F4h] [ebp-C8h]
    int v111; // [esp+1F8h] [ebp-C4h]
    int v112; // [esp+1FCh] [ebp-C0h]
    int v113[4]; // [esp+200h] [ebp-BCh]
    int n; // [esp+210h] [ebp-ACh]
    int v115; // [esp+214h] [ebp-A8h]
    int v116; // [esp+218h] [ebp-A4h]
    int v117; // [esp+21Ch] [ebp-A0h]
    int v118; // [esp+220h] [ebp-9Ch]
    int v119; // [esp+224h] [ebp-98h]
    int v120; // [esp+228h] [ebp-94h]
    int v121; // [esp+22Ch] [ebp-90h]
    int v122; // [esp+230h] [ebp-8Ch]
    int v123; // [esp+234h] [ebp-88h]
    int v124; // [esp+238h] [ebp-84h]
    int v125; // [esp+23Ch] [ebp-80h]
    int v126; // [esp+240h] [ebp-7Ch]
    int v127; // [esp+244h] [ebp-78h]
    int i; // [esp+248h] [ebp-74h]
    int v129; // [esp+24Ch] [ebp-70h]
    CHAR String[32]; // [esp+250h] [ebp-6Ch] BYREF
    int v131[14]; // [esp+270h] [ebp-4Ch] BYREF
    int v132; // [esp+2A8h] [ebp-14h]
    int v133[4]; // [esp+2ACh] [ebp-10h] BYREF

    v132 = (unsigned __int8)byte_4B9986;
    for (i = 0; i < v132; ++i)
        sub_477F0C(i);
    v129 = 0;
    memset(v133, 0, sizeof(v133));
    v127 = 0;
    for (i = 0; i < 4; ++i)
    {
        v122 = 0;
        v121 = 0;
        v120 = 0;
        v118 = 0;
        v126 = 0;
        v125 = 0;
        v119 = 0;
        v1 = *(_WORD*)(thisx + 2 * i + 2572);
        v124 = v1;
        if (!v1)
            continue;
        if (v124 >= 100)
        {
            *(_WORD*)(thisx + 2 * i + 2572) -= 100;
            continue;
        }
        v2 = --v124;
        if (!*(_BYTE*)(thisx + 2516))
        {
            LOBYTE(v2) = v124;
            v3 = sub_476D78(v2);
            LOBYTE(v4) = v124;
            v5 = sub_476D29(v4);
            v121 = v3 - v5;
            LOBYTE(v5) = v124;
            v6 = sub_476CDA(v5);
            LOBYTE(v7) = v124;
            v120 = v6 - sub_476C8B(v7);
            LOBYTE(v8) = v124;
            v9 = sub_476DC7(v8, 0);
            v118 = v9;
            LOBYTE(v9) = v124;
            v126 = sub_476DC7(v9, 1);
            LOBYTE(v10) = v124;
            v125 = sub_476DC7(v10, 2);
            LOBYTE(v11) = v124;
            v12 = sub_476DC7(v11, 5);
            v119 = v12;
            LOBYTE(v12) = v124;
            v13 = sub_476DC7(v12, 6);
            v127 |= v13;
        }
        v123 = *(unsigned __int8*)(i + thisx + 2584);
        if (v119)
        {
            if (*(_BYTE*)(i + thisx + 2604))
                *(_BYTE*)(i + thisx + 2604) = 0;
            else
                *(_BYTE*)(i + thisx + 2604) = 1;
        }
        if (*(_BYTE*)(i + thisx + 2604))
        {
            v121 = 0;
            v120 = 0;
            if ((unsigned __int8)++ * (_BYTE*)(i + thisx + 2604) >= 5u)
                *(_BYTE*)(i + thisx + 2604) = 1;
        }
        if (v123)
        {
            if (v123 != 1)
            {
                if (v123 == 2)
                {
                    if (*(_BYTE*)(i + thisx + 2604) == 1)
                    {
                        v106 = 0;
                        for (j = 0; j < 4; ++j)
                        {
                            v104[j] = *(__int16*)(thisx + 244 * j + 1630);
                            if (v104[j] >= 0)
                                ++v106;
                        }
                        for (j = 0; j < 4; ++j)
                        {
                            v103 = 3;
                            for (k = 2; k >= j; --k)
                            {
                                if (v104[v103] >= 0 && (v104[k] < 0 || v104[v103] < v104[k]))
                                {
                                    v101 = v104[v103];
                                    v104[v103] = v104[k];
                                    v104[k] = v101;
                                }
                                --v103;
                            }
                        }
                        v105 = rand() % (word_4B99E4 - v106);
                        for (j = 0; j < 4; ++j)
                        {
                            if (v104[j] <= v105 && v104[j] >= 0)
                                ++v105;
                        }
                        *(_WORD*)(thisx + 2 * i + 2564) = v105;
                        sub_476E46(*(unsigned __int16*)(thisx + 2 * i + 2564), (void*)(8 * i + 4952656));
                        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
                        v122 = 1;
                    }
                    if (v121)
                    {
                        *(_BYTE*)(i + thisx + 2600) = (*(unsigned __int8*)(i + thisx + 2600) + v121 + 6) % 6;
                        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
                        v122 = 1;
                    }
                    else if (v120)
                    {
                        *(_WORD*)(thisx + 2 * i + 2564) = (word_4B99E4 + v120 + *(unsigned __int16*)(thisx + 2 * i + 2564))
                            % word_4B99E4;
                        sub_476E46(*(unsigned __int16*)(thisx + 2 * i + 2564), (void*)(8 * i + 4952656));
                        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
                        v122 = 1;
                    }
                    else if (v118)
                    {
                        if (!sub_46D56B((__int16*)(thisx + 1392), *(unsigned __int16*)(thisx + 2 * i + 2564), -1))
                        {
                            *(_WORD*)(thisx + 244 * i + 1630) = *(_WORD*)(thisx + 2 * i + 2564);
                            *(_BYTE*)(i + thisx + 2584) = 3;
                            sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
                            v129 = 1;
                            for (m = 0; m < 4; ++m)
                            {
                                if (!*(_BYTE*)(m + thisx + 2584) && !*(_WORD*)(thisx + 2 * m + 2572))
                                {
                                    *(_WORD*)(thisx + 2 * i + 2572) = 0;
                                    *(_WORD*)(thisx + 2 * m + 2572) = v124 + 101;
                                    *(_BYTE*)(m + thisx + 2554) = i + 1;
                                    goto LABEL_139;
                                }
                            }
                        }
                    }
                    else if (v126)
                    {
                        *(_WORD*)(thisx + 2 * i + 2564) = *(_WORD*)(thisx + 244 * i + 1628);
                        *(_WORD*)(thisx + 244 * i + 1628) = -1;
                        *(_BYTE*)(i + thisx + 2600) = 6;
                        *(_BYTE*)(i + thisx + 2584) = 1;
                        v122 = 1;
                        v129 = 1;
                    }
                }
                else if (v123 == 3 && v126)
                {
                    *(_BYTE*)(i + thisx + 2584) = 2;
                    *(_WORD*)(thisx + 2 * i + 2564) = *(_WORD*)(thisx + 244 * i + 1630);
                    *(_WORD*)(thisx + 244 * i + 1630) = -1;
                    v129 = 1;
                }
                goto LABEL_139;
            }
            v116 = *(unsigned __int8*)(i + thisx + 2600);
            if (*(_BYTE*)(i + thisx + 2604) == 1)
            {
                if (v116 >= 6)
                {
                    if (*(_BYTE*)(thisx + 81))
                    {
                        *(_WORD*)(thisx + 2 * i + 2564) = rand() % dword_4B92D8;
                    }
                    else
                    {
                        v112 = 0;
                        for (n = 0; n < 4; ++n)
                        {
                            v113[n] = *(__int16*)(thisx + 244 * n + 1628);
                            if (v113[n] >= 0)
                                ++v112;
                        }
                        for (n = 0; n < 4; ++n)
                        {
                            v111 = 3;
                            for (ii = 2; ii >= n; --ii)
                            {
                                if (v113[v111] >= 0 && (v113[ii] < 0 || v113[v111] < v113[ii]))
                                {
                                    v109 = v113[v111];
                                    v113[v111] = v113[ii];
                                    v113[ii] = v109;
                                }
                                --v111;
                            }
                        }
                        v115 = rand() % (dword_4B92D8 - v112);
                        for (n = 0; n < 4; ++n)
                        {
                            if (v113[n] <= v115 && v113[n] >= 0)
                                ++v115;
                        }
                        *(_WORD*)(thisx + 2 * i + 2564) = v115;
                    }
                }
                else
                {
                    v15 = sub_46D5C0((char*)thisx);
                    *(_WORD*)(thisx + 2 * i + 2564) = v15;
                    if (*(_BYTE*)(thisx + 98))
                    {
                        *(_BYTE*)(i + thisx + 2580) = rand() % 4;
                    }
                    else
                    {
                        v16 = MarkedForDetachment((_BYTE*)(36 * *(unsigned __int16*)(thisx + 2 * i + 2564) + dword_4B92E0));
                        *(_BYTE*)(i + thisx + 2580) = v16;
                    }
                }
                sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
                v122 = 1;
            }
            if (v121)
            {
                if (v116 >= 6)
                {
                    *(_WORD*)(thisx + 2 * i + 2564) = (dword_4B92D8 + v121 + *(unsigned __int16*)(thisx + 2 * i + 2564))
                        % dword_4B92D8;
                }
                else
                {
                    *(_WORD*)(thisx + 2 * i + 2564) = (int)(Size + v121 + *(unsigned __int16*)(thisx + 2 * i + 2564)) % (int)Size;
                    v17 = MarkedForDetachment((_BYTE*)(dword_4B92E0 + 36 * *(unsigned __int16*)(thisx + 2 * i + 2564)));
                    *(_BYTE*)(i + thisx + 2580) = v17;
                    *(_BYTE*)(i + thisx + 13092) = 0;
                }
            }
            else
            {
                if (!v120)
                {
                    if (v118)
                    {
                        v108 = *(unsigned __int16*)(thisx + 2 * i + 2564);
                        if (*(unsigned __int8*)(i + thisx + 2600) > 5u)
                        {
                            if (*(_BYTE*)(i + thisx + 2600) == 6
                                && (*(_BYTE*)(thisx + 81) || !sub_46D516((__int16*)(thisx + 1392), v108, -1)))
                            {
                                sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
                                *(_WORD*)(thisx + 244 * i + 1628) = *(_WORD*)(thisx + 2 * i + 2564);
                                *(_BYTE*)(i + thisx + 2600) = 0;
                                *(_BYTE*)(i + thisx + 2584) = 2;
                                if (*(__int16*)(thisx + 244 * i + 1630) < 0)
                                {
                                    *(_WORD*)(thisx + 2 * i + 2564) = i;
                                }
                                else
                                {
                                    *(_WORD*)(thisx + 2 * i + 2564) = *(_WORD*)(thisx + 244 * i + 1630);
                                    *(_WORD*)(thisx + 244 * i + 1630) = -1;
                                }
                                sub_476E46(*(unsigned __int16*)(thisx + 2 * i + 2564), (void*)(8 * i + 4952656));
                            }
                        }
                        else if (*(_BYTE*)(thisx + 81) || !*((_BYTE*)dword_4B92DC + v108))
                        {
                            sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
                            *(_DWORD*)(thisx + 244 * i + 1392 + 28 * v116) = *(unsigned __int16*)(thisx + 2 * i + 2564);
                            *((_BYTE*)dword_4B92DC + *(unsigned __int16*)(thisx + 2 * i + 2564)) = 1;
                            *(_BYTE*)(thisx + 244 * i + 1392 + 28 * v116 + 4) = *(_BYTE*)(i + thisx + 2580);
                            if (++ * (_BYTE*)(i + thisx + 2600) == 6)
                            {
                                *(_WORD*)(thisx + 2 * i + 2564) = 0;
                                if (*(__int16*)(thisx + 244 * i + 1628) >= 0)
                                {
                                    *(_BYTE*)(i + thisx + 2600) = 0;
                                    *(_BYTE*)(i + thisx + 2584) = 2;
                                    *(_WORD*)(thisx + 2 * i + 2564) = i;
                                }
                            }
                        }
                        v122 = 1;
                        v129 = 1;
                    }
                    else if (v126)
                    {
                        if (--v116 < 0)
                        {
                            *(_BYTE*)(i + thisx + 2584) = 0;
                            *(_WORD*)(thisx + 2 * i + 2564) = 0;
                        }
                        else
                        {
                            *(_WORD*)(thisx + 2 * i + 2564) = *(_WORD*)(thisx + 244 * i + 1392 + 28 * v116);
                            *((_BYTE*)dword_4B92DC + *(unsigned __int16*)(thisx + 2 * i + 2564)) = 0;
                            *(_BYTE*)(i + thisx + 2580) = *(_BYTE*)(thisx + 244 * i + 1392 + 28 * v116 + 4);
                            *(_DWORD*)(thisx + 244 * i + 1392 + 28 * v116) = -1;
                            --* (_BYTE*)(i + thisx + 2600);
                        }
                        v122 = 1;
                        v129 = 1;
                    }
                    else if (v125)
                    {
                        *(_BYTE*)(i + thisx + 2596) = *(_BYTE*)(i + thisx + 2596) == 0;
                        *(_BYTE*)(i + thisx + 13092) = 0;
                        v122 = 1;
                        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
                    }
                    goto LABEL_139;
                }
                if (*(_BYTE*)(i + thisx + 2596) == 1)
                    *(_BYTE*)(i + thisx + 13092) = (*(unsigned __int8*)(i + thisx + 13092) + v120 + 4) % 4;
                else
                    *(_BYTE*)(i + thisx + 2580) = (*(unsigned __int8*)(i + thisx + 2580) + v120 + 4) % 4;
            }
            sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
            v122 = 1;
        }
        else
        {
            if (*(_BYTE*)(i + thisx + 2604) == 1)
            {
                *(_WORD*)(thisx + 2 * i + 2564) = rand() % 2;
                sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
            }
            if (v120)
            {
                *(_WORD*)(thisx + 2 * i + 2564) = *(_WORD*)(thisx + 2 * i + 2564) == 0;
                sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
            }
            else if (v118)
            {
                sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
                *(_BYTE*)(i + thisx + 13092) = 0;
                if (*(_WORD*)(thisx + 2 * i + 2564))
                {
                    *(_BYTE*)(i + thisx + 2584) = 4;
                    v123 = 4;
                    v118 = 0;
                    v120 = *(_DWORD*)(thisx + 15636);
                    *(_WORD*)(thisx + 2 * i + 2564) = 0;
                    v122 = 1;
                }
                else
                {
                    *(_BYTE*)(i + thisx + 2584) = 1;
                    v122 = 1;
                    v14 = MarkedForDetachment((_BYTE*)(36 * *(unsigned __int16*)(thisx + 2 * i + 2564) + dword_4B92E0));
                    *(_BYTE*)(i + thisx + 2580) = v14;
                    *(_BYTE*)(thisx + 244 * i + 1564) = 0;
                }
            }
            else if (v126 && *(_BYTE*)(i + thisx + 2554))
            {
                v117 = *(unsigned __int8*)(i + thisx + 2554) - 1;
                *(_BYTE*)(i + thisx + 2554) = 0;
                *(_WORD*)(thisx + 2 * i + 2572) = 100;
                *(_BYTE*)(v117 + thisx + 2584) = 2;
                *(_WORD*)(thisx + 2 * v117 + 2564) = *(_WORD*)(thisx + 244 * v117 + 1630);
                *(_WORD*)(thisx + 244 * v117 + 1630) = -1;
                *(_WORD*)(thisx + 2 * v117 + 2572) = v124 + 101;
                *(_BYTE*)(v117 + thisx + 2600) = 0;
                v129 = 1;
            }
        }
    LABEL_139:
        if (v123 == 4)
        {
            if (*(_BYTE*)(i + thisx + 2604) == 1)
            {
                if (byte_4B99CD)
                {
                    v99 = rand() % *(_DWORD*)(thisx + 15636);
                }
                else
                {
                    v97 = 0;
                    memset(*(void**)(thisx + 15632), 0, *(_DWORD*)(thisx + 15636));
                    for (jj = 0; jj < *(_DWORD*)(thisx + 15636); ++jj)
                    {
                        v96 = 244 * jj + *(_DWORD*)(thisx + 15628);
                        if (sub_46DCBB((_DWORD*)thisx, jj, 0))
                            *(_BYTE*)(*(_DWORD*)(thisx + 15632) + jj) = 1;
                        else
                            ++v97;
                    }
                    if (v97)
                    {
                        v95 = rand() % v97;
                        v99 = -1;
                        while (v95 >= 0)
                        {
                            ++v99;
                            if (!*(_BYTE*)(*(_DWORD*)(thisx + 15632) + v99))
                                --v95;
                        }
                    }
                    else
                    {
                        *(_BYTE*)(i + thisx + 2604) = 0;
                        v99 = 0;
                    }
                }
                *(_WORD*)(thisx + 2 * i + 2564) = v99;
                v121 = 0;
                v120 = 2 * *(_DWORD*)(thisx + 15636);
            }
            if (v118)
            {
                v129 = 1;
                sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
                v89 = *(unsigned __int16*)(thisx + 2 * i + 2564);
                v94 = 244 * v89 + *(_DWORD*)(thisx + 15628);
                v92 = thisx + 244 * i + 1392;
                sub_46D2DE(v92);
                lstrcpyA((LPSTR)(v92 + 172), (LPCSTR)(v94 + 172));
                v88 = 0;
                for (kk = 0; kk < 6; ++kk)
                {
                    v87 = *(_DWORD*)(v94 + 28 * kk);
                    if (v87 >= 0 && (byte_4B99CD || !*((_BYTE*)dword_4B92DC + v87)))
                    {
                        *(_DWORD*)(v92 + 28 * v88) = v87;
                        *(_BYTE*)(v92 + 28 * v88 + 4) = *(_BYTE*)(v94 + 28 * kk + 4);
                        *((_BYTE*)dword_4B92DC + v87) = 1;
                        ++v88;
                    }
                }
                v90 = *(__int16*)(v94 + 236);
                if (v90 >= 0 && (byte_4B99CD || !sub_46D516((__int16*)(thisx + 1392), v90, -1)))
                    *(_WORD*)(v92 + 236) = v90;
                v93 = *(__int16*)(v94 + 238);
                if (v93 < 0 || sub_46D56B((__int16*)(thisx + 1392), v93, -1))
                    *(_WORD*)(v92 + 238) = -1;
                else
                    *(_WORD*)(v92 + 238) = v93;
                *(_WORD*)(thisx + 2 * i + 2564) = 0;
                *(_BYTE*)(i + thisx + 2580) = 0;
                *(_BYTE*)(i + thisx + 2596) = 0;
                if (v88 >= 6)
                {
                    if (*(__int16*)(v92 + 236) == -1)
                    {
                        *(_BYTE*)(i + thisx + 2600) = 6;
                        *(_BYTE*)(i + thisx + 2584) = 1;
                    }
                    else if (*(__int16*)(v92 + 238) == -1)
                    {
                        *(_BYTE*)(i + thisx + 2600) = 0;
                        *(_BYTE*)(i + thisx + 2584) = 2;
                        *(_WORD*)(thisx + 2 * i + 2564) = i;
                        sub_476E46(*(unsigned __int16*)(thisx + 2 * i + 2564), (void*)(8 * i + 4952656));
                    }
                    else
                    {
                        *(_BYTE*)(i + thisx + 2584) = 3;
                        for (mm = 0; mm < 4; ++mm)
                        {
                            if (!*(_BYTE*)(mm + thisx + 2584) && !*(_WORD*)(thisx + 2 * mm + 2572))
                            {
                                *(_WORD*)(thisx + 2 * i + 2572) = 0;
                                *(_WORD*)(thisx + 2 * mm + 2572) = v124 + 101;
                                *(_BYTE*)(mm + thisx + 2554) = i + 1;
                                break;
                            }
                        }
                    }
                }
                else
                {
                    *(_BYTE*)(i + thisx + 2600) = v88;
                    *(_BYTE*)(i + thisx + 2584) = 1;
                }
            }
            else if (v121)
            {
                sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
                *(_BYTE*)(i + thisx + 2600) = (*(unsigned __int8*)(i + thisx + 2600) + v121 + 8) % 8;
                v122 = 1;
            }
            else if (v120)
            {
                if (v120 != *(_DWORD*)(thisx + 15636))
                    sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
                *(_WORD*)(thisx + 2 * i + 2564) = (*(_DWORD*)(thisx + 15636) + v120 + *(unsigned __int16*)(thisx + 2 * i + 2564))
                    % *(_DWORD*)(thisx + 15636);
                *(_BYTE*)(i + thisx + 2600) = 7;
                v82 = *(unsigned __int16*)(thisx + 2 * i + 2564);
                v85 = 244 * v82 + *(_DWORD*)(thisx + 15628);
                v83 = thisx + 244 * i + 1392;
                lstrcpyA((LPSTR)(thisx + 244 * i + 1564), (LPCSTR)(v85 + 172));
                for (nn = 0; nn < 6; ++nn)
                {
                    if (*(int*)(v85 + 28 * nn) < 0)
                        *(_DWORD*)(v83 + 28 * nn) = -1;
                    else
                        *(_DWORD*)(v83 + 28 * nn) = -(*(_DWORD*)(v85 + 28 * nn) + 2);
                    *(_BYTE*)(v83 + 28 * nn + 4) = *(_BYTE*)(v85 + 28 * nn + 4);
                }
                if (*(__int16*)(v85 + 236) < 0)
                    *(_WORD*)(v83 + 236) = -1;
                else
                    *(_WORD*)(v83 + 236) = -(__int16)(*(_WORD*)(v85 + 236) + 2);
                if (*(__int16*)(v85 + 238) < 0)
                {
                    *(_WORD*)(v83 + 238) = i;
                    sub_476E46(i, (void*)(8 * i + 4952656));
                }
                else
                {
                    *(_WORD*)(v83 + 238) = -(__int16)(*(_WORD*)(v85 + 238) + 2);
                    sub_476E46(*(__int16*)(v85 + 238), (void*)(8 * i + 4952656));
                }
                v122 = 1;
            }
            else if (v126)
            {
                sub_46D2DE(thisx + 244 * i + 1392);
                *(_BYTE*)(i + thisx + 2584) = 0;
                *(_BYTE*)(i + thisx + 2600) = 0;
                *(_WORD*)(thisx + 2 * i + 2564) = 0;
                v122 = 1;
            }
            else if (v125)
            {
                *(_BYTE*)(i + thisx + 2596) = *(_BYTE*)(i + thisx + 2596) == 0;
                v122 = 1;
                sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
            }
        }
        if (v122)
            v133[i] = 1;
    }
    if (v127)
    {
        for (i = 0; i < 4; ++i)
        {
            v80 = thisx + 244 * i + 1392;
            v81 = *(unsigned __int8*)(i + thisx + 2584);
            if (!v81)
            {
                v18 = rand() % 2;
                v81 = 3 * v18 + 1;
                if (!(3 * v18))
                {
                    *(_BYTE*)(i + thisx + 2600) = 0;
                    *(_BYTE*)(thisx + 244 * i + 1564) = 0;
                }
            }
            if (v81 == 4)
            {
                if (byte_4B99CD)
                {
                    v79 = rand() % *(_DWORD*)(thisx + 15636);
                }
                else
                {
                    v77 = 0;
                    memset(*(void**)(thisx + 15632), 0, *(_DWORD*)(thisx + 15636));
                    for (i1 = 0; i1 < *(_DWORD*)(thisx + 15636); ++i1)
                    {
                        v76 = 244 * i1 + *(_DWORD*)(thisx + 15628);
                        if (sub_46DCBB((_DWORD*)thisx, i1, 1))
                            *(_BYTE*)(*(_DWORD*)(thisx + 15632) + i1) = 1;
                        else
                            ++v77;
                    }
                    if (v77)
                    {
                        v75 = rand() % v77;
                        v79 = -1;
                        while (v75 >= 0)
                        {
                            ++v79;
                            if (!*(_BYTE*)(*(_DWORD*)(thisx + 15632) + v79))
                                --v75;
                        }
                    }
                    else
                    {
                        *(_BYTE*)(i + thisx + 2604) = 0;
                        v79 = -1;
                    }
                }
                if (v79 < 0)
                {
                    *(_BYTE*)(i + thisx + 2600) = 0;
                    v81 = 1;
                }
                else
                {
                    v70 = v79;
                    v74 = 244 * v79 + *(_DWORD*)(thisx + 15628);
                    sub_46D2DE(v80);
                    lstrcpyA((LPSTR)(v80 + 172), (LPCSTR)(v74 + 172));
                    v69 = 0;
                    for (i2 = 0; i2 < 6; ++i2)
                    {
                        v68 = *(_DWORD*)(v74 + 28 * i2);
                        if (v68 >= 0 && (byte_4B99CD || !*((_BYTE*)dword_4B92DC + v68)))
                        {
                            *(_DWORD*)(v80 + 28 * v69) = v68;
                            *(_BYTE*)(v80 + 28 * v69 + 4) = *(_BYTE*)(v74 + 28 * i2 + 4);
                            *((_BYTE*)dword_4B92DC + v68) = 1;
                            ++v69;
                        }
                    }
                    v71 = *(__int16*)(v74 + 236);
                    if (v71 >= 0 && (byte_4B99CD || !sub_46D516((__int16*)(thisx + 1392), v71, -1)))
                        *(_WORD*)(v80 + 236) = v71;
                    v73 = *(__int16*)(v74 + 238);
                    if (v73 >= 0)
                    {
                        if (sub_46D56B((__int16*)(thisx + 1392), v73, i))
                            *(_WORD*)(v80 + 238) = -1;
                        else
                            *(_WORD*)(v80 + 238) = v73;
                    }
                    if (v69 < 6)
                    {
                        *(_BYTE*)(i + thisx + 2600) = v69;
                        v81 = 1;
                    }
                }
            }
            if (v81 == 1)
            {
                v67 = *(unsigned __int8*)(i + thisx + 2600);
                for (i3 = v67; i3 < 6; ++i3)
                {
                    v65 = sub_46D5C0((char*)thisx);
                    *(_DWORD*)(v80 + 28 * i3) = v65;
                    if (*(_BYTE*)(thisx + 98))
                    {
                        *(_BYTE*)(v80 + 28 * i3 + 4) = rand() % 4;
                    }
                    else
                    {
                        v19 = MarkedForDetachment((_BYTE*)(36 * v65 + dword_4B92E0));
                        *(_BYTE*)(v80 + 28 * i3 + 4) = v19;
                    }
                    *((_BYTE*)dword_4B92DC + v65) = 1;
                }
            }
            if (*(__int16*)(v80 + 236) < 0)
            {
                if (*(_BYTE*)(thisx + 81))
                {
                    *(_WORD*)(thisx + 2 * i + 2564) = rand() % dword_4B92D8;
                }
                else
                {
                    v61 = 0;
                    for (i4 = 0; i4 < 4; ++i4)
                    {
                        v62[i4] = *(__int16*)(thisx + 244 * i4 + 1628);
                        if (v62[i4] >= 0)
                            ++v61;
                    }
                    for (i4 = 0; i4 < 4; ++i4)
                    {
                        v60 = 3;
                        for (i5 = 2; i5 >= i4; --i5)
                        {
                            if (v62[v60] >= 0 && (v62[i5] < 0 || v62[v60] < v62[i5]))
                            {
                                v58 = v62[v60];
                                v62[v60] = v62[i5];
                                v62[i5] = v58;
                            }
                            --v60;
                        }
                    }
                    v64 = rand() % (dword_4B92D8 - v61);
                    for (i4 = 0; i4 < 4; ++i4)
                    {
                        if (v62[i4] <= v64 && v62[i4] >= 0)
                            ++v64;
                    }
                    *(_WORD*)(thisx + 2 * i + 2564) = v64;
                }
                *(_WORD*)(v80 + 236) = *(_WORD*)(thisx + 2 * i + 2564);
            }
            if (*(__int16*)(v80 + 238) < 0)
            {
                v56 = 0;
                for (i6 = 0; i6 < 4; ++i6)
                {
                    v54[i6] = *(__int16*)(thisx + 244 * i6 + 1630);
                    if (v54[i6] >= 0)
                        ++v56;
                }
                for (i6 = 0; i6 < 4; ++i6)
                {
                    v53 = 3;
                    for (i7 = 2; i7 >= i6; --i7)
                    {
                        if (v54[v53] >= 0 && (v54[i7] < 0 || v54[v53] < v54[i7]))
                        {
                            v51 = v54[v53];
                            v54[v53] = v54[i7];
                            v54[i7] = v51;
                        }
                        --v53;
                    }
                }
                v55 = rand() % (word_4B99E4 - v56);
                for (i6 = 0; i6 < 4; ++i6)
                {
                    if (v54[i6] <= v55 && v54[i6] >= 0)
                        ++v55;
                }
                *(_WORD*)(v80 + 238) = v55;
            }
            *(_BYTE*)(i + thisx + 2584) = 3;
        }
    }
    for (i = 0; i < 4; ++i)
    {
        if (v133[i] || v129)
            sub_46B8AE((_BYTE*)thisx, i);
    }
    for (i = 0; i < 4 && *(_BYTE*)(i + thisx + 2584) == 3; ++i)
        ;
    if (i != 4 || *(_BYTE*)(thisx + 2516))
    {
        sub_49C15E((int)v131);
        v131[0] = dword_4B9248;
        result = sub_49AB05((int)unk_4BDC60, v131);
        for (i = 0; ; ++i)
        {
            if (i >= 4)
                return result;
            v27 = -8;
            v26 = -8;
            result = (unsigned __int16*)thisx;
            v24 = *(_WORD*)(thisx + 2 * i + 2572);
            if (v24 && v24 < 0x64u)
            {
                wsprintfA(String, "%d>", v24);
                v28 = *(unsigned __int8*)(i + thisx + 2584);
                if (!*(_BYTE*)(i + thisx + 2584))
                {
                    result = (unsigned __int16*)sub_47B91A(
                        160 * (i / 2) + 64,
                        120 * (i % 2) + 16 * *(unsigned __int16*)(thisx + 2 * i + 2564) + 64,
                        String,
                        0,
                        -1);
                    continue;
                }
                switch (v28)
                {
                case 1:
                    result = (unsigned __int16*)sub_47B91A(160 * (i / 2) + 2, 120 * (i % 2) + 32, String, 0, -1);
                    continue;
                case 2:
                    result = (unsigned __int16*)sub_47B91A(160 * (i / 2) + 48, 120 * (i % 2) + 48, String, 0, -1);
                    continue;
                case 4:
                    if (*(_BYTE*)(i + thisx + 2600) == 7)
                    {
                        result = (unsigned __int16*)sub_47B91A(160 * (i / 2) + 16, 120 * (i % 2) + 88, String, 0, -1);
                        continue;
                    }
                    v27 = 160 * (i / 2) + 2;
                    v26 = 120 * (i % 2) + 32;
                    break;
                }
                result = (unsigned __int16*)sub_47B91A(v27, v26, String, 0, -1);
            }
        }
    }
    for (i8 = 0; i8 < 4; ++i8)
    {
        v40 = thisx + 244 * i8 + 1392;
        if (lstrlenA((LPCSTR)(thisx + 244 * i8 + 1564)) <= 0)
        {
            v20 = (char*)sub_472F91((_DWORD*)v40);
            v21 = unknown_libname_18(v20);
            lstrcpyA(String1, v21);
            v38 = rand() % 5;
            switch (v38)
            {
            case 0:
                wsprintfA(String, byte_4B3480);
                break;
            case 1:
                wsprintfA(String, byte_4B348C);
                break;
            case 2:
                wsprintfA(String, byte_4B349C);
                break;
            case 3:
                wsprintfA(String, byte_4B34A8);
                break;
            case 4:
                wsprintfA(String, byte_4B34B0);
                break;
            default:
                break;
            }
            if (!v38)
            {
                v37 = 4;
                v36 = 2;
                while (1)
                {
                    v22 = lstrlenA(String1);
                    if (v22 <= v37)
                        break;
                    v35[0] = String1[v37 - 2];
                    v35[1] = String1[v37 - 1];
                    v35[2] = 0;
                    if (lstrcmpiA(v35, byte_4B34B8)
                        && lstrcmpiA(v35, byte_4B34BC)
                        && lstrcmpiA(v35, byte_4B34C0)
                        && lstrcmpiA(v35, byte_4B34C4)
                        && lstrcmpiA(v35, byte_4B34C8)
                        && lstrcmpiA(v35, byte_4B34CC)
                        && lstrcmpiA(v35, byte_4B34D0)
                        && lstrcmpiA(v35, byte_4B34D4)
                        && lstrcmpiA(v35, byte_4B34D8)
                        && lstrcmpiA(v35, byte_4B34DC)
                        && lstrcmpiA(v35, byte_4B34E0)
                        && lstrcmpiA(v35, byte_4B34E4)
                        && lstrcmpiA(v35, byte_4B34E8)
                        && lstrcmpiA(v35, byte_4B34EC)
                        && lstrcmpiA(v35, byte_4B34F0)
                        && lstrcmpiA(v35, byte_4B34F4))
                    {
                        if (lstrcmpiA(v35, byte_4B34F8) && lstrcmpiA(v35, byte_4B34FC))
                        {
                            String1[v37] = 0;
                            break;
                        }
                        String1[v37 - 2] = -126;
                        String1[v37 - 1] = -63;
                    }
                    else
                    {
                        v37 += 2;
                    }
                }
            }
            wsprintfA((LPSTR)(v40 + 172), "%s%s", String1, String);
        }
    }
    for (i = 0; i < 4; ++i)
    {
        v49[i] = 0;
        for (i9 = i + 1; i9 < 4; ++i9)
        {
            if (!lstrcmpiA((LPCSTR)(thisx + 244 * i + 1564), (LPCSTR)(thisx + 244 * i9 + 1564)))
                ++v49[i];
        }
    }
    v41 = word_4B3508;
    v42 = byte_4B350A;
    v43 = word_4B350C;
    v44 = byte_4B350E;
    v45 = word_4B3510;
    v46 = byte_4B3512;
    v47 = word_4B3514;
    v48 = byte_4B3516;
    for (i = 0; i < 4; ++i)
    {
        if (v49[i] > 0)
        {
            lstrcpyA(v33, (LPCSTR)(thisx + 244 * i + 1564));
            v31 = 0;
            for (i10 = i; i10 < 4; ++i10)
            {
                v30 = thisx + 244 * i10 + 1392;
                if (!lstrcmpiA(v33, (LPCSTR)(thisx + 244 * i10 + 1564)))
                {
                    v29 = lstrlenA((LPCSTR)(thisx + 244 * i10 + 1564));
                    if (v29 + 3 >= 64)
                        v29 = 61;
                    *(_BYTE*)(v29 + v30 + 172) = *((_BYTE*)&v41 + 3 * v31);
                    *(_BYTE*)(v29 + v30 + 173) = *((_BYTE*)&v41 + 3 * v31 + 1);
                    *(_BYTE*)(v29 + v30 + 174) = 0;
                    v49[i10] = 0;
                    ++v31;
                }
            }
        }
    }
    result = (unsigned __int16*)thisx;
    *(_DWORD*)(thisx + 108) = 21;
    *(_BYTE*)(thisx + 2516) = 2;
    return result;
}

 
void sub_46B8AE(_BYTE* thisx, int a2)
{
    int v2; // edx
    int v3; // eax
    int v4; // edx
    int v5; // eax
    int v6; // edx
    char* v7; // eax
    char* v8; // eax
    const CHAR* v9; // eax
    int v10; // eax
    int v11; // eax
    int v12; // edx
    int v13; // eax
    int v14; // [esp-4h] [ebp-228h]
    int v15; // [esp-4h] [ebp-228h]
    int v16; // [esp-4h] [ebp-228h]
    int v17; // [esp-4h] [ebp-228h]
    int v18; // [esp-4h] [ebp-228h]
    int v19; // [esp-4h] [ebp-228h]
    int v20; // [esp-4h] [ebp-228h]
    int v21; // [esp-4h] [ebp-228h]
    int v23; // [esp+8h] [ebp-21Ch]
    _WORD* v24; // [esp+Ch] [ebp-218h]
    int v25; // [esp+10h] [ebp-214h]
    int v26; // [esp+14h] [ebp-210h]
    int v27; // [esp+1Ch] [ebp-208h]
    int v28; // [esp+20h] [ebp-204h]
    int v29; // [esp+24h] [ebp-200h]
    int v30; // [esp+28h] [ebp-1FCh]
    int v31; // [esp+2Ch] [ebp-1F8h]
    int v32; // [esp+38h] [ebp-1ECh]
    int v33; // [esp+3Ch] [ebp-1E8h]
    int v34; // [esp+40h] [ebp-1E4h]
    CHAR v35[64]; // [esp+44h] [ebp-1E0h] BYREF
    int v36; // [esp+84h] [ebp-1A0h]
    int v37; // [esp+88h] [ebp-19Ch]
    int m; // [esp+8Ch] [ebp-198h]
    char* v39; // [esp+90h] [ebp-194h]
    int v40; // [esp+94h] [ebp-190h]
    int v41; // [esp+98h] [ebp-18Ch]
    int n; // [esp+9Ch] [ebp-188h]
    int v43; // [esp+A0h] [ebp-184h]
    int v44; // [esp+A4h] [ebp-180h]
    int ii; // [esp+A8h] [ebp-17Ch]
    int v46; // [esp+ACh] [ebp-178h]
    int v47; // [esp+B0h] [ebp-174h]
    int v48; // [esp+B4h] [ebp-170h]
    int v49; // [esp+B8h] [ebp-16Ch]
    int v50; // [esp+BCh] [ebp-168h]
    int v51; // [esp+C0h] [ebp-164h]
    int v52; // [esp+C4h] [ebp-160h]
    int v53; // [esp+C8h] [ebp-15Ch]
    int v54; // [esp+CCh] [ebp-158h]
    int v55; // [esp+D0h] [ebp-154h]
    CHAR v56[4]; // [esp+D4h] [ebp-150h] BYREF
    char v57; // [esp+D8h] [ebp-14Ch]
    int v58; // [esp+D9h] [ebp-14Bh]
    int v59; // [esp+DDh] [ebp-147h]
    int v60; // [esp+E1h] [ebp-143h]
    char v61; // [esp+E5h] [ebp-13Fh]
    int v62; // [esp+E6h] [ebp-13Eh]
    __int16 v63; // [esp+EAh] [ebp-13Ah]
    char v64; // [esp+ECh] [ebp-138h]
    __int16 v65; // [esp+EDh] [ebp-137h]
    int v66; // [esp+EFh] [ebp-135h]
    int v67; // [esp+F3h] [ebp-131h]
    char v68; // [esp+F7h] [ebp-12Dh]
    int v69; // [esp+F8h] [ebp-12Ch]
    char v70; // [esp+FCh] [ebp-128h]
    int v71; // [esp+FDh] [ebp-127h]
    int v72; // [esp+101h] [ebp-123h]
    int v73; // [esp+105h] [ebp-11Fh]
    char v74; // [esp+109h] [ebp-11Bh]
    int v75; // [esp+10Ah] [ebp-11Ah]
    int v76; // [esp+10Eh] [ebp-116h]
    char v77; // [esp+112h] [ebp-112h]
    int v78; // [esp+113h] [ebp-111h]
    int v79; // [esp+117h] [ebp-10Dh]
    char v80; // [esp+11Bh] [ebp-109h]
    int v81; // [esp+11Ch] [ebp-108h]
    char v82; // [esp+120h] [ebp-104h]
    int v83; // [esp+121h] [ebp-103h]
    int v84; // [esp+125h] [ebp-FFh]
    int v85; // [esp+129h] [ebp-FBh]
    char v86; // [esp+12Dh] [ebp-F7h]
    unsigned __int16* v87; // [esp+130h] [ebp-F4h]
    int v88; // [esp+134h] [ebp-F0h]
    int v89; // [esp+138h] [ebp-ECh]
    char* v90; // [esp+13Ch] [ebp-E8h]
    CHAR String[32]; // [esp+140h] [ebp-E4h] BYREF
    int v92; // [esp+160h] [ebp-C4h]
    int v93; // [esp+164h] [ebp-C0h]
    int v94; // [esp+168h] [ebp-BCh]
    int yTop; // [esp+16Ch] [ebp-B8h]
    int v96; // [esp+170h] [ebp-B4h]
    int xLeft; // [esp+174h] [ebp-B0h]
    int v98; // [esp+178h] [ebp-ACh]
    int jj; // [esp+17Ch] [ebp-A8h]
    int v100; // [esp+180h] [ebp-A4h]
    struct tagRECT rc; // [esp+184h] [ebp-A0h] BYREF
    int v102; // [esp+194h] [ebp-90h] BYREF
    int v103; // [esp+198h] [ebp-8Ch]
    int v104; // [esp+19Ch] [ebp-88h]
    int v105; // [esp+1ACh] [ebp-78h]
    int v106; // [esp+1CCh] [ebp-58h]
    int j; // [esp+1D0h] [ebp-54h]
    int k; // [esp+1D4h] [ebp-50h]
    int i; // [esp+1D8h] [ebp-4Ch]
    int v110; // [esp+1ECh] [ebp-38h] BYREF
    int v111; // [esp+1F0h] [ebp-34h]
    int v112; // [esp+1F4h] [ebp-30h]

    if (a2 == -1)
    {
        sub_49C15E((int)&v110);
        v110 = dword_4B91F8;
        for (i = 0; i < 31; ++i)
        {
            v111 = 8 * ((i + 1) % 5) - 40;
            v112 = 8 * i - 4;
            for (j = 0; j < 9; ++j)
            {
                sub_49CC5B((short*)unk_4BDC60, dword_4B9248, &v110);
                v111 += 40;
            }
        }
        for (k = 0; k < 4; ++k)
            sub_46B8AE(thisx, k);
    }
    else
    {
        xLeft = 160 * (a2 / 2) + 4;
        yTop = 120 * (a2 % 2) + 4;
        SetRect(&rc, xLeft, yTop, 160 * (a2 / 2) + 125, 120 * (a2 % 2) + 23);
        sub_4A02E9((_DWORD*)unk_4BDC60, dword_4B9248, (int)&rc, 0, dword_4B9248);
        SetRect(&rc, 160 * (a2 / 2) + 135, yTop, 160 * (a2 / 2) + 156, 120 * (a2 % 2) + 23);
        sub_4A02E9((_DWORD*)unk_4BDC60, v2, (int)&rc, 0, dword_4B9248);
        SetRect(&rc, xLeft, 120 * (a2 % 2) + 28, 160 * (a2 / 2) + 156, 120 * (a2 % 2) + 116);
        sub_4A02E9((_DWORD*)unk_4BDC60, (int)&rc, (int)&rc, 0, dword_4B9248);
        sub_49C15E((int)&v102);
        v100 = (unsigned __int8)thisx[a2 + 2584];
        v96 = (unsigned __int8)thisx[a2 + 2600];
        v106 = 20 * v96 + xLeft;
        if (v96 == 6)
            v106 += 11;
        if (v100 != 3 && v96 <= 6)
        {
            SetRect(&rc, v106, yTop, v106 + 21, yTop + 19);
            v14 = dword_4B9248;
            v3 = sub_49FFEC(255, 255, 255);
            sub_4A02E9((_DWORD*)unk_4BDC60, v4, (int)&rc, v3, v14);
            SetRect(&rc, v106 + 1, yTop + 1, v106 + 20, yTop + 18);
            sub_4A02E9((_DWORD*)unk_4BDC60, (int)&rc, (int)&rc, 0, dword_4B9248);
        }
        if (v100)
        {
            switch (v100)
            {
            case 1:
            case 4:
                v94 = *(unsigned __int16*)&thisx[2 * a2 + 2564];
                if (v100 == 4 && v96 <= 6)
                {
                    if (v96 >= 6)
                        v94 = -(*(__int16*)&thisx[244 * a2 + 1628] + 2);
                    else
                        v94 = -(*(_DWORD*)&thisx[244 * a2 + 1392 + 28 * v96] + 2);
                }
                if (v94 >= 0 || v96 == 7)
                {
                    v106 = xLeft + 2;
                    v93 = yTop + 46;
                    if (v96 <= 6)
                    {
                        SetRect(&rc, v106, v93, v106 + 28, v93 + 40);
                        v15 = dword_4B9248;
                        v5 = sub_49FFEC(198, 113, 0);
                        sub_4A02E9((_DWORD*)unk_4BDC60, v6, (int)&rc, v5, v15);
                    }
                    v106 += 2;
                    v93 += 6;
                    if (v96 >= 6)
                    {
                        if (v96 == 6)
                        {
                            v39 = (char*)(84 * v94 + dword_4B92D4);
                            v103 = v106 + 4;
                            v104 = v93 + 8;
                            v102 = dword_4B91E0 + 1;
                            SetRect(&rc, 0, 0, 16, 24);
                            sub_4A03B3((short*)unk_4BDC60, dword_4B9248, &v102, (_DWORD*)&rc);
                            v103 = v106 - 4;
                            v104 = v93;
                            v102 = dword_4B91E0;
                            v37 = (unsigned __int16)sub_475CB0((short*)v39);
                            SetRect(&rc, 0, 16 * v37, 32, 16);
                            sub_4A03B3((short*)unk_4BDC60, dword_4B9248, &v102, (_DWORD*)&rc);
                            v103 = v106 - 2;
                            v104 = v93 + 12;
                            v102 = dword_4B91E0 + 1;
                            SetRect(&rc, 16 * a2 + 18, 0, 14, 16);
                            sub_4A03B3((short*)unk_4BDC60, dword_4B9248, &v102, (_DWORD*)&rc);
                            v103 = v106 + 17;
                            v104 = v93 + 12;
                            v102 = dword_4B91E0 + 1;
                            SetRect(&rc, 16 * a2 + 24, 0, 8, 16);
                            sub_4A03B3((short*)unk_4BDC60, dword_4B9248, &v102, (_DWORD*)&rc);
                            if (!thisx[81] && sub_46D516((__int16*)thisx + 696, v94, -1))
                            {
                                v103 = v106;
                                v104 = v93 + 4;
                                v102 = dword_4B91E0 + 1;
                                SetRect(&rc, 16, 24, 24, 24);
                                sub_4A03B3((short*)unk_4BDC60, dword_4B9248, &v102, (_DWORD*)&rc);
                            }
                            v106 = xLeft + 8;
                            v17 = dword_4B9248;
                            v8 = unknown_libname_18(v39);
                            sub_47B91A(v106, yTop + 28, v8, 0, v17);
                            sub_47B91A(v106 + 56, yTop + 28, byte_4B35C0, 0, dword_4B9248);
                            v106 = xLeft + 32;
                            v93 = yTop + 44;
                            for (m = 0; m < 5; ++m)
                            {
                                if (sub_475CD0((_DWORD*)v39, m))
                                {
                                    v18 = dword_4B9248;
                                    v9 = (const CHAR*)sub_475CD0((_DWORD*)v39, m);
                                    sub_47B91A(v106, v93, v9, 0, v18);
                                }
                                v93 += 14;
                            }
                        }
                        else if (v96 == 7)
                        {
                            v106 = xLeft + 8;
                            sub_47B91A(xLeft + 8, yTop + 32, byte_4B35D0, 0, dword_4B9248);
                            sub_47B91A(v106, yTop + 48, asc_4B35F0, 0, dword_4B9248);
                            sub_47B91A(v106, yTop + 64, asc_4B3608, 0, dword_4B9248);
                            v93 = yTop + 80;
                            sub_47B91A(v106 + 16, yTop + 84, &thisx[244 * a2 + 1564], 0, dword_4B9248);
                        }
                    }
                    else
                    {
                        v103 = v106 + 4;
                        v104 = v93;
                        sub_47900E(&v102, 1, v94, dword_4B9248);
                        v103 = v106;
                        v104 = v93 + 8;
                        v88 = a2;
                        v89 = (unsigned __int8)sub_401710((_BYTE*)(36 * v94 + dword_4B92E0));
                        v87 = (unsigned short*)word_4B9290;
                        sub_4A1307((int)word_4B9290, (Concurrency::details::HardwareAffinity*)(8 * a2 + 4952656));
                        sub_485E5A((int)dword_4B93A4 + 24 * v89, (unsigned short*)word_4B9290);
                        v92 = (unsigned __int8)thisx[a2 + 2580];
                        if (v100 == 4)
                            v92 = (char)thisx[244 * a2 + 1396 + 28 * v96];
                        SetRect(&rc, 24 * v92, 0, 24, 24);
                        v102 = dword_4B9234;
                        sub_4A03B3((short*)unk_4BDC60, dword_4B9248, &v102, (_DWORD*)&rc);
                        if (!thisx[81] && *((_BYTE*)dword_4B92DC + v94))
                        {
                            v103 = v106;
                            v104 = v93 + 4;
                            v102 = dword_4B91E0 + 1;
                            SetRect(&rc, 16, 24, 24, 24);
                            sub_4A03B3((short*)unk_4BDC60, dword_4B9248, &v102, (_DWORD*)&rc);
                        }
                        v106 = xLeft + 8;
                        v93 = yTop + 28;
                        v90 = (char*)(36 * v94 + dword_4B92E0);
                        v16 = dword_4B9248;
                        v7 = unknown_libname_18(v90);
                        sub_47B91A(v106, yTop + 28, v7, 0, v16);
                        v106 += 56;
                        sub_47B91A(v106, yTop + 28, (LPCSTR)&byte_4B4664[18 * v92], 0, dword_4B9248);
                        if (thisx[a2 + 2596])
                        {
                            for (n = 0; n < 3; ++n)
                            {
                                v41 = (unsigned __int8)sub_4266B0(v90, n);
                                if (thisx[a2 + 13092])
                                {
                                    if (n)
                                        break;
                                    v41 = (unsigned __int8)sub_4266B0(v90, (unsigned __int8)thisx[a2 + 13092] - 1);
                                }
                                if (v41 >= 73)
                                {
                                    v41 -= 128;
                                    if (v41 >= 13)
                                        sub_47B91A(xLeft + 32, yTop + 16 * n + 44, byte_4B35B4, 0, dword_4B9248);
                                    else
                                        sub_47B91A(xLeft + 32, yTop + 16 * n + 44, (LPCSTR)&byte_4B4E74[21 * v41], 0, dword_4B9248);
                                }
                                else
                                {
                                    sub_47B91A(xLeft + 32, yTop + 16 * n + 44, (LPCSTR)&byte_4B46C0[27 * v41], 0, dword_4B9248);
                                }
                            }
                            if (thisx[a2 + 13092])
                            {
                                v40 = (unsigned __int8)sub_4266B0(v90, (unsigned __int8)thisx[a2 + 13092] - 1);
                                sub_47BD8E(xLeft + 32, yTop + 60, v40, dword_4B9248);
                            }
                        }
                        else
                        {
                            *(_DWORD*)v56 = dword_4B3548;
                            v57 = byte_4B354C;
                            v58 = 0;
                            v59 = dword_4B3550;
                            v60 = dword_4B3554;
                            v61 = byte_4B3558;
                            v62 = dword_4B355C;
                            v63 = word_4B3560;
                            v64 = byte_4B3562;
                            v65 = 0;
                            v66 = dword_4B3564;
                            v67 = dword_4B3568;
                            v68 = byte_4B356C;
                            v69 = dword_4B3570;
                            v70 = byte_4B3574;
                            v71 = 0;
                            v72 = dword_4B3578;
                            v73 = dword_4B357C;
                            v74 = byte_4B3580;
                            v75 = dword_4B3584;
                            v76 = dword_4B3588;
                            v77 = byte_4B358C;
                            v78 = dword_4B3590;
                            v79 = dword_4B3594;
                            v80 = byte_4B3598;
                            v81 = dword_4B359C;
                            v82 = byte_4B35A0;
                            v83 = 0;
                            v84 = dword_4B35A4;
                            v85 = dword_4B35A8;
                            v86 = byte_4B35AC;
                            v46 = (unsigned __int8)sub_4265B0(v90);
                            v47 = (unsigned __int8)sub_4265D0(v90);
                            v48 = (unsigned __int8)sub_426570(v90);
                            v49 = (unsigned __int8)sub_4265F0(v90);
                            v50 = (unsigned __int8)sub_426610(v90);
                            v51 = (unsigned __int8)sub_426550(v90);
                            v52 = (unsigned __int8)sub_426670(v90);
                            v53 = (unsigned __int8)sub_426630(v90);
                            v54 = (unsigned __int8)sub_426650(v90);
                            v55 = (unsigned __int8)sub_426690(v90);
                            switch (v92)
                            {
                            case 0:
                                v47 += 5;
                                v48 += 5;
                                v49 += 5;
                                break;
                            case 1:
                                v48 += 15;
                                break;
                            case 2:
                                v47 += 15;
                                break;
                            case 3:
                                v49 += 15;
                                break;
                            default:
                                break;
                            }
                            v106 = xLeft + 32;
                            v93 = yTop + 44;
                            for (ii = 0; ii < 10; ++ii)
                            {
                                v44 = ((ii % 2) << 6) + v106;
                                v43 = 14 * (ii / 2) + v93;
                                sub_47B91A(v44, v43, &v56[9 * ii], 0, dword_4B9248);
                                wsprintfA(String, "%3d", *(&v46 + ii));
                                sub_47B7ED(v44 + 32, v43, String, 0, dword_4B9248);
                            }
                        }
                    }
                }
                break;
            case 2:
                v106 = xLeft + 2;
                SetRect(&rc, xLeft + 2, yTop + 46, xLeft + 30, yTop + 86);
                v19 = dword_4B9248;
                v10 = sub_49FFEC(198, 113, 0);
                sub_4A02E9((_DWORD*)unk_4BDC60, (int)&rc, (int)&rc, v10, v19);
                v106 += 2;
                v33 = *(_DWORD*)&thisx[244 * a2 + 1392 + 28 * v96];
                v103 = v106 + 4;
                v104 = yTop + 52;
                sub_47900E(&v102, 1, v33, dword_4B9248);
                v103 = v106;
                v104 = yTop + 60;
                v32 = (unsigned __int8)sub_401710((_BYTE*)(36 * v33 + dword_4B92E0));
                sub_4A1307((int)word_4B9290, (Concurrency::details::HardwareAffinity*)(8 * a2 + 4952656));
                sub_485E5A((int)dword_4B93A4 + 24 * v32, (unsigned short*)word_4B9290);
                v36 = (char)thisx[244 * a2 + 1396 + 28 * v96];
                SetRect(&rc, 24 * v36, 0, 24, 24);
                v102 = dword_4B9234;
                sub_4A03B3((short*)unk_4BDC60, dword_4B9248, &v102, (_DWORD*)&rc);
                v106 = xLeft + 8;
                v34 = yTop + 28;
                sub_47B91A(xLeft + 8, yTop + 28, byte_4B362C, 0, dword_4B9248);
                wsprintfA(v35, "%2d/%2d", *(unsigned __int16*)&thisx[2 * a2 + 2564] + 1, word_4B99E4);
                sub_47B7ED(v106 + 48, v34 + 16, v35, 0, dword_4B9248);
                if (sub_46D56B((__int16*)thisx + 696, *(unsigned __int16*)&thisx[2 * a2 + 2564], a2))
                {
                    sub_47B91A(v106 + 32, v34 + 32, byte_4B3654, 0, dword_4B9248);
                    sub_47B91A(v106 + 32, v34 + 48, byte_4B366C, 0, dword_4B9248);
                }
                break;
            case 3:
                v106 = xLeft + 36;
                sub_47B91A(xLeft + 36, yTop + 52, byte_4B3680, 0, dword_4B9248);
                sub_47B91A(v106, yTop + 68, byte_4B3698, 0, dword_4B9248);
                break;
            }
        }
        else
        {
            sub_47B91A(xLeft + 24, yTop + 44, byte_4B351C, 0, dword_4B9248);
            sub_47B91A(xLeft + 72, yTop + 60, byte_4B3538, 0, dword_4B9248);
            sub_47B91A(xLeft + 72, yTop + 76, byte_4B3540, 0, dword_4B9248);
        }
        for (jj = 0; jj < 6; ++jj)
        {
            v28 = *(_DWORD*)&thisx[244 * a2 + 1392 + 28 * jj];
            v30 = (char)thisx[244 * a2 + 1396 + 28 * jj];
            if (v28 < -1)
                v28 = -(v28 + 2);
            if (v28 >= 0 && v28 < (int)Size && v30 >= 0)
            {
                v31 = xLeft + 20 * jj + 1;
                v29 = yTop + 1;
                SetRect(&rc, v31, yTop + 1, xLeft + 20 * jj + 20, yTop + 18);
                v20 = dword_4B9248;
                v11 = sub_49FFEC(198, 113, 0);
                sub_4A02E9((_DWORD*)unk_4BDC60, v12, (int)&rc, v11, v20);
                v103 = v31 + 3;
                v104 = v29 + 1;
                sub_47900E(&v102, 1, v28, dword_4B9248);
                v103 = v31;
                v104 = v29 + 9;
                v27 = (unsigned __int8)sub_401710((_BYTE*)(36 * v28 + dword_4B92E0));
                sub_4A1307((int)word_4B9290, (Concurrency::details::HardwareAffinity*)(8 * a2 + 4952656));
                sub_485E5A((int)dword_4B93A4 + 24 * v27, (unsigned short*)word_4B9290);
                SetRect(&rc, 24 * v30 + 1, 0, 19, 8);
                v102 = dword_4B9234;
                sub_4A03B3((short*)unk_4BDC60, dword_4B9248, &v102, (_DWORD*)&rc);
                if (!thisx[81])
                {
                    if (sub_46D48E((_DWORD*)thisx + 348, v28, a2, jj))
                    {
                        v103 = v31 + 1;
                        v104 = v29 + 1;
                        v102 = dword_4B91E0 + 1;
                        SetRect(&rc, 0, 24, 16, 16);
                        sub_4A03B3((short*)unk_4BDC60, dword_4B9248, &v102, (_DWORD*)&rc);
                    }
                }
            }
        }
        v98 = *(__int16*)&thisx[244 * a2 + 1628];
        if (v98 < -1)
            v98 = -(v98 + 2);
        if (v98 >= 0)
        {
            v24 = (_WORD*)(84 * v98 + dword_4B92D4);
            v26 = xLeft + 132;
            v25 = yTop + 1;
            SetRect(&rc, xLeft + 132, yTop + 1, xLeft + 151, yTop + 18);
            v21 = dword_4B9248;
            v13 = sub_49FFEC(198, 113, 0);
            sub_4A02E9((_DWORD*)unk_4BDC60, (int)&rc, (int)&rc, v13, v21);
            v103 = v26 + 1;
            v104 = v25 + 8;
            v105 = 1;
            v102 = dword_4B91E0 + 1;
            SetRect(&rc, 0, 0, 16, 9);
            sub_4A03B3((short*)unk_4BDC60, dword_4B9248, &v102, (_DWORD*)&rc);
            v103 = v26;
            v104 = v25;
            v105 = 1;
            v102 = dword_4B91E0;
            v23 = (unsigned __int16)sub_475CB0(v24);
            SetRect(&rc, 6, 16 * v23, 19, 16);
            sub_4A03B3((short*)unk_4BDC60, dword_4B9248, &v102, (_DWORD*)&rc);
            if (!thisx[81])
            {
                if (sub_46D516((__int16*)thisx + 696, v98, a2))
                {
                    v103 = v26 + 1;
                    v104 = v25 + 1;
                    v102 = dword_4B91E0 + 1;
                    SetRect(&rc, 0, 24, 16, 16);
                    sub_4A03B3((short*)unk_4BDC60, dword_4B9248, &v102, (_DWORD*)&rc);
                }
            }
        }
    }
}

 
_BYTE* sub_46D26F(_BYTE* thisx)
{
    _BYTE* result; // eax

    thisx[11] = 0;
    thisx[10] = 0;
    thisx[4] = 0;
    *(_DWORD*)thisx = -1;
    *((_WORD*)thisx + 4) = 0;
    *((_WORD*)thisx + 3) = 0;
    *((_DWORD*)thisx + 3) = 0;
    *((_DWORD*)thisx + 4) = 0;
    thisx[20] = 0;
    result = thisx;
    thisx[26] = 0;
    *((_WORD*)thisx + 11) = 0;
    *((_WORD*)thisx + 12) = 0;
    return result;
}

 
int sub_46D2DE(int thisx)
{
    int result; // eax
    int i; // [esp+4h] [ebp-4h]

    for (i = 0; i < 6; ++i)
    {
        sub_46D26F((_BYTE*)(thisx + 28 * i));
        *(_DWORD*)(thisx + 28 * i + 12) = thisx;
    }
    memset((void*)(thisx + 172), 0, 0x40u);
    *(_BYTE*)(thisx + 240) = -1;
    *(_BYTE*)(thisx + 241) = -1;
    *(_DWORD*)(thisx + 168) = 0;
    *(_WORD*)(thisx + 236) = -1;
    *(_WORD*)(thisx + 238) = -1;
    result = thisx;
    *(_BYTE*)(thisx + 242) = 0;
    *(_BYTE*)(thisx + 243) = 0;
    return result;
}

 
void* sub_46D387(_BYTE* thisx)
{
    int i; // [esp+4h] [ebp-4h]

    for (i = 0; i < 4; ++i)
        sub_46D2DE((int)&thisx[244 * i]);
    thisx[1084] = 0;
    return memset(thisx + 1086, 0, 9u);
}

 
BOOL sub_46D3E1()
{
    int v1; // [esp+4h] [ebp-3Ch] BYREF
    int v2; // [esp+8h] [ebp-38h]
    int v3; // [esp+Ch] [ebp-34h]
    int v4; // [esp+10h] [ebp-30h]
    int v5; // [esp+14h] [ebp-2Ch]
    int v6; // [esp+28h] [ebp-18h]

    sub_49DB90(&v1);
    v2 = 0;
    v3 = 0;
    v4 = -1;
    v5 = -1;
    v1 = -1;
    v6 = 0;
    if (!sub_49DA45((_DWORD*)unk_4BDC60, aGraphicCheergi, (int)&v1))
        return 0;
    dword_4B91E0 = v1;
    v2 = 0;
    v3 = 0;
    v4 = -1;
    v5 = -1;
    v1 = -1;
    v6 = 0;
    return sub_49DA45((_DWORD*)unk_4BDC60, aGraphicCheergi_0, (int)&v1) != 0;
}

 
int sub_46D48E(_DWORD* thisx, int a2, int a3, int a4)
{
    int v5; // [esp+4h] [ebp-Ch]
    int j; // [esp+8h] [ebp-8h]
    int i; // [esp+Ch] [ebp-4h]

    for (i = 0; i < 4; ++i)
    {
        for (j = 0; j < 6; ++j)
        {
            v5 = thisx[61 * i + 7 * j];
            if (v5 == -1)
                break;
            if ((a3 != i || a4 != j) && a2 == v5)
                return 1;
        }
    }
    return 0;
}

 
int sub_46D516(__int16* thisx, int a2, int a3)
{
    int i; // [esp+4h] [ebp-4h]

    for (i = 0; i < 4; ++i)
    {
        if (i != a3 && a2 == thisx[122 * i + 118])
            return 1;
    }
    return 0;
}

 
int sub_46D56B(__int16* thisx, int a2, int a3)
{
    int i; // [esp+4h] [ebp-4h]

    for (i = 0; i < 4; ++i)
    {
        if (i != a3 && a2 == thisx[122 * i + 119])
            return 1;
    }
    return 0;
}

 
int sub_46D5C0(_BYTE* thisx)
{
    int j; // [esp+4h] [ebp-10h]
    int v3; // [esp+8h] [ebp-Ch]
    int i; // [esp+Ch] [ebp-8h]
    signed int k; // [esp+Ch] [ebp-8h]
    int v6; // [esp+10h] [ebp-4h]

    if (thisx[81])
        return rand() % (int)Size;
    v3 = 0;
    for (i = 0; i < 4; ++i)
    {
        for (j = 0; j < 6 && *(int*)&thisx[244 * i + 1392 + 28 * j] >= 0; ++j)
            ++v3;
    }
    v6 = rand() % (int)(Size - v3);
    for (k = 0; k < (int)Size; ++k)
    {
        if (*((_BYTE*)dword_4B92DC + k))
        {
            if (--v3 <= 0)
            {
                k += v6 + 1;
                return k;
            }
        }
        else if (--v6 < 0)
        {
            return k;
        }
    }
    return k;
}

 
int sub_46D6CB(int thisx)
{
    int result; // eax

    if (*(_DWORD*)(thisx + 15628))
        operator delete(*(void**)(thisx + 15628));
    *(_DWORD*)(thisx + 15628) = 0;
    if (*(_DWORD*)(thisx + 15632))
        operator delete(*(void**)(thisx + 15632));
    result = thisx;
    *(_DWORD*)(thisx + 15632) = 0;
    *(_DWORD*)(thisx + 15636) = 0;
    return result;
}

 
void sub_46D747(int thisx)
{
    char* v1; // eax
    char* v2; // eax
    signed int j; // [esp+10h] [ebp-438h]
    char v5; // [esp+14h] [ebp-434h]
    int i; // [esp+1Ch] [ebp-42Ch]
    int v7; // [esp+20h] [ebp-428h]
    int v8[4]; // [esp+24h] [ebp-424h] BYREF
    int v9; // [esp+34h] [ebp-414h]
    CHAR String1[1024]; // [esp+38h] [ebp-410h] BYREF
    int v11; // [esp+438h] [ebp-10h]
    int v12; // [esp+444h] [ebp-4h]

    sub_46D6CB(thisx);
    sub_482BF0(v8);
    v12 = 0;
    if (sub_482C74((int)v8, aKkTeamTxt))
    {
        LOBYTE(v11) = 0;
        while (sub_482D44(v8, String1))
        {
            if (lstrcmpiA(String1, aStart_4))
            {
                if (!lstrcmpiA(String1, aEnd_0))
                    break;
                if ((unsigned __int8)v11 == 1)
                {
                    ++* (_DWORD*)(thisx + 15636);
                    sub_482FAA(v8);
                }
            }
            else
            {
                LOBYTE(v11) = 1;
                *(_DWORD*)(thisx + 15636) = 0;
                sub_482FAA(v8);
            }
        }
        if (*(_DWORD*)(thisx + 15628))
            operator delete(*(void**)(thisx + 15628));
        *(_DWORD*)(thisx + 15628) = (_DWORD)operator new(244 * *(_DWORD*)(thisx + 15636));
        *(_DWORD*)(thisx + 15632) = (_DWORD)operator new(*(_DWORD*)(thisx + 15636));
        memset(*(void**)(thisx + 15632), 0, *(_DWORD*)(thisx + 15636));
        sub_48314A(v8);
        while (sub_482D44(v8, String1))
        {
            if (!lstrcmpiA(String1, aStart_5))
            {
                sub_482FAA(v8);
                break;
            }
            if (!lstrcmpiA(String1, aEnd_1))
                break;
            sub_482FAA(v8);
        }
        v9 = 0;
    LABEL_21:
        if (v9 < *(_DWORD*)(thisx + 15636))
        {
            v7 = 244 * v9 + *(_DWORD*)(thisx + 15628);
            sub_46D2DE(v7);
            LOBYTE(v11) = 0;
            while (sub_482D44(v8, String1))
            {
                if (String1[0] == 110 && !String1[1])
                    goto LABEL_20;
                LOBYTE(v11) = v11 + 1;
                switch ((unsigned __int8)v11)
                {
                case 1u:
                    *(_WORD*)(v7 + 238) = sub_48307F(String1) - 1;
                    if (word_4B99E4 <= *(__int16*)(v7 + 238))
                        *(_WORD*)(v7 + 238) = -1;
                    break;
                case 2u:
                    for (i = 0; i < dword_4B92D8; ++i)
                    {
                        v1 = unknown_libname_18((char*)(84 * i + dword_4B92D4));
                        if (!lstrcmpiA(String1, v1))
                            break;
                    }
                    if (i == dword_4B92D8)
                        LOWORD(i) = -1;
                    *(_WORD*)(v7 + 236) = i;
                    break;
                case 3u:
                    if (lstrlenA(String1) >= 64)
                        String1[63] = 0;
                    lstrcpyA((LPSTR)(v7 + 172), String1);
                    break;
                default:
                    if ((unsigned __int8)v11 >= 4u)
                    {
                        if ((unsigned __int8)v11 - 4 >= 6)
                        {
                            sub_482FAA(v8);
                        LABEL_20:
                            ++v9;
                            goto LABEL_21;
                        }
                        v5 = -1;
                        for (j = 0; j < (int)Size; ++j)
                        {
                            v2 = unknown_libname_18((char*)(dword_4B92E0 + 36 * j));
                            if (!lstrcmpiA(String1, v2))
                            {
                                v5 = MarkedForDetachment((_BYTE*)(dword_4B92E0 + 36 * j));
                                break;
                            }
                        }
                        if (j == Size)
                            j = -1;
                        *(_DWORD*)(v7 + 28 * ((unsigned __int8)v11 - 4)) = j;
                        *(_BYTE*)(v7 + 28 * ((unsigned __int8)v11 - 4) + 4) = v5;
                    }
                    break;
                }
            }
        }
    }
    v12 = -1;
    sub_482C2F(v8);
}

 
BOOL sub_46DCBB(_DWORD* thisx, int a2, int a3)
{
    int v4; // [esp+4h] [ebp-Ch]
    int i; // [esp+8h] [ebp-8h]

    for (i = 0; i < 6; ++i)
    {
        v4 = *(_DWORD*)(244 * a2 + thisx[3907] + 28 * i);
        if (v4 >= 0)
        {
            if (*((_BYTE*)dword_4B92DC + v4))
            {
                if (a3)
                    return 1;
            }
            else if (!a3)
            {
                return 0;
            }
        }
        else if (!a3)
        {
            return 0;
        }
    }
    return a3 == 0;
}

 
int sub_46DD55(int a1, double a2, double a3, double a4)
{
    int v6; // [esp+Ch] [ebp-50Ch]
    int k; // [esp+18h] [ebp-500h]
    DWORD NumberOfBytesRead; // [esp+1Ch] [ebp-4FCh] BYREF
    _DWORD Buffer[256]; // [esp+20h] [ebp-4F8h] BYREF
    HANDLE hFile; // [esp+420h] [ebp-F8h]
    CHAR FileName[64]; // [esp+424h] [ebp-F4h] BYREF
    int v12[15]; // [esp+464h] [ebp-B4h] BYREF
    char v13[28]; // [esp+4A0h] [ebp-78h] BYREF
    int v14; // [esp+4BCh] [ebp-5Ch]
    int v15; // [esp+4C0h] [ebp-58h]
    int v16; // [esp+4C4h] [ebp-54h]
    int j; // [esp+4C8h] [ebp-50h]
    int m; // [esp+4CCh] [ebp-4Ch]
    int i; // [esp+4D0h] [ebp-48h]
    int v20; // [esp+4D4h] [ebp-44h]
    CHAR v21[64]; // [esp+4D8h] [ebp-40h] BYREF

    *(_DWORD*)(a1 + 104) = 23;
    *(_DWORD*)(a1 + 2540) = 0;
    *(_BYTE*)(a1 + 2516) = 1;
    *(_BYTE*)(a1 + 2562) = 0;
    *(_DWORD*)(a1 + 2528) = 0;
    memset((void*)(a1 + 2620), 0, 8u);
    memset((void*)(a1 + 2564), 0, 0x10u);
    memset((void*)(a1 + 2580), 0, 8u);
    memset((void*)(a1 + 2612), 0, 8u);
    memset((void*)(a1 + 2588), 0, 8u);
    memset((void*)(a1 + 13092), 0, 8u);
    for (i = 0; i < 4; ++i)
    {
        *(_BYTE*)(i + a1 + 2616) = byte_4B9988[(*(_DWORD*)(a1 + 2368) + 1) * i] + 1;
        if (*(unsigned __int8*)(i + a1 + 2616) > (int)(unsigned __int8)byte_4B9986)
            *(_BYTE*)(i + a1 + 2616) = 0;
    }
    for (i = 0; i < 4; ++i)
    {
        v16 = a1 + 244 * i + 1392;
        v15 = *(_DWORD*)(a1 + 244 * i + 1560);
        *(_BYTE*)(a1 + 244 * i + 1634) = 1;
        for (j = 0; j < 4; ++j)
        {
            v14 = a1 + 244 * j + 1392;
            if (v15 < *(_DWORD*)(a1 + 244 * j + 1560))
                ++* (_BYTE*)(v16 + 242);
        }
    }
    for (i = 0; i < 4; ++i)
        sub_470596((void*)(a1 + 244 * i + 1392), *(unsigned __int8*)(a1 + 2476) == 0, *(_DWORD*)(a1 + 2368));
    for (i = 0; i < 8; ++i)
    {
        sub_41BF1D(a1 + 612 * i + 2628);
        sub_474FB0((_DWORD*)(a1 + 612 * i + 2628), 0);
        sub_474F30((_BYTE*)(a1 + 612 * i + 2628), 0);
    }
    sub_4898D3((_DWORD*)(a1 + 128));
    sub_464A8A((char*)a1);
    for (i = 0; i < 8; ++i)
    {
        v13[0] = 1;
        sub_464194((_DWORD*)a1, a2, a3, a4, (int)v13);
    }
    v20 = 1;
    for (i = 0; i < 5; ++i)
    {
        sub_49DB90(v12);
        v12[14] = (int)word_4B9290;
        wsprintfA(v21, "Graphic\\Body%02d.bmp", i + 1);
        if (sub_49DA45((int*)unk_4BDC60, v21, (int)v12) && v20)
        {
            dword_4B9234 = v12[0];
            v20 = 0;
        }
    }
    for (i = 0; i < 4; ++i)
    {
        wsprintfA(FileName, "Graphic\\%02dpPalette.bin", *(__int16*)(a1 + 244 * i + 1630) + 1);
        hFile = CreateFileA(FileName, 0x80000000, 0, 0, 3u, 0x80u, 0);
        if (hFile != (HANDLE)-1)
        {
            for (k = 0; k < 256; ++k)
                ReadFile(hFile, &Buffer[k], 3u, (LPDWORD)&NumberOfBytesRead, 0);
            CloseHandle(hFile);
        }
        sub_4A0AE7((void*)(8 * i + 4952656), (int)Buffer, 256);
    }
    for (m = 0; m < 4; ++m)
    {
        for (i = 0;
            i < 2
            && (i <= 0 || *(_DWORD*)(a1 + 2368))
            && (!*(_DWORD*)(a1 + 2368) || i <= *(unsigned __int8*)(m + a1 + 2612));
            ++i)
        {
            v6 = (unsigned __int8)sub_401710((_BYTE*)(36
                * *(_DWORD*)(28 * *(unsigned __int8*)(a1 + i + 2 * m + 2580)
                    + a1
                    + 244 * m
                    + 1392)
                + dword_4B92E0));
            sub_4A1307(8 * (i + 2 * m) + 4952720, (Concurrency::details::HardwareAffinity*)(8 * m + 4952656));
            sub_485E5A((int)dword_4B93A4 + 24 * v6, (unsigned __int16*)(8 * (i + 2 * m) + 4952720));
        }
    }
    sub_46D3E1();
    sub_46F18C(a1, -1);
    return sub_456D33((const CHAR*)a1, aUndoukaiCharse, 1, 0);
} 
unsigned __int16* sub_46E35A(int thisx, double a2, double a3, double a4)
{
    int v4; // eax
    int v5; // esi
    int v6; // esi
    int v7; // esi
    int v8; // ecx
    int v9; // edx
    int v10; // eax
    int v11; // esi
    int v12; // ecx
    int v13; // edx
    unsigned __int16* result; // eax
    int v16; // [esp+Ch] [ebp-CCh]
    int v17; // [esp+10h] [ebp-C8h]
    int v18; // [esp+14h] [ebp-C4h]
    int v19; // [esp+18h] [ebp-C0h]
    int jj; // [esp+1Ch] [ebp-BCh]
    int v21; // [esp+24h] [ebp-B4h]
    int v22; // [esp+28h] [ebp-B0h]
    char v23; // [esp+30h] [ebp-A8h]
    int v24; // [esp+34h] [ebp-A4h]
    int v25; // [esp+38h] [ebp-A0h]
    int v26; // [esp+3Ch] [ebp-9Ch]
    _WORD* v27; // [esp+40h] [ebp-98h]
    unsigned int v28; // [esp+44h] [ebp-94h]
    int v29; // [esp+48h] [ebp-90h]
    int v30; // [esp+4Ch] [ebp-8Ch]
    int v31; // [esp+50h] [ebp-88h]
    char v32; // [esp+54h] [ebp-84h]
    int k; // [esp+58h] [ebp-80h]
    int v34; // [esp+5Ch] [ebp-7Ch]
    int v35; // [esp+60h] [ebp-78h]
    int v36; // [esp+68h] [ebp-70h]
    int v37; // [esp+6Ch] [ebp-6Ch]
    int v38; // [esp+70h] [ebp-68h]
    int v39; // [esp+78h] [ebp-60h]
    char* v40; // [esp+7Ch] [ebp-5Ch]
    _BYTE* v41; // [esp+80h] [ebp-58h]
    int v42; // [esp+84h] [ebp-54h]
    int v43; // [esp+88h] [ebp-50h]
    int v44; // [esp+8Ch] [ebp-4Ch]
    int v45; // [esp+90h] [ebp-48h]
    int j; // [esp+94h] [ebp-44h]
    int i; // [esp+98h] [ebp-40h]
    int m; // [esp+98h] [ebp-40h]
    int n; // [esp+98h] [ebp-40h]
    int ii; // [esp+98h] [ebp-40h]
    int v51[14]; // [esp+9Ch] [ebp-3Ch] BYREF
    int v52; // [esp+D4h] [ebp-4h]

    v52 = (unsigned __int8)byte_4B9986;
    for (i = 0; i < v52; ++i)
        sub_477F0C(i);
    for (j = 0; j < 4; ++j)
    {
        v39 = 0;
        v38 = 0;
        v37 = 0;
        v35 = 0;
        v45 = 0;
        v44 = 0;
        v40 = (char*)(thisx + *(unsigned __int8*)(j + thisx + 2612) + 2 * j + 2580);
        v41 = (_BYTE*)(thisx + j + 2596);
        v42 = *(_DWORD*)(thisx + 2368) + 1;
        v43 = *(unsigned __int8*)(j + thisx + 2616) - 1;
        v4 = *(unsigned __int8*)(thisx + 2516);
        if (!*(_BYTE*)(thisx + 2516))
        {
            if (*(_BYTE*)(j + thisx + 2616) || *(unsigned __int8*)(j + thisx + 2612) >= v42)
            {
                if (v43 >= 0)
                {
                    if (*(unsigned __int8*)(j + thisx + 2612) < v42)
                    {
                        LOBYTE(v4) = *(_BYTE*)(j + thisx + 2616) - 1;
                        v7 = sub_476D78(v4);
                        LOBYTE(v8) = v43;
                        v38 = v7 - sub_476D29(v8);
                        LOBYTE(v9) = v43;
                        v10 = sub_476CDA(v9);
                        v11 = v10;
                        LOBYTE(v10) = v43;
                        v37 = v11 - sub_476C8B(v10);
                        LOBYTE(v12) = v43;
                        v35 = sub_476DC7(v12, 0);
                        LOBYTE(v13) = v43;
                        v4 = sub_476DC7(v13, 2);
                        v44 = v4;
                    }
                    LOBYTE(v4) = v43;
                    v45 = sub_476DC7(v4, 1);
                }
            }
            else
            {
                if (!*(_BYTE*)(j + thisx + 2612) || *(_BYTE*)(thisx + 2 * j + 2588) == 2)
                {
                    v32 = -1;
                    v34 = 0;
                    for (k = 0; k < 6; ++k)
                    {
                        if (*(_BYTE*)(j + thisx + 2612) != 1 || k != *(unsigned __int8*)(thisx + 2 * j + 2580))
                        {
                            v30 = 28 * k + thisx + 244 * j + 1392;
                            v5 = *(__int16*)(v30 + 8);
                            v6 = v5 * ((unsigned __int8)sub_426670((char*)(36 * *(_DWORD*)v30 + dword_4B92E0)) + v5);
                            v31 = v6 / sub_47075A((_DWORD*)v30);
                            if (v31 > v34 || v31 == v34 && rand() % 2)
                            {
                                v32 = k;
                                v34 = v31;
                            }
                        }
                    }
                    v38 = 7;
                    *v40 = v32;
                    v39 = 1;
                }
                if (!*(_BYTE*)(j + thisx + 2612) || *(_BYTE*)(thisx + 2 * j + 2588) == 3)
                    v35 = 1;
            }
        }
        if (v35 && (unsigned __int8)*v40 < 6u)
        {
            if ((*(_BYTE*)(j + thisx + 2612) != 1 || *(unsigned __int8*)(thisx + 2 * j + 2580) != (unsigned __int8)*v40)
                && *(unsigned __int8*)(j + thisx + 2612) <= *(int*)(thisx + 2368))
            {
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
                *(_WORD*)(thisx + 2 * (*(unsigned __int8*)(j + thisx + 2612) + 2 * j) + 2564) = *(_WORD*)(thisx
                    + 244 * j
                    + 1392
                    + 28
                    * *(unsigned __int8*)(j + thisx + 2580));
                *(_BYTE*)(thisx + (unsigned __int8)(*(_BYTE*)(j + thisx + 2612))++ + 2 * j + 2588) = 1;
                if (*(_BYTE*)(j + thisx + 2612) == 1)
                {
                    *(_BYTE*)(thisx + 2 * j + 2581) = *v40;
                    *(_BYTE*)(thisx + 2 * j + 2589) = 0;
                }
            }
        }
        else if (v45)
        {
            if (*(_BYTE*)(j + thisx + 2612))
            {
                sub_43FFC3((int*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
                *(_BYTE*)(thisx + (unsigned __int8)-- * (_BYTE*)(j + thisx + 2612) + 2 * j + 2588) = 4;
                v39 = 1;
            }
        }
        else if (v44)
        {
            sub_43FFC3((int*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
            v39 = 1;
            *v41 = ((unsigned __int8)*v41 + 1) % 3;
            *(_BYTE*)(j + thisx + 13092) = 0;
        }
        else if (v38)
        {
            sub_43FFC3((int*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
            *v40 = ((unsigned __int8)*v40 + v38 + 7) % 7;
            *(_BYTE*)(j + thisx + 13092) = 0;
            v39 = 1;
        }
        else if (v37 && *v41 == 2)
        {
            *(_BYTE*)(j + thisx + 13092) = (*(unsigned __int8*)(j + thisx + 13092) + v37 + 4) % 4;
            sub_43FFC3((int*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
            v39 = 1;
        }
        v36 = 160 * (j / 2) + 20;
        if (*(_BYTE*)(thisx + 2516) != 2)
        {
            for (m = 0;
                m < 2
                && (m <= 0 || *(_DWORD*)(thisx + 2368))
                && (!*(_DWORD*)(thisx + 2368) || m <= *(unsigned __int8*)(j + thisx + 2612));
                ++m)
            {
                v28 = *(unsigned __int8*)(thisx + m + 2 * j + 2580);
                v24 = 0;
                LOWORD(v26) = 0;
                v23 = 0;
                v25 = 0;
                if (v28 < 6)
                {
                    v24 = 28 * v28 + thisx + 244 * j + 1392;
                    v26 = *(_DWORD*)v24;
                    v23 = *(_BYTE*)(v24 + 4);
                    v25 = (unsigned __int8)sub_401710((_BYTE*)(dword_4B92E0 + 36 * *(_DWORD*)v24));
                }
                sub_4A1307(8 * (m + 2 * j) + 4952720, (Concurrency::details::HardwareAffinity*)(8 * j + 4952656));
                sub_485E5A((int)dword_4B93A4 + 24 * v25, (unsigned __int16*)(8 * (m + 2 * j) + 4952720));
                v27 = (_WORD*)(thisx + 612 * (j + 4 * m) + 2628);
                sub_475010(v27, v26);
                sub_474FF0((char*)v27, v23);
                sub_475050((char*)v27, m + 2 * j);
                sub_41D84A((int)v27);
                sub_42371C((int)v27);
                if (v24 && *(_BYTE*)(v24 + 10))
                {
                    sub_475D90((_BYTE*)(thisx + 196 * (j + 4 * m) + 7524), *(_BYTE*)(v24 + 10) - 1);
                    sub_41F24C((int)v27, (Concurrency::details::SchedulerProxy*)(thisx + 196 * (j + 4 * m) + 7524));
                }
                else
                {
                    sub_41F6DE((int*)v27);
                }
                v29 = *(unsigned __int8*)(thisx + m + 2 * j + 2588);
                if (*(_BYTE*)(j + thisx + 2612)
                    && m == 1
                    && *(unsigned __int8*)(thisx + 2 * j + 2580) == *(unsigned __int8*)(thisx + 2 * j + 2581)
                    || !v24)
                {
                    v36 += 320;
                }
                if (*(_BYTE*)(thisx + m + 2 * j + 2588))
                {
                    switch (v29)
                    {
                    case 1:
                        v22 = sub_426090((int*)v27);
                        if (v22 <= -3200)
                            *(_BYTE*)(thisx + m + 2 * j + 2588) = 2;
                        sub_475D30((int*)v27, v22 - 400);
                        sub_426050((int*)v27, 10);
                        break;
                    case 2:
                        *(_BYTE*)(thisx + m + 2 * j + 2588) = 3;
                        break;
                    case 3:
                        sub_475D30((int*)v27, 34000);
                        break;
                    case 4:
                        v21 = sub_426090((int*)v27);
                        if (v21 - 100 * v36 <= 500)
                            *(_BYTE*)(thisx + m + 2 * j + 2588) = 0;
                        sub_475D30((int*)(int*)v27, v21 - 500);
                        sub_426050((int*)v27, 10);
                        break;
                    }
                }
                else
                {
                    sub_475D30((int*)v27, 100 * v36);
                    sub_475D50((int*)v27, 100 * (112 * (j % 2) + 116));
                    sub_475D10((int*)v27, 5);
                    sub_426050((int*)v27, 5);
                }
                sub_475D70((int*)v27, 0);
                sub_4757B0((int*)v27, 0);
                sub_408F50((int)v27, a2, a3, a4, 0);
            }
        }
        if (v39)
            sub_46F18C(thisx, j);
    }
    sub_49C15E((int)v51);
    v51[0] = dword_4B9248;
    result = sub_49AB05((int)unk_4BDC60, v51);
    for (n = 0; n < 8; ++n)
    {
        if (n < 4)
            goto LABEL_92;
        if (!*(_DWORD*)(thisx + 2368))
            break;
        result = (unsigned __int16*)(n + thisx);
        if (*(_BYTE*)(n + thisx + 2608))
            LABEL_92:
        sub_40230C(thisx + 612 * n + 2628);
    }
    if (!*(_BYTE*)(thisx + 2516))
    {
        for (ii = 0; ii < 4 * *(_DWORD*)(thisx + 2368) + 4; ++ii)
        {
            if (*(_BYTE*)((ii >= 4) + 2 * (ii % 4) + thisx + 2588) != 3)
            {
                *(_DWORD*)(thisx + 2528) = 0;
                break;
            }
        }
        result = (unsigned __int16*)(4 * *(_DWORD*)(thisx + 2368) + 4);
        if ((unsigned __int16*)ii == result)
        {
            result = (unsigned __int16*)thisx;
            if ((int)++ * (_DWORD*)(thisx + 2528) > 60)
            {
                memcpy((void*)(thisx + 2588), (const void*)(thisx + 2580), 8u);
                for (jj = 0; jj < (unsigned __int8)byte_4B9985; ++jj)
                {
                    v19 = *(unsigned __int8*)(thisx + ((*(_DWORD*)(thisx + 2368) == 0) + 1) * jj + 2580);
                    v17 = thisx + 244 * (jj / (*(_DWORD*)(thisx + 2368) + 1)) + 1392;
                    v16 = 28 * v19 + v17;
                    *(_BYTE*)(v17 + jj % (*(_DWORD*)(thisx + 2368) + 1) + 240) = v19;
                    v18 = *(_DWORD*)v16;
                    *(_DWORD*)(v16 + 16) = 1;
                    *(_WORD*)(thisx + 2 * jj + 2564) = v18;
                    word_4B99CE[jj] = *(_WORD*)(v16 + 8);
                    *(_BYTE*)(jj + thisx + 2580) = *(_BYTE*)(v16 + 4);
                    *(_BYTE*)(jj + thisx + 2403) = *(_BYTE*)(v16 + 10);
                    *(_BYTE*)(jj + thisx + 2411) = *(_BYTE*)(v16 + 11);
                }
                *(_BYTE*)(thisx + 29) = *(_BYTE*)(thisx + *(unsigned __int8*)(thisx + 2476) + 2478);
                byte_4B9999 = *(_BYTE*)(thisx + 29);
                result = (unsigned __int16*)thisx;
                *(_DWORD*)(thisx + 108) = 11;
                *(_BYTE*)(thisx + 2516) = 2;
            }
        }
    }
    return result;
}

 
void sub_46F18C(int thisx, int a2)
{
    int v2; // edx
    int v3; // eax
    int v4; // edx
    int v5; // edx
    int v6; // eax
    int v7; // edx
    char* v8; // eax
    __int16 v9; // ax
    char v10; // al
    char v11; // al
    char v12; // al
    char v13; // al
    unsigned __int8 v14; // al
    char* v15; // eax
    const CHAR* v16; // eax
    int v17; // [esp-4h] [ebp-230h]
    int v18; // [esp-4h] [ebp-230h]
    int v19; // [esp-4h] [ebp-230h]
    int v20; // [esp-4h] [ebp-230h]
    int v21; // [esp-4h] [ebp-230h]
    int v23; // [esp+8h] [ebp-224h]
    int n; // [esp+Ch] [ebp-220h]
    char* v25; // [esp+10h] [ebp-21Ch]
    int v26; // [esp+18h] [ebp-214h]
    int v27; // [esp+18h] [ebp-214h]
    BOOL v28; // [esp+1Ch] [ebp-210h]
    unsigned __int8 v29; // [esp+20h] [ebp-20Ch]
    unsigned __int8 v30; // [esp+24h] [ebp-208h]
    int v31[4]; // [esp+28h] [ebp-204h]
    int ii; // [esp+38h] [ebp-1F4h]
    _BYTE* v33; // [esp+3Ch] [ebp-1F0h]
    int v34; // [esp+40h] [ebp-1ECh]
    int v35; // [esp+44h] [ebp-1E8h]
    int v36; // [esp+48h] [ebp-1E4h]
    int jj; // [esp+4Ch] [ebp-1E0h]
    int v38; // [esp+50h] [ebp-1DCh]
    int v39; // [esp+54h] [ebp-1D8h]
    int v40; // [esp+58h] [ebp-1D4h]
    int v41; // [esp+5Ch] [ebp-1D0h]
    int v42; // [esp+60h] [ebp-1CCh]
    int v43; // [esp+64h] [ebp-1C8h]
    int v44; // [esp+68h] [ebp-1C4h]
    int v45; // [esp+6Ch] [ebp-1C0h]
    int v46; // [esp+70h] [ebp-1BCh]
    int v47; // [esp+74h] [ebp-1B8h]
    int v48; // [esp+78h] [ebp-1B4h]
    _BYTE* v49; // [esp+7Ch] [ebp-1B0h]
    CHAR v50[4]; // [esp+80h] [ebp-1ACh] BYREF
    __int16 v51; // [esp+84h] [ebp-1A8h]
    char v52; // [esp+86h] [ebp-1A6h]
    __int16 v53; // [esp+87h] [ebp-1A5h]
    int v54; // [esp+89h] [ebp-1A3h]
    int v55; // [esp+8Dh] [ebp-19Fh]
    char v56; // [esp+91h] [ebp-19Bh]
    int v57; // [esp+92h] [ebp-19Ah]
    int v58; // [esp+96h] [ebp-196h]
    char v59; // [esp+9Ah] [ebp-192h]
    int v60; // [esp+9Bh] [ebp-191h]
    char v61; // [esp+9Fh] [ebp-18Dh]
    int v62; // [esp+A0h] [ebp-18Ch]
    int v63; // [esp+A4h] [ebp-188h]
    int v64; // [esp+A8h] [ebp-184h]
    char v65; // [esp+ACh] [ebp-180h]
    int v66; // [esp+ADh] [ebp-17Fh]
    int v67; // [esp+B1h] [ebp-17Bh]
    char v68; // [esp+B5h] [ebp-177h]
    int v69; // [esp+B6h] [ebp-176h]
    int v70; // [esp+BAh] [ebp-172h]
    char v71; // [esp+BEh] [ebp-16Eh]
    int v72; // [esp+BFh] [ebp-16Dh]
    char v73; // [esp+C3h] [ebp-169h]
    int v74; // [esp+C4h] [ebp-168h]
    int v75; // [esp+C8h] [ebp-164h]
    int v76; // [esp+CCh] [ebp-160h]
    char v77; // [esp+D0h] [ebp-15Ch]
    int v78; // [esp+D4h] [ebp-158h]
    _WORD* v79; // [esp+D8h] [ebp-154h]
    int yTop; // [esp+DCh] [ebp-150h]
    int* v81; // [esp+E0h] [ebp-14Ch]
    int xLeft; // [esp+E4h] [ebp-148h]
    int v83; // [esp+E8h] [ebp-144h]
    int v84; // [esp+ECh] [ebp-140h]
    char* v85; // [esp+F0h] [ebp-13Ch]
    int m; // [esp+F4h] [ebp-138h]
    int v87; // [esp+F8h] [ebp-134h]
    int v88; // [esp+FCh] [ebp-130h]
    int v89; // [esp+100h] [ebp-12Ch]
    CHAR Buffer[64]; // [esp+104h] [ebp-128h] BYREF
    struct tagRECT v91; // [esp+144h] [ebp-E8h] BYREF
    int v92; // [esp+154h] [ebp-D8h]
    int v93; // [esp+158h] [ebp-D4h] BYREF
    int v94; // [esp+15Ch] [ebp-D0h]
    int v95; // [esp+160h] [ebp-CCh]
    int v96; // [esp+170h] [ebp-BCh]
    int v97; // [esp+18Ch] [ebp-A0h]
    int v98; // [esp+190h] [ebp-9Ch]
    int j; // [esp+194h] [ebp-98h]
    int v100; // [esp+198h] [ebp-94h]
    int k; // [esp+19Ch] [ebp-90h]
    int i; // [esp+1A0h] [ebp-8Ch]
    CHAR String[64]; // [esp+1A4h] [ebp-88h] BYREF
    struct tagRECT rc; // [esp+1E4h] [ebp-48h] BYREF
    int v105; // [esp+1F4h] [ebp-38h] BYREF
    int v106; // [esp+1F8h] [ebp-34h]
    int v107; // [esp+1FCh] [ebp-30h]

    if (a2 == -1)
    {
        SetRect(&rc, 0, 0, 320, 16);
        sub_4A02E9((_DWORD*)unk_4BDC60, (int)&rc, (int)&rc, 0, dword_4B9248);
        sub_49C15E((int)&v105);
        v105 = dword_4B91F8;
        for (i = 1; i < 31; ++i)
        {
            v106 = 8 * ((i + 1) % 5) - 40;
            v107 = 8 * i + 4;
            for (j = 0; j < 9; ++j)
            {
                sub_49CC5B((short*)unk_4BDC60, dword_4B9248, &v105);
                v106 += 40;
            }
        }
        v100 = 8;
        if (dword_4B99F4)
            v100 += 16;
        wsprintfA(String, "%d/%d", *(unsigned __int8*)(thisx + 2476) + 1, *(unsigned __int8*)(thisx + 2477));
        sub_47B7ED(v100, 2, String, 0, dword_4B9248);
        sub_47B91A(v100 + 24, 2, byte_4B376C, 0, dword_4B9248);
        sub_47B91A(v100 + 72, 2, byte_4B3778, 0, dword_4B9248);
        for (k = 0; k < 4; ++k)
            sub_46F18C(thisx, k);
    }
    else if (a2 >= 0 && a2 < 4)
    {
        xLeft = 160 * (a2 / 2) + 4;
        yTop = 112 * (a2 & 0x80000001) + 20;
        SetRect(&v91, xLeft, yTop, 160 * (a2 / 2) + 156, 112 * (a2 & 0x80000001) + 36);
        sub_4A02E9((_DWORD*)unk_4BDC60, v2, (int)&v91, 0, dword_4B9248);
        v98 = 160 * (a2 / 2) + 115;
        v89 = yTop;
        for (m = *(_DWORD*)(thisx + 2368) == 0; m < 2; ++m)
        {
            v98 = xLeft + 19 * m + 114;
            SetRect(&v91, v98, v89, xLeft + 19 * m + 132, v89 + 16);
            v17 = dword_4B9248;
            v3 = sub_49FFEC(198, 113, 0);
            sub_4A02E9((_DWORD*)unk_4BDC60, v4, (int)&v91, v3, v17);
        }
        v98 = xLeft;
        SetRect(&v91, xLeft, yTop + 24, xLeft + 152, yTop + 104);
        sub_4A02E9((_DWORD*)unk_4BDC60, v5, (int)&v91, 0, dword_4B9248);
        v98 = xLeft + 3;
        SetRect(&v91, xLeft + 3, yTop + 56, xLeft + 28, yTop + 100);
        v18 = dword_4B9248;
        v6 = sub_49FFEC(198, 113, 0);
        sub_4A02E9((_DWORD*)unk_4BDC60, v7, (int)&v91, v6, v18);
        v84 = thisx + 244 * a2 + 1392;
        v98 = xLeft + 8;
        sub_47B91A(xLeft + 8, yTop + 4, (LPCSTR)(thisx + 244 * a2 + 1564), 0, dword_4B9248);
        v98 += 126;
        v89 = yTop;
        sub_49C15E((int)&v93);
        v83 = *(unsigned __int8*)(a2 + thisx + 2612) + 1;
        if (*(_DWORD*)(thisx + 2368))
            v98 -= 19;
        else
            v83 = 1;
        for (m = 0; m < v83; ++m)
        {
            v88 = *(unsigned __int8*)(thisx + m + 2 * a2 + 2580);
            if (v88 >= 6)
            {
                if (v88 == 6)
                {
                    v79 = (_WORD*)(84 * *(__int16*)(v84 + 236) + dword_4B92D4);
                    v94 = v98;
                    v95 = v89;
                    v96 = 1;
                    v93 = dword_4B91E0;
                    v78 = (unsigned __int16)sub_475CB0(v79);
                    SetRect(&v91, 8, 16 * v78, 16, 16);
                    sub_4A03B3((short*)unk_4BDC60, dword_4B9248, &v93, (_DWORD*)&v91);
                    v96 = 0;
                }
            }
            else
            {
                v81 = (int*)(28 * v88 + v84);
                v87 = *v81;
                v92 = *((char*)v81 + 4);
                v85 = (char*)(36 * v87 + dword_4B92E0);
                v94 = v98;
                v95 = v89;
                sub_47900E(&v93, 1, v87, dword_4B9248);
                v94 = v98;
                v95 = v89 + 8;
                v93 = v92 + dword_4B9234;
                v97 = 8 * (m + 2 * a2) + 4952720;
                SetRect(&v91, 0, 0, 16, 8);
                sub_4A03B3((short*)unk_4BDC60, dword_4B9248, &v93, (_DWORD*)&v91);
            }
            v98 += 19;
        }
        v88 = *(unsigned __int8*)(thisx + *(unsigned __int8*)(a2 + thisx + 2612) + 2 * a2 + 2580);
        if (v88 >= 6)
        {
            if (v88 == 6)
            {
                v25 = (char*)(84 * *(__int16*)(v84 + 236) + dword_4B92D4);
                v98 = xLeft + 4;
                v94 = xLeft + 8;
                v95 = yTop + 72;
                v93 = dword_4B91E0 + 1;
                SetRect(&v91, 0, 0, 16, 24);
                sub_4A03B3((short*)unk_4BDC60, dword_4B9248, &v93, (_DWORD*)&v91);
                v94 = v98 - 4;
                v95 = yTop + 64;
                v93 = dword_4B91E0;
                v23 = (unsigned __int16)sub_475CB0((short*)v25);
                SetRect(&v91, 0, 16 * v23, 32, 16);
                sub_4A03B3((short*)unk_4BDC60, dword_4B9248, &v93, (_DWORD*)&v91);
                v94 = v98 - 4;
                v95 = yTop + 76;
                v93 = dword_4B91E0 + 1;
                SetRect(&v91, 16 * a2 + 16, 0, 16, 16);
                sub_4A03B3((short*)unk_4BDC60, dword_4B9248, &v93, (_DWORD*)&v91);
                v94 = v98 + 17;
                v95 = yTop + 76;
                v93 = dword_4B91E0 + 1;
                SetRect(&v91, 16 * a2 + 24, 0, 8, 16);
                sub_4A03B3((short*)unk_4BDC60, dword_4B9248, &v93, (_DWORD*)&v91);
                v98 = xLeft + 8;
                v20 = dword_4B9248;
                v15 = unknown_libname_18(v25);
                sub_47B91A(v98, yTop + 28, v15, 0, v20);
                v98 += 64;
                sub_47B91A(v98, yTop + 28, byte_4B3824, 0, dword_4B9248);
                v98 = xLeft + 32;
                v89 = yTop + 44;
                for (n = 0; n < 5; ++n)
                {
                    if (sub_475CD0((_DWORD*)v25, n))
                    {
                        v21 = dword_4B9248;
                        v16 = (const CHAR*)sub_475CD0((_DWORD*)v25, n);
                        sub_47B91A(v98, 12 * n + v89, v16, 0, v21);
                    }
                }
            }
        }
        else
        {
            v81 = (int*)(28 * v88 + v84);
            v87 = *v81;
            v92 = *((char*)v81 + 4);
            v85 = (char*)(36 * v87 + dword_4B92E0);
            v98 = xLeft + 8;
            v89 = yTop + 32;
            v19 = dword_4B9248;
            v8 = unknown_libname_18(v85);
            sub_47B91A(v98, yTop + 32, v8, 0, v19);
            v98 += 56;
            v9 = sub_47075A(v81);
            sprintf(Buffer, "HP %3d/%3d", *((__int16*)v81 + 4), v9);
            sub_47B7ED(v98, yTop + 32, Buffer, 0, dword_4B9248);
            if (*(unsigned __int8*)(a2 + thisx + 2596) > 1u)
            {
                if (*(_BYTE*)(a2 + thisx + 2596) == 2)
                {
                    for (ii = 0; ii < 3; ++ii)
                    {
                        v14 = sub_4266B0(v85, ii);
                        v31[ii + 1] = v14;
                    }
                    v33 = (_BYTE*)(84 * *(__int16*)(v84 + 236) + dword_4B92D4);
                    for (ii = 0; ii < 3; ++ii)
                    {
                        v29 = sub_475090(v33, ii);
                        if (v29)
                        {
                            v31[0] = 0;
                            v28 = 0;
                            do
                            {
                                v30 = v31[v31[0] + 1];
                                if (!v30)
                                    break;
                                v28 = sub_47744C(v30, v29);
                                if (v28)
                                    break;
                                ++v31[0];
                            } while (v31[0] != 3);
                            if (v31[0] == 3)
                                break;
                            if (!v28)
                                v31[v31[0] + 1] = v29;
                        }
                    }
                    for (ii = 0; ii < 3; ++ii)
                    {
                        v26 = v31[ii + 1];
                        if (*(_BYTE*)(a2 + thisx + 13092))
                        {
                            if (ii)
                                break;
                            v26 = v31[*(unsigned __int8*)(a2 + thisx + 13092)];
                        }
                        if (v26 >= 73)
                        {
                            v27 = v26 - 128;
                            if (v27 >= 13)
                                sub_47B91A(xLeft + 32, yTop + 16 * ii + 56, byte_4B3818, 0, dword_4B9248);
                            else
                                sub_47B91A(xLeft + 32, yTop + 16 * ii + 56, (LPCSTR)&byte_4B4E74[21 * v27], 0, dword_4B9248);
                        }
                        else
                        {
                            sub_47B91A(xLeft + 32, yTop + 16 * ii + 56, (LPCSTR)&byte_4B46C0[27 * v26], 0, dword_4B9248);
                        }
                    }
                    if (*(_BYTE*)(a2 + thisx + 13092))
                        sub_47BD8E(xLeft + 32, yTop + 72, v31[*(unsigned __int8*)(a2 + thisx + 13092)], dword_4B9248);
                }
            }
            else
            {
                *(_DWORD*)v50 = dword_4B37B4;
                v51 = word_4B37B8;
                v52 = byte_4B37BA;
                v53 = 0;
                v54 = dword_4B37BC;
                v55 = dword_4B37C0;
                v56 = byte_4B37C4;
                v57 = dword_4B37C8;
                v58 = dword_4B37CC;
                v59 = byte_4B37D0;
                v60 = dword_4B37D4;
                v61 = byte_4B37D8;
                v62 = 0;
                v63 = dword_4B37DC;
                v64 = dword_4B37E0;
                v65 = byte_4B37E4;
                v66 = dword_4B37E8;
                v67 = dword_4B37EC;
                v68 = byte_4B37F0;
                v69 = dword_4B37F4;
                v70 = dword_4B37F8;
                v71 = byte_4B37FC;
                v72 = dword_4B3800;
                v73 = byte_4B3804;
                v74 = 0;
                v75 = dword_4B3808;
                v76 = dword_4B380C;
                v77 = byte_4B3810;
                v40 = (unsigned __int8)sub_426570(v85);
                v41 = (unsigned __int8)sub_4265D0(v85);
                v42 = (unsigned __int8)sub_4265F0(v85);
                v43 = (unsigned __int8)sub_426610(v85);
                v44 = (unsigned __int8)sub_426550(v85);
                v45 = (unsigned __int8)sub_426670(v85);
                v46 = (unsigned __int8)sub_426630(v85);
                v47 = (unsigned __int8)sub_426650(v85);
                v48 = (unsigned __int8)sub_426690(v85);
                v49 = (_BYTE*)(84 * *(__int16*)(v84 + 236) + dword_4B92D4);
                for (jj = 0; jj < 5; ++jj)
                    *(&v40 + jj) += sub_43EE02((unsigned char*)v49, jj + 1, v84);
                v10 = sub_43EE02((unsigned char*)v49, 9, v84);
                v45 += v10;
                v11 = sub_43EE02((unsigned char*)v49, 6, v84);
                v46 += v11;
                v12 = sub_43EE02((unsigned char*)v49, 7, v84);
                v47 += v12;
                v13 = sub_43EE02((unsigned char*)v49, 8, v84);
                v48 += v13;
                switch (v92)
                {
                case 0:
                    v40 += 5;
                    v41 += 5;
                    v42 += 5;
                    break;
                case 1:
                    v40 += 15;
                    break;
                case 2:
                    v41 += 15;
                    break;
                case 3:
                    v42 += 15;
                    break;
                default:
                    break;
                }
                for (jj = 0; jj < 9; ++jj)
                {
                    if (*(&v40 + jj) <= 0)
                        *(&v40 + jj) = 1;
                }
                v98 = xLeft + 32;
                v89 = yTop + 56;
                v39 = 5 * *(unsigned __int8*)(a2 + thisx + 2596);
                v38 = 4 * *(unsigned __int8*)(a2 + thisx + 2596) + 5;
                v36 = 0;
                for (jj = v39; jj < v38; ++jj)
                {
                    v35 = ((v36 % 2) << 6) + v98;
                    v34 = 16 * (v36 / 2) + v89;
                    sub_47B91A(v35, v34, &v50[9 * jj], 0, dword_4B9248);
                    wsprintfA(Buffer, "%3d", *(&v40 + jj));
                    sub_47B7ED(v35 + 32, v34, Buffer, 0, dword_4B9248);
                    ++v36;
                }
            }
        }
    }
}
 
int sub_470596(void* thisx, int a2, int a3)
{
    int result; // eax
    int i; // [esp+4h] [ebp-4h]

    for (i = 0; i < 6; ++i)
    {
        sub_4705D7((int)thisx + 28 * i, a2, a3);
        result = i + 1;
    }
    return result;
}

 
__int16 sub_4705D7(int thisx, int a2, int a3)
{
    __int16 result; // ax
    char v4; // [esp+0h] [ebp-20h]
    int v5; // [esp+4h] [ebp-1Ch]
    int v7; // [esp+Ch] [ebp-14h]
    unsigned __int8* v8; // [esp+10h] [ebp-10h]
    int v9; // [esp+14h] [ebp-Ch]

    result = sub_47075A((_DWORD*)thisx);
    if (*(__int16*)(thisx + 8) <= result)
    {
        if (a2)
        {
            result = sub_47075A((_DWORD*)thisx);
            *(_WORD*)(thisx + 8) = result;
        }
        else if (!*(_DWORD*)(thisx + 16))
        {
            v7 = 32;
            if (a3)
                v7 = 64;
            v9 = sub_472F91((_DWORD*)thisx);
            v5 = sub_40181C((unsigned char*)v9);
            if (v5)
            {
                if (v5 == 1)
                {
                    v7 += 48;
                }
                else if (v5 == 2)
                {
                    v7 += 24;
                }
            }
            else
            {
                v7 += 96;
            }
            v4 = *(_BYTE*)(*(_DWORD*)(thisx + 12) + 242);
            switch (v4)
            {
            case 2:
                v7 += 16;
                break;
            case 3:
                v7 += 32;
                break;
            case 4:
                v7 += 64;
                break;
            }
            v8 = (unsigned __int8*)(84 * *(__int16*)(*(_DWORD*)(thisx + 12) + 236) + dword_4B92D4);
            if (sub_43ED9E(v8, 3u, 0))
                v7 += 32;
            if (sub_43ED9E(v8, 3u, 1u))
                v7 -= 32;
            if (!a3 && v7 < 32 || a3 && v7 < 64)
                v7 = 32 * a3 + 32;
            result = sub_4707C7((int)thisx, v7);
        }
        *(_DWORD*)(thisx + 16) = 0;
    }
    return result;
}

 
__int16 sub_47075A(_DWORD* thisx)
{
    __int16 v1; // bx
    __int16 v4; // [esp+8h] [ebp-4h]

    v1 = (unsigned __int8)sub_4265B0((_BYTE*)(dword_4B92E0 + 36 * *thisx));
    v4 = (char)sub_43EE02((unsigned __int8*)(dword_4B92D4 + 84 * *(__int16*)(thisx[3] + 236)), 0, thisx[3]) + v1;
    if (v4 <= 0)
        return 1;
    return v4;
}

 
__int16 sub_4707C7(int thisx, int a2)
{
    int v2; // eax
    int v5; // [esp+4h] [ebp-4h]

    v5 = sub_47075A((_DWORD*)thisx);
    if (a2 + *(__int16*)(thisx + 8) <= v5)
    {
        v2 = a2 + *(__int16*)(thisx + 8);
        if (v2 >= 0)
        {
            LOWORD(v2) = a2 + *(_WORD*)(thisx + 8);
            *(_WORD*)(thisx + 8) = v2;
        }
        else
        {
            *(_WORD*)(thisx + 8) = 0;
        }
    }
    else
    {
        LOWORD(v2) = thisx;
        *(_WORD*)(thisx + 8) = v5;
    }
    return v2;
}

 
int sub_47082B(int thisx)
{
    int j; // [esp+4h] [ebp-Ch]
    int v4; // [esp+8h] [ebp-8h]
    int i; // [esp+Ch] [ebp-4h]

    *(_DWORD*)(thisx + 104) = 24;
    *(_DWORD*)(thisx + 2540) = 0;
    *(_BYTE*)(thisx + 2516) = 1;
    *(_BYTE*)(thisx + 2562) = 0;
    dword_4B91E0 = 0;
    *(_DWORD*)(thisx + 2540) = 0;
    *(_BYTE*)(thisx + 2562) = 0;
    *(_WORD*)(thisx + 2564) = 0;
    *(_WORD*)(thisx + 2566) = 0;
    v4 = 4;
    for (i = 1; i < 5; ++i)
    {
        for (j = 0; j < 4; ++j)
        {
            if (*(unsigned __int8*)(j + thisx + 13044) == i)
            {
                *(_BYTE*)(v4 + thisx + 13044) = j;
                *(_BYTE*)(thisx + 244 * j + 1635) = i;
                ++v4;
            }
            if (v4 >= 8)
                break;
        }
        if (v4 >= 8)
            break;
    }
    sub_4898D3((_DWORD*)(thisx + 128));
    sub_4891E4((_DWORD*)(thisx + 128), aDemoKkResult1T);
    sub_47F958((_DWORD*)(thisx + 736));
    return sub_456D33((const CHAR*)thisx, aCheergirlsWav, 1, 0);
}

 
int sub_470968(int thisx)
{
    int v1; // edx
    char* v2; // eax
    char* v3; // eax
    int v6; // [esp+4h] [ebp-134h]
    int v7; // [esp+8h] [ebp-130h]
    int v8; // [esp+10h] [ebp-128h]
    int v9; // [esp+14h] [ebp-124h]
    int v10; // [esp+18h] [ebp-120h]
    unsigned __int8* v11; // [esp+1Ch] [ebp-11Ch]
    int v12; // [esp+20h] [ebp-118h]
    int v13; // [esp+24h] [ebp-114h]
    CHAR String[256]; // [esp+28h] [ebp-110h] BYREF
    struct tagRECT rc; // [esp+128h] [ebp-10h] BYREF

    v8 = *(unsigned __int16*)(thisx + 2564);
    v7 = *(unsigned __int8*)(thisx + *(unsigned __int8*)(thisx + 2562) + 13047);
    v9 = thisx + 244 * v7 + 1392;
    v11 = (unsigned __int8*)(84 * *(__int16*)(thisx + 244 * v7 + 1628) + dword_4B92D4);
    v12 = unknown_libname_10((_DWORD*)(thisx + 128));
    v6 = 24 * (*(unsigned __int8*)(thisx + 2562) - 1) + 88;
    wsprintfA(String, "%d", v8 + 1);
    sub_47B7ED(152, v6, String, 0, v12);
    sub_47B91A(160, v6, byte_4B385C, 0, v12);
    sub_47B91A(176, v6, (LPCSTR)(v9 + 172), 0, v12);
    v10 = 50 * (4 - v8);
    if (sub_43ED9E(v11, 1u, 0))
    {
        v10 = 300 * (4 - v8) / 5;
    }
    else if (sub_43ED9E(v11, 1u, 1u))
    {
        v10 = 200 * (4 - v8) / 5;
    }
    wsprintfA(String, "%3d", v10);
    sub_47B7ED(272, v6 + 8, String, 0, v12);
    sub_47B91A(296, v6 + 8, byte_4B3864, 0, v12);
    *(_DWORD*)(v9 + 168) += v10;
    SetRect(&rc, 24, 144, 104, 160);
    sub_4A02E9((_DWORD*)unk_4BDC60, v1, (int)&rc, 0, v12);
    v2 = unknown_libname_18((char*)v11);
    v13 = lstrlenA(v2);
    v3 = unknown_libname_18((char*)v11);
    return sub_47B91A(64 - 8 * (v13 / 4), 152, v3, 0, v12);
}

 
_DWORD* sub_470C48(int thisx)
{
    int v1; // edx
    _DWORD* result; // eax
    int v3; // eax
    char* v4; // eax
    int v5; // [esp-4h] [ebp-528h]
    int v7[256]; // [esp+4h] [ebp-520h] BYREF
    int v8; // [esp+404h] [ebp-120h]
    int v9; // [esp+408h] [ebp-11Ch]
    int v10; // [esp+40Ch] [ebp-118h]
    _DWORD* v11; // [esp+410h] [ebp-114h]
    __int16* v12; // [esp+414h] [ebp-110h]
    CHAR FileName[256]; // [esp+418h] [ebp-10Ch] BYREF
    int j; // [esp+518h] [ebp-Ch]
    int i; // [esp+51Ch] [ebp-8h]
    int v16; // [esp+520h] [ebp-4h]

    v16 = 0;
    if (!*(_BYTE*)(thisx + 2516))
    {
        for (i = 0; i < (unsigned __int8)byte_4B9986; ++i)
        {
            sub_477F0C(i);
            LOBYTE(v1) = i;
            if (sub_476DC7(v1, 0))
                v16 = 1;
        }
        if (v16)
            *(_DWORD*)(thisx + 2540) = 240;
    }
    if ((int)++ * (_DWORD*)(thisx + 2540) <= 240 && (*(_BYTE*)(thisx + 2562) || *(int*)(thisx + 2540) <= 60))
        goto LABEL_30;
    while (*(unsigned __int16*)(thisx + 2564) < 4u)
    {
        for (j = *(unsigned __int16*)(thisx + 2566); j < 4; ++j)
        {
            if (*(unsigned __int16*)(thisx + 2564) + 1 == *(unsigned __int8*)(j + thisx + 13044))
            {
                *(_WORD*)(thisx + 2566) = j + 1;
                break;
            }
        }
        if (j != 4)
            break;
        ++* (_WORD*)(thisx + 2564);
        *(_WORD*)(thisx + 2566) = 0;
    }
    *(_DWORD*)(thisx + 2540) = 0;
    if ((unsigned __int8)++ * (_BYTE*)(thisx + 2562) < 5u)
    {
    LABEL_30:
        if (!*(_DWORD*)(thisx + 2540))
        {
            v9 = *(unsigned __int16*)(thisx + 2564);
            v8 = *(unsigned __int8*)(thisx + *(unsigned __int8*)(thisx + 2562) + 13047);
            v10 = *(__int16*)(thisx + 244 * v8 + 1628);
            v11 = (_DWORD*)sub_488E1E((_DWORD*)(thisx + 128), 0);
            v12 = (__int16*)(84 * v10 + dword_4B92D4);
            sub_475DB0(v11, v10);
            v3 = sub_475DD0(v12, v9);
            sub_48DC0D((int)v11, v3);
            wsprintfA(FileName, "Graphic\\CheerGirl_Palette%02d.bin", v8 + 1);
            sub_47846F(FileName, (int)v7);
            sub_4A0AE7((void*)word_4B9290, (int)v7, 256);
            v5 = sub_475DF0((_DWORD*)v12, v9);
            v4 = unknown_libname_18((char*)v12);
            wsprintfA(FileName, aS_6, v4, v5);
            sub_47FA81((int*)(thisx + 736));
            sub_47F9D6(thisx + 736, FileName, 4);
            sub_470968(thisx);
        }
        sub_488981((_DWORD*)thisx + 128);
        sub_486476((_DWORD*)(thisx + 128));
        sub_47F211(thisx + 736);
        return sub_47F98B((_DWORD*)(thisx + 736));
    }
    else
    {
        if (*(unsigned __int8*)(thisx + 2476) >= (int)*(unsigned __int8*)(thisx + 2477))
        {
            *(_DWORD*)(thisx + 108) = 25;
            result = (_DWORD*)thisx;
        }
        else
        {
            result = (_DWORD*)thisx;
            *(_DWORD*)(thisx + 108) = 23;
        }
        *(_BYTE*)(thisx + 2516) = 2;
    }
    return result;
}

 
int sub_471036(unsigned __int8* thisx, int a2)
{
    int v3; // [esp+4h] [ebp-4h]

    v3 = 0;
    if (a2)
    {
        if (a2 >= 1 && a2 <= 4)
            v3 = (int)&thisx[244 * a2 + 1148];
    }
    else
    {
        v3 = (int)&thisx[244 * thisx[thisx[2562] + 13047] + 1392];
    }
    if (v3)
        return v3 + 172;
    else
        return 0;
}

 
int sub_4710B5(int thisx)
{
    int v2; // [esp+0h] [ebp-160h]
    int v3; // [esp+4h] [ebp-15Ch]
    int mm; // [esp+Ch] [ebp-154h]
    int kk; // [esp+10h] [ebp-150h]
    int v7; // [esp+14h] [ebp-14Ch]
    int v8; // [esp+18h] [ebp-148h]
    int v9; // [esp+1Ch] [ebp-144h]
    unsigned __int8 v10; // [esp+20h] [ebp-140h]
    int v11; // [esp+28h] [ebp-138h]
    int v12; // [esp+2Ch] [ebp-134h]
    int ii; // [esp+30h] [ebp-130h]
    int v14; // [esp+34h] [ebp-12Ch]
    int m; // [esp+38h] [ebp-128h]
    int v16; // [esp+3Ch] [ebp-124h]
    int v17; // [esp+40h] [ebp-120h]
    unsigned __int8 v18; // [esp+44h] [ebp-11Ch]
    int v19; // [esp+48h] [ebp-118h]
    int v20; // [esp+4Ch] [ebp-114h]
    int n; // [esp+50h] [ebp-110h]
    int k; // [esp+58h] [ebp-108h]
    int v23; // [esp+60h] [ebp-100h]
    int v24; // [esp+64h] [ebp-FCh]
    int j; // [esp+68h] [ebp-F8h]
    int v26[44]; // [esp+6Ch] [ebp-F4h] BYREF
    int i; // [esp+11Ch] [ebp-44h]
    int v28[15]; // [esp+120h] [ebp-40h] BYREF
    int jj; // [esp+15Ch] [ebp-4h]

    *(_DWORD*)(thisx + 104) = 25;
    *(_DWORD*)(thisx + 2540) = 0;
    *(_BYTE*)(thisx + 2516) = 1;
    *(_BYTE*)(thisx + 2562) = 0;
    *(_BYTE*)(thisx + 2580) = 0;
    sub_440B78((int)unk_4BDB28);
    sub_4A02E9((_DWORD*)unk_4BDC60, dword_4B9248, 0, 0, dword_4B9248);
    sub_49DB90(v28);
    if (sub_49DA45((_DWORD*)unk_4BDC60, aGraphicKkResul, (int)v28) >= 0)
    {
        sub_49C15E((int)v26);
        v26[0] = v28[0];
        sub_49CC5B((short*)unk_4BDC60, dword_4B9248, v26);
        sub_49DA8A((_DWORD*)unk_4BDC60, v28[0]);
    }
    *(_DWORD*)(thisx + 2528) = sub_43FC18((_DWORD*)unk_4BDB28, pszFileName);
    for (i = 0; i < 4; ++i)
    {
        v24 = thisx + 244 * i + 1392;
        v23 = *(_DWORD*)(thisx + 244 * i + 1560);
        *(_BYTE*)(thisx + 244 * i + 1634) = 1;
        for (j = 0; j < 4; ++j)
        {
            if (v23 < *(_DWORD*)(thisx + 244 * j + 1560))
                ++* (_BYTE*)(v24 + 242);
        }
    }
    for (i = 0; i < 4; ++i)
    {
        for (k = 0; k < 6; ++k)
        {
            for (m = 0; m < 5; ++m)
                *((_BYTE*)&v26[6 * m + 14] + 6 * i + k) = 1;
            v16 = *(unsigned __int8*)(thisx + 244 * i + 1634);
            v20 = v16 + 10 * *(__int16*)(28 * k + thisx + 244 * i + 1392 + 6);
            v17 = v16 + 10 * *(unsigned __int8*)(28 * k + thisx + 244 * i + 1392 + 26);
            v18 = v16 + 10 * *(_BYTE*)(28 * k + thisx + 244 * i + 1392 + 20);
            v19 = v16
                + 10
                * (*(__int16*)(28 * k + thisx + 244 * i + 1392 + 22) - 2 * *(__int16*)(28 * k + thisx + 244 * i + 1392 + 24));
            if (!(v18 / 10))
                v20 = 0;
            for (n = 0; n < 4; ++n)
            {
                v14 = *(unsigned __int8*)(thisx + 244 * n + 1634);
                for (ii = 0; ii < 6; ++ii)
                {
                    v11 = v14 + 10 * *(__int16*)(28 * ii + thisx + 244 * n + 1392 + 6);
                    v12 = v14 + 10 * *(unsigned __int8*)(28 * ii + thisx + 244 * n + 1392 + 26);
                    v10 = v14 + 10 * *(_BYTE*)(28 * ii + thisx + 244 * n + 1392 + 20);
                    v9 = v14
                        + 10
                        * (*(__int16*)(28 * ii + thisx + 244 * n + 1392 + 22)
                            - 2 * *(__int16*)(28 * ii + thisx + 244 * n + 1392 + 24));
                    if (!(v10 / 10))
                        v11 = 0;
                    if (v18 < (int)v10 || v18 / 10 <= 1)
                        ++* ((_BYTE*)&v26[14] + 6 * i + k);
                    if (v20 < v11 || !(v18 / 10))
                        ++* ((_BYTE*)&v26[20] + 6 * i + k);
                    if (v20 <= 0)
                        v3 = -v20;
                    else
                        v3 = v20;
                    if (v11 <= 0)
                        v2 = -v11;
                    else
                        v2 = v11;
                    if (v3 > v2 && v10 / 10 || !(v18 / 10))
                        ++* ((_BYTE*)&v26[26] + 6 * i + k);
                    if (v17 < v12 || !(v17 / 10))
                        ++* ((_BYTE*)&v26[32] + 6 * i + k);
                    if (v19 < v9)
                        ++* ((_BYTE*)&v26[38] + 6 * i + k);
                }
            }
        }
    }
    for (jj = 0; jj < 5; ++jj)
    {
        v8 = 0;
        for (i = 0; i < 4; ++i)
        {
            for (kk = 0; kk < 6; ++kk)
            {
                if (*((_BYTE*)&v26[6 * jj + 14] + 6 * i + kk) == 1)
                    ++v8;
            }
        }
        if (v8)
        {
            v7 = rand() % v8;
            for (i = 0; i < 4; ++i)
            {
                for (mm = 0; mm < 6; ++mm)
                {
                    if (*((_BYTE*)&v26[6 * jj + 14] + 6 * i + mm) == 1 && --v7 == -1)
                    {
                        *(_WORD*)(thisx + 2 * jj + 2564) = mm + 10 * i;
                        break;
                    }
                }
                if (v7 == -1)
                    break;
            }
        }
        else
        {
            *(_WORD*)(thisx + 2 * jj + 2564) = 100;
        }
    }
    return sub_47F958((_DWORD*)(thisx + 736));
}
 
_DWORD* sub_47188C(int thisx)
{
    int v1; // eax
    int v2; // ecx
    char* v3; // eax
    int v5; // [esp-4h] [ebp-170h]
    _DWORD* v7; // [esp+8h] [ebp-164h]
    int v8; // [esp+10h] [ebp-15Ch]
    int v9; // [esp+10h] [ebp-15Ch]
    int v10; // [esp+18h] [ebp-154h]
    int v11; // [esp+1Ch] [ebp-150h]
    CHAR String[256]; // [esp+20h] [ebp-14Ch] BYREF
    int v13; // [esp+120h] [ebp-4Ch]
    _BYTE* v14; // [esp+124h] [ebp-48h]
    int v15; // [esp+128h] [ebp-44h]
    int i; // [esp+12Ch] [ebp-40h]
    int v17; // [esp+130h] [ebp-3Ch]
    int v18[14]; // [esp+134h] [ebp-38h] BYREF

    if (!*(_BYTE*)(thisx + 2516))
    {
        v17 = 0;
        v1 = *(unsigned __int8*)(thisx + 2516);
        if (!*(_BYTE*)(thisx + 2516))
        {
            for (i = 0; i < (unsigned __int8)byte_4B9986; ++i)
            {
                LOBYTE(v1) = i;
                sub_477F0C(v1);
                LOBYTE(v2) = i;
                v1 = sub_476DC7(v2, 0);
                if (v1)
                    v17 = 1;
            }
            if (v17 && *(_BYTE*)(thisx + 2562) && *(unsigned __int8*)(thisx + 2562) <= 5u)
                *(_DWORD*)(thisx + 2540) = 60;
        }
        if (*(_BYTE*)(thisx + 2562))
        {
            if (*(unsigned __int8*)(thisx + 2562) > 5u)
            {
                if (*(_BYTE*)(thisx + 2562) == 6 && *(int*)(thisx + 2540) >= 540)
                {
                    *(_DWORD*)(thisx + 108) = 26;
                    *(_BYTE*)(thisx + 2516) = 2;
                }
            }
            else if (!(*(_DWORD*)(thisx + 2540) % 60))
            {
                v11 = 0;
                switch (*(_BYTE*)(thisx + 2562))
                {
                case 1:
                    wsprintfA(String, byte_4B38E4);
                    v11 = 100;
                    break;
                case 2:
                    wsprintfA(String, byte_4B38F4);
                    v11 = 200;
                    break;
                case 3:
                    wsprintfA(String, byte_4B3914);
                    v11 = -100;
                    break;
                case 4:
                    wsprintfA(String, byte_4B392C);
                    v11 = 50;
                    break;
                case 5:
                    wsprintfA(String, byte_4B3944);
                    v11 = 100;
                    break;
                default:
                    break;
                }
                v14 = (_BYTE*)(thisx + 2580);
                v8 = 28 * (*(unsigned __int8*)(thisx + 2562) - 1) + 52;
                LOBYTE(v15) = *(_BYTE*)(thisx + 2 * *(unsigned __int8*)(thisx + 2562) + 2562);
                LOBYTE(v13) = (unsigned __int8)v15 % 10;
                LOBYTE(v15) = (unsigned __int8)v15 / 10;
                v10 = 0;
                if ((unsigned __int8)v15 < 4u)
                    v10 = thisx + 244 * (unsigned __int8)v15 + 1392;
                if (*v14)
                {
                    if (*v14 == 1 && v10)
                    {
                        v7 = (_DWORD*)(28 * (unsigned __int8)v13 + v10);
                        sub_47B91A(168, v8, (LPCSTR)(v10 + 172), 0, dword_4B9248);
                        v5 = dword_4B9248;
                        v3 = unknown_libname_18((char*)(36 * *v7 + dword_4B92E0));
                        sub_47B91A(168, v8 + 12, v3, 0, v5);
                    }
                    else if (*v14 == 2 && v10)
                    {
                        v9 = v8 + 12;
                        wsprintfA(String, "%4d", v11);
                        sub_47B7ED(248, v9, String, 0, dword_4B9248);
                        sub_47B91A(280, v9, byte_4B3964, 0, dword_4B9248);
                        *(_DWORD*)(v10 + 168) += v11;
                    }
                }
                else
                {
                    sub_47B91A(32, v8, String, 0, dword_4B9248);
                }
                if (v10 && *v14 && (unsigned __int8)*v14 <= 2u && *(_BYTE*)(thisx + 2562) != 3)
                    sub_43FFC3((_DWORD*)unk_4BDB28, *(_DWORD*)(thisx + 2528), -1, 100, 100, 0);
                if (++ * v14 == 4)
                {
                    ++* (_BYTE*)(thisx + 2562);
                    *v14 = 0;
                    *(_DWORD*)(thisx + 2540) = 0;
                }
            }
        }
        else if (*(_DWORD*)(thisx + 2540) == 260)
        {
            sub_456D33((const CHAR*)thisx, aKkResult1Wav, 0, 0);
        }
        else if (*(_DWORD*)(thisx + 2540) == 500)
        {
            sub_456D33((const CHAR*)thisx, aKkResult2Wav, 1, 0);
            sub_47FA81((int*)(thisx + 736));
            *(_DWORD*)(thisx + 2540) = 0;
            *(_BYTE*)(thisx + 2562) = 1;
        }
        if (!*(_DWORD*)(thisx + 2540))
        {
            if (*(_BYTE*)(thisx + 2562))
            {
                if (*(_BYTE*)(thisx + 2562) == 6)
                    sub_47F9D6(thisx + 736, byte_4B39D8, 4);
            }
            else
            {
                sub_47F9D6(thisx + 736, byte_4B3968, 4);
            }
        }
        ++* (_DWORD*)(thisx + 2540);
    }
    sub_49C15E((int)v18);
    v18[0] = dword_4B9248;
    sub_49AB05((int)unk_4BDC60, v18);
    sub_47F211(thisx + 736);
    return sub_47F98B((_DWORD*)(thisx + 736));
}

 
void sub_471F33(int thisx)
{
    void* v1; // esp
    unsigned __int8 v2; // al
    _BYTE* v3; // eax
    char v5[1024]; // [esp+4h] [ebp-18D4h] BYREF
    int v6; // [esp+404h] [ebp-14D4h]
    int v7; // [esp+408h] [ebp-14D0h]
    int v8; // [esp+40Ch] [ebp-14CCh]
    int v9; // [esp+410h] [ebp-14C8h]
    _BYTE* v10; // [esp+414h] [ebp-14C4h]
    CHAR FileName[64]; // [esp+418h] [ebp-14C0h] BYREF
    int v12[15]; // [esp+458h] [ebp-1480h] BYREF
    int m; // [esp+494h] [ebp-1444h]
    int v14; // [esp+498h] [ebp-1440h]
    int k; // [esp+49Ch] [ebp-143Ch]
    int v16; // [esp+4A0h] [ebp-1438h]
    int j; // [esp+4A4h] [ebp-1434h]
    int v18; // [esp+4A8h] [ebp-1430h]
    void* v19[4]; // [esp+4ACh] [ebp-142Ch] BYREF
    int v20[1280]; // [esp+4BCh] [ebp-141Ch] BYREF
    int i; // [esp+18BCh] [ebp-1Ch]
    int v22; // [esp+18C0h] [ebp-18h] BYREF
    int v23; // [esp+18C4h] [ebp-14h]
    int v24; // [esp+18C8h] [ebp-10h]
    int v25; // [esp+18D4h] [ebp-4h]

    v1 = alloca(6348);
    *(_DWORD*)(thisx + 104) = 26;
    *(_DWORD*)(thisx + 2540) = 0;
    *(_BYTE*)(thisx + 2516) = 1;
    *(_BYTE*)(thisx + 2562) = 0;
    *(_DWORD*)(thisx + 2528) = 0;
    *(_DWORD*)(thisx + 2540) = 0;
    for (i = 0; i < dword_4B9368; ++i)
    {
        for (j = 0; j < (int)dword_4B93A0; ++j)
            *(_DWORD*)(*((_DWORD*)dword_4B9360 + i) + 4 * j) = 0;
    }
    memset((void*)(thisx + 13044), 0, 8u);
    memset((void*)(thisx + 2564), 0, 0x10u);
    v18 = thisx + 1392;
    for (i = 0; i < 4; ++i)
    {
        v14 = 1;
        v16 = *(_DWORD*)(thisx + 244 * i + 1560);
        for (k = 0; k < 4; ++k)
        {
            if (v16 < *(_DWORD*)(thisx + 244 * k + 1560))
                ++v14;
        }
        *(_BYTE*)(i + thisx + 13044) = v14;
    }
    for (i = 1; i < 5; ++i)
    {
        for (m = 0; m < 4; ++m)
        {
            if (*(unsigned __int8*)(m + thisx + 13044) == i)
                ++* (_BYTE*)(i + thisx + 13047);
        }
    }
    sub_402080((int)v20, 20, 256, (void(*)(int))sub_48A44E);
    sub_482BF0((_DWORD*)v19);
    v25 = 0;
    sub_482C74((int)v19, aDemoKkResult3T);
    v24 = sub_489927((void*)(thisx + 128), (int)v19, (int)v20, 256, &v22);
    if (v24 >= 0)
    {
        *(_WORD*)(thisx + 11404) = sub_485ED0((int)v20, v22, a1st_0, -1);
        *(_WORD*)(thisx + 11406) = sub_485ED0((int)v20, v22, a2nd_0, -1);
        *(_WORD*)(thisx + 11408) = sub_485ED0((int)v20, v22, a3rd_0, -1);
    }
    sub_482C42(v19);
    sub_4898D3((_DWORD*)(thisx + 128));
    sub_4891E4((_DWORD*)(thisx + 128), aDemoKkResult3T_0);
    sub_47F958((_DWORD*)(thisx + 736));
    v23 = 1;
    for (i = 0; i < 5; ++i)
    {
        sub_49DB90(v12);
        v12[14] = 8 * i + 4952720;
        wsprintfA(FileName, "Graphic\\KK_Result3_Body%02d.bmp", i + 1);
        if (sub_49DA45((_DWORD*)unk_4BDC60, FileName, (int)v12) >= 0 && v23)
        {
            dword_4B9234 = v12[0];
            v23 = 0;
        }
    }
    for (i = 0; i < 4; ++i)
    {
        v10 = (_BYTE*)sub_472F91((_DWORD*)thisx + 244 * i + 1392);
        if (v10)
        {
            LOBYTE(v8) = sub_4016F0(v10);
            v2 = sub_401710(v10);
            LOWORD(v9) = v2;
            *(_DWORD*)(*((_DWORD*)dword_4B9360 + (unsigned __int8)v8) + 4 * v2) = 1;
        }
    }
    sub_4680EF();
    for (i = 0; i < 4; ++i)
    {
        v7 = *(__int16*)(thisx + 244 * i + 1630) + 1;
        v3 = (_BYTE*)sub_472F91((_DWORD*)thisx + 244 * i + 1392);
        LOWORD(v6) = (unsigned __int8)sub_401710(v3);
        sub_4784EA(v7, (_DWORD)v5);
        sub_485DFD((int)dword_4B93A4 + 24 * (unsigned __int16)v6, (int)v5);
        sub_4A0AE7((void*)(8 * i + 4952720), (int)v5, 256);
    }
    v25 = -1;
    sub_482C2F(v19);
} 
_DWORD* sub_4724BD(int thisx)
{
    char v3; // [esp+10h] [ebp-170h]
    int v4; // [esp+14h] [ebp-16Ch]
    int v5; // [esp+1Ch] [ebp-164h]
    _DWORD* v6; // [esp+20h] [ebp-160h]
    CHAR String[2]; // [esp+24h] [ebp-15Ch] BYREF
    char v8; // [esp+26h] [ebp-15Ah]
    __int16 v9; // [esp+27h] [ebp-159h]
    char v10; // [esp+29h] [ebp-157h]
    __int16 v11; // [esp+2Ah] [ebp-156h]
    char v12; // [esp+2Ch] [ebp-154h]
    __int16 v13; // [esp+2Dh] [ebp-153h]
    char v14; // [esp+2Fh] [ebp-151h]
    __int16 v15; // [esp+30h] [ebp-150h]
    char v16; // [esp+32h] [ebp-14Eh]
    __int16 v17; // [esp+33h] [ebp-14Dh]
    char v18; // [esp+35h] [ebp-14Bh]
    __int16 v19; // [esp+36h] [ebp-14Ah]
    char v20; // [esp+38h] [ebp-148h]
    __int16 v21; // [esp+39h] [ebp-147h]
    char v22; // [esp+3Bh] [ebp-145h]
    __int16 v23; // [esp+3Ch] [ebp-144h]
    char v24; // [esp+3Eh] [ebp-142h]
    __int16 v25; // [esp+3Fh] [ebp-141h]
    char v26; // [esp+41h] [ebp-13Fh]
    int v27; // [esp+44h] [ebp-13Ch]
    int j; // [esp+48h] [ebp-138h]
    int v29; // [esp+4Ch] [ebp-134h]
    int v30; // [esp+50h] [ebp-130h]
    int v31; // [esp+54h] [ebp-12Ch]
    int v32; // [esp+58h] [ebp-128h]
    int v33; // [esp+5Ch] [ebp-124h]
    CHAR v34[256]; // [esp+60h] [ebp-120h] BYREF
    _WORD* v35; // [esp+160h] [ebp-20h]
    int i; // [esp+164h] [ebp-1Ch]
    int v37; // [esp+168h] [ebp-18h]
    _WORD* v38; // [esp+16Ch] [ebp-14h]
    int v39; // [esp+170h] [ebp-10h]
    int v40; // [esp+174h] [ebp-Ch]
    int v41; // [esp+178h] [ebp-8h]
    int v42; // [esp+17Ch] [ebp-4h]

    if (*(_BYTE*)(thisx + 2562))
    {
        if (*(unsigned __int8*)(thisx + 2562) > 4u)
        {
            if (*(_BYTE*)(thisx + 2562) == 5)
            {
                if (*(_DWORD*)(thisx + 2540) == 1)
                    sub_47F9D6(thisx + 736, byte_4B3CB0, 4);
                if (sub_475E70((_DWORD*)thisx + 736) >= 300)
                {
                    *(_DWORD*)(thisx + 108) = 27;
                    *(_BYTE*)(thisx + 2516) = 2;
                }
            }
        }
        else
        {
            v41 = 4 - (*(unsigned __int8*)(thisx + 2562) - 1);
            v38 = (_WORD*)(thisx + 2564);
            v39 = *(unsigned __int8*)(v41 + thisx + 13047);
            v42 = v39 - *(unsigned __int16*)(thisx + 2564);
            if (*(_DWORD*)(thisx + 2540) == 1)
            {
                v35 = (_WORD*)(thisx + 2574);
                while (1)
                {
                    *v38 = *(unsigned __int8*)(v41 + thisx + 13047);
                    if (*v38)
                        break;
                    --v41;
                }
                *(_BYTE*)(thisx + 2562) = 5 - v41;
                v37 = 0;
                for (i = 0; i < 4; ++i)
                {
                    if (*(unsigned __int8*)(i + thisx + 13044) == v41)
                        *(_WORD*)(thisx + 2 * v37++ + 2566) = i;
                }
                sub_47FBA3(thisx + 736);
                if (*v35)
                {
                    if (v41 == 1)
                        sub_47F9D6(thisx + 736, byte_4B3B28, 4);
                }
                else
                {
                    sub_47F9D6(thisx + 736, byte_4B3B1C, 4);
                }
                ++* v35;
                switch (v41)
                {
                case 1:
                    sub_47FADE(thisx + 736, byte_4B3B34);
                    break;
                case 2:
                    sub_47FADE(thisx + 736, byte_4B3B44);
                    break;
                case 3:
                    sub_47FADE(thisx + 736, byte_4B3B54);
                    break;
                case 4:
                    sub_47FADE(thisx + 736, byte_4B3B64);
                    break;
                default:
                    break;
                }
            }
            else if (*(_DWORD*)(thisx + 2540) == 2)
            {
                if (*v38)
                {
                    switch (v42)
                    {
                    case 1:
                        sub_47FADE(thisx + 736, byte_4B3B74);
                        break;
                    case 2:
                        sub_47FA81((int*)(thisx + 736));
                        sub_47FBA3(thisx + 736);
                        sub_47FADE(thisx + 736, byte_4B3B80);
                        break;
                    case 3:
                        sub_47FADE(thisx + 736, byte_4B3B8C);
                        break;
                    }
                    v32 = *(unsigned __int16*)(thisx + 2 * v42 + 2566);
                    v33 = thisx + 244 * v32 + 1392;
                    if (!v42)
                    {
                        *(_WORD*)String = word_4B3B98;
                        v8 = byte_4B3B9A;
                        v9 = word_4B3B9C;
                        v10 = byte_4B3B9E;
                        v11 = word_4B3BA0;
                        v12 = byte_4B3BA2;
                        v13 = word_4B3BA4;
                        v14 = byte_4B3BA6;
                        v15 = word_4B3BA8;
                        v16 = byte_4B3BAA;
                        v17 = word_4B3BAC;
                        v18 = byte_4B3BAE;
                        v19 = word_4B3BB0;
                        v20 = byte_4B3BB2;
                        v21 = word_4B3BB4;
                        v22 = byte_4B3BB6;
                        v23 = word_4B3BB8;
                        v24 = byte_4B3BBA;
                        v25 = word_4B3BBC;
                        v26 = byte_4B3BBE;
                        v29 = *(_DWORD*)(v33 + 168);
                        if (v29 < 0)
                        {
                            sub_47FADE(thisx + 736, byte_4B3BC0);
                            v29 = -v29;
                        }
                        v30 = 1;
                        v27 = 1;
                        v31 = v29;
                        while (v31 > 9)
                        {
                            v31 /= 10;
                            ++v30;
                            v27 *= 10;
                        }
                        for (j = 0; j < v30; ++j)
                        {
                            sub_47FADE(thisx + 736, &String[3 * (v29 / v27 % 10)]);
                            v29 %= 10 * v27;
                            v27 /= 10;
                        }
                        sub_47FADE(thisx + 736, byte_4B3BC4);
                    }
                    wsprintfA(v34, aS_7, v33 + 172);
                    sub_47FADE(thisx + 736, v34);
                    if (v42 == 3)
                        sub_47FADE(thisx + 736, byte_4B3BE0);
                    else
                        sub_47FADE(thisx + 736, byte_4B3BD8);
                    if (v41 <= 3 && v32 < 4)
                    {
                        v3 = *(_BYTE*)(v33 + 4);
                        v5 = *(_DWORD*)v33;
                        v4 = 0;
                        switch (v39)
                        {
                        case 2:
                            if (v41 == 2)
                                v4 = 16 * v42 - 12;
                            else
                                v4 = 16 * v42 - 4;
                            break;
                        case 3:
                            if (v41 == 1)
                                v4 = 16 * v42 - 16;
                            else
                                v4 = 10 * v42 - 16;
                            break;
                        case 4:
                            v4 = 12 * v42 - 16;
                            break;
                        }
                        v6 = (_DWORD*)sub_488E1E((_DWORD*)(thisx + 128), *(_DWORD*)(thisx + 2528) + 2);
                        if (v6)
                        {
                            sub_475E50(v6, v3 + dword_4B9234);
                            sub_475DB0(v6, v5);
                            sub_475E30((char*)v6, v32);
                            sub_475E10(v6, v4);
                            sub_48DC0D((int)v6, *(__int16*)(thisx + 2 * v41 + 11402));
                        }
                        ++* (_DWORD*)(thisx + 2528);
                    }
                }
                else
                {
                    if (v42 == 2 || v42 == 4)
                    {
                        sub_47FA81((int*)(thisx + 736));
                        sub_47FBA3(thisx + 736);
                    }
                    if (v42 == 4)
                    {
                        sub_47FADE(thisx + 736, byte_4B3C40);
                    }
                    else
                    {
                        switch (v41)
                        {
                        case 1:
                            sub_47FADE(thisx + 736, byte_4B3C34);
                            break;
                        case 2:
                            sub_47FADE(thisx + 736, byte_4B3C28);
                            break;
                        case 3:
                            sub_47FADE(thisx + 736, byte_4B3C1C);
                            break;
                        case 4:
                            sub_47FADE(thisx + 736, byte_4B3BEC);
                            break;
                        default:
                            break;
                        }
                    }
        }
      }
            if (*v38)
                v40 = 60;
            else
                v40 = 360;
            if (v41 == 4 && sub_475E70((_DWORD*)thisx + 736) >= 120
                || *v38 == 1 && v39 == 1 && *(int*)(thisx + 2540) > 3
                || *v38 == 3 && v39 == 3 && *(int*)(thisx + 2540) > 3
                || *v38 && *(int*)(thisx + 2540) >= 241
                || !*v38 && *(int*)(thisx + 2540) > 420)
            {
                if (*v38)
                {
                    --* v38;
                    *(_DWORD*)(thisx + 2540) = 1;
                }
                else
                {
                    ++* (_BYTE*)(thisx + 2562);
                    *(_DWORD*)(thisx + 2540) = 0;
                }
            }
        }
    }
    else
    {
        if (!*(_DWORD*)(thisx + 2540))
            sub_47F9D6(thisx + 736, byte_4B3AB8, 4);
        if (sub_475E70((_DWORD*)thisx + 736) > 120)
        {
            *(_DWORD*)(thisx + 2540) = 0;
            ++* (_BYTE*)(thisx + 2562);
        }
    }
    ++* (_DWORD*)(thisx + 2540);
    sub_488981((_DWORD*)thisx + 128);
    sub_486476((_DWORD*)(thisx + 128));
    sub_47F211(thisx + 736);
    return sub_47F98B((_DWORD*)(thisx + 736));
}

 
int sub_472F91(int* thisx)
{
    if (*thisx >= 0 && *thisx < (int)Size)
        return 36 * *thisx + dword_4B92E0;
    else
        return 0;
}

 
void sub_472FC4(int thisx)
{
    _DWORD* v2; // [esp+4h] [ebp-184h]
    int v3; // [esp+8h] [ebp-180h]
    int v4; // [esp+Ch] [ebp-17Ch] BYREF
    int v5; // [esp+10h] [ebp-178h]
    int v6; // [esp+14h] [ebp-174h]
    int v7; // [esp+1Ch] [ebp-16Ch]
    int v8; // [esp+20h] [ebp-168h]
    int v9; // [esp+44h] [ebp-144h]
    int i; // [esp+48h] [ebp-140h]
    int v11; // [esp+4Ch] [ebp-13Ch] BYREF
    int v12; // [esp+50h] [ebp-138h]
    int v13; // [esp+54h] [ebp-134h]
    int v14; // [esp+58h] [ebp-130h]
    int v15; // [esp+5Ch] [ebp-12Ch]
    int v16; // [esp+60h] [ebp-128h]
    int v17; // [esp+70h] [ebp-118h]
    CHAR FileName[256]; // [esp+88h] [ebp-100h] BYREF

    *(_DWORD*)(thisx + 104) = 21;
    *(_BYTE*)(thisx + 2516) = 1;
    *(_DWORD*)(thisx + 2540) = 0;
    *(_BYTE*)(thisx + 2604) = 0;
    *(_BYTE*)(thisx + 2562) = 0;
    *(_DWORD*)(thisx + 2528) = 0;
    sub_49DB90(&v11);
    v12 = 0;
    v13 = 0;
    v14 = 32;
    v15 = 32;
    v16 = 2;
    v17 = 0;
    v11 = -1;
    sub_49DA45((_DWORD*)unk_4BDC60, aGraphicStagese_0, (int)&v11);
    if (v11 <= 0)
        dword_4B9244 = 0;
    else
        dword_4B9244 = v11;
    for (i = 0; i < *(_DWORD*)(thisx + 13388); ++i)
    {
        v12 = 0;
        v13 = 0;
        v14 = -1;
        v15 = -1;
        v16 = 1;
        v17 = -1;
        v11 = -1;
        wsprintfA(FileName, "Stage\\Stage%02d_Select.bmp", i + 1);
        sub_49DA45((_DWORD*)unk_4BDC60, FileName, (int)&v11);
        sub_475770((_WORD*)(*(_DWORD*)(thisx + 13392) + 20 * i), v11);
        if (v11 <= 0)
        {
            v3 = sub_49CB92((int)unk_4BDC60, -1, 32, 32, 0, 0);
            if (v3 != -1)
            {
                wsprintfA(FileName, "Stage\\Stage%02d.bmp", i + 1);
                if (sub_49B9E0((_DWORD*)unk_4BDC60, FileName))
                {
                    v2 = (_DWORD*)sub_475750((_DWORD*)unk_4BDC60);
                    v9 = unknown_libname_13(v2);
                    v12 = v9 / 2 - 88;
                    v13 = 0;
                    v14 = 176;
                    v15 = 176;
                    v16 = 1;
                    v17 = -1;
                    v11 = -1;
                    if (sub_49D318((int)unk_4BDC60, (int)&v11))
                    {
                        sub_49C15E((int)&v4);
                        v5 = 0;
                        v6 = 0;
                        v4 = v11;
                        v7 = 46;
                        v8 = 46;
                        sub_49CC5B((short*)unk_4BDC60, v3, &v4);
                        v5 = 0;
                        v6 = 0;
                        v4 = dword_4B9244;
                        v7 = 256;
                        v8 = 256;
                        sub_49CC5B((short*)unk_4BDC60, v3, &v4);
                        sub_475770((_WORD*)(20 * i + *(_DWORD*)(thisx + 13392)), v3);
                        sub_49DA8A((_DWORD*)unk_4BDC60, v11);
                    }
                }
            }
        }
    }
    sub_4737C8(thisx);
} 
unsigned __int16* sub_47336A(int thisx)
{
    int v1; // esi
    int v2; // esi
    int i; // [esp+8h] [ebp-5Ch]
    int v6; // [esp+Ch] [ebp-58h]
    int v7; // [esp+10h] [ebp-54h]
    int v8; // [esp+14h] [ebp-50h]
    int v9; // [esp+18h] [ebp-4Ch]
    int v10; // [esp+1Ch] [ebp-48h]
    int v11; // [esp+20h] [ebp-44h]
    int v12; // [esp+24h] [ebp-40h]
    int v13[14]; // [esp+28h] [ebp-3Ch] BYREF
    int v14; // [esp+60h] [ebp-4h]

    v11 = 0;
    v10 = 0;
    v7 = 0;
    v14 = 0;
    v8 = 0;
    v9 = 0;
    if (!*(_BYTE*)(thisx + 2516))
    {
        sub_477F0C(0);
        v1 = sub_476D78(0);
        v11 = v1 - sub_476D29(0);
        v2 = sub_476CDA(0);
        v10 = v2 - sub_476C8B(0);
        v7 = sub_476DC7(0, 0);
        v14 = sub_476DC7(0, 1);
        v8 = sub_476DC7(0, 5);
        v9 = sub_476DC7(0, 6);
    }
    v12 = 0;
    if (*(_BYTE*)(thisx + 2604) && *(unsigned __int8*)(thisx + 2562) < (int)*(unsigned __int8*)(thisx + 2477))
    {
        if ((unsigned __int8)++ * (_BYTE*)(thisx + 2604) > 5u)
        {
            *(_BYTE*)(thisx + 2604) = 1;
            *(_DWORD*)(thisx + 2528) = rand() % (*(_DWORD*)(thisx + 13388) + 1);
            sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
            v12 = 1;
        }
    }
    else if (v11 && *(unsigned __int8*)(thisx + 2562) < (int)*(unsigned __int8*)(thisx + 2477))
    {
        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
        *(_DWORD*)(thisx + 2528) = (v11 + *(_DWORD*)(thisx + 2528) + *(_DWORD*)(thisx + 13388) + 1)
            % (*(_DWORD*)(thisx + 13388) + 1);
        v12 = 1;
    }
    else if (v10 && *(unsigned __int8*)(thisx + 2562) < (int)*(unsigned __int8*)(thisx + 2477))
    {
        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
        v6 = 10;
        if (*(_DWORD*)(thisx + 13388) + 1 < 10)
            v6 = 10 - (*(_DWORD*)(thisx + 13388) + 1);
        *(_DWORD*)(thisx + 2528) = (v6 * v10 + *(_DWORD*)(thisx + 2528) + *(_DWORD*)(thisx + 13388) + 1)
            % (*(_DWORD*)(thisx + 13388) + 1);
        v12 = 1;
    }
    if (v7)
    {
        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
        if (*(unsigned __int8*)(thisx + 2562) < (int)*(unsigned __int8*)(thisx + 2477))
            *(_BYTE*)(thisx + *(unsigned __int8*)(thisx + 2562) + 2478) = *(_BYTE*)(thisx + 2528);
        if ((unsigned __int8)++ * (_BYTE*)(thisx + 2562) >= *(unsigned __int8*)(thisx + 2477) + 1)
        {
            *(_DWORD*)(thisx + 108) = 23;
            *(_BYTE*)(thisx + 2516) = 2;
        }
        v12 = 1;
    }
    else if (v14)
    {
        if (*(_BYTE*)(thisx + 2562))
            --* (_BYTE*)(thisx + 2562);
        v12 = 1;
    }
    else if (v8)
    {
        *(_BYTE*)(thisx + 2604) = *(_BYTE*)(thisx + 2604) == 0;
    }
    else if (v9)
    {
        for (i = *(unsigned __int8*)(thisx + 2562); i < *(unsigned __int8*)(thisx + 2477); ++i)
            *(_BYTE*)(i + thisx + 2478) = rand() % (*(_DWORD*)(thisx + 13388) + 1);
        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
        *(_BYTE*)(thisx + 2562) = *(_BYTE*)(thisx + 2477) + 1;
        *(_DWORD*)(thisx + 108) = 23;
        *(_BYTE*)(thisx + 2516) = 2;
        v12 = 1;
    }
    if (v12)
        sub_4737C8(thisx);
    sub_49C15E((int)v13);
    v13[0] = dword_4B9248;
    return sub_49AB05((int)unk_4BDC60, v13);
}

 
void sub_4737C8(int thisx)
{
    const char* v1; // eax
    const char* v2; // eax
    int v3; // eax
    const CHAR* v4; // eax
    int v5; // [esp-4h] [ebp-150h]
    int v6; // [esp-4h] [ebp-150h]
    _DWORD* v8; // [esp+4h] [ebp-148h]
    int v9[14]; // [esp+8h] [ebp-144h] BYREF
    _DWORD* v10; // [esp+40h] [ebp-10Ch]
    int v11; // [esp+44h] [ebp-108h]
    int i; // [esp+48h] [ebp-104h]
    CHAR String[256]; // [esp+4Ch] [ebp-100h] BYREF

    sub_451EB5((_BYTE*)thisx, 1, 1);
    sub_452045((_BYTE*)thisx, 14, 0, 12, 3);
    sub_47B91A(128, 8, byte_4B3D54, 0, dword_4B9248);
    sub_452045((_BYTE*)thisx, 1, 4, 18, 2 * *(unsigned __int8*)(thisx + 2477) + 1);
    for (i = 0; i < *(unsigned __int8*)(thisx + 2477); ++i)
    {
        v11 = 16 * i + 40;
        if (i == *(unsigned __int8*)(thisx + 2562))
        {
            sub_47B91A(16, v11, asc_4B3D68, 0, dword_4B9248);
        }
        else
        {
            wsprintfA(String, "%d", i + 1);
            sub_47B7ED(16, v11, String, 0, dword_4B9248);
        }
        if (i < *(unsigned __int8*)(thisx + 2562))
        {
            if (*(_BYTE*)(i + thisx + 2478))
            {
                v10 = (_DWORD*)(20 * (*(unsigned __int8*)(i + thisx + 2478) - 1) + *(_DWORD*)(thisx + 13392));
                if (unknown_libname_26(v10))
                {
                    v1 = (const char*)unknown_libname_26(v10);
                    wsprintfA(String, "%s", v1);
                    String[28] = 0;
                    sub_47B91A(32, v11, String, 0, dword_4B9248);
                }
                else
                {
                    sub_47B91A(32, v11, byte_4B3D7C, 0, dword_4B9248);
                    wsprintfA(String, "%d", *(unsigned __int8*)(i + thisx + 2478));
                    sub_47BC5A(64, v11, String, 0, dword_4B9248);
                }
            }
            else
            {
                sub_47B91A(32, v11, byte_4B3D70, 0, dword_4B9248);
            }
        }
    }
    sub_452045((_BYTE*)thisx, 20, 4, 19, 10);
    if (*(unsigned __int8*)(thisx + 2562) >= (int)*(unsigned __int8*)(thisx + 2477))
    {
        sub_47B91A(188, 52, byte_4B3DE4, 0, dword_4B9248);
        sub_47B91A(168, 80, byte_4B3E00, 0, dword_4B9248);
    }
    else
    {
        v8 = 0;
        if (*(int*)(thisx + 2528) > 0 && *(_DWORD*)(thisx + 2528) <= *(_DWORD*)(thisx + 13388))
            v8 = (_DWORD*)(20 * (*(_DWORD*)(thisx + 2528) - 1) + *(_DWORD*)(thisx + 13392));
        if (*(_DWORD*)(thisx + 2528))
        {
            if (unknown_libname_26(v8))
            {
                v2 = (const char*)unknown_libname_26(v8);
                wsprintfA(String, "%s", v2);
            }
            else
            {
                wsprintfA(String, byte_4B3D9C);
            }
        }
        else
        {
            wsprintfA(String, byte_4B3D90);
        }
        String[34] = 0;
        v5 = dword_4B9248;
        v3 = lstrlenA(String);
        sub_47B91A(236 - 2 * v3, 40, String, 0, v5);
        if (v8 && !unknown_libname_26(v8))
        {
            wsprintfA(String, "%02d", *(_DWORD*)(thisx + 2528));
            sub_47B7ED(244, 40, String, 0, dword_4B9248);
        }
        sub_49C15E((int)v9);
        v9[1] = 220;
        v9[2] = 64;
        if (v8)
        {
            v9[0] = sub_475790((short*)v8);
            if (!v9[0])
                v9[0] = dword_4B9244 + *(_DWORD*)(thisx + 2528) + 1;
        }
        else
        {
            v9[0] = dword_4B9244 + 1;
        }
        sub_49CC5B((short*)unk_4BDC60, dword_4B9248, v9);
        if (v8)
        {
            if (unknown_libname_12(v8))
            {
                v6 = dword_4B9248;
                v4 = (const CHAR*)unknown_libname_12(v8);
                sub_47B91A(24, 208, v4, 0, v6);
            }
        }
        else
        {
            sub_47B91A(24, 208, byte_4B3DB8, 0, dword_4B9248);
        }
    }
}

 
int sub_473CFA(int thisx)
{
	*(_DWORD*)(thisx + 104) = 27;
	*(_BYTE*)(thisx + 2516) = 1;
	sub_4898D3((_DWORD*)(thisx + 128));
	sub_4891E4((_DWORD*)(thisx + 128), aDemoKkEndTxt);
	return sub_456D33((const CHAR*)thisx, aKkEndWav, 1, 0);
}

 
_DWORD*  sub_473D4B(int thisx)
{
    if (!*(_BYTE*)(thisx + 2516))
    {
        sub_477F0C(0);
        if (sub_476DC7(0, 0))
            return (_DWORD*)sub_453B66(thisx);
    }
    sub_488981((_DWORD*)thisx + 128);
    return sub_486476((_DWORD*)(thisx + 128));
}
 
_DWORD* sub_473DA5(_DWORD* thisx, int a2, int a3)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[4034] = a2;
    return result;
}

 
int sub_473F53(_DWORD* thisx)
{
    thisx[26] = 1;
    thisx[31] = 7;
    return sub_467AC6((int)thisx, aDdEnddemoTxt);
}

 
int(*** sub_473F7F(_DWORD* thisx))(_DWORD, int)
{
    int v1; // eax
    _DWORD* v2; // eax

    sub_45F935((int)thisx);
    sub_45FD81((int)thisx);
    thisx[3276] = -1;
    v1 = unknown_libname_10(thisx + 32);
    sub_49DA8A((int*)unk_4BDC60, v1);
    if (sub_4894E3(thisx + 32, 0) >= 0)
    {
        v2 = (_DWORD*)sub_4894E3(thisx + 32, 0);
        sub_43FED3((int*)unk_4BDB28, v2);
    }
    thisx[323] = 0;
    return sub_4898D3(thisx + 32);
}
 
LPSTR sub_474011(CHAR* thisx, LPCSTR lpString2)
{
    return lstrcpyA(thisx + 16140, lpString2);
}

 
int sub_474032(char* thisx, Concurrency::details::SchedulerBase* a2)
{
    int v3; // [esp+4h] [ebp-50h]
    int v4; // [esp+8h] [ebp-4Ch]
    int v5; // [esp+Ch] [ebp-48h]
    Concurrency::details::SchedulerBase* v7; // [esp+18h] [ebp-3Ch]
    int v8; // [esp+20h] [ebp-34h]
    int v9; // [esp+24h] [ebp-30h]
    int v10; // [esp+2Ch] [ebp-28h]
    int i; // [esp+38h] [ebp-1Ch]
    int v12; // [esp+3Ch] [ebp-18h]
    int v13; // [esp+44h] [ebp-10h]
    int v14; // [esp+48h] [ebp-Ch]
    char v15; // [esp+4Ch] [ebp-8h]

    v13 = sub_426090((_DWORD*)a2) / 100;
    v12 = sub_4260B0((_DWORD*)a2) / 100;
    v14 = sub_4260D0((_DWORD*)a2) / 100;
    sub_425EF0((char*)a2);
    v15 = sub_426070((char*)a2);
    sub_425D70((_DWORD*)a2);
    for (i = 0; i < 8; ++i)
    {
        v7 = (Concurrency::details::SchedulerBase*)&thisx[612 * i + 2628];
        if (a2 != v7
            && unknown_libname_7((_DWORD*)v7)
            && Concurrency::details::SchedulerBase::GetSchedulerProxy(v7) == (struct Concurrency::ISchedulerProxy*)15
            && (byte_4B99CC || v15 != sub_426070((char*)v7)))
        {
            v9 = sub_4260D0((_DWORD*)v7) / 100;
            v5 = v14 - v9 <= 0 ? v9 - v14 : v14 - v9;
            if (v5 <= 16)
            {
                v10 = sub_426090((_DWORD*)v7) / 100;
                v8 = sub_4260B0((_DWORD*)v7) / 100;
                v4 = v13 - v10 <= 0 ? v10 - v13 : v13 - v10;
                if (v4 < 32)
                {
                    v3 = v12 - v8 <= 0 ? v8 - v12 : v12 - v8;
                    if (v3 <= 5)
                        return 1;
                }
            }
        }
    }
    return 0;
}

 
int sub_4741F8(int thisx, char a1, char a2)
{
	return sub_489C16((void*)(thisx + 128), a1, a2);
}

 
int sub_47421B(char* thisx)
{
    return sub_475E90(thisx + 128);
}

 
BOOL sub_474234(void* thisx, Concurrency::details::ContextBase* a2, int a3)
{
    struct _TaskCollectionBase* ExecutingCollection; // eax
    int* v5; // eax
    int v6; // eax
    int* v7; // eax
    int* v8; // eax
    int v9; // edx
    int v10; // eax
    int v11; // eax
    int v12; // eax
    int v13; // eax
    int v14; // eax
    int v15; // eax
    int v16; // eax
    int v17; // eax
    int v18; // eax
    int v19; // eax
    char v20[8]; // [esp+4h] [ebp-58h] BYREF
    int v21[4]; // [esp+Ch] [ebp-50h] BYREF
    char v22[16]; // [esp+1Ch] [ebp-40h] BYREF
    int v23; // [esp+2Ch] [ebp-30h]
    int v24; // [esp+30h] [ebp-2Ch]
    int v25; // [esp+34h] [ebp-28h]
    int v26; // [esp+38h] [ebp-24h]
    int v27; // [esp+3Ch] [ebp-20h]
    int v28; // [esp+40h] [ebp-1Ch]
    int v29; // [esp+44h] [ebp-18h]
    int v30; // [esp+48h] [ebp-14h]
    int v31; // [esp+4Ch] [ebp-10h]
    int v32; // [esp+50h] [ebp-Ch]
    int v33; // [esp+54h] [ebp-8h]
    char* v34; // [esp+58h] [ebp-4h]

    v34 = (char*)sub_41C915(a3);
    if (!v34)
        return 0;
    ExecutingCollection = Concurrency::details::ContextBase::GetExecutingCollection(a2);
    v5 = sub_475F00((_DWORD*)a2, (_DWORD*)v22, (int)ExecutingCollection);
    v29 = *v5;
    v30 = v5[1];
    v31 = v5[2];
    v32 = v5[3];
    v6 = sub_425D70((_DWORD*)a3);
    v7 = sub_425BD0(v34, v21, v6, 0);
    v25 = *v7;
    v26 = v7[1];
    v27 = v7[2];
    v28 = v7[3];
    v8 = sub_475ED0((_DWORD*)a2, (_DWORD*)v20);
    v9 = v8[1];
    v23 = *v8;
    v24 = v9;
    if (!v29 && !v30 && !v31 && !v32)
        return 0;
    if (!v25 && !v26 && !v27 && !v28)
        return 0;
    v33 = sub_4260B0((_DWORD*)a3) / 100;
    if (sub_4754B0((char*)a2) == 2 || sub_4754B0((char*)a2) == 3)
    {
        v10 = sub_475F40((_DWORD*)a2);
        v29 += v10;
        v11 = unknown_libname_19((_DWORD*)a2);
        v30 -= v11 / 100;
        v12 = sub_475F40((_DWORD*)a2);
        v31 += v12;
        v13 = unknown_libname_19((_DWORD*)a2);
        v32 -= v13 / 100;
        v14 = sub_474DD0((_DWORD*)a2);
        v23 += v14;
        v15 = sub_474DD0((_DWORD*)a2);
        v24 += v15;
    }
    if (v33 < v23 || v33 > v24)
        return 0;
    v16 = sub_426090((_DWORD*)a3);
    v25 += v16 / 100;
    v17 = sub_4260D0((_DWORD*)a3);
    v26 += v17 / 100;
    v18 = sub_426090((_DWORD*)a3);
    v27 += v18 / 100;
    v19 = sub_4260D0((_DWORD*)a3);
    v28 += v19 / 100;
    return v29 - v25 <= v27 - v25 && v25 - v29 <= v31 - v29 && v30 - v26 <= v28 - v26 && v26 - v30 <= v32 - v30;
} 
int sub_474471(int thisx, unsigned __int16 a1)
{
    if (a1)
        return sub_489C74((void*)(thisx + 128), a1 - 1);
    else
        return 0;
}

 
__int16 sub_4744A9(_DWORD* thisx, char a1, char a2)
{
	return sub_489C95(thisx + 32, a1, a2);
}
 
_DWORD* sub_4744CC(_DWORD* thisx, int a2)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[4100] = a2;
    return result;
}

 
int __fastcall sub_4744E5(int a1)
{
    int result; // eax
    int kk; // [esp+8h] [ebp-38h]
    _DWORD* v4; // [esp+Ch] [ebp-34h]
    int n; // [esp+10h] [ebp-30h]
    int k; // [esp+14h] [ebp-2Ch]
    int m; // [esp+14h] [ebp-2Ch]
    int ii; // [esp+14h] [ebp-2Ch]
    int jj; // [esp+14h] [ebp-2Ch]
    int j; // [esp+18h] [ebp-28h]
    int i; // [esp+1Ch] [ebp-24h]
    int mm; // [esp+20h] [ebp-20h]
    char* v13; // [esp+24h] [ebp-1Ch]
    int v14; // [esp+28h] [ebp-18h]
    int v15; // [esp+2Ch] [ebp-14h]
    int v16; // [esp+30h] [ebp-10h]
    int v17; // [esp+34h] [ebp-Ch]
    int v18; // [esp+38h] [ebp-8h]
    int v19; // [esp+38h] [ebp-8h]
    int v20; // [esp+3Ch] [ebp-4h]

    result = a1;
    if (*(_DWORD*)(a1 + 16400))
    {
        *(_DWORD*)(a1 + 16400) = 0;
        v15 = sub_4897D0((_BYTE*)(a1 + 128)) / 8;
        v14 = sub_4261D0((char*)(a1 + 128));
        v13 = unknown_libname_20((char*)(a1 + 128));
        for (i = 0; i < v14; ++i)
        {
            for (j = 0; j < v15; ++j)
            {
                if (sub_482A7E((int)v13, j, i))
                {
                    for (k = j + 1; k < v15 && sub_482A7E((int)v13, k, i); ++k)
                        ;
                    v18 = k;
                    for (m = i + 1; m < v15; ++m)
                    {
                        for (n = j; n < v18 && sub_482A7E((int)v13, n, m); ++n)
                            ;
                        if (n < v18)
                            break;
                    }
                    v16 = j - 1;
                    v17 = i - 1;
                    v19 = v18 + 1;
                    v20 = m + 1;
                    for (ii = 0; ii < (unsigned __int8)byte_4B9985; ++ii)
                    {
                        if (sub_41BEA6((_DWORD*)(a1 + 612 * ii + 2628)))
                        {
                            v4 = (_DWORD*)sub_41F0A9((_DWORD*)a1 + 612 * ii + 2628);
                            sub_424C9A(v4, v20, v16, v17, v19, v20);
                            sub_425617(v4, v16, v17, v19, v20);
                        }
                    }
                    for (jj = i; jj < v20 - 1; ++jj)
                    {
                        for (kk = j; kk < v19 - 1; ++kk)
                            sub_482A1B((int)v13, kk, jj, 0);
                    }
                }
            }
        }
        for (mm = 0; ; ++mm)
        {
            result = (unsigned __int8)byte_4B9985;
            if (mm >= (unsigned __int8)byte_4B9985)
                break;
            if (sub_41BEA6((_DWORD*)(a1 + 612 * mm + 2628)))
                sub_41F0A9((_DWORD*)a1 + 612 * mm + 2628);
        }
    }
    return result;
}

 
void sub_4747D2(_DWORD* thisx, int a2, int a3)
{
    if (a2)
    {
        if (a2 == 1)
            sub_489473(thisx + 32, a3, 100, 100, 0);
    }
    else if (a3 >= 0 && a3 < 60)
    {
        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[a3], -1, 100, 100, 0);
    }
}

 
void sub_47482E(int thisx)
{
	*(_DWORD*)(thisx + 104) = 4;
	*(_DWORD*)(thisx + 2540) = 0;
	sub_480054(thisx + 15644, (int)&unk_4B3E50);
	sub_475630((_BYTE*)(thisx + 15644), 12, 2, 17, 4);
	sub_475690((_BYTE*)(thisx + 15644), 2);
	streambuf::unbuffered((streambuf*)(thisx + 15644), 0);
	sub_475670((_DWORD*)(thisx + 15644), 0);
	(*(void(**)(int, _DWORD))(*(_DWORD*)(thisx + 15680) + 4))(thisx + 15680, 0);
	(*(void(**)(int, _DWORD))(*(_DWORD*)(thisx + 15716) + 4))(thisx + 15716, 0);
	(*(void(**)(int, _DWORD))(*(_DWORD*)(thisx + 15752) + 4))(thisx + 15752, 0);
	(*(void(**)(int, int))(*(_DWORD*)(thisx + 15788) + 4))(thisx + 15788, 1);
	sub_4756B0((_BYTE*)(thisx + 15788), 8, 7);
	sub_48089C(thisx + 15788, 0);
	*(_DWORD*)(thisx + 15640) = thisx + 15788;
	*(_BYTE*)(thisx + 2516) = 1;
	sub_47494F(thisx, 1, 1);
}

 
void sub_47494F(int thisx, int a2, int a3)
{
    if (a2)
    {
        sub_451EB5((_BYTE*)thisx, 1, 0);
        (*(void(**)(int))(*(_DWORD*)(thisx + 15644) + 12))(thisx + 15644);
        if (*(_DWORD*)(thisx + 15640))
            (*(void(**)(_DWORD))(**(_DWORD**)(thisx + 15640) + 12))(*(_DWORD*)(thisx + 15640));
    }
    if (a3)
    {
        sub_451EB5((_BYTE*)thisx, 0, 1);
        if (*(_DWORD*)(thisx + 15640))
            *(_DWORD*)(thisx + 2528) = unknown_libname_13(*(_DWORD**)(thisx + 15640));
        if (*(_DWORD*)(thisx + 2528))
        {
            switch (*(_DWORD*)(thisx + 2528))
            {
            case 1:
                sub_47B91A(16, 208, (LPCSTR)&byte_4B21F0, 0, dword_4B9248);
                sub_47B91A(16, 224, (LPCSTR)&byte_4B222A, 0, dword_4B9248);
                break;
            case 2:
                sub_47B91A(16, 208, (LPCSTR)&byte_4B226A, 0, dword_4B9248);
                sub_47B91A(16, 224, (LPCSTR)&byte_4B22AE, 0, dword_4B9248);
                break;
            case 3:
                sub_47B91A(16, 208, (LPCSTR)&byte_4B2302, 0, dword_4B9248);
                break;
            case 4:
                sub_47B91A(16, 208, (LPCSTR)&byte_4B2372, 0, dword_4B9248);
                sub_47B91A(16, 224, (LPCSTR)&byte_4B23AE, 0, dword_4B9248);
                break;
            case 5:
                sub_47B91A(16, 208, (LPCSTR)&byte_4B2406, 0, dword_4B9248);
                break;
            case 6:
                sub_47B91A(16, 208, (LPCSTR)&byte_4B2762, 0, dword_4B9248);
                break;
            case 7:
                sub_47B91A(16, 208, (LPCSTR)&byte_4B2A16, 0, dword_4B9248);
                break;
            case 8:
                sub_47B91A(16, 208, byte_4B2E8C, 0, dword_4B9248);
                break;
            }
        }
        else
        {
            sub_47B91A(16, 208, byte_4B1F78, 0, dword_4B9248);
        }
    }
}

 
int sub_474BC1(int thisx)
{
    int result; // eax
    int v3; // [esp+8h] [ebp-44h]
    int v4[14]; // [esp+Ch] [ebp-40h] BYREF
    int v5; // [esp+44h] [ebp-8h]
    int v6; // [esp+48h] [ebp-4h]

    sub_477F0C(0);
    v5 = 0;
    v3 = 0;
    v6 = 0;
    if (*(_DWORD*)(thisx + 15640) && !*(_BYTE*)(thisx + 2516))
    {
        v6 = (*(int(**)(_DWORD))(**(_DWORD**)(thisx + 15640) + 16))(*(_DWORD*)(thisx + 15640));
        *(_DWORD*)(thisx + 2528) = unknown_libname_13(*(_DWORD**)(thisx + 15640));
    }
    if (v6 == 1)
    {
        *(_BYTE*)(thisx + 2516) = 2;
        result = thisx;
        if (*(_DWORD*)(thisx + 112) == 3)
        {
            *(_DWORD*)(thisx + 108) = 13;
        }
        else if (*(_DWORD*)(thisx + 112) == 20)
        {
            *(_DWORD*)(thisx + 108) = 19;
            sub_45B65A(thisx);
            *(_BYTE*)(thisx + 11690) = 0;
            *(_BYTE*)(thisx + 11968) = *(_BYTE*)(thisx + 11689);
            *(_BYTE*)(thisx + 13044) = *(_BYTE*)(thisx + 11804);
            *(_BYTE*)(thisx + 13100) = 0;
            sub_45FF40((unsigned __int8*)thisx);
            return (int)sub_466901((_DWORD*)thisx);
        }
    }
    else
    {
        if (v6 != 2)
        {
            if (v6 == 3)
            {
                v5 = 1;
                v3 = 1;
            }
            else if (v6 == 4)
            {
                v5 = 1;
            }
        }
        if (v5 || v3)
            sub_47494F(thisx, v5, v3);
        sub_49C15E((int)v4);
        v4[1] = 0;
        v4[2] = 0;
        v4[0] = dword_4B9248;
        sub_49AB05((int)unk_4BDC60, v4);
        result = *(unsigned __int8*)(thisx + 2516);
        if (!*(_BYTE*)(thisx + 2516) && *(_DWORD*)(thisx + 15640))
            return (*(int(**)(_DWORD))(**(_DWORD**)(thisx + 15640) + 8))(*(_DWORD*)(thisx + 15640));
    }
    return result;
}

 
_DWORD* sub_474D80(_DWORD* thisx, char a2)
{
    sub_442E54(thisx);
    if ((a2 & 1) != 0)
        operator delete(thisx);
    return thisx;
}

 
_BYTE* sub_474DB0(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[50440] = a2;
    return result;
}

 
int sub_474DD0(_DWORD* thisx)
{
    return thisx[27] / 100;
}

 
int sub_474E10(unsigned __int8* thisx)
{
    return thisx[249];
}

 
__int16 sub_474E30(_WORD* thisx)
{
    return thisx[300];
}

 
int sub_474E50(_DWORD* thisx)
{
    return thisx[147];
}

 
int sub_474E70(_DWORD* thisx)
{
    return thisx[145];
}

 
char sub_474E90(_BYTE* thisx)
{
    return thisx[556];
}

 
__int16 sub_474EB0(_WORD* thisx)
{
    return thisx[107];
}

 
_WORD* sub_474ED0(_WORD* thisx, __int16 a2)
{
    _WORD* result; // eax

    result = thisx;
    thisx[107] = a2;
    return result;
}
 
char* sub_474EF0(_BYTE* thisx, int a2, char a3)
{
    char* result; // eax

    result = &thisx[a2];
    thisx[a2 + 520] = a3;
    return result;
}
 
char sub_474F10(_BYTE* thisx, int a2)
{
    return thisx[a2 + 520];
}
 
_BYTE* sub_474F30(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[188] = a2;
    return result;
}
 
__int16 sub_474F50(_WORD* thisx)
{
    return thisx[249];
}
 
_WORD* sub_474F70(_WORD* thisx, __int16 a2)
{
    _WORD* result; // eax

    result = thisx;
    thisx[95] = a2;
    return result;
}
 
_WORD* sub_474F90(_WORD* thisx, __int16 a2)
{
    _WORD* result; // eax

    result = thisx;
    thisx[248] = a2;
    return result;
}
 
_DWORD* sub_474FB0(_DWORD* thisx, int a2)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[42] = a2;
    return result;
}
 
_DWORD* sub_474FD0(_DWORD* thisx, int a2)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[49] = a2;
    return result;
}
 
_BYTE* sub_474FF0(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[195] = a2;
    return result;
}
 
_WORD* sub_475010(_WORD* thisx, __int16 a2)
{
    _WORD* result; // eax

    result = thisx;
    thisx[93] = a2;
    return result;
}
 
_BYTE* sub_475030(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[184] = a2;
    return result;
}
 
_BYTE* sub_475050(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[193] = a2;
    return result;
}


 
char sub_475090(_BYTE* thisx, int a2)
{
    return thisx[a2 + 28];
}
 
int sub_4750B0(_DWORD* thisx)
{
    return thisx[555];
}
 
__int16 sub_4750D0(void* thisx)
{
    return *(_WORD*)thisx;
}

 
BOOL sub_475130(_DWORD* thisx)
{
    return thisx[3] != 0;
}
 
int sub_475150(_DWORD* thisx)
{
    return thisx[71];
}
 
char sub_475170(_BYTE* thisx)
{
    return thisx[260];
}
 
char sub_475190(_BYTE* thisx)
{
    return thisx[259];
}
 
char sub_4751B0(_BYTE* thisx)
{
    return thisx[452];
}
 
char sub_4751D0(_BYTE* thisx)
{
    return thisx[222];
}
 
char sub_4751F0(_BYTE* thisx)
{
    return thisx[251];
}
 
char sub_475210(_BYTE* thisx)
{
    return thisx[252];
}

 
char sub_475250(_BYTE* thisx)
{
    return thisx[256];
}
 
int sub_475270(_DWORD* thisx)
{
    return thisx[66];
}
 
char sub_475290(_BYTE* thisx)
{
    return thisx[254];
}
 
int sub_4752B0(unsigned __int8* thisx)
{
    return thisx[255];
}
 
int sub_4752D0(__int16* thisx)
{
    return thisx[122];
}
 
char sub_4752F0(_BYTE* thisx)
{
    return thisx[253];
}
 
char sub_475310(_BYTE* thisx)
{
    return thisx[213];
}
 
int sub_475330(_DWORD* thisx)
{
    return thisx[67];
}
 
int sub_475350(_DWORD* thisx)
{
    return thisx[70];
}
 
char sub_475370(_BYTE* thisx)
{
    return thisx[272];
}
 
_DWORD* sub_475390(_DWORD* thisx, int a2)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[76] = a2;
    return result;
}
 
char sub_4753B0(_BYTE* thisx)
{
    return thisx[248];
}
 
char sub_4753D0(_BYTE* thisx, int a2)
{
    return thisx[a2 + 453];
}
 
char sub_4753F0(_BYTE* thisx, int a2)
{
    return thisx[a2 + 461];
}
 
char sub_475410(_BYTE* thisx, int a2)
{
    return thisx[a2 + 336];
}
 
char* sub_475430(char* thisx)
{
    return thisx + 228;
}
 
__int16 sub_475450(_WORD* thisx)
{
    return thisx[172];
}

 
char* sub_475490(char* thisx)
{
    return thisx + 284;
}
 
char sub_4754B0(_BYTE* thisx)
{
    return thisx[346];
}

 
char sub_4754F0(_BYTE* thisx)
{
    return thisx[70];
}
 
BOOL sub_475510(unsigned __int8* thisx)
{
    return thisx[69] != 0;
}
 
int sub_475530(_DWORD* thisx)
{
    return thisx[43];
}
 
char sub_475550(_BYTE* thisx)
{
    return thisx[194];
}
 
__int16 sub_475570(_WORD* thisx)
{
    return thisx[96];
}
 
int sub_475590(_DWORD* thisx)
{
    return thisx[41];
}
 
char sub_4755B0(_BYTE* thisx, unsigned __int8 a2)
{
    return thisx[a2 + 181];
}

 
int sub_4755F0(_DWORD* thisx)
{
    return thisx[77];
}
 
char sub_475610(_BYTE* thisx)
{
    return thisx[598];
}
 
_BYTE* sub_475630(_BYTE* thisx, char a2, char a3, char a4, char a5)
{
    _BYTE* result; // eax

    thisx[4] = a2;
    thisx[5] = a3;
    thisx[6] = a4;
    result = thisx;
    thisx[7] = a5;
    return result;
}
 
_DWORD* sub_475670(_DWORD* thisx, int a2)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[8] = a2;
    return result;
}
 
_BYTE* sub_475690(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[28] = a2;
    return result;
}
 
char sub_4756B0(_BYTE* thisx, char a2, char a3)
{
    char result; // al

    thisx[4] = a2;
    result = a3;
    thisx[5] = a3;
    return result;
}


 
char sub_475710(_BYTE* thisx, unsigned __int8 a2)
{
    return thisx[a2 + 36];
}
 
_WORD* sub_475730(_WORD* thisx, __int16 a2)
{
    _WORD* result; // eax

    result = thisx;
    thisx[9] = a2;
    return result;
}
 
int sub_475750(_DWORD* thisx)
{
    return thisx[12609];
}

 
_WORD* sub_475770(_WORD* thisx, __int16 a2)
{
    _WORD* result; // eax

    result = thisx;
    thisx[8] = a2;
    return result;
}
 
int sub_475790(__int16* thisx)
{
    return thisx[8];
}

 
_DWORD* sub_4757B0(_DWORD* thisx, int a2)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[106] = a2;
    return result;
}

 
int sub_4757D0(_DWORD* thisx)
{
    return thisx[69];
}

 
int sub_475810(_DWORD* thisx)
{
    return thisx[41];
}
 
_BYTE* sub_475830(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[15] = a2;
    return result;
}
 
__int16 sub_475850(_WORD* thisx)
{
    return thisx[9];
}

 
int sub_475890(_BYTE* thisx, unsigned __int8 a2, char a3)
{
    int result; // eax

    result = a2;
    thisx[a2 + 71] = a3;
    return result;
}

 
char sub_4758B0(_BYTE* thisx, unsigned __int8 a2)
{
    return thisx[a2 + 71];
}

 
char sub_4758D0(_BYTE* thisx, int a2)
{
    return thisx[a2 + 11];
}
 
char sub_4758F0(_BYTE* thisx, int a2)
{
    return thisx[a2 + 13];
}
 
int sub_475910(char* thisx, int a2, int a3, int a4, int a5, int a6, int a7)
{
    char* v7; // edx
    int result; // eax

    v7 = &thisx[32 * a6 + 16 + 16 * a7];
    *(_DWORD*)v7 = a2;
    *((_DWORD*)v7 + 1) = a3;
    *((_DWORD*)v7 + 2) = a4;
    result = a5;
    *((_DWORD*)v7 + 3) = a5;
    return result;
}
 
int sub_475950(char* thisx, int a2, int a3, int a4, int a5, int a6, int a7)
{
    char* v7; // edx
    int result; // eax

    v7 = &thisx[32 * a6 + 80 + 16 * a7];
    *(_DWORD*)v7 = a2;
    *((_DWORD*)v7 + 1) = a3;
    *((_DWORD*)v7 + 2) = a4;
    result = a5;
    *((_DWORD*)v7 + 3) = a5;
    return result;
}
 
char* sub_475990(_BYTE* thisx, char a2, int a3)
{
    char* result; // eax

    result = &thisx[a3];
    thisx[a3 + 11] = a2;
    return result;
}

 
char* sub_4759B0(_BYTE* thisx, char a2, int a3)
{
    char* result; // eax

    result = &thisx[a3];
    thisx[a3 + 13] = a2;
    return result;
}
 
char* sub_4759D0(char* thisx, char a2)
{
    if ((a2 & 2) != 0)
    {
        eh_vector_destructor_iterator(thisx, 0x98u, *((_DWORD *)thisx - 1), sub_401927);
            if ((a2 & 1) != 0)
                operator delete(thisx - 4);
        return thisx - 4;
    }
    else
    {
        sub_401927(thisx);
        if ((a2 & 1) != 0)
            operator delete(thisx);
        return thisx;
    }
}


 
int sub_475AC0(_DWORD* thisx)
{
    return thisx[49];
}
 
_WORD* sub_475AE0(_WORD* thisx, __int16 a2)
{
    _WORD* result; // eax

    result = thisx;
    thisx[249] = a2;
    return result;
}
 
int sub_475B00(_DWORD* thisx)
{
    return thisx[141];
}
 
int sub_475B20(_DWORD* thisx)
{
    return thisx[142];
}
 
int sub_475B40(_DWORD* thisx)
{
    return thisx[144];
}
 
int sub_475B60(_DWORD* thisx)
{
    return thisx[143];
}

 
int sub_475BA0(void* thisx, int a2)
{
    return (int)thisx + 16 * a2 + 24;
}
 
int sub_475BE0(_DWORD* thisx)
{
    return thisx[29];
}
 
BOOL sub_475C00(_DWORD* thisx)
{
    return thisx[1] != 0;
}

 
char* sub_475C40(char* thisx, char a2)
{
    if ((a2 & 2) != 0)
    {
        eh_vector_destructor_iterator(thisx, 0x14u, *((_DWORD *)thisx - 1), sub_48A134);
            if ((a2 & 1) != 0)
                operator delete(thisx - 4);
        return thisx - 4;
    }
    else
    {
        sub_48A134(thisx);
        if ((a2 & 1) != 0)
            operator delete(thisx);
        return thisx;
    }
}
 
__int16 sub_475CB0(_WORD* thisx)
{
    return thisx[8];
}
 
int sub_475CD0(_DWORD* thisx, int a2)
{
    return thisx[a2 + 14];
}

 
_DWORD* sub_475D10(_DWORD* thisx, int a2)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[111] = a2;
    return result;
}
 
_DWORD* sub_475D30(_DWORD* thisx, int a2)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[82] = a2;
    return result;
}
 
_DWORD* sub_475D50(_DWORD* thisx, int a2)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[83] = a2;
    return result;
}
 
_DWORD* sub_475D70(_DWORD* thisx, int a2)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[84] = a2;
    return result;
}
 
_BYTE* sub_475D90(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[72] = a2;
    return result;
}
 
_DWORD* sub_475DB0(_DWORD* thisx, int a2)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[20] = a2;
    return result;
}
 
int sub_475DD0(__int16* thisx, int a2)
{
    return thisx[a2 + 38];
}
 
int sub_475DF0(_DWORD* thisx, int a2)
{
    return thisx[a2 + 10];
}
 
_DWORD* sub_475E10(_DWORD* thisx, int a2)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[35] = a2;
    return result;
}
 
_BYTE* sub_475E30(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[86] = a2;
    return result;
}
 
_DWORD* sub_475E50(_DWORD* thisx, int a2)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[22] = a2;
    return result;
}
 
int sub_475E70(_DWORD* thisx)
{
    return thisx[138];
}
 
int sub_475E90(char* thisx)
{
    return sub_475EB0(thisx + 4);
}
 
char sub_475EB0(_BYTE* thisx)
{
    return thisx[15];
}
 
_DWORD* sub_475ED0(_DWORD* thisx, _DWORD* a2)
{
    int v2; // edx

    v2 = thisx[96];
    *a2 = thisx[95];
    a2[1] = v2;
    return a2;
}
 
_DWORD* sub_475F00(_DWORD* thisx, _DWORD* a2, int a3)
{
    *a2 = thisx[4 * a3 + 87];
    a2[1] = thisx[4 * a3 + 88];
    a2[2] = thisx[4 * a3 + 89];
    a2[3] = thisx[4 * a3 + 90];
    return a2;
}
 
int sub_475F40(_DWORD* thisx)
{
    return thisx[26] / 100;
}

 
_BYTE* sub_475FA0(_BYTE* thisx)
{
    char i; // [esp+4h] [ebp-4h]
    char j; // [esp+4h] [ebp-4h]

    for (i = 0; i < 4; ++i)
        thisx[i + 76] = -(char)(i + 1);
    for (j = 4; j < 16; ++j)
        thisx[j + 76] = j - 4;
    return thisx;
}
 
BOOL sub_476009(int* thisx)
{
    int v1; // eax
    int v2; // eax
    int v3; // eax
    int v4; // eax
    int v5; // eax
    int v6; // eax
    int v7; // eax
    int v8; // eax
    int v9; // eax

    if (*(_DWORD*)thisx)
        return joyGetPosEx(*((_DWORD*)thisx + 1), (LPJOYINFOEX)(thisx + 24)) == 0;
    *((_DWORD*)thisx + 9) = 1;
    *((_DWORD*)thisx + 8) = 1;
    *((_DWORD*)thisx + 14) = 0;
    if (GetAsyncKeyState((unsigned __int8)thisx[92]) < 0)
        *((_DWORD*)thisx + 9) = 0;
    if (GetAsyncKeyState((unsigned __int8)thisx[93]) < 0)
        *((_DWORD*)thisx + 9) = 2;
    if (GetAsyncKeyState((unsigned __int8)thisx[94]) < 0)
        *((_DWORD*)thisx + 8) = 0;
    if (GetAsyncKeyState((unsigned __int8)thisx[95]) < 0)
        *((_DWORD*)thisx + 8) = 2;
    if (GetAsyncKeyState((unsigned __int8)thisx[96]) < 0)
    {
        v1 = *((_DWORD*)thisx + 14);
        LOBYTE(v1) = v1 | 1;
        *((_DWORD*)thisx + 14) = v1;
    }
    if (GetAsyncKeyState((unsigned __int8)thisx[97]) < 0)
    {
        v2 = *((_DWORD*)thisx + 14);
        LOBYTE(v2) = v2 | 2;
        *((_DWORD*)thisx + 14) = v2;
    }
    if (GetAsyncKeyState((unsigned __int8)thisx[98]) < 0)
    {
        v3 = *((_DWORD*)thisx + 14);
        LOBYTE(v3) = v3 | 4;
        *((_DWORD*)thisx + 14) = v3;
    }
    if (GetAsyncKeyState((unsigned __int8)thisx[99]) < 0)
    {
        v4 = *((_DWORD*)thisx + 14);
        LOBYTE(v4) = v4 | 8;
        *((_DWORD*)thisx + 14) = v4;
    }
    if (GetAsyncKeyState((unsigned __int8)thisx[100]) < 0)
    {
        v5 = *((_DWORD*)thisx + 14);
        LOBYTE(v5) = v5 | 0x10;
        *((_DWORD*)thisx + 14) = v5;
    }
    if (GetAsyncKeyState((unsigned __int8)thisx[101]) < 0)
    {
        v6 = *((_DWORD*)thisx + 14);
        LOBYTE(v6) = v6 | 0x20;
        *((_DWORD*)thisx + 14) = v6;
    }
    if (GetAsyncKeyState((unsigned __int8)thisx[102]) < 0)
    {
        v7 = *((_DWORD*)thisx + 14);
        LOBYTE(v7) = v7 | 0x40;
        *((_DWORD*)thisx + 14) = v7;
    }
    if (GetAsyncKeyState((unsigned __int8)thisx[103]) < 0)
    {
        v8 = *((_DWORD*)thisx + 14);
        LOBYTE(v8) = v8 | 0x80;
        *((_DWORD*)thisx + 14) = v8;
    }
    if (GetAsyncKeyState((unsigned __int8)thisx[104]) < 0)
    {
        v9 = *((_DWORD*)thisx + 14);
        BYTE1(v9) |= 1u;
        *((_DWORD*)thisx + 14) = v9;
    }
    return 1;
}

 
BOOL sub_476223(_DWORD* thisx)
{
    return thisx[9] < thisx[3];
}

 
BOOL sub_47623E(_DWORD* thisx)
{
    return thisx[5] < thisx[9];
}
 
BOOL sub_476259(_DWORD* thisx)
{
    return thisx[8] < thisx[2];
}
 
BOOL sub_476274(_DWORD* thisx)
{
    return thisx[4] < thisx[8];
}
 
BOOL sub_47628F(_DWORD* thisx)
{
    return (thisx[14] & 1) != 0;
}
 
BOOL sub_4762AB(_DWORD* thisx)
{
    return (thisx[14] & 2) != 0;
}
 
BOOL sub_4762C7(_DWORD* thisx)
{
    return (thisx[14] & 4) != 0;
}
 
BOOL sub_4762E3(_DWORD* thisx)
{
    return (thisx[14] & 8) != 0;
}
 
BOOL sub_4762FF(_DWORD* thisx)
{
    return (thisx[14] & 0x10) != 0;
}
 
BOOL sub_47631B(_DWORD* thisx)
{
    return (thisx[14] & 0x20) != 0;
}
 
BOOL sub_476337(_DWORD* thisx)
{
    return (thisx[14] & 0x40) != 0;
}
 
BOOL sub_476353(_DWORD* thisx)
{
    return (thisx[14] & 0x80) != 0;
}
 
BOOL sub_476372(_DWORD* thisx)
{
    return (thisx[14] & 0x100) != 0;
}
 
BOOL sub_476391(_DWORD* thisx)
{
    return (thisx[14] & 0x200) != 0;
}
 
BOOL sub_4763B0(_DWORD* thisx)
{
    return (thisx[14] & 0x400) != 0;
}
 
BOOL sub_4763CF(_DWORD* thisx)
{
    return (thisx[14] & 0x800) != 0;
}
 
BOOL sub_4763EE(_DWORD* thisx)
{
    return (thisx[14] & 0x1000) != 0;
}
 
BOOL sub_47640D(_DWORD* thisx)
{
    return (thisx[14] & 0x2000) != 0;
}
 
BOOL sub_47642C(_DWORD* thisx)
{
    return (thisx[14] & 0x4000) != 0;
}
 
BOOL sub_47644B(_DWORD* thisx)
{
    return (thisx[14] & 0x8000) != 0;
}
 
BOOL sub_47646A(_DWORD* thisx, char a2)
{
    return ((BOOL(*)(_DWORD*))funcs_476478[a2])(thisx);
}
 
BOOL sub_476485(_DWORD* thisx, char a2)
{
    BOOL result; // eax
    char v3; // [esp+8h] [ebp-4h]

    if (!*thisx)
        return ((BOOL(*)(_DWORD*))funcs_476478[a2])(thisx);
    v3 = *((_BYTE*)thisx + a2 + 80);
    if (v3 >= 0)
        return ((BOOL(*)(_DWORD*))funcs_476478[v3])(thisx);
    switch (v3)
    {
    case -4:
        result = sub_476274(thisx);
        break;
    case -3:
        result = sub_476259(thisx);
        break;
    case -2:
        result = sub_47623E(thisx);
        break;
    case -1:
        result = sub_476223(thisx);
        break;
    default:
        result = 0;
        break;
    }
    return result;
}
 
void* sub_47652C(_DWORD* thisx, signed int a2)
{
    void* result; // eax
    char v4[11]; // [esp+4h] [ebp-1D0h] BYREF
    char Src[11]; // [esp+10h] [ebp-1C4h] BYREF
    UINT v6; // [esp+1Ch] [ebp-1B8h]
    UINT v7; // [esp+20h] [ebp-1B4h]
    struct tagJOYCAPSA pjc; // [esp+24h] [ebp-1B0h] BYREF
    BOOL v9; // [esp+1B8h] [ebp-1Ch]
    struct joyinfo_tag pji; // [esp+1BCh] [ebp-18h] BYREF
    UINT uJoyID; // [esp+1D0h] [ebp-4h]

    memset(thisx + 6, 0, 52);
    thisx[6] = 52;
    thisx[7] = 255;
    v9 = 0;
    if (!joyGetNumDevs())//º¯Êý²éÑ¯ÓÎÏ·¸ËÇý¶¯³ÌÐò£¬ÒÔ»ñÈ¡ËüÖ§³ÖµÄ²Ù×Ý¸ËÊýÁ¿¡£
        v9 = 0;
    if (a2 < 0)
    {
        uJoyID = -(a2 + 1);
        v9 = 0;
    }
    else
    {
        uJoyID = a2;
        v9 = joyGetPos(a2, &pji) == 0; //joyGetPos º¯Êý²éÑ¯ÓÎÏ·¸ËµÄÎ»ÖÃºÍ°´Å¥×´Ì¬¡£
    }
    if (v9)
    {
        thisx[1] = uJoyID;
        *thisx = 1;
        joyGetDevCapsA(thisx[1], &pjc, 404); //joyGetDevCaps º¯Êý²éÑ¯Ò»¸öÓÎÏ·¸ËÒÔÈ·¶¨Æä¹¦ÄÜ¡£
        v6 = (pjc.wXmax + pjc.wXmin) >> 1;
        v7 = (pjc.wYmax + pjc.wYmin) >> 1;
        thisx[2] = ((unsigned __int16)v6 + pjc.wXmin) >> 1;
        thisx[4] = ((unsigned __int16)v6 + pjc.wXmax) >> 1;
        thisx[3] = ((unsigned __int16)v7 + pjc.wYmin) >> 1;
        thisx[5] = ((unsigned __int16)v7 + pjc.wYmax) >> 1;
    }
    else
    {
        thisx[1] = uJoyID;
        *thisx = 0;
        thisx[5] = 1;
        thisx[3] = 1;
        thisx[4] = 1;
        thisx[2] = 1;
    }
    if (thisx[1] % 2)
    {
        result = (void*)(thisx[1] / 2);
        if (thisx[1] % 2 == 1)
        {
            memcpy(v4, "&(%'IOP890", 10);//Ò²Ã»ÈËÖªµÀÕâ¸ö×Ö·û´®ÊÇÊ²Ã´ÒâË¼
            v4[10] = 16;
            return memcpy(thisx + 23, v4, 11);
        }
    }
    else
    {
        //ºÜÆæ¹ÖµÄ×Ö·û´®£¬¿ÉÄÜÊÇÈÕÎÄ£¬µ«Õâ¸öº¯ÊýÊÇ´¦ÀíÊÖ±úµÄ¡£¡£
        Src[0] = 89;
        Src[1] = 66;
        Src[2] = 71;
        Src[3] = 74;
        Src[4] = 65;
        Src[5] = 83;
        Src[6] = 68;
        Src[7] = 81;
        Src[8] = 87;
        Src[9] = 69;
        Src[10] = 9;
        return memcpy(thisx + 23, Src, 11);
    }
    return result;
}
 
int sub_4768A2(int* thisx, char a2, char a3)//ÕâÀïÃæµÄ³£Á¿Æñ²»ÊÇÒ²Òª¸Ä±ä£¬Ó¦¸Ã³ýÒÔ4
{
    int result; // eax

    result = a2;
    thisx[a2 + 76] = a3;
    return result;
}
 
char sub_4768BD(int* thisx, char a2)
{
    return thisx[a2 + 76];
}
 
char sub_4768D5(_DWORD* thisx)
{
    int v1; // eax

    if (*thisx)
        return thisx[1] + 1;
    else
        LOBYTE(v1) = 0;
    return v1;
}

 
char sub_4768F5(int* thisx, char a2)
{
    return thisx[a2 + 92];
}

 
int sub_47690D(int* thisx, char a2, char a3)
{
    int result; // eax

    result = a2;
    thisx[a2 + 92] = a3;
    return result;
}
 
BOOL sub_476928(_DWORD* thisx, char a2)
{
    BOOL result; // eax
    char v3; // [esp+Ch] [ebp-4h]

    if (a2 >= 0 || a2 < -4)
        return 0;
    if (*thisx)
    {
    LABEL_10:
        v3 = ((_BYTE*)thisx - a2)[75];
        if (v3 >= 0)
        {
            return sub_47646A(thisx, v3);
        }
        else
        {
            switch (v3)
            {
            case -4:
                goto LABEL_9;
            case -3:
                goto LABEL_8;
            case -2:
                goto LABEL_7;
            case -1:
                goto LABEL_6;
            default:
                result = 0;
                break;
            }
        }
    }
    else
    {
        switch (a2)
        {
        case -4:
        LABEL_9:
            result = sub_476274(thisx);
            break;
        case -3:
        LABEL_8:
            result = sub_476259(thisx);
            break;
        case -2:
        LABEL_7:
            result = sub_47623E(thisx);
            break;
        case -1:
        LABEL_6:
            result = sub_476223(thisx);
            break;
        default:
            goto LABEL_10;
        }
    }
    return result;
}
 
BOOL sub_476A3A(_DWORD* thisx)
{
    return sub_476928(thisx, -1);
}
 
BOOL sub_476A4F(_DWORD* thisx)
{
    return sub_476928(thisx, -2);
}
 
BOOL sub_476A64(_DWORD* thisx)
{
    return sub_476928(thisx, -3);
}
 
BOOL sub_476A79(_DWORD* thisx)
{
    return sub_476928(thisx, -4);
}
 
BOOL sub_476A8E(_DWORD* thisx, char a2)
{
    BOOL result; // eax

    switch (a2)
    {
    case -4:
        result = sub_476274(thisx);
        break;
    case -3:
        result = sub_476259(thisx);
        break;
    case -2:
        result = sub_47623E(thisx);
        break;
    case -1:
        result = sub_476223(thisx);
        break;
    default:
        result = 0;
        break;
    }
    return result;
}

 
int sub_476B00()
{
    sub_476B0F();
    return sub_476B1E();
}
 
int sub_476B0F()
{
    return sub_49A318((int) & unk_4BDC60);
}
 
int sub_476B1E()
{
    return atexit(sub_476B30);
}
 
void __cdecl sub_476B30()
{
    sub_49A2BB((int**) & unk_4BDC60);
}
 
int sub_476B3F()
{
    sub_476B4E();
    return sub_476B5D();
}
 
_DWORD* sub_476B4E()
{
    return sub_43F690((_DWORD*)unk_4BDB28);
}
 
int sub_476B5D()
{
    return atexit(sub_476B6F);
}
 
void __cdecl sub_476B6F()
{
    sub_43F7BF((_DWORD*)unk_4BDB28);
}
 
int sub_476B7E()
{
    sub_476B8D();
    return sub_476B9C();
}
 
char* sub_476B8D()
{
    return sub_4428D0(unk_4B9B10);
}
 
int sub_476B9C()
{
    return atexit(sub_476BAE);
}
 
void __cdecl sub_476BAE()
{
    sub_442E54((_DWORD*)unk_4B9B10);
}

 
int sub_476BBD()
{
    return sub_476BC7();
}
 
int sub_476BC7()
{
	return sub_402080((int)player_list, 27, 8, (void(*)(int))sub_475FA0);
} 
int sub_476BDF()
{
    sub_476BEE();
    return sub_476C0B();
}
 
void sub_476BEE()
{
    eh_vector_constructor_iterator(&word_4B9290, 8u, 8, sub_4A0A0D, sub_4A0A2D);
}
 
int sub_476C0B()
{
    return atexit(sub_476C1D);
}
 
void __cdecl sub_476C1D()
{
    eh_vector_destructor_iterator(&word_4B9290, 8u, 8, sub_4A0A2D);
}
 
int sub_476C35()
{
    sub_476C44();
    return sub_476C61();
}
 
void sub_476C44()
{
    eh_vector_constructor_iterator(&word_4B9250, 8u, 8, sub_4A0A0D, sub_4A0A2D);
}
 
int sub_476C61()
{
    return atexit(sub_476C73);
}
 
void __cdecl sub_476C73()
{
    eh_vector_destructor_iterator(&word_4B9250, 8u, 8, sub_4A0A2D);
}
 
BOOL __cdecl sub_476C8B(unsigned __int8 a1)
{
    return byte_4B93EC[4 * a1] == 1 || byte_4B93EC[4 * a1] == byte_4B4154;
}
 
BOOL __cdecl sub_476CDA(unsigned __int8 a1)
{
    return byte_4B93ED[4 * a1] == 1 || byte_4B93ED[4 * a1] == byte_4B4154;
}
 
BOOL __cdecl sub_476D29(unsigned __int8 a1)
{
    return byte_4B93EE[4 * a1] == 1 || byte_4B93EE[4 * a1] == byte_4B4154;
}
 
BOOL __cdecl sub_476D78(unsigned __int8 a1)
{
    return byte_4B93EF[4 * a1] == 1 || byte_4B93EF[4 * a1] == byte_4B4154;
}
 
BOOL __cdecl sub_476DC7(unsigned __int8 a1, char a2)
{
    return byte_4B93B4[7 * a1 + a2] == 1;
}
 
int __cdecl sub_476DEE(LPCSTR lpString1)
{
    char* v1; // eax
    signed int i; // [esp+4h] [ebp-4h]

    for (i = 0; i < (int)Size; ++i)
    {
        v1 = unknown_libname_18((char*)(36 * i + dword_4B92E0));
        if (!lstrcmpiA(lpString1, v1))
            return i;
    }
    return -1;
}
 
int __cdecl sub_476E46(int a1, void* a2)
{
    int i; // [esp+0h] [ebp-50Ch]
    DWORD NumberOfBytesRead; // [esp+4h] [ebp-508h] BYREF
    _DWORD Buffer[256]; // [esp+8h] [ebp-504h] BYREF
    HANDLE hFile; // [esp+408h] [ebp-104h]
    CHAR FileName[256]; // [esp+40Ch] [ebp-100h] BYREF

    wsprintfA(FileName, "Graphic\\%02dpPalette.bin", a1 + 1);
    hFile = CreateFileA(FileName, 0x80000000, 0, 0, 3u, 0x80u, 0);
    if (hFile != (HANDLE)-1)
    {
        for (i = 0; i < 256; ++i)
            ReadFile(hFile, &Buffer[i], 3u, (LPDWORD)&NumberOfBytesRead, 0);
        CloseHandle(hFile);
    }
    return sub_4A0AE7(a2, (int)Buffer, 256);
} 
void sub_476F0D()
{
    int v0; // [esp+0h] [ebp-130h]
    int v1; // [esp+4h] [ebp-12Ch]
    int v2; // [esp+8h] [ebp-128h]
    int v3[4]; // [esp+Ch] [ebp-124h] BYREF
    int i; // [esp+1Ch] [ebp-114h]
    CHAR String1[260]; // [esp+20h] [ebp-110h] BYREF
    int v6; // [esp+12Ch] [ebp-4h]

    sub_482BF0(v3);
    v6 = 0;
    for (i = 0; i < 2; ++i)
    {
        wsprintfA(String1, "Graphic\\SpCharGraphic%02d.txt", i + 1);
        if (sub_482C74((int)v3, String1) && sub_48328F(v3, ::String1))
        {
            sub_482FAA(v3);
            v1 = 0;
            v0 = 0;
            while (sub_482D44(v3, String1) && String1[0] != 110 && lstrcmpiA(String1, aGraphicend))
            {
                if (v1)
                {
                    v2 = atoi(String1);
                    if (v2 >= 0 && v2 < (unsigned __int16)word_4B92F8[i])
                    {
                        sub_482FAA(v3);
                        v1 = 0;
                        *((_WORD*)*(dword_4B9310 + i) + v0) = v2;
                        continue;
                    }
                }
                else
                {
                    v0 = atoi(String1);
                    if (v0 >= 0 && v0 < (unsigned __int16)word_4B9318[0])
                    {
                        v1 = 1;
                        continue;
                    }
                }
                sub_482FAA(v3);
                v1 = 0;
            }
        }
    }
    v6 = -1;
    sub_482C2F(v3);
}
 
char sub_477148()
{
    int v1; // [esp+4h] [ebp-8h]
    unsigned __int8 i; // [esp+8h] [ebp-4h]

    v1 = rand() % 140;
    for (i = 0; i < 0xEu; ++i)
    {
        if (v1 < (unsigned __int16)word_4B99AC[i])
            return i + 1;
        v1 -= (unsigned __int16)word_4B99AC[i];
    }
    return 0;
}
 
BOOL __cdecl sub_4771C5(int a1, char a2)
{
    if (a1)
    {
        if (a1 == 1)
        {
            return !a2 || a2 == 6;
        }
        else if (a1 == 2)
        {
            return a2 == 1 || a2 == 2 || a2 == 7 || a2 == 11;
        }
        else
        {
            return a1 == 3 && a2 != 3 && a2 != 8 && a2 != 9 && a2 != 10 && a2 != 12 && a2 != 13;
        }
    }
    else
    {
        return a2 == 3 || a2 == 8 || a2 == 9 || a2 == 10 || a2 == 13;
    }
}
 
void sub_47732A()
{
    HANDLE hObject; // [esp+0h] [ebp-10Ch]
    int i; // [esp+4h] [ebp-108h]
    CHAR FileName[260]; // [esp+8h] [ebp-104h] BYREF

    for (i = 0; i < 256; ++i)
    {
        wsprintfA(FileName, "Graphic\\%02dpPalette.bin", i + 1);
        hObject = CreateFileA(FileName, 0x80000000, 0, 0, 3u, 0x80u, 0);
        if (hObject == (HANDLE)-1)
            break;
        CloseHandle(hObject);
    }
    word_4B99E4 = i;
}
 
BOOL __cdecl sub_4773CC(unsigned __int8 a1, unsigned __int8 a2)
{
    if (sub_446497((_DWORD*)unk_4B9B10, 8 * a1, 8 * a2) == 1020)
        return 0;
    return !sub_4744A9((_DWORD*)unk_4B9B10, a1, a2) && sub_4464F6((_DWORD*)unk_4B9B10, a1, a2) != 7;
}

 
BOOL __cdecl sub_47744C(unsigned __int8 a1, unsigned __int8 a2)
{
    unsigned __int8 v3; // [esp+8h] [ebp-70h]
    unsigned __int8 v4; // [esp+10h] [ebp-68h]
    char v5[8]; // [esp+24h] [ebp-54h]
    int v6; // [esp+2Ch] [ebp-4Ch]
    char v7; // [esp+30h] [ebp-48h]
    int v8; // [esp+34h] [ebp-44h]
    int i; // [esp+38h] [ebp-40h]
    char v10; // [esp+3Ch] [ebp-3Ch]
    int v11; // [esp+40h] [ebp-38h]
    char v12; // [esp+44h] [ebp-34h]
    char v13; // [esp+48h] [ebp-30h]
    int v14; // [esp+4Ch] [ebp-2Ch]
    char v15; // [esp+50h] [ebp-28h]
    char v16; // [esp+54h] [ebp-24h]
    char v17; // [esp+58h] [ebp-20h]
    char v18; // [esp+5Ch] [ebp-1Ch]
    char v19; // [esp+60h] [ebp-18h]
    int v20; // [esp+64h] [ebp-14h]
    char v21; // [esp+68h] [ebp-10h]
    int v22; // [esp+6Ch] [ebp-Ch]
    char v23; // [esp+70h] [ebp-8h]
    char v24; // [esp+74h] [ebp-4h]

    if (a1 == 255 || a2 == 255)
        return 0;
    if (a1 == a2)
        return 1;
    if (a1 > (int)a2)
    {
        v3 = a1;
        a1 = a2;
        a2 = v3;
    }
    v5[0] = a1;
    v5[1] = a2;
    v12 = 0;
    v21 = 0;
    v13 = 0;
    v5[4] = 0;
    LOBYTE(v14) = 0;
    v15 = 0;
    v16 = 0;
    v24 = 0;
    v18 = 0;
    v17 = 0;
    LOBYTE(v6) = 0;
    v10 = 0;
    LOBYTE(v22) = 0;
    v23 = 0;
    v4 = 0;
    v19 = 0;
    v7 = 0;
    LOBYTE(v11) = 0;
    LOBYTE(v8) = 0;
    for (i = 0; i < 2; ++i)
    {
        switch (v5[i])
        {
        case 3:
        case 12:
            LOBYTE(v14) = v14 + 1;
            break;
        case 4:
        case 13:
        case 15:
            LOBYTE(v6) = v6 + 1;
            break;
        case 16:
        case 27:
        case 45:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 71:
            LOBYTE(v22) = v22 + 1;
            break;
        case 25:
        case 54:
            ++v4;
            break;
        case 29:
        case 31:
        case 44:
        case 49:
        case 51:
        case 61:
        case 63:
        case 65:
        case 67:
            LOBYTE(v11) = v11 + 1;
            break;
        case 30:
        case 50:
        case 52:
        case 60:
        case 62:
        case 64:
        case 66:
        case 68:
        case 69:
            LOBYTE(v8) = v8 + 1;
            break;
        case 70:
            LOBYTE(v11) = v11 + 1;
            LOBYTE(v8) = v8 + 1;
            break;
        case 72:
            LOBYTE(v14) = v14 + 1;
            LOBYTE(v6) = v6 + 1;
            break;
        default:
            continue;
        }
    }
    if ((unsigned __int8)v14 >= 2u
        || (unsigned __int8)v6 >= 2u
        || (unsigned __int8)v11 >= 2u
        || (unsigned __int8)v8 >= 2u
        || (unsigned __int8)v22 >= 2u
        || v4 >= 2u)
    {
        return 1;
    }
    v20 = 1;
    if (a1 == 1 && (a2 == 22 || a2 == 46))
        v20 = 0;
    if (v20 && a1 == 2 && (a2 == 18 || a2 == 47))
        v20 = 0;
    if (v20 && a1 == 3 && (a2 == 12 || a2 == 72))
        v20 = 0;
    if (v20 && a1 == 4 && (a2 == 13 || a2 == 15))
        v20 = 0;
    if (v20 && a1 == 6 && (a2 == 14 || a2 == 22))
        v20 = 0;
    if (v20 && a1 == 7 && a2 == 37)
        v20 = 0;
    if (v20 && a1 == 8 && a2 == 22)
        v20 = 0;
    if (v20 && a1 == 11 && (a2 == 14 || a2 == 22))
        v20 = 0;
    if (v20 && a1 == 13 && a2 == 15)
        v20 = 0;
    if (v20 && a1 == 14 && a2 == 22)
        v20 = 0;
    if (v20 && a1 == 16 && (a2 == 27 || a2 == 45))
        v20 = 0;
    if (v20 && a1 == 17 && a2 == 41)
        v20 = 0;
    if (v20 && a1 == 18 && a2 == 47)
        v20 = 0;
    if (v20 && a1 == 20 && a2 == 21)
        v20 = 0;
    if (v20 && a1 == 22 && a2 == 46)
        v20 = 0;
    if (v20 && a1 == 23 && (a2 == 24 || a2 == 40 || a2 == 41 || a2 == 53))
        v20 = 0;
    if (v20 && a1 == 24 && (a2 == 40 || a2 == 53))
        v20 = 0;
    if (v20 && a1 == 27 && a2 == 45)
        v20 = 0;
    if (v20 && a1 == 32 && a2 == 33)
        v20 = 0;
    if (v20 && a1 == 29 && (a2 == 31 || a2 == 44 || a2 == 49))
        v20 = 0;
    if (v20 && a1 == 31 && a2 == 44)
        v20 = 0;
    if (v20 && a1 == 40 && (a2 == 41 || a2 == 53))
        v20 = 0;
    return v20 == 0;
}

 
int __cdecl sub_477F0C(unsigned __int8 a1)
{
    int result; // eax
    int i; // [esp+Ch] [ebp-4h]
    int j; // [esp+Ch] [ebp-4h]

    result = sub_476009((int*)&player_list[27 * a1]);//??
    for (i = 0; i < 4; ++i)
    {
        if (sub_476928((_DWORD*)&player_list[27 * a1], -(char)(i + 1)))
        {
            if ((unsigned __int8)byte_4B4154 <= (int)(unsigned __int8)byte_4B93EC[4 * a1 + i])
                byte_4B93EC[4 * a1 + i] = byte_4B4154 - 4;
            ++byte_4B93EC[4 * a1 + i];
        }
        else
        {
            byte_4B93EC[4 * a1 + i] = 0;
        }
        result = i + 1;
    }
    for (j = 0; j < 7; ++j)
    {
        if (sub_476485((_DWORD*)&player_list[27 * a1], j))
        {
            if (j < 5 && (unsigned __int8)byte_4B4154 <= (int)(unsigned __int8)byte_4B93B4[7 * a1 + j])
                byte_4B93B4[7 * a1 + j] = 0;
            ++byte_4B93B4[7 * a1 + j];
        }
        else
        {
            byte_4B93B4[7 * a1 + j] = 0;
        }
        result = j + 1;
    }
    return result;
} 
signed int sub_4780C0()
{
    signed int result; // eax
    int v1; // [esp+4h] [ebp-10h]
    _BYTE* v2; // [esp+8h] [ebp-Ch]
    signed int j; // [esp+Ch] [ebp-8h]
    int i; // [esp+10h] [ebp-4h]
    signed int k; // [esp+10h] [ebp-4h]

    for (i = 0; i < dword_4B9368; ++i)
    {
        for (j = 0; j < (int)dword_4B93A0; ++j)
            *(_BYTE*)(*((_DWORD*)dword_4B9364 + i) + j) = 0;
    }
    for (k = 0; ; ++k)
    {
        result = k;
        if (k >= (int)Size)
            break;
        v2 = (_BYTE*)(36 * k + dword_4B92E0);
        v1 = (unsigned __int8)sub_4016F0(v2);
        *(_BYTE*)(*((_DWORD*)dword_4B9364 + v1) + (unsigned __int8)sub_401710(v2)) = 1;
    }
    **((_BYTE**)dword_4B9364 + 3) = 1;
    return result;
}
 
int sub_47818A()
{
    void* v1; // [esp+10h] [ebp-578h]
    char v2[1356]; // [esp+2Ch] [ebp-55Ch] BYREF
    int i; // [esp+578h] [ebp-10h]
    int v4; // [esp+584h] [ebp-4h]

    sub_4A1450((int*)v2);
    v4 = 0;
    if (!sub_4A14C0((short*)v2, aGraphicHeadBmp_0))
        goto LABEL_8;
    dword_4B9368 = unknown_libname_21((int*)v2) / 8;
    if (dword_4B9368 <= 0)
    {
        dword_4B9368 = 0;
        v4 = -1;
        sub_4A148B((void**)v2);
        return 0;
    }
    dword_4B9364 = operator new(4 * dword_4B9368);
    if (dword_4B9364 && (memset((void*)dword_4B9364, 0, 4 * dword_4B9368), (dword_4B9360 = operator new(4 * dword_4B9368)) != 0))
    {
        memset((void*)dword_4B9360, 0, 4 * dword_4B9368);
        for (i = 0; i < dword_4B9368; ++i)
        {
            v1 = operator new(dword_4B93A0);
            *((_DWORD*)dword_4B9364 + i) = (_DWORD)v1;
            if (!*((_DWORD*)dword_4B9364 + i))
                goto LABEL_8;
            memset(*((void**)dword_4B9364 + i), 0, dword_4B93A0);
            *((_DWORD*)dword_4B9360 + i) = (_DWORD)operator new(4 * dword_4B93A0);
            if (!*((_DWORD*)dword_4B9360 + i))
                goto LABEL_8;
            memset(*((void**)dword_4B9360 + i), 0, 4 * dword_4B93A0);
        }
        v4 = -1;
        sub_4A148B((void**)v2);
        return 1;
    }
    else
    {
    LABEL_8:
        v4 = -1;
        sub_4A148B((void**)v2);
        return 0;
    }
}
 
int __cdecl sub_47846F(LPCSTR lpFileName, int a2)
{
    HANDLE hFile; // [esp+0h] [ebp-Ch]
    int i; // [esp+4h] [ebp-8h]
    DWORD NumberOfBytesRead; // [esp+8h] [ebp-4h] BYREF

    hFile = CreateFileA(lpFileName, 0x80000000, 0, 0, 3u, 0x80u, 0);
    if (hFile == (HANDLE)-1)
        return 0;
    for (i = 0; i < 256; ++i)
        ReadFile(hFile, (LPVOID)(a2 + 4 * i), 3u, (LPDWORD)&NumberOfBytesRead, 0);
    CloseHandle(hFile);
    return 1;
}
 
int __cdecl sub_4784EA(int a1, int a2)
{
    CHAR FileName[260]; // [esp+0h] [ebp-104h] BYREF

    wsprintfA(FileName, "Graphic\\%02dpPalette.bin", a1);
    return sub_47846F(FileName, a2);
}

 
int __cdecl sub_478523(LPCSTR lpFileName, int a2, int a3)
{
    char v4[1024]; // [esp+0h] [ebp-540h] BYREF
    int v5[80]; // [esp+400h] [ebp-140h] BYREF

    memset(v4, 0, sizeof(v4));
    sub_49DB90(v5);
    if (a2 >= 0 && sub_4784EA(a2 + 1, (int)v4))
        v5[11] = (int)v4;
    if (a3 >= 0)
        sub_485DFD((int)dword_4B93A4 + 24 * a3, (int)v4);
    v5[1] = 0;
    v5[2] = 0;
    v5[3] = -1;
    v5[4] = -1;
    v5[5] = 1;
    v5[9] = 0;
    v5[0] = -1;
    if (sub_49DA45((_DWORD*)unk_4BDC60, lpFileName, (int)v5))
        return v5[0];
    else
        return -1;
}

 
int __cdecl sub_478607(_DWORD* a1, unsigned __int8 a2, int a3, int a4, int a5)
{
    int result; // eax
    int v6; // [esp+0h] [ebp-14h]
    struct tagRECT rc; // [esp+4h] [ebp-10h] BYREF

    result = a2;
    if (a2)
    {
        v6 = (unsigned __int16)sub_475CB0((_WORD*)(dword_4B92D4 + 84 * a3));
        *a1 = a4;
        a1[9] = a5;
        SetRect(&rc, 32 * (a2 - 1), 16 * v6, 32, 16);
        return sub_49C8A6((int)unk_4BDC60, a1, (_DWORD*)&rc);
    }
    return result;
}
 
char __cdecl sub_478682(_DWORD* a1, unsigned __int8 a2, int a3, int a4, int a5, int a6)
{
    char result; // al
    unsigned __int8 v7; // [esp+0h] [ebp-44h]
    int yBottom; // [esp+4h] [ebp-40h]
    int v9; // [esp+8h] [ebp-3Ch]
    int j; // [esp+Ch] [ebp-38h]
    int v11; // [esp+10h] [ebp-34h]
    unsigned __int8 v12; // [esp+14h] [ebp-30h]
    unsigned __int8 v13; // [esp+18h] [ebp-2Ch]
    int v14; // [esp+1Ch] [ebp-28h]
    int v15; // [esp+20h] [ebp-24h]
    int v16; // [esp+28h] [ebp-1Ch]
    int i; // [esp+2Ch] [ebp-18h]
    struct tagRECT rc; // [esp+30h] [ebp-14h] BYREF
    int v19; // [esp+40h] [ebp-4h]

    if (a6)
    {
        result = a2;
        if (a2)
        {
            a1[9] = a5;
            if (a2 >= 0x80u)
                *a1 = a4;
            else
                *a1 = (int)dword_4B9238 + a3;
            v19 = 0;
            v15 = 8;
            v14 = 8;
            if (a1[6])
                v15 = -8;
            if (a1[7])
                v14 = -8;
            v11 = a1[1];
            result = SetRect(&rc, 0, 0, 8, 8);
            if (a2 >= 0x80u)
            {
                v12 = 2;
                v13 = 2;
                v16 = 1;
            }
            else
            {
                result = byte_4B011F[a2];
                v12 = result;
                v13 = byte_4B0113[a2];
                v16 = 0;
            }
            for (i = 0; i < v12; ++i)
            {
                v9 = a1[2];
                if (a6 > 0)
                {
                    if (a1[7])
                        yBottom = a6 - 8 * (v12 - 1 - i);
                    else
                        yBottom = a6 - 8 * i;
                    if (yBottom <= 0)
                        yBottom = 0;
                    if (yBottom > 8)
                        yBottom = 8;
                    if (a1[7])
                        SetRect(&rc, 0, 8 - yBottom, 8, yBottom);
                    else
                        SetRect(&rc, 0, 0, 8, yBottom);
                }
                for (j = 0; j < v13; ++j)
                {
                    if (v16)
                        v7 = byte_4AFF40[4 * a2 + v19];
                    else
                        v7 = byte_4B012A[2 * a2 + v19] + 1;
                    if (v7)
                        sub_4A00C6((int)unk_4BDC60, a1, v7 - 1, (int*) & rc);
                    a1[1] += v15;
                    ++v19;
                }
                a1[1] = v11;
                a1[2] = v14 + v9;
                result = i + 1;
            }
        }
    }
    return result;
}
 
int __cdecl sub_4788FA(int* a1, char* a2, int a3, int a4, int a5, unsigned __int8 a6)
{
    int result; // eax
    unsigned __int8 v7; // al
    char v8; // al
    int v9; // esi
    char v10; // al
    int v11; // esi
    char v12; // al
    int v13; // esi
    int v14; // ebx
    unsigned __int8 v15; // al
    unsigned __int8 v16; // al
    char v17; // al
    char v18; // al
    char v19; // al
    char v20; // al
    int v21; // edx
    char v22[4]; // [esp+8h] [ebp-C4h] BYREF
    int v23; // [esp+Ch] [ebp-C0h]
    int v24; // [esp+10h] [ebp-BCh]
    int v25; // [esp+20h] [ebp-ACh]
    void* v26; // [esp+40h] [ebp-8Ch]
    int v27; // [esp+44h] [ebp-88h] BYREF
    int v28; // [esp+48h] [ebp-84h]
    int v29; // [esp+4Ch] [ebp-80h]
    int v30; // [esp+5Ch] [ebp-70h]
    int v31; // [esp+7Ch] [ebp-50h]
    int v32; // [esp+80h] [ebp-4Ch]
    int v33; // [esp+84h] [ebp-48h]
    int i; // [esp+88h] [ebp-44h]
    _BYTE* v35; // [esp+8Ch] [ebp-40h]
    int v36; // [esp+90h] [ebp-3Ch]
    int Src[6]; // [esp+94h] [ebp-38h] BYREF
    int v38; // [esp+ACh] [ebp-20h]
    int v39; // [esp+B0h] [ebp-1Ch]

    v36 = (unsigned __int8)sub_401DFE(a2);
    v32 = a1[1];
    v33 = a1[2];
    result = sub_49C15E((int)Src);
    Src[0] = *a1;
    for (i = 0; i < v36 + 1; ++i)
    {
        v7 = sub_425C10(a2);
        if (v7 == i && unknown_libname_5(a2))
        {
            v35 = (_BYTE*)(12 * (unsigned __int16)sub_401BEF((_DWORD*)a2, 0) + a3);
            sub_49C15E((int)&v27);
            v30 = a1[6];
            v8 = sub_425F90(a2);
            v9 = v8 + v32;
            v28 = sub_401C1E((_DWORD*)a2, 0, a1[6]) + v9;
            v10 = sub_425F50(a2);
            v11 = v10 + v33;
            v29 = sub_401C5B((_DWORD*)a2, 0, 0) + v11;
            v31 = 8;
            if (a1[6])
            {
                v12 = sub_401C1E((_DWORD*)a2, 0, a1[6]);
                v13 = v12 + v32;
                v14 = 8 * (unsigned __int8)sub_425F50(v35);
                v28 = v13 + v14 - sub_425F90(a2) - 8;
                v31 = -v31;
            }
            if (unknown_libname_6(a2))
            {
                v30 = a1[6] == 0;
                v28 += v31;
            }
            v15 = unknown_libname_5(a2);
            sub_478682(&v27, v15, a4, a5, -1, -1);
        }
        if (a6)
        {
            v16 = sub_475EB0(a2);
            if (v16 == i)
            {
                if (sub_425B70(a2))
                {
                    sub_49C15E((int)v22);
                    v25 = a1[6];
                    v17 = sub_4758D0(a2, a1[6]);
                    v23 = v17 + v32;
                    v18 = sub_4758F0(a2, a1[7]);
                    v24 = v18 + v33;
                    v26 = (void*)(140 * *(_DWORD*)&dword_4B7180[44 * a6 - 44 + 4 * (unsigned __int8)sub_425B70(a2)]
                        + dword_4B92E8);
                    sub_490A5B(v26, v22);
                }
            }
        }
        if (i != v36)
        {
            v35 = (_BYTE*)(12 * (unsigned __int16)sub_401BEF((_DWORD*)a2, i) + a3);
            v19 = sub_401C1E((_DWORD*)a2, i, a1[6]);
            Src[1] = v19 + v32;
            v20 = sub_401C5B((_DWORD*)a2, i, 0);
            Src[2] = v20 + v33;
            if (sub_401C98((_DWORD*)a2, i))
                v38 = a1[6] == 0;
            else
                v38 = a1[6];
            if (sub_401CC6((_DWORD*)a2, i))
                v39 = 1;
            sub_48FB00((int)v35, v21, (int)unk_4BDC60, Src, 0);
        }
        result = i + 1;
    }
    return result;
}
 
int __cdecl sub_478C4C(_DWORD* a1, int a2)
{
    int result; // eax
    unsigned __int8 v3; // al
    unsigned __int16 v4; // ax
    char v5; // al
    int v6; // esi
    char v7; // al
    int v8; // esi
    char v9; // al
    int v10; // esi
    int v11; // ebx
    unsigned __int8 v12; // al
    unsigned __int8 v13; // al
    unsigned __int8 v14; // al
    char v15; // al
    char v16; // al
    int v17; // esi
    unsigned __int16 v18; // ax
    char v19; // al
    char v20; // al
    int v21; // [esp-10h] [ebp-E8h]
    int v22; // [esp-Ch] [ebp-E4h]
    int v23; // [esp-Ch] [ebp-E4h]
    int v24; // [esp-8h] [ebp-E0h]
    char v25[4]; // [esp+8h] [ebp-D0h] BYREF
    int v26; // [esp+Ch] [ebp-CCh]
    int v27; // [esp+10h] [ebp-C8h]
    int v28; // [esp+20h] [ebp-B8h]
    void* v29; // [esp+40h] [ebp-98h]
    char v30[4]; // [esp+44h] [ebp-94h] BYREF
    int v31; // [esp+48h] [ebp-90h]
    int v32; // [esp+4Ch] [ebp-8Ch]
    int v33; // [esp+5Ch] [ebp-7Ch]
    int v34; // [esp+7Ch] [ebp-5Ch]
    char* v35; // [esp+80h] [ebp-58h]
    int v36; // [esp+84h] [ebp-54h]
    int v37; // [esp+88h] [ebp-50h]
    int i; // [esp+8Ch] [ebp-4Ch]
    _BYTE* v39; // [esp+90h] [ebp-48h]
    int v40; // [esp+94h] [ebp-44h]
    int v41; // [esp+98h] [ebp-40h]
    int v42; // [esp+9Ch] [ebp-3Ch]
    int Src[6]; // [esp+A0h] [ebp-38h] BYREF
    int v44; // [esp+B8h] [ebp-20h]
    int v45; // [esp+BCh] [ebp-1Ch]
    int v46; // [esp+D4h] [ebp-4h]

    v35 = *(char**)a2;
    v40 = *(_DWORD*)(a2 + 4);
    LOBYTE(v42) = *(_BYTE*)(a2 + 24);
    v41 = (unsigned __int8)sub_401DFE(v35);
    v36 = a1[1];
    v37 = a1[2];
    sub_49C15E((int)Src);
    Src[0] = *(_DWORD*)(a2 + 16);
    v46 = a1[13];
    for (i = 0; ; ++i)
    {
        result = v41 + 1;
        if (i >= v41 + 1)
            break;
        v3 = sub_425C10(v35);
        if (v3 == i && unknown_libname_5(v35))
        {
            v4 = sub_401BEF((_DWORD*)v35, 0);
            v39 = (_BYTE*)(12 * v4 + v40);
            sub_49C15E((int)v30);
            v33 = a1[6];
            v5 = sub_425F90(v35);
            v6 = v5 + v36;
            v31 = sub_401C1E((_DWORD*)v35, 0, a1[6]) + v6;
            v7 = sub_425F50(v35);
            v8 = v7 + v37;
            v32 = sub_401C5B((_DWORD*)v35, 0, 0) + v8;
            v34 = 8;
            if (a1[6])
            {
                v9 = sub_401C1E((_DWORD*)v35, 0, a1[6]);
                v10 = v9 + v36;
                v11 = 8 * (unsigned __int8)sub_425F50(v39);
                v31 = v10 + v11 - sub_425F90(v35) - 8;
                v34 = -v34;
            }
            if (unknown_libname_6(v35))
            {
                v33 = a1[6] == 0;
                v31 += v34;
            }
            if (*(_BYTE*)(a2 + 25))
            {
                if (*(_BYTE*)(a2 + 25) == 1)
                {
                    v24 = *(_DWORD*)(a2 + 8);
                    v23 = *(_DWORD*)(a2 + 28);
                    v13 = unknown_libname_5(v35);
                    sub_478607((_DWORD*)v30, v13, v23, v24, -1);
                }
            }
            else
            {
                v22 = *(_DWORD*)(a2 + 12);
                v21 = *(_DWORD*)(a2 + 32);
                v12 = unknown_libname_5(v35);
                sub_478682((int*)v30, v12, v21, v22, -1, -1);
            }
        }
        if ((_BYTE)v42)
        {
            v14 = sub_475EB0(v35);
            if (v14 == i)
            {
                if (sub_425B70(v35))
                {
                    sub_49C15E((int)v25);
                    v28 = a1[6];
                    v15 = sub_4758D0(v35, a1[6]);
                    v26 = v15 + v36;
                    v16 = sub_4758F0(v35, a1[7]);
                    v27 = v16 + v37;
                    v17 = 44 * ((unsigned __int8)v42 - 1);
                    v29 = (void*)(140 * *(_DWORD*)&dword_4B7180[4 * (unsigned __int8)sub_425B70(v35) + v17] + dword_4B92E8);
                    sub_490A5B(v29, v25);
                }
            }
        }
        if (i != v41)
        {
            v18 = sub_401BEF((_DWORD*)v35, i);
            v39 = (_BYTE*)(12 * v18 + v40);
            v19 = sub_401C1E((_DWORD*)v35, i, a1[6]);
            Src[1] = v19 + v36;
            v20 = sub_401C5B((_DWORD*)v35, i, 0);
            Src[2] = v20 + v37;
            if (sub_401C98((_DWORD*)v35, i))
                v44 = a1[6] == 0;
            else
                v44 = a1[6];
            if (sub_401CC6((_DWORD*)v35, i))
                v45 = 1;
            sub_48FB00((int)v39, (int)Src, (int)unk_4BDC60, Src, 0);
        }
    }
    return result;
}

 
char __cdecl sub_47900E(_DWORD* a1, unsigned __int8 a2, int a3, int a4)
{
    _WORD* v5; // [esp+0h] [ebp-8h]
    int v6; // [esp+4h] [ebp-4h]

    if (a3 < 0)
    {
        v5 = (_WORD*)sub_426590(unk_4B9B10, -a3 - 1);
        v6 = (unsigned __int16)sub_4266F0(v5);
    }
    else
    {
        v6 = (unsigned __int16)sub_475CB0((_WORD*)(36 * a3 + dword_4B92E0));
    }
    return sub_478682(a1, a2, v6, 0, a4, -1);
}
 
int __cdecl sub_47907D(LPCSTR lpFileName)
{
    return sub_44FE88((int)unk_4B9B10, lpFileName);
}
 
UINT sub_479090()
{
    CHAR FileName[256]; // [esp+0h] [ebp-100h] BYREF

    wsprintfA(FileName, "%s\\%s", Buffer, aKdIni);//»ñÈ¡ÅäÖÃÎÄ¼þÂ·¾¶
    return ¶ÁÈ¡ÅäÖÃÎÄ¼þ((int)unk_4B9B10, FileName);
}
 
int sub_4790CD()
{
    unsigned __int16 v0; // ax
    char v1; // al
    char v2; // al
    char v3; // al
    char v4; // al
    char v5; // al
    char v6; // al
    char v7; // al
    char v8; // al
    char v9; // al
    char v10; // al
    char v11; // al
    char v12; // al
    unsigned __int8 v14; // al
    int v15; // [esp+0h] [ebp-4ACh]
    int v16; // [esp+4h] [ebp-4A8h]
    _DWORD* Block; // [esp+54h] [ebp-458h]
    int n; // [esp+68h] [ebp-444h]
    int ii; // [esp+6Ch] [ebp-440h]
    int v20; // [esp+70h] [ebp-43Ch]
    char v21; // [esp+78h] [ebp-434h]
    signed int j; // [esp+7Ch] [ebp-430h]
    int k; // [esp+7Ch] [ebp-430h]
    int m; // [esp+7Ch] [ebp-430h]
    int v25; // [esp+80h] [ebp-42Ch]
    int v26[4]; // [esp+84h] [ebp-428h] BYREF
    int i; // [esp+94h] [ebp-418h]
    int v28; // [esp+98h] [ebp-414h]
    CHAR String1[1024]; // [esp+9Ch] [ebp-410h] BYREF
    int v30; // [esp+49Ch] [ebp-10h]
    int v31; // [esp+4A8h] [ebp-4h]

    sub_482BF0(v26);
    v31 = 0;
    if (sub_482C74((int)v26, aChardataTxt))
    {
        LOBYTE(v30) = 0;
        while (sub_482D44(v26, String1))
        {
            if (lstrcmpiA(String1, aStart_6))
            {
                if (!lstrcmpiA(String1, aEnd_2))
                    break;
                if ((unsigned __int8)v30 == 1)
                {
                    ++Size;
                    sub_482FAA(v26);
                }
            }
            else
            {
                LOBYTE(v30) = 1;
                Size = 0;
                sub_482FAA(v26);
            }
        }
        if (dword_4B92E0)
            (**(void(__thiscall***)(int, int))dword_4B92E0)(dword_4B92E0, 3);
        v28 = Size;
        Block = (_DWORD*)operator new(36 * Size + 4);
        LOBYTE(v31) = 1;
        if (Block)
        {
            *Block = v28;
            eh_vector_constructor_iterator(Block + 1, 0x24u, v28, sub_401730, sub_40174E);
                v16 = (int)(Block + 1);
        }
        else
        {
            v16 = 0;
        }
        LOBYTE(v31) = 0;
        dword_4B92E0 = v16;
        dword_4B92DC = operator new(Size);
        memset((void*)dword_4B92DC, 0, Size);
        sub_48314A(v26);
        while (sub_482D44(v26, String1))
        {
            if (!lstrcmpiA(String1, aStart_7))
            {
                sub_482FAA(v26);
                break;
            }
            if (!lstrcmpiA(String1, aEnd_3))
                break;
            sub_482FAA(v26);
        }
        for (i = 0; i < (int)Size; ++i)
        {
            if (!sub_482D44(v26, String1))
                goto LABEL_78;
            if (String1[0] == 110)
                goto LABEL_78;
            sub_401762((CHAR*)(36 * i + dword_4B92E0), String1);
            if (!sub_482D44(v26, String1))
                goto LABEL_78;
            if (String1[0] == 110)
                goto LABEL_78;
            v0 = atoi(String1);
            sub_4017EE((_WORD*)(36 * i + dword_4B92E0), v0);
            if (!sub_482D44(v26, String1))
                goto LABEL_78;
            if (String1[0] == 110)
                goto LABEL_78;
            v1 = atoi(String1);
            sub_47EA90((_BYTE*)(dword_4B92E0 + 36 * i), v1);
            if (!sub_482D44(v26, String1) || String1[0] == 110)
                goto LABEL_78;
            v25 = atoi(String1);
            for (j = 0; j < (int)dword_4B93A0 && unknown_libname_22((_DWORD*)dword_4B93A4 + 6 * j) != v25; ++j)
                ;
            if (j == dword_4B93A0)
                j = 0;
            streambuf::unbuffered((streambuf*)((char*)dword_4B93A4 + 24 * j), 1);
            sub_47EAB0((_BYTE*)(dword_4B92E0 + 36 * i), j);
            if (!sub_482D44(v26, String1))
                goto LABEL_78;
            if (String1[0] == 110)
                goto LABEL_78;
            v2 = atoi(String1);
            sub_47EAD0((_BYTE*)(36 * i + dword_4B92E0), v2);
            if (!sub_482D44(v26, String1))
                goto LABEL_78;
            if (String1[0] == 110)
                goto LABEL_78;
            v3 = atoi(String1);
            sub_47EAF0((_BYTE*)(dword_4B92E0 + 36 * i), v3);
            if (!sub_482D44(v26, String1))
                goto LABEL_78;
            if (String1[0] == 110)
                goto LABEL_78;
            v4 = atoi(String1);
            sub_47EB10((_BYTE*)(36 * i + dword_4B92E0), v4);
            if (!sub_482D44(v26, String1))
                goto LABEL_78;
            if (String1[0] == 110)
                goto LABEL_78;
            v5 = atoi(String1);
            sub_47EB30((_BYTE*)(dword_4B92E0 + 36 * i), v5);
            if (!sub_482D44(v26, String1))
                goto LABEL_78;
            if (String1[0] == 110)
                goto LABEL_78;
            v6 = atoi(String1);
            sub_47EB50((_BYTE*)(36 * i + dword_4B92E0), v6);
            if (!sub_482D44(v26, String1))
                goto LABEL_78;
            if (String1[0] == 110)
                goto LABEL_78;
            v7 = atoi(String1);
            sub_47EB70((_BYTE*)(dword_4B92E0 + 36 * i), v7);
            if (!sub_482D44(v26, String1))
                goto LABEL_78;
            if (String1[0] == 110)
                goto LABEL_78;
            v8 = atoi(String1);
            sub_47EB90((_BYTE*)(36 * i + dword_4B92E0), v8);
            if (!sub_482D44(v26, String1))
                goto LABEL_78;
            if (String1[0] == 110)
                goto LABEL_78;
            v9 = atoi(String1);
            sub_47EBB0((_BYTE*)(dword_4B92E0 + 36 * i), v9);
            if (!sub_482D44(v26, String1))
                goto LABEL_78;
            if (String1[0] == 110)
                goto LABEL_78;
            v10 = atoi(String1);
            sub_489E30((_BYTE*)(36 * i + dword_4B92E0), v10);
            if (!sub_482D44(v26, String1))
                goto LABEL_78;
            if (String1[0] == 110)
                goto LABEL_78;
            v11 = atoi(String1);
            sub_47EBF0((_BYTE*)(dword_4B92E0 + 36 * i), v11);
            if (!sub_482D44(v26, String1) || String1[0] == 110)
                goto LABEL_78;
            v12 = atoi(String1);
            sub_47EBD0((_BYTE*)(36 * i + dword_4B92E0), v12);
            for (k = 0; k < 3; ++k)
            {
                if (!sub_482D44(v26, String1) || String1[0] == 110)
                    goto LABEL_78;
                if (atoi(String1) <= 0)
                    v15 = -atoi(String1);
                else
                    v15 = atoi(String1);
                v21 = v15;
                if (v15 != 255 && v15 != 254 && v15 >= 73 && (v15 - 128 < 2 || v15 - 128 >= 13))
                    v21 = 0;
                sub_47EC10((_BYTE*)(36 * i + dword_4B92E0), k, v21);
            }
            for (m = 0; m < 3; ++m)
            {
                if ((unsigned __int8)sub_4266B0((_BYTE*)(36 * i + dword_4B92E0), m) == 254)
                {
                    v20 = 0;
                    while (!v20)
                    {
                        v20 = rand() % 86 + 1;
                        if (v20 < 73)
                        {
                            for (n = 0; n < 3; ++n)
                            {
                                if (n != m)
                                {
                                    v14 = sub_4266B0((_BYTE*)(dword_4B92E0 + 36 * i), n);
                                    if (sub_47744C(v20, v14))
                                        v20 = 0;
                                }
                            }
                        }
                        else
                        {
                            v20 += 55;
                            if (v20 >= 131)
                            {
                                for (ii = 0; ii < 3; ++ii)
                                {
                                    if (ii != m && v20 == (unsigned __int8)sub_4266B0((_BYTE*)(36 * i + dword_4B92E0), ii))
                                        v20 = 0;
                                }
                            }
                            else
                            {
                                v20 = 0;
                            }
                        }
                    }
                    sub_47EC10((_BYTE*)(36 * i + dword_4B92E0), m, v20);
                }
            }
            sub_482FAA(v26);
        }
        dword_4B92D0 = (int)(Size - 6) / 2;
        if ((int)(Size - 6) / 2 % 4 == 1)
            --dword_4B92D0;
        if (dword_4B92D0 < 0)
            dword_4B92D0 = 0;
        if (dword_4B92D0 > 16)
            dword_4B92D0 = 16;
        v31 = -1;
        sub_482C2F(v26);
        return 1;
    }
    else
    {
    LABEL_78:
        v31 = -1;
        sub_482C2F(v26);
        return 0;
    }
} 
int sub_479E2A()
{
    void* v0; // esp
    char* v2; // eax
    int v3; // [esp+0h] [ebp-1574h]
    _DWORD* Block; // [esp+10h] [ebp-1564h]
    int j; // [esp+24h] [ebp-1550h]
    int v6[4]; // [esp+28h] [ebp-154Ch] BYREF
    int v7[1280]; // [esp+38h] [ebp-153Ch] BYREF
    int i; // [esp+1438h] [ebp-13Ch]
    int v9; // [esp+143Ch] [ebp-138h]
    int v10[4]; // [esp+1440h] [ebp-134h] BYREF
    int v11[4]; // [esp+1450h] [ebp-124h]
    CHAR String1[256]; // [esp+1460h] [ebp-114h] BYREF
    int v13; // [esp+1560h] [ebp-14h]
    int v14; // [esp+1564h] [ebp-10h]
    int v15; // [esp+1570h] [ebp-4h]

    v0 = alloca(5480);
    sub_482BF0(v6);
    v15 = 0;
    if (sub_482C74((int)v6, aDataCheergirld))
    {
        dword_4B92D8 = 0;
        LOBYTE(v13) = 0;
        v9 = 0;
        while (sub_482D44(v6, String1))
        {
            if (lstrcmpiA(String1, aStart_8))
            {
                if (!lstrcmpiA(String1, aEnd_4))
                    break;
                if ((unsigned __int8)v13 != 1 || v9 || lstrcmpiA(String1, aDef))
                {
                    if ((unsigned __int8)v13 == 1 && v9 && !lstrcmpiA(String1, aDefend_0))
                    {
                        v9 = 0;
                        ++dword_4B92D8;
                        sub_482FAA(v6);
                    }
                    else
                    {
                        sub_482FAA(v6);
                    }
                }
                else
                {
                    v9 = 1;
                    sub_482FAA(v6);
                }
            }
            else
            {
                LOBYTE(v13) = 1;
                dword_4B92D8 = 0;
                sub_482FAA(v6);
            }
        }
        if (dword_4B92D4)
            (**(void(__thiscall***)(int, int))dword_4B92D4)(dword_4B92D4, 3);
        v14 = dword_4B92D8;
        Block = (_DWORD*)operator new(84 * dword_4B92D8 + 4);
        LOBYTE(v15) = 1;
        if (Block)
        {
            *Block = v14;
            eh_vector_constructor_iterator(Block + 1, 0x54u, v14, sub_43E640, sub_43E6E5);
                v3 = (int)(Block + 1);
        }
        else
        {
            v3 = 0;
        }
        LOBYTE(v15) = 0;
        dword_4B92D4 = v3;
        sub_48314A(v6);
        sub_482BF0(v10);
        LOBYTE(v15) = 2;
        if (sub_482C74((int)v10, aDemoKkResult1T_0))
        {
            sub_402080((int)v7, 20, 256, (void(*)(int))sub_48A44E);
            v2 = sub_426210((char*)unk_4B9B10);
            sub_489927(v2, (int)v10, (int)v7, 256, 0);
            v11[0] = sub_485ED0((int)v7, 256, a1st_1, -1);
            v11[1] = sub_485ED0((int)v7, 256, a2nd_1, -1);
            v11[2] = sub_485ED0((int)v7, 256, a3rd_1, -1);
            v11[3] = sub_485ED0((int)v7, 256, aBiri_0, -1);
            sub_48314A(v6);
            while (sub_482D44(v6, String1))
            {
                if (!lstrcmpiA(String1, aStart_9))
                {
                    sub_482FAA(v6);
                    break;
                }
                if (!lstrcmpiA(String1, aEnd_5))
                    break;
                sub_482FAA(v6);
            }
            for (i = 0; i < dword_4B92D8; ++i)
            {
                for (j = 0; j < 4; ++j)
                    sub_47ECA0((_WORD*)(84 * i + dword_4B92D4), j, v11[j]);
                sub_43E7AA(84 * i + dword_4B92D4, (_DWORD)v6, (int)v7);
            }
            LOBYTE(v15) = 0;
            sub_482C2F(v10);
            v15 = -1;
            sub_482C2F(v6);
            return 1;
        }
        else
        {
            LOBYTE(v15) = 0;
            sub_482C2F(v10);
            v15 = -1;
            sub_482C2F(v6);
            return 0;
        }
    }
    else
    {
        v15 = -1;
        sub_482C2F(v6);
        return 0;
    }
} 
int __cdecl sub_47A326(HANDLE hFile, int a2, LPVOID lpBuffer)
{
    _DWORD* v4; // [esp+0h] [ebp-28h]
    int* Block; // [esp+4h] [ebp-24h]
    int i; // [esp+Ch] [ebp-1Ch]
    char Buffer[4]; // [esp+10h] [ebp-18h] BYREF
    DWORD NumberOfBytesRead; // [esp+14h] [ebp-14h] BYREF
    int v9; // [esp+18h] [ebp-10h]
    int v10; // [esp+24h] [ebp-4h]

    int r = 0;
    r = ReadFile(hFile, Buffer, 2u, (LPDWORD)&NumberOfBytesRead, 0);
    r = ReadFile(hFile, lpBuffer, 2u, (LPDWORD)&NumberOfBytesRead, 0);
    int err = GetLastError();

    v9 = *(unsigned __int16*)lpBuffer;
    Block = (int*)operator new(12 * v9 + 4);
    v10 = 0;
    if (Block)
    {
        *Block = v9;
        eh_vector_constructor_iterator(Block + 1, 0xCu, v9, sub_48F630, sub_48F666);
            v4 = Block + 1;
    }
    else
    {
        v4 = 0;
    }
    v10 = -1;
    *(_DWORD*)a2 = (_DWORD)v4;
    for (i = 0; i < *(unsigned __int16*)lpBuffer; ++i)//Õâ¸öinbufferµÄÖ¸ÏòµØÖ·´æÁËÒ»¸öÊý×Ö
        sub_48F6C5((LPVOID*)(12 * i + *(_DWORD*)a2), hFile);
    return 1;
}

 
int __cdecl sub_47A42F(HANDLE hFile, int a2, LPVOID lpBuffer)
{
    _DWORD* v4; // [esp+0h] [ebp-28h]
    int* Block; // [esp+4h] [ebp-24h]
    int i; // [esp+Ch] [ebp-1Ch]
    int Buffer; // [esp+10h] [ebp-18h] BYREF
    DWORD NumberOfBytesRead; // [esp+14h] [ebp-14h] BYREF
    int v9; // [esp+18h] [ebp-10h]
    int v10; // [esp+24h] [ebp-4h]

    SetFilePointer(hFile, 12, 0, 0);
    ReadFile(hFile, &Buffer, 1u, (LPDWORD)&NumberOfBytesRead, 0);
    ReadFile(hFile, lpBuffer, 2u, (LPDWORD)&NumberOfBytesRead, 0);
    v9 = *(unsigned __int16*)lpBuffer;
    int size = 152 * v9 + 4;
    Block = (int*)operator new(size);
    v10 = 0;
    if (Block)
    {
        *Block = v9;
        eh_vector_constructor_iterator(Block + 1, 152, v9, sub_401870, sub_401927);
            v4 = Block + 1;
    }
    else
    {
        v4 = 0;
    }
    v10 = -1;
    *(_DWORD*)a2 = (_DWORD)v4;
    int size_2 = *(unsigned __int16*)lpBuffer;
    for (i = 0; i < *(unsigned __int16*)lpBuffer; ++i)
        sub_40197E((_BYTE*)(152 * i + *(_DWORD*)a2), hFile, (unsigned __int8)Buffer, 0);
    return 1;
}

 
//int sub_47A55C(LPCSTR lpFileName)
//{
//    _DWORD* v2; // esi
//    unsigned __int16 v3; // ax
//    _DWORD* v4; // esi
//    unsigned __int16 v5; // ax
//    char v6; // al
//    char v7; // al
//    int* v8; // eax
//    int* v9; // eax
//    char v10; // al
//    char v11; // al
//    int v12[4]; // [esp+4h] [ebp-64h] BYREF
//    int v13[4]; // [esp+14h] [ebp-54h] BYREF
//    int v14; // [esp+24h] [ebp-44h]
//    int v15; // [esp+28h] [ebp-40h]
//    struct tagRECT rc; // [esp+2Ch] [ebp-3Ch] BYREF
//    int v17; // [esp+3Ch] [ebp-2Ch]
//    int yTop; // [esp+40h] [ebp-28h]
//    int v19; // [esp+44h] [ebp-24h]
//    int yBottom; // [esp+48h] [ebp-20h]
//    int v21; // [esp+4Ch] [ebp-1Ch]
//    int v22; // [esp+50h] [ebp-18h]
//    char* v23; // [esp+54h] [ebp-14h]
//    int j; // [esp+58h] [ebp-10h]
//    int v25; // [esp+5Ch] [ebp-Ch]
//    HANDLE hObject; // [esp+60h] [ebp-8h]
//    int i; // [esp+64h] [ebp-4h]
//
//    hObject = CreateFileA(lpFileName, 0x80000000, 0, 0, 3u, 0x80u, 0);
//    if (hObject == (HANDLE)-1)
//        return 0;
//    //if (!sub_47A326(hObject, *((_DWORD*)lpFileName + 130), *((LPVOID*)lpFileName + 132)))
//    if (!sub_47A326(hObject, (int)((_DWORD*)lpFileName - 130), ((LPVOID*)lpFileName - 132)))//ÎªÊ²Ã´ËûÕâÀïµÄ¶ÑÕ»Ë³ÐòÊÇ·´¹ýÀ´µÄ£¿£¿£¿
//        goto LABEL_4;
//    CloseHandle(hObject);
//    //hObject = CreateFileA(lpFileName + 260, 0x80000000, 0, 0, 3u, 0x80u, 0);
//    hObject = CreateFileA(lpFileName - 260, 0x80000000, 0, 0, 3u, 0x80u, 0);
//    if (hObject == (HANDLE)-1)
//        return 0;
//    //if (!sub_47A42F(hObject, *((_DWORD*)lpFileName + 131), *((LPVOID*)lpFileName + 133)))
//    if (!sub_47A42F(hObject, *((_DWORD*)lpFileName - 131), *((LPVOID*)lpFileName - 133)))
//    {
//    LABEL_4:
//        CloseHandle(hObject);
//        return 0;
//    }
//    CloseHandle(hObject);
//    for (i = 0; i < **((unsigned __int16**)lpFileName + 133); ++i)
//    {
//        v23 = (char*)(152 * i + **((_DWORD**)lpFileName + 131));
//        LOBYTE(v25) = sub_401DFE(v23);
//        v25 = (unsigned __int8)v25;
//        for (j = 0; j < v25; ++j)
//        {
//            v2 = (_DWORD*)*((_DWORD*)lpFileName + 130);
//            v3 = sub_401BEF((_DWORD*)v23, j);
//            LOBYTE(v22) = sub_425F50((_BYTE*)(12 * v3 + *v2));
//            v22 = (unsigned __int8)v22;
//            v4 = (_DWORD*)*((_DWORD*)lpFileName + 130);
//            v5 = sub_401BEF((_DWORD*)v23, j);
//            LOBYTE(v21) = sub_425F90((_BYTE*)(12 * v5 + *v4));
//            v21 = (unsigned __int8)v21;
//            v6 = sub_401C1E((_DWORD*)v23, j, 0);
//            v14 = -v6 - 8 * v22;
//            v7 = sub_401C5B((_DWORD*)v23, j, 0);
//            v15 = -v7 - 8 * v21;
//            sub_401D24((_DWORD*)v23, j, v14, 1);
//            sub_401D62((_DWORD*)v23, j, v15, 1);
//            v8 = sub_425B90(v23, v13, 0, 0);
//            v17 = *v8;
//            yTop = v8[1];
//            v19 = v8[2];
//            yBottom = v8[3];
//            SetRect(&rc, -v19, yTop, -v17, yBottom);
//            sub_475910(v23, rc.left, rc.top, rc.right, rc.bottom, 1, 0);
//            v9 = sub_425BD0(v23, v12, 0, 0);
//            v17 = *v9;
//            yTop = v9[1];
//            v19 = v9[2];
//            yBottom = v9[3];
//            SetRect(&rc, -v19, yTop, -v17, yBottom);
//            sub_475950(v23, rc.left, rc.top, rc.right, rc.bottom, 1, 0);
//            v10 = sub_4758D0(v23, 0);
//            sub_475990(v23, -v10, 1);
//            v11 = sub_4758F0(v23, 0);
//            sub_4759B0(v23, -v11, 1);
//        }
//    }
//    return 1;
//} 
int sub_47A55C(LPCSTR lpFileName, int a0, int a1, int a2,int a3, LPCSTR lpFileName2)
{
    _DWORD* v2; // esi
    unsigned __int16 v3; // ax
    _DWORD* v4; // esi
    unsigned __int16 v5; // ax
    char v6; // al
    char v7; // al
    int* v8; // eax
    int* v9; // eax
    char v10; // al
    char v11; // al
    int v12[4]; // [esp+4h] [ebp-64h] BYREF
    int v13[4]; // [esp+14h] [ebp-54h] BYREF
    int v14; // [esp+24h] [ebp-44h]
    int v15; // [esp+28h] [ebp-40h]
    struct tagRECT rc; // [esp+2Ch] [ebp-3Ch] BYREF
    int v17; // [esp+3Ch] [ebp-2Ch]
    int yTop; // [esp+40h] [ebp-28h]
    int v19; // [esp+44h] [ebp-24h]
    int yBottom; // [esp+48h] [ebp-20h]
    int v21; // [esp+4Ch] [ebp-1Ch]
    int v22; // [esp+50h] [ebp-18h]
    char* v23; // [esp+54h] [ebp-14h]
    int j; // [esp+58h] [ebp-10h]
    int v25; // [esp+5Ch] [ebp-Ch]
    HANDLE hObject; // [esp+60h] [ebp-8h]
    int i; // [esp+64h] [ebp-4h]

    hObject = CreateFileA(lpFileName, 0x80000000, 0, 0, 3u, 0x80u, 0);
    if (hObject == (HANDLE)-1)
        return 0;
    //if (!sub_47A326(hObject, *((_DWORD*)lpFileName + 130), *((LPVOID*)lpFileName + 132)))
    if (!sub_47A326(hObject, *(int*)a0, *(LPVOID*)a2))//ÎªÊ²Ã´ËûÕâÀïµÄ¶ÑÕ»Ë³ÐòÊÇ·´¹ýÀ´µÄ£¿£¿£¿
        goto LABEL_4;
    CloseHandle(hObject);
    //hObject = CreateFileA(lpFileName + 260, 0x80000000, 0, 0, 3u, 0x80u, 0);
    hObject = CreateFileA(lpFileName2, 0x80000000, 0, 0, 3u, 0x80u, 0);
    if (hObject == (HANDLE)-1)
        return 0;
    //if (!sub_47A42F(hObject, *((_DWORD*)lpFileName + 131), *((LPVOID*)lpFileName + 133)))
    if (!sub_47A42F(hObject, *(int*)a1, *((LPVOID*)a3)))
    {
    LABEL_4:
        CloseHandle(hObject);
        return 0;
    }
    CloseHandle(hObject);
    //for (i = 0; i < **((unsigned __int16**)lpFileName + 133); ++i)
    for (i = 0; i < **((unsigned __int16**)a3); ++i)
    {
        //v23 = (char*)(152 * i + **((_DWORD**)lpFileName + 131));
        v23 = (char*)(152 * i + **((_DWORD**)a1));
        LOBYTE(v25) = sub_401DFE(v23);
        v25 = (unsigned __int8)v25;
        for (j = 0; j < v25; ++j)
        {
            //v2 = (_DWORD*)*((_DWORD*)lpFileName + 130);
            v2 = (_DWORD*)*((_DWORD*)a0);
            v3 = sub_401BEF((_DWORD*)v23, j);
            LOBYTE(v22) = sub_425F50((_BYTE*)(12 * v3 + *v2));
            v22 = (unsigned __int8)v22;
            //v4 = (_DWORD*)*((_DWORD*)lpFileName + 130);
            v4 = (int*)*(int*)a0;
            v5 = sub_401BEF((_DWORD*)v23, j);
            LOBYTE(v21) = sub_425F90((_BYTE*)(12 * v5 + *v4));
            v21 = (unsigned __int8)v21;
            v6 = sub_401C1E((_DWORD*)v23, j, 0);
            v14 = -v6 - 8 * v22;
            v7 = sub_401C5B((_DWORD*)v23, j, 0);
            v15 = -v7 - 8 * v21;
            sub_401D24((_DWORD*)v23, j, v14, 1);
            sub_401D62((_DWORD*)v23, j, v15, 1);
            v8 = sub_425B90(v23, v13, 0, 0);
            v17 = *v8;
            yTop = v8[1];
            v19 = v8[2];
            yBottom = v8[3];
            SetRect(&rc, -v19, yTop, -v17, yBottom);
            sub_475910(v23, rc.left, rc.top, rc.right, rc.bottom, 1, 0);
            v9 = sub_425BD0(v23, v12, 0, 0);
            v17 = *v9;
            yTop = v9[1];
            v19 = v9[2];
            yBottom = v9[3];
            SetRect(&rc, -v19, yTop, -v17, yBottom);
            sub_475950(v23, rc.left, rc.top, rc.right, rc.bottom, 1, 0);
            v10 = sub_4758D0(v23, 0);
            sub_475990(v23, -v10, 1);
            v11 = sub_4758F0(v23, 0);
            sub_4759B0(v23, -v11, 1);
        }
    }
    return 1;
}


int __cdecl sub_47A8B4(HANDLE hFile)
{
    int v2; // [esp+0h] [ebp-128h]
    _DWORD* Block; // [esp+4h] [ebp-124h]
    int i; // [esp+Ch] [ebp-11Ch]
    int v5; // [esp+10h] [ebp-118h] BYREF
    int v6; // [esp+14h] [ebp-114h]
    DWORD NumberOfBytesRead; // [esp+18h] [ebp-110h] BYREF
    CHAR Buffer[256]; // [esp+1Ch] [ebp-10Ch] BYREF
    int v9; // [esp+124h] [ebp-4h]

    ReadFile(hFile, Buffer, 0xCu, (LPDWORD)&NumberOfBytesRead, 0);
    if (lstrcmpiA(Buffer, aWpgraphic))
        return 0;
    ReadFile(hFile, &v5, 1u, (LPDWORD)&NumberOfBytesRead, 0);
    ReadFile(hFile, &word_4B92EC, 2u, (LPDWORD)&NumberOfBytesRead, 0);
    v6 = (unsigned __int16)word_4B92EC;
    Block = (_DWORD*)operator new(140 * (unsigned __int16)word_4B92EC + 4);
    v9 = 0;
    if (Block)
    {
        *Block = v6;
        eh_vector_constructor_iterator(Block + 1, 0x8Cu, v6, sub_4909B0, sub_4909D5);
            v2 = (int)(Block + 1);
    }
    else
    {
        v2 = 0;
    }
    v9 = -1;
    dword_4B92E8 = v2;
    for (i = 0; i < (unsigned __int16)word_4B92EC; ++i)
        sub_4909F7((unsigned char*)(dword_4B92E8 + 140 * i), hFile, (unsigned __int8)v5);
    return 1;
}
 
int sub_47AA55()
{
    streambuf* v1; // [esp+0h] [ebp-54h]
    _DWORD* Block; // [esp+20h] [ebp-34h]
    int v3[4]; // [esp+30h] [ebp-24h] BYREF
    int i; // [esp+40h] [ebp-14h]
    int v5; // [esp+44h] [ebp-10h]
    int v6; // [esp+50h] [ebp-4h]

    sub_482BF0(v3);
    v6 = 0;
    if (!sub_482C74((int)v3, aGraphicSkincol))
        goto LABEL_11;
    dword_4B93A0 = sub_4831B2(v3, aStart_10, aEnd_6);
    if ((int)dword_4B93A0 <= 0)
        goto LABEL_11;
    v5 = dword_4B93A0;
    Block = (_DWORD*)operator new(24 * dword_4B93A0 + 4);
    LOBYTE(v6) = 1;
    if (Block)
    {
        *Block = v5;
        eh_vector_constructor_iterator(Block + 1, 0x18u, v5, sub_485B30, sub_485B78);
            v1 = (streambuf*)(Block + 1);
    }
    else
    {
        v1 = 0;
    }
    LOBYTE(v6) = 0;
    dword_4B93A4 = v1;
    if (v1 && (Src = operator new(2 * dword_4B93A0)) != 0 && (dword_4B9394 = operator new(8 * dword_4B93A0)) != 0)
    {
        sub_48328F(v3, aStart_11);
        sub_482FAA(v3);
        for (i = 0; i < (int)dword_4B93A0; ++i)
        {
            if (!sub_485BCA((int)dword_4B93A4 + 24 * i, v3))
                goto LABEL_11;
        }
        v6 = -1;
        sub_482C2F(v3);
        return 1;
    }
    else
    {
    LABEL_11:
        v6 = -1;
        sub_482C2F(v3);
        return 0;
    }
}
 
int sub_47AC9D()
{
    //¶ÑÕ»ÊÇ·´µÄ¡£
    signed int n; // [esp+Ch] [ebp-344h]
    signed int v2; // [esp+10h] [ebp-340h]
    int v3; // [esp+14h] [ebp-33Ch]
    _BYTE* v4; // [esp+18h] [ebp-338h]
    signed int k; // [esp+1Ch] [ebp-334h]
    int j; // [esp+20h] [ebp-330h]
    HANDLE hObject; // [esp+24h] [ebp-32Ch]
    CHAR FileName[260]; // [esp+28h] [ebp-328h] BYREF
    int m; // [esp+12Ch] [ebp-224h]
    int v10; // [esp+130h] [ebp-220h]
    CHAR v11[260]; // [esp+134h] [ebp-21Ch] BYREF
    CHAR v12[260]; // [esp+238h] [ebp-118h] BYREF
    int* v13; // [esp+33Ch] [ebp-14h]
    int* v14; // [esp+340h] [ebp-10h]
    void* v15; // [esp+344h] [ebp-Ch]
    __int16* v16; // [esp+348h] [ebp-8h]
    int i; // [esp+34Ch] [ebp-4h]

    wsprintfA(FileName, "%s\\Data\\WeaponTP.dat", Buffer);
    hObject = CreateFileA(FileName, 0x80000000, 0, 0, 3u, 0x80u, 0);
    if (hObject == (HANDLE)-1)
        return 0;
    if (!sub_47A326(hObject, (int)&dword_4B92F0, &word_4B92F4))
        goto LABEL_4;
    CloseHandle(hObject);
    wsprintfA(FileName, "%s\\Data\\WeaponCG.dat", Buffer);
    hObject = CreateFileA(FileName, 0x80000000, 0, 0, 3u, 0x80u, 0);
    if (hObject == (HANDLE)-1)
        return 0;
    if (!sub_47A8B4(hObject))
    {
    LABEL_4:
        CloseHandle(hObject);
        return 0;
    }
    CloseHandle(hObject);
    for (i = 0; i < 6; ++i)
    {
        wsprintfA(v11, "%s\\Data\\TilePat%02d.dat", Buffer, i);
        wsprintfA(v12, "%s\\Data\\CharGraphic%02d.dat", Buffer, i);
        //v13 = (int*)(4 * i + 4952904);
        //v15 = (void*)(2 * i + 4952892);
        //v14 = (int*)(4 * i + 4952868);
        //v16 = (__int16*)(2 * i + 4952856);
        v13 = (int*)(4 * i + (int)&dword_4B9348);
        v15 = (void*)(2 * i + (int)&dword_4B9328[17]);
        v14 = (int*)(4 * i + (int)&dword_4B9324);
        v16 = (__int16*)(2 * i + (int)&word_4B9318);

        if (!sub_47A55C(v11, (int)&v13, (int)&v14, (int)&v15, (int)&v16,v12))
            return 0;
        if (!i)
        {
            for (j = 0; j < 2; ++j)
            {
                dword_4B9310[j]  = (_DWORD)operator new(2 * (unsigned __int16)word_4B9318[0]);
                memset((void*) *(dword_4B9310 + j), 0, 2 * (unsigned __int16)word_4B9318[0]);
            }
        }
    }
    wsprintfA(v11, "%s\\Data\\misuzu_tp.dat", Buffer);
    //v13 = Sdword_4B9308;
    v13 = (int*)&dword_4B9308;
    v15 = &unk_4B9304;
    wsprintfA(v12, "%s\\Data\\misuzu_cg.dat", Buffer);
    //v14 = dword_4B92FC;
    v14 = (int*)&dword_4B92FC;
    //v16 = &word_4B92F8;
    v16 = (short*)&word_4B92F8;
    if (!sub_47A55C(v11, (int)&v13, (int)&v14, (int)&v15, (int)&v16, v12))
        return 0;
    wsprintfA(v11, "%s\\Data\\Double_Dragon_TP.dat", Buffer);
    v13 = (int*)&unk_4B930C;
    v15 = &unk_4B9306;
    wsprintfA(v12, "%s\\Data\\Double_Dragon_CG.dat", Buffer);
    v14 = (int*)&unk_4B9300;
    v16 = (__int16*)&unk_4B92FA;
    if (!sub_47A55C(v11, (int)&v13, (int)&v14, (int)&v15, (int)&v16, v12))
        return 0;
    if (!sub_47AA55())
        return 0;
    if (!sub_4790CD())
        return 0;
    if (!sub_479E2A())
        return 0;
    v10 = 0;
    dword_4B9398 = 0;
    streambuf::unbuffered((streambuf *)dword_4B93A4, 1);
    for (i = 0; i < (int)dword_4B93A0; ++i)
    {
        if (unknown_libname_17((_DWORD*)dword_4B93A4 + 6 * i))
        {
            *((_WORD*)Src + i) = v10++;
            ++dword_4B9398;
        }
        else
        {
            *((_WORD*)Src + i) = -1;
        }
    }
    for (i = 0; i < 4; ++i)
    {
        dword_4B9380[i] = (int)operator new(2 * dword_4B93A0);
        if (!*(&dword_4B9380 + i))
            return 0;
        dword_4B9370[i] = (_DWORD)operator new(2 * dword_4B93A0);
        if (!dword_4B9370[i])
            return 0;
        for (k = 0; k < (int)dword_4B93A0; ++k)
        {
            *((_WORD*)*(&dword_4B9380 + i) + k) = -1;
            *((_WORD*)dword_4B9370[i] + k) = -1;
        }
    }
    for (m = 0; m < (int)Size; ++m)
    {
        v4 = (_BYTE*)(36 * m + dword_4B92E0);
        v2 = (unsigned __int8)sub_401710(v4);
        v3 = (unsigned __int8)MarkedForDetachment(v4);
        if (v2 < (int)dword_4B93A0 && v3 < 4)
            *((_WORD*)*(&dword_4B9380 + v3) + v2) = 1;
    }
    v10 = 0;
    for (i = 0; i < 4; ++i)
    {
        v10 = 0;
        for (n = 0; n < (int)dword_4B93A0; ++n)
        {
            if (*((_WORD*)*(&dword_4B9380 + i) + n) == 1)
                *((_WORD*)*(&dword_4B9380 + i) + n) = v10++;
        }
    }
    if (!sub_47818A())
        return 0;
    sub_4780C0();
    return 1;
}
 
void sub_47B2C4()
{
    /*  ???
    void(__thiscall * **v0)(_DWORD, int); // [esp+3Ch] [ebp-5Ch]
    void(__thiscall * **v1)(_DWORD, int); // [esp+44h] [ebp-54h]
    void(__thiscall * **v2)(_DWORD, int); // [esp+4Ch] [ebp-4Ch]
    void(__thiscall * **v3)(_DWORD, int); // [esp+54h] [ebp-44h]
    int i; // [esp+94h] [ebp-4h]
    int j; // [esp+94h] [ebp-4h]
    int k; // [esp+94h] [ebp-4h]
    int m; // [esp+94h] [ebp-4h]

    if (Src)
         delete(Src);
    Src = 0;
    if (dword_4B9394)
         delete(dword_4B9394);
    dword_4B9394 = 0;
    for (i = 0; i < 4; ++i)
    {
        if (*(&dword_4B9380 + i))
             delete(*(&dword_4B9380 + i));
        *(&dword_4B9380 + i) = 0;
        if (dword_4B9370[i])
             delete(dword_4B9370[i]);
        dword_4B9370[i] = 0;
    }
    if (dword_4B93A4)
        (**(void(__thiscall***)(streambuf*, int))dword_4B93A4)(dword_4B93A4, 3);
    dword_4B93A4 = 0;
    dword_4B93A0 = 0;
    for (j = 0; j < dword_4B9368; ++j)
    {
        if (*((_DWORD*)dword_4B9364 + j))
            operator delete(*((void**)dword_4B9364 + j));
        *((_DWORD*)dword_4B9364 + j) = 0;
        if (*((_DWORD*)dword_4B9360 + j))
            operator delete(*((void**)dword_4B9360 + j));
        *((_DWORD*)dword_4B9360 + j) = 0;
    }
    if (dword_4B9364)
         delete(dword_4B9364);
    dword_4B9364 = 0;
    if (dword_4B9360)
         delete(dword_4B9360);
    dword_4B9360 = 0;
    dword_4B9368 = 0;
    if (dword_4B92E0)
        (**(void(__thiscall***)(int, int))dword_4B92E0)(dword_4B92E0, 3);
    dword_4B92E0 = 0;
    if (dword_4B92DC)
         delete(dword_4B92DC);
    dword_4B92DC = 0;
    Size = 0;
    if (dword_4B92D4)
        (**(void(__thiscall***)(int, int))dword_4B92D4)(dword_4B92D4, 3);
    dword_4B92D4 = 0;
    dword_4B92D8 = 0;
    for (k = 0; k < 6; ++k)
    {
        if (dword_4B9348[k])
        {
            v3 = (void(__thiscall***)(_DWORD, int))dword_4B9348[k];
            if (v3)
                (**v3)(v3, 3);
        }
        if (dword_4B9324[k])
        {
            v2 = (void(__thiscall***)(_DWORD, int))dword_4B9324[k];
            if (v2)
                (**v2)(v2, 3);
        }
        dword_4B9348[k] = 0;
        dword_4B9324[k] = 0;
    }
    for (m = 0; m < 2; ++m)
    {
        if (dword_4B9308[m])
        {
            v1 = (void(__thiscall***)(_DWORD, int))dword_4B9308[m];
            if (v1)
                (**v1)(v1, 3);
        }
        if (dword_4B92FC[m])
        {
            v0 = (void(__thiscall***)(_DWORD, int))dword_4B92FC[m];
            if (v0)
                (**v0)(v0, 3);
        }
        if (*(dword_4B9310 + m))
             delete(*(dword_4B9310 + m));
        dword_4B9308[m] = 0;
        dword_4B92FC[m] = 0;
        *(dword_4B9310 + m) = 0;
    }
    if (dword_4B92F0)
        (**(void(__thiscall***)(int, int))dword_4B92F0)(dword_4B92F0, 3);
    dword_4B92F0 = 0;
    word_4B92F4 = 0;
    if (dword_4B92E8)
        (**(void(__thiscall***)(int, int))dword_4B92E8)(dword_4B92E8, 3);
    dword_4B92E8 = 0;
    word_4B92EC = 0;
    */
}
 
int __cdecl sub_47B7ED(int a1, int a2, LPCSTR lpString, int a4, int a5)
{
    int result; // eax
    int v6; // [esp+4h] [ebp-50h]
    int i; // [esp+8h] [ebp-4Ch]
    struct tagRECT rc; // [esp+Ch] [ebp-48h] BYREF
    int v9; // [esp+1Ch] [ebp-38h] BYREF
    int v10; // [esp+20h] [ebp-34h]
    int v11; // [esp+24h] [ebp-30h]

    sub_49C15E((_DWORD)&v9);
    v10 = a1;
    v11 = a2;
    v6 = lstrlenA(lpString);
    result = a4 & 2;
    if ((a4 & 2) != 0)
    {
        v10 -= 4 * v6;
    }
    else
    {
        result = a4 & 4;
        if ((a4 & 4) != 0)
            v10 -= 8 * v6;
    }
    for (i = 0; i < v6; ++i)
    {
        v9 = dword_4B9218;
        SetRect(&rc, 8 * ((lpString[i] - 32) % 32), 8 * ((lpString[i] - 32) / 32), 8, 8);
        sub_4A03B3((short*)unk_4BDC60, a5, &v9, (_DWORD*)&rc);
        if ((a4 & 1) != 0)
        {
            ++v10;
            sub_4A03B3((short*)unk_4BDC60, a5, &v9, (_DWORD*)&rc);
            v10 += 7;
        }
        else
        {
            v10 += 8;
        }
        result = i + 1;
    }
    return result;
}

 
int __cdecl sub_47B91A(int a1, int a2, LPCSTR lpString, int a4, int a5)
{
    int result; // eax
    int n; // [esp+0h] [ebp-6Ch]
    int j; // [esp+4h] [ebp-68h]
    int k; // [esp+4h] [ebp-68h]
    int m; // [esp+4h] [ebp-68h]
    int v10; // [esp+8h] [ebp-64h]
    int v11; // [esp+Ch] [ebp-60h]
    int i; // [esp+10h] [ebp-5Ch]
    CHAR String1; // [esp+14h] [ebp-58h] BYREF
    char v14; // [esp+15h] [ebp-57h]
    int v15; // [esp+18h] [ebp-54h]
    int v16; // [esp+1Ch] [ebp-50h]
    int v17[2]; // [esp+20h] [ebp-4Ch] BYREF
    int v18; // [esp+28h] [ebp-44h]
    struct tagRECT rc; // [esp+58h] [ebp-14h] BYREF
    int v20; // [esp+68h] [ebp-4h]

    sub_49C15E((int)v17);
    v20 = a1 - 8;
    v15 = a2;
    v16 = lstrlenA(lpString);
    result = a4 & 2;
    if ((a4 & 2) != 0)
    {
        v20 -= 2 * v16;
    }
    else
    {
        result = a4 & 4;
        if ((a4 & 4) != 0)
            v20 -= 4 * v16;
    }
    for (i = 0; i < v16; i += 2)
    {
        v20 += 8;
        lstrcpynA(&String1, &lpString[i], 3);
        if (String1 == 92 && v14 == 110)
        {
            v15 += 16;
            v20 = a1 - 8;
        }
        else
        {
            v10 = 0;
            v11 = 0;
            for (j = 0; j < 81; ++j)
            {
                if (String1 == byte_4B443C[3 * j] && v14 == byte_4B443D[3 * j])
                {
                    v10 = 1;
                    String1 = byte_4B4530[3 * j];
                    v14 = byte_4B4531[3 * j];
                    break;
                }
            }
            if (!v10)
            {
                for (k = 0; k < 10; ++k)
                {
                    if (String1 == byte_4B4624[3 * k] && v14 == byte_4B4625[3 * k])
                    {
                        v11 = 1;
                        String1 = byte_4B4644[3 * k];
                        v14 = byte_4B4645[3 * k];
                        break;
                    }
                }
            }
            for (m = 0; m < 246 && (String1 != byte_4B4158[3 * m] || v14 != byte_4B4159[3 * m]); ++m)
                ;
            if (m != 246)
            {
                for (n = 0; n < (a4 & 1) + 1; ++n)
                {
                    v17[1] = n + v20;
                    v18 = v15;
                    v17[0] = dword_4B921C;
                    SetRect(&rc, 8 * (m % 16), 8 * (m / 16), 8, 8);
                    if (a5 == -1)
                        sub_49C8A6((int)unk_4BDC60, v17, (_DWORD*)&rc);
                    else
                        sub_4A03B3((short*)unk_4BDC60, a5, v17, (_DWORD*)&rc);
                    if (v10 || v11)
                    {
                        v18 = v15 - 8;
                        v17[0] = dword_4B921C;
                        if (v10)
                            SetRect(&rc, 120, 56, 8, 8);
                        else
                            SetRect(&rc, 0, 64, 8, 8);
                        if (a5 == -1)
                            sub_49C8A6((int)unk_4BDC60, v17, (_DWORD*)&rc);
                        else
                            sub_4A03B3((short*)unk_4BDC60, a5, v17, (_DWORD*)&rc);
                    }
                }
            }
        }
        result = i + 2;
    }
    return result;
} 
int __cdecl sub_47BC5A(int a1, int a2, LPCSTR lpString, int a4, int a5)
{
    int result; // eax
    int v6; // [esp+4h] [ebp-54h]
    int i; // [esp+8h] [ebp-50h]
    int v8; // [esp+Ch] [ebp-4Ch]
    struct tagRECT rc; // [esp+10h] [ebp-48h] BYREF
    int v10; // [esp+20h] [ebp-38h] BYREF
    int v11; // [esp+24h] [ebp-34h]
    int v12; // [esp+28h] [ebp-30h]

    sub_49C15E((_DWORD)&v10);
    v12 = a2;
    v8 = lstrlenA(lpString);
    v6 = a1;
    result = a4 & 2;
    if ((a4 & 2) != 0)
    {
        v6 = a1 - 4 * v8;
    }
    else
    {
        result = a4 & 4;
        if ((a4 & 4) != 0)
            v6 = a1 - 8 * v8;
    }
    for (i = 0; i < v8; ++i)
    {
        if (lpString[i] != 32)
        {
            v11 = v6 + 8 * i;
            v10 = dword_4B921C;
            SetRect(&rc, 8 * ((lpString[i] + 15) % 16), 8 * ((lpString[i] + 15) / 16), 8, 8);
            sub_4A03B3((short*)unk_4BDC60, a5, &v10, (_DWORD*)&rc);
            if ((a4 & 1) != 0)
            {
                ++v11;
                sub_4A03B3((short*)unk_4BDC60, a5, &v10, (_DWORD*)&rc);
            }
        }
        result = i + 1;
    }
    return result;
}

 
int __cdecl sub_47BD8E(int a1, int a2, int a3, int a4)
{
    int result; // eax
    int i; // [esp+4h] [ebp-18h]
    int v6; // [esp+8h] [ebp-14h]
    int v7; // [esp+Ch] [ebp-10h]
    CHAR String[4]; // [esp+10h] [ebp-Ch] BYREF
    int v9; // [esp+14h] [ebp-8h]
    int v10; // [esp+18h] [ebp-4h]

    v9 = 0;
    result = a3 - 1;
    switch (a3)
    {
    case 1:
    case 22:
    case 46:
        v9 = 1;
        break;
    case 2:
    case 18:
    case 47:
        v9 = 2;
        break;
    case 3:
    case 12:
        v9 = 3;
        break;
    case 4:
    case 13:
    case 15:
        v9 = 4;
        break;
    case 5:
        v9 = 5;
        break;
    case 6:
        v9 = 6;
        break;
    case 7:
        v9 = 7;
        break;
    case 8:
        v9 = 8;
        break;
    case 9:
        v9 = 9;
        break;
    case 10:
        v9 = 10;
        break;
    case 11:
        v9 = 11;
        break;
    case 14:
        v9 = 12;
        break;
    case 16:
    case 27:
    case 45:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 71:
        v9 = 13;
        break;
    case 17:
        v9 = 14;
        break;
    case 19:
        v9 = 15;
        break;
    case 20:
    case 21:
        v9 = 16;
        break;
    case 23:
        v9 = 17;
        break;
    case 24:
    case 53:
        v9 = 18;
        break;
    case 25:
    case 54:
        v9 = 19;
        break;
    case 26:
        v9 = 20;
        break;
    case 28:
        v9 = 21;
        break;
    case 29:
    case 31:
    case 44:
    case 49:
    case 51:
    case 61:
    case 63:
    case 65:
    case 67:
        v9 = 22;
        break;
    case 30:
    case 50:
    case 52:
    case 60:
    case 62:
    case 64:
    case 66:
    case 68:
    case 69:
        v9 = 23;
        break;
    case 32:
    case 33:
        v9 = 24;
        break;
    case 34:
        v9 = 25;
        break;
    case 35:
        v9 = 26;
        break;
    case 36:
        v9 = 27;
        break;
    case 37:
        v9 = 28;
        break;
    case 38:
        v9 = 29;
        break;
    case 39:
        v9 = 30;
        break;
    case 40:
        v9 = 31;
        break;
    case 41:
        v9 = 32;
        break;
    case 42:
        v9 = 33;
        break;
    case 43:
        v9 = 34;
        break;
    case 48:
        v9 = 35;
        break;
    case 70:
        v9 = 36;
        break;
    case 72:
        v9 = 37;
        break;
    case 255:
        v9 = 38;
        break;
    default:
        break;
    }
    if (a3 != 255 && a3 >= 73)
        v9 = a3 - 127;
    if (v9)
    {
        --v9;
        if (a3 == 255 || a3 < 73)
            v10 = (int)byte_4B4F88 + 57 * v9;
        else
            v10 = (int)&byte_4B5800 + 57 * v9;
        v7 = a1;
        result = a2;
        v6 = a2;
        while (1)
        {
            for (i = 0; i < 2; ++i)
            {
                result = i + v10;
                if (!*(_BYTE*)(i + v10))
                    break;
                result = i;
                String[i] = *(_BYTE*)(i + v10);
            }
            if (i < 2)
                break;
            v10 += 2;
            String[2] = 0;
            if (String[0] == 92 && String[1] == 110)
            {
                v7 = a1;
                result = v6 + 16;
                v6 += 16;
            }
            else
            {
                result = sub_47B91A(v7, v6, String, 0, a4);
                v7 += 8;
            }
        }
    }
    return result;
}
 
int __cdecl sub_47C20C(unsigned __int16 a1)
{
    signed int i; // [esp+0h] [ebp-4h]

    for (i = 0; i < (int)dword_4B93A0; ++i)
    {
        if (unknown_libname_22((_DWORD*)dword_4B93A4 + 6 * i) == a1)
            return i;
    }
    return -1;
}

 
int __cdecl sub_47C25B(unsigned __int8 a1)
{
    int j; // [esp+0h] [ebp-554h]
    DWORD NumberOfBytesRead; // [esp+4h] [ebp-550h] BYREF
    HANDLE hFile; // [esp+8h] [ebp-54Ch]
    int v5[15]; // [esp+Ch] [ebp-548h] BYREF
    _DWORD Buffer[256]; // [esp+48h] [ebp-50Ch] BYREF
    int i; // [esp+448h] [ebp-10Ch]
    int v8; // [esp+44Ch] [ebp-108h]
    CHAR FileName[260]; // [esp+450h] [ebp-104h] BYREF

    v8 = 1;
    for (i = 0; i < (int)dword_4B93A0; ++i)
    {
        if (unknown_libname_17((_DWORD*)dword_4B93A4 + 6 * i))
        {
            sub_49DB90(v5);
            v5[1] = 0;
            v5[2] = 0;
            v5[3] = -1;
            v5[4] = -1;
            v5[5] = 1;
            v5[9] = 0;
            v5[0] = -1;
            wsprintfA(FileName, "Graphic\\%02dpPalette.bin", a1 + 1);
            hFile = CreateFileA(FileName, 0x80000000, 0, 0, 3u, 0x80u, 0);
            if (hFile != (HANDLE)-1)
            {
                for (j = 0; j < 256; ++j)
                    ReadFile(hFile, &Buffer[j], 3u, (LPDWORD)&NumberOfBytesRead, 0);
                v5[11] = (int)Buffer;
                CloseHandle(hFile);
            }
            sub_485DFD((int)dword_4B93A4 + 24 * i, (int)Buffer);
            if (!sub_49DA45((_DWORD*)unk_4BDC60, aGraphicCharsel, (int)v5))
                return 0;
            if (v8)
            {
                v8 = 0;
                dword_4B9234 = v5[0];
            }
        }
    }
    return 1;
}
 
int sub_47C427()
{
    int j; // [esp+0h] [ebp-554h]
    DWORD NumberOfBytesRead; // [esp+4h] [ebp-550h] BYREF
    HANDLE hFile; // [esp+8h] [ebp-54Ch]
    _DWORD Buffer[256]; // [esp+Ch] [ebp-548h] BYREF
    int i; // [esp+40Ch] [ebp-148h]
    int v6; // [esp+410h] [ebp-144h]
    int v7[15]; // [esp+414h] [ebp-140h] BYREF
    CHAR FileName[260]; // [esp+450h] [ebp-104h] BYREF

    v6 = 1;
    sub_49DB90(v7);
    v7[1] = 0;
    v7[2] = 0;
    v7[3] = -1;
    v7[4] = -1;
    v7[5] = 1;
    v7[9] = 0;
    v7[0] = -1;
    v7[14] = (int)&word_4B9290;
    if (!sub_49DA45((_DWORD*)unk_4BDC60, aGraphicCharsel_0, (int)v7))
        return 0;
    v6 = 0;
    dword_4B9234 = v7[0];
    for (i = 0; i < 8; ++i)
    {
        wsprintfA(FileName, "Graphic\\%02dpPalette.bin", i + 1);
        hFile = CreateFileA(FileName, 0x80000000, 0, 0, 3u, 0x80u, 0);
        if (hFile != (HANDLE)-1)
        {
            for (j = 0; j < 256; ++j)
                ReadFile(hFile, &Buffer[j], 3u, (LPDWORD)&NumberOfBytesRead, 0);
            CloseHandle(hFile);
        }
        sub_4A0AE7((void*)(8 * i + 4952656), (int)Buffer, 256);
        sub_4A0AE7((void*)(8 * i + 4952720), (int)Buffer, 256);
    }
    return 1;
}
 
int sub_47C5F0()
{
    unsigned __int16 v1; // ax
    unsigned __int16 v2; // ax
    char v3; // al
    char v4; // al
    int* v5; // eax
    int* v6; // eax
    char v7; // al
    char v8; // al
    int* v9; // eax
    int* v10; // eax
    char v11[16]; // [esp+0h] [ebp-40Ch] BYREF
    char v12[16]; // [esp+10h] [ebp-3FCh] BYREF
    char v13[16]; // [esp+20h] [ebp-3ECh] BYREF
    char v14[16]; // [esp+30h] [ebp-3DCh] BYREF
    struct tagRECT v15; // [esp+40h] [ebp-3CCh] BYREF
    int v16; // [esp+50h] [ebp-3BCh]
    int v17; // [esp+54h] [ebp-3B8h]
    int v18; // [esp+58h] [ebp-3B4h]
    int v19; // [esp+5Ch] [ebp-3B0h]
    int v20; // [esp+60h] [ebp-3ACh]
    int v21; // [esp+64h] [ebp-3A8h]
    int v22; // [esp+68h] [ebp-3A4h]
    int m; // [esp+6Ch] [ebp-3A0h]
    int v24; // [esp+70h] [ebp-39Ch]
    char* v25; // [esp+74h] [ebp-398h]
    char* v26; // [esp+78h] [ebp-394h]
    int v27; // [esp+7Ch] [ebp-390h]
    int v28; // [esp+80h] [ebp-38Ch]
    struct tagRECT rc; // [esp+84h] [ebp-388h] BYREF
    int v30; // [esp+94h] [ebp-378h]
    int yTop; // [esp+98h] [ebp-374h]
    int v32; // [esp+9Ch] [ebp-370h]
    int yBottom; // [esp+A0h] [ebp-36Ch]
    int v34; // [esp+A4h] [ebp-368h]
    int v35; // [esp+A8h] [ebp-364h]
    char* v36; // [esp+ACh] [ebp-360h]
    int k; // [esp+B0h] [ebp-35Ch]
    int v38; // [esp+B4h] [ebp-358h]
    int v39[15]; // [esp+B8h] [ebp-354h] BYREF
    int v40[15]; // [esp+F4h] [ebp-318h] BYREF
    int v41[15]; // [esp+130h] [ebp-2DCh] BYREF
    int v42[15]; // [esp+16Ch] [ebp-2A0h] BYREF
    int v43[15]; // [esp+1A8h] [ebp-264h] BYREF
    int v44[15]; // [esp+1E4h] [ebp-228h] BYREF
    int v45[15]; // [esp+220h] [ebp-1ECh] BYREF
    int v46; // [esp+25Ch] [ebp-1B0h] BYREF
    int v47; // [esp+260h] [ebp-1ACh]
    int v48; // [esp+264h] [ebp-1A8h]
    int v49; // [esp+268h] [ebp-1A4h]
    int v50; // [esp+26Ch] [ebp-1A0h]
    int v51; // [esp+270h] [ebp-19Ch]
    int v52; // [esp+280h] [ebp-18Ch]
    int v53; // [esp+298h] [ebp-174h] BYREF
    int v54; // [esp+29Ch] [ebp-170h]
    int v55; // [esp+2A0h] [ebp-16Ch]
    int v56; // [esp+2A4h] [ebp-168h]
    int v57; // [esp+2A8h] [ebp-164h]
    int v58; // [esp+2ACh] [ebp-160h]
    int v59; // [esp+2BCh] [ebp-150h]
    int v60; // [esp+2D4h] [ebp-138h] BYREF
    int v61; // [esp+2D8h] [ebp-134h]
    int v62; // [esp+2DCh] [ebp-130h]
    int v63; // [esp+2E0h] [ebp-12Ch]
    int v64; // [esp+2E4h] [ebp-128h]
    int v65; // [esp+2E8h] [ebp-124h]
    int v66; // [esp+2F8h] [ebp-114h]
    int v67; // [esp+310h] [ebp-FCh] BYREF
    int v68; // [esp+314h] [ebp-F8h]
    int v69; // [esp+318h] [ebp-F4h]
    int v70; // [esp+31Ch] [ebp-F0h]
    int v71; // [esp+320h] [ebp-ECh]
    int v72; // [esp+324h] [ebp-E8h]
    int v73; // [esp+334h] [ebp-D8h]
    int v74; // [esp+34Ch] [ebp-C0h] BYREF
    int v75; // [esp+350h] [ebp-BCh]
    int v76; // [esp+354h] [ebp-B8h]
    int v77; // [esp+358h] [ebp-B4h]
    int v78; // [esp+35Ch] [ebp-B0h]
    int v79; // [esp+360h] [ebp-ACh]
    int v80; // [esp+370h] [ebp-9Ch]
    int v81[15]; // [esp+388h] [ebp-84h] BYREF
    int v82; // [esp+3C4h] [ebp-48h] BYREF
    int v83; // [esp+3C8h] [ebp-44h]
    int v84; // [esp+3CCh] [ebp-40h]
    int v85; // [esp+3D0h] [ebp-3Ch]
    int v86; // [esp+3D4h] [ebp-38h]
    int v87; // [esp+3D8h] [ebp-34h]
    int v88; // [esp+3E8h] [ebp-24h]
    int j; // [esp+400h] [ebp-Ch]
    int i; // [esp+404h] [ebp-8h]
    int v91; // [esp+408h] [ebp-4h]

    sub_467CD0((int*)unk_4B9B10);
    v91 = sub_49CB92((int)unk_4BDC60, -1, 320, 240, 0, 0);
    if (v91 == -1)
        return 0;
    dword_4B9248 = v91;
    sub_49DB90(&v82);
    v83 = 0;
    v84 = 0;
    v85 = -1;
    v86 = -1;
    v87 = 1;
    v88 = 0;
    v82 = -1;
    if (sub_49DA45((_DWORD*)unk_4BDC60, aGraphicFont00B, (int)&v82))
    {
        dword_4B921C = v82;
        v83 = 0;
        v84 = 0;
        v85 = -1;
        v86 = -1;
        v87 = 1;
        v88 = 0;
        v82 = -1;
        if (sub_49DA45((_DWORD*)unk_4BDC60, aGraphicFont01B, (int)&v82))
        {
            dword_4B9218 = v82;
            sub_49DB90(v81);
            v81[1] = 0;
            v81[2] = 0;
            v81[3] = 8;
            v81[4] = 8;
            v81[5] = -1;
            v81[9] = 0;
            v81[0] = -1;
            v81[14] = 0;
            if (sub_49DA45((_DWORD*)unk_4BDC60, aGraphicDamagef, (int)v81))
            {
                dword_4B91FC = v81[0];
                sub_49DB90(&v74);
                v75 = 0;
                v76 = 0;
                v77 = 40;
                v78 = 8;
                v79 = 1;
                v80 = -1;
                v74 = -1;
                if (sub_49DA45((_DWORD*)unk_4BDC60, aGraphicSystem0_2, (int)&v74))
                {
                    dword_4B91F8 = v74;
                    v75 = 0;
                    v76 = 8;
                    v77 = 8;
                    v78 = 8;
                    v79 = 5;
                    v80 = -1;
                    v74 = -1;
                    if (sub_49DA45((_DWORD*)unk_4BDC60, aGraphicSystem0_3, (int)&v74))
                    {
                        v75 = 0;
                        v76 = 16;
                        v77 = 8;
                        v78 = 8;
                        v79 = 10;
                        v80 = -1;
                        v74 = -1;
                        if (sub_49DA45((_DWORD*)unk_4BDC60, aGraphicSystem0_4, (int)&v74))
                        {
                            dword_4B91F4 = v74;
                            sub_49DB90(&v67);
                            v68 = 0;
                            v69 = 0;
                            v70 = 8;
                            v71 = 8;
                            v72 = 8;
                            v73 = 0;
                            v67 = -1;
                            if (sub_49DA45((_DWORD*)unk_4BDC60, aGraphicEffect0, (int)&v67))
                            {
                                dword_4B91F0 = v67;
                                v68 = 0;
                                v69 = 16;
                                v70 = 16;
                                v71 = 16;
                                v72 = 2;
                                v73 = 0;
                                v67 = -1;
                                if (sub_49DA45((_DWORD*)unk_4BDC60, aGraphicEffect0_0, (int)&v67))
                                {
                                    v68 = 0;
                                    v69 = 32;
                                    v70 = 8;
                                    v71 = 8;
                                    v72 = 3;
                                    v73 = 0;
                                    v67 = -1;
                                    if (sub_49DA45((_DWORD*)unk_4BDC60, aGraphicEffect0_1, (int)&v67))
                                    {
                                        v68 = 0;
                                        v69 = 40;
                                        v70 = 8;
                                        v71 = 8;
                                        v72 = 2;
                                        v73 = 0;
                                        v67 = -1;
                                        if (sub_49DA45((_DWORD*)unk_4BDC60, aGraphicEffect0_2, (int)&v67))
                                        {
                                            v68 = 0;
                                            v69 = 48;
                                            v70 = 32;
                                            v71 = 8;
                                            v72 = 13;
                                            v73 = 0;
                                            v67 = -1;
                                            if (sub_49DA45((_DWORD*)unk_4BDC60, aGraphicEffect0_3, (int)&v67))
                                            {
                                                sub_49DB90(&v60);
                                                v61 = 0;
                                                v62 = 0;
                                                v63 = -1;
                                                v64 = -1;
                                                v65 = 1;
                                                v66 = -1;
                                                v60 = -1;
                                                if (sub_49DA45((_DWORD*)unk_4BDC60, aGraphicSystem0_5, (int)&v60))
                                                    dword_4B9208 = v60;
                                                else
                                                    dword_4B9208 = 0;
                                                v61 = 0;
                                                v62 = 0;
                                                v63 = -1;
                                                v64 = -1;
                                                v65 = 1;
                                                v66 = -1;
                                                v60 = -1;
                                                if (sub_49DA45((_DWORD*)unk_4BDC60, aGraphicSystem0_6, (int)&v60))
                                                {
                                                    dword_4B920C = v60;
                                                    if (!dword_4B9208)
                                                        dword_4B9208 = v60;
                                                    sub_49DB90(&v53);
                                                    v54 = 0;
                                                    v55 = 0;
                                                    v56 = 48;
                                                    v57 = 8;
                                                    v58 = 3;
                                                    v59 = 0;
                                                    v53 = -1;
                                                    if (sub_49DA45((_DWORD*)unk_4BDC60, aGraphicSystem0_7, (int)&v53))
                                                    {
                                                        v54 = 0;
                                                        v55 = 32;
                                                        v56 = 48;
                                                        v57 = 8;
                                                        v58 = 2;
                                                        v59 = 0;
                                                        v53 = -1;
                                                        if (sub_49DA45((_DWORD*)unk_4BDC60, aGraphicSystem0_8, (int)&v53))
                                                        {
                                                            dword_4B91DC = v53;
                                                            v54 = 96;
                                                            v55 = 32;
                                                            v56 = 8;
                                                            v57 = 8;
                                                            v58 = 5;
                                                            v59 = 0;
                                                            v53 = -1;
                                                            if (sub_49DA45((_DWORD*)unk_4BDC60, aGraphicSystem0_9, (int)&v53))
                                                            {
                                                                sub_49DB90(&v46);
                                                                v47 = 0;
                                                                v48 = 24;
                                                                v49 = 8;
                                                                v50 = 8;
                                                                v51 = 11;
                                                                v52 = 0;
                                                                v46 = -1;
                                                                if (sub_49DA45((_DWORD*)unk_4BDC60, aGraphicSystem0_10, (int)&v46))
                                                                {
                                                                    dword_4B9200 = v46;
                                                                    v47 = 104;
                                                                    v48 = 8;
                                                                    v49 = 40;
                                                                    v50 = 8;
                                                                    v51 = 1;
                                                                    v46 = -1;
                                                                    if (sub_49DA45((_DWORD*)unk_4BDC60, aGraphicSystem0_11, (int)&v46))
                                                                    {
                                                                        dword_4B91E4 = v46;
                                                                        v47 = 136;
                                                                        v48 = 16;
                                                                        v49 = 8;
                                                                        v50 = 8;
                                                                        v51 = 1;
                                                                        v46 = -1;
                                                                        if (sub_49DA45((_DWORD*)unk_4BDC60, aGraphicSystem0_12, (int)&v46))
                                                                        {
                                                                            sub_49DB90(v45);
                                                                            v45[1] = 0;
                                                                            v45[2] = 0;
                                                                            v45[3] = -1;
                                                                            v45[4] = -1;
                                                                            v45[5] = 1;
                                                                            v45[9] = 0;
                                                                            v45[0] = -1;
                                                                            v45[6] = 0;
                                                                            if (sub_49DA45((_DWORD*)unk_4BDC60, aGraphicShadowB, (int)v45))
                                                                            {
                                                                                dword_4B9214 = v45[0];
                                                                                sub_49DB90(v44);
                                                                                v44[1] = 0;
                                                                                v44[2] = 0;
                                                                                v44[3] = 8;
                                                                                v44[4] = 8;
                                                                                v44[5] = -1;
                                                                                v44[9] = 0;
                                                                                v44[0] = -1;
                                                                                v44[6] = 0;
                                                                                if (sub_49DA45((_DWORD*)unk_4BDC60, aGraphicRectBmp, (int)v44))
                                                                                {
                                                                                    dword_4B9210 = v44[0];
                                                                                    sub_49DB90(v43);
                                                                                    v43[1] = 0;
                                                                                    v43[2] = 0;
                                                                                    v43[3] = -1;
                                                                                    v43[4] = 8;
                                                                                    v43[5] = -1;
                                                                                    v43[9] = 0;
                                                                                    v43[0] = -1;
                                                                                    dword_4B936C = sub_49DA45((_DWORD*)unk_4BDC60, aGraphicFaceBmp, (int)v43);
                                                                                    if (dword_4B936C)
                                                                                    {
                                                                                        dword_4B9238 = v43[0];
                                                                                        sub_49DB90(v42);
                                                                                        v42[1] = 0;
                                                                                        v42[2] = 0;
                                                                                        v42[3] = 72;
                                                                                        v42[4] = 40;
                                                                                        v42[5] = -1;
                                                                                        v42[9] = 0;
                                                                                        v42[0] = -1;
                                                                                        if (sub_49DA45((_DWORD*)unk_4BDC60, aGraphicSystem0_13, (int)v42))
                                                                                        {
                                                                                            dword_4B9240 = v42[0];
                                                                                            sub_49DB90(v41);
                                                                                            v41[1] = 0;
                                                                                            v41[2] = 0;
                                                                                            v41[3] = 32;
                                                                                            v41[4] = 32;
                                                                                            v41[5] = -1;
                                                                                            v41[9] = -1;
                                                                                            v41[0] = -1;
                                                                                            if (sub_49DA45((_DWORD*)unk_4BDC60, aGraphicStagese_1, (int)v41))
                                                                                            {
                                                                                                dword_4B9244 = v41[0];
                                                                                                sub_49DB90(v40);
                                                                                                v40[1] = 0;
                                                                                                v40[2] = 0;
                                                                                                v40[3] = 16;
                                                                                                v40[4] = 16;
                                                                                                v40[5] = -1;
                                                                                                v40[9] = 0;
                                                                                                v40[0] = -1;
                                                                                                if (sub_49DA45((_DWORD*)unk_4BDC60, aGraphicItemBmp, (int)v40))
                                                                                                {
                                                                                                    dword_4B91EC = v40[0];
                                                                                                    sub_49DB90(v39);
                                                                                                    v39[1] = 0;
                                                                                                    v39[2] = 0;
                                                                                                    memset(&v39[3], 255, 12);
                                                                                                    v39[9] = 0;
                                                                                                    v39[0] = -1;
                                                                                                    if (sub_49DA45((_DWORD*)unk_4BDC60, aGraphicWeaponB, (int)v39))
                                                                                                    {
                                                                                                        dword_4B91E8 = v39[0];
                                                                                                        for (i = 0; i < 60; ++i)
                                                                                                            dword_4B99FC[i] = -1;
                                                                                                        dword_4B99FC[0] = sub_43FC18((_DWORD*)unk_4BDB28, aSoundCursourWa);
                                                                                                        dword_4B9A00 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundClickWav);
                                                                                                        dword_4B9A04 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundJumpWav);
                                                                                                        dword_4B9A08 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundKaraburiW);
                                                                                                        dword_4B9A0C = sub_43FC18((_DWORD*)unk_4BDB28, aSoundHit01Wav);
                                                                                                        dword_4B9A10 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundHit02Wav);
                                                                                                        dword_4B9A14 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundDown01Wav);
                                                                                                        dword_4B9A18 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundSlidingWa);
                                                                                                        dword_4B9A1C = sub_43FC18((_DWORD*)unk_4BDB28, aSoundTsukamiWa);
                                                                                                        dword_4B9A20 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundHit03Wav);
                                                                                                        dword_4B9A24 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundTsukitoba);
                                                                                                        dword_4B9A28 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundGuard01Wa);
                                                                                                        dword_4B9A2C = sub_43FC18((_DWORD*)unk_4BDB28, aSoundDown03Wav);
                                                                                                        dword_4B9A30 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundGoodbyWav);
                                                                                                        dword_4B9A34 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundExplosion);
                                                                                                        dword_4B9A38 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundSpecial01);
                                                                                                        dword_4B9A3C = sub_43FC18((_DWORD*)unk_4BDB28, aSoundSpecial02);
                                                                                                        dword_4B9A40 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundSpecial03);
                                                                                                        dword_4B9A44 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundSpecial04);
                                                                                                        dword_4B9A48 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundDown02Wav);
                                                                                                        dword_4B9A4C = sub_43FC18((_DWORD*)unk_4BDB28, aSoundTaihouWav);
                                                                                                        dword_4B9A50 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundSpecial05);
                                                                                                        dword_4B9A54 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundSpecial06);
                                                                                                        dword_4B9A58 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundSpecial07);
                                                                                                        dword_4B9A5C = sub_43FC18((_DWORD*)unk_4BDB28, aSoundHit04Wav);
                                                                                                        dword_4B9A60 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundSpecial08);
                                                                                                        dword_4B9A64 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundHit05Wav);
                                                                                                        dword_4B9A68 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundSpecial09);
                                                                                                        dword_4B9A6C = sub_43FC18((_DWORD*)unk_4BDB28, aSoundSpecial10);
                                                                                                        dword_4B9A70 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundSpecial11);
                                                                                                        dword_4B9A74 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundWeaponget);
                                                                                                        dword_4B9A78 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundBound01Wa);
                                                                                                        dword_4B9A7C = sub_43FC18((_DWORD*)unk_4BDB28, aSoundBound02Wa);
                                                                                                        dword_4B9A80 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundBound03Wa);
                                                                                                        dword_4B9A84 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundBound04Wa);
                                                                                                        dword_4B9A88 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundKaraburi2);
                                                                                                        dword_4B9A8C = sub_43FC18((_DWORD*)unk_4BDB28, aSoundBound05Wa);
                                                                                                        dword_4B9A90 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundSpecial12);
                                                                                                        dword_4B9A94 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundSpecial13);
                                                                                                        dword_4B9A98 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundSpecial14);
                                                                                                        dword_4B9A9C = sub_43FC18((_DWORD*)unk_4BDB28, aSoundSpecial15);
                                                                                                        dword_4B9AA0 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundSpecial16);
                                                                                                        dword_4B9AA4 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundSpecial17);
                                                                                                        dword_4B9AA8 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundSpecial18);
                                                                                                        dword_4B9AAC = sub_43FC18((_DWORD*)unk_4BDB28, aSoundSpecial19);
                                                                                                        dword_4B9AB0 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundSpecial20);
                                                                                                        dword_4B9AB4 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundCommand01);
                                                                                                        dword_4B9AB8 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundSpecial21);
                                                                                                        dword_4B9ABC = sub_43FC18((_DWORD*)unk_4BDB28, aSoundHit06Wav);
                                                                                                        dword_4B9AC0 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundHit07Wav);
                                                                                                        dword_4B9AC4 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundExplosion_0);
                                                                                                        dword_4B9AC8 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundDashWav);
                                                                                                        dword_4B9ACC = sub_43FC18((_DWORD*)unk_4BDB28, aSoundBound06Wa);
                                                                                                        dword_4B9AD0 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundThrow01Wa);
                                                                                                        dword_4B9AD4 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundLvupWav);
                                                                                                        dword_4B9AD8 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundCheerWav);
                                                                                                        dword_4B9ADC = sub_43FC18((_DWORD*)unk_4BDB28, aSoundHit08Wav);
                                                                                                        dword_4B9AE0 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundSupercomb);
                                                                                                        dword_4B9AE4 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundSplashdow);
                                                                                                        dword_4B9AE8 = sub_43FC18((_DWORD*)unk_4BDB28, aSoundTeleportW);
                                                                                                        if (sub_47AC9D())
                                                                                                        {
                                                                                                            for (j = 0; j < 6; ++j)
                                                                                                            {
                                                                                                                for (i = 0; i < (unsigned __int16)word_4B9318[j]; ++i)
                                                                                                                {
                                                                                                                    v36 = (char*)(152 * i + dword_4B9324[j]);
                                                                                                                    LOBYTE(v38) = sub_401DFE(v36);
                                                                                                                    v38 = (unsigned __int8)v38;
                                                                                                                    for (k = 0; k < v38; ++k)
                                                                                                                    {
                                                                                                                        v1 = sub_401BEF((_DWORD*)v36, k);
                                                                                                                        LOBYTE(v35) = sub_425F50((_BYTE*)(12 * v1 + dword_4B9348[j]));
                                                                                                                        v35 = (unsigned __int8)v35;
                                                                                                                        v2 = sub_401BEF((_DWORD*)v36, k);
                                                                                                                        LOBYTE(v34) = sub_425F90((_BYTE*)(12 * v2 + dword_4B9348[j]));
                                                                                                                        v34 = (unsigned __int8)v34;
                                                                                                                        v3 = sub_401C1E((_DWORD*)v36, k, 0);
                                                                                                                        v27 = -v3 - 8 * v35;
                                                                                                                        v4 = sub_401C5B((_DWORD*)v36, k, 0);
                                                                                                                        v28 = -v4 - 8 * v34;
                                                                                                                        sub_401D24((_DWORD*)v36, k, v27, 1);
                                                                                                                        sub_401D62((_DWORD*)v36, k, v28, 1);
                                                                                                                        v5 = sub_425B90(v36, (_DWORD*)v14, 0, 0);
                                                                                                                        v30 = *v5;
                                                                                                                        yTop = v5[1];
                                                                                                                        v32 = v5[2];
                                                                                                                        yBottom = v5[3];
                                                                                                                        SetRect(&rc, -v32, yTop, -v30, yBottom);
                                                                                                                        sub_475910(v36, rc.left, rc.top, rc.right, rc.bottom, 1, 0);
                                                                                                                        v6 = sub_425BD0(v36, (_DWORD*)v13, 0, 0);
                                                                                                                        v30 = *v6;
                                                                                                                        yTop = v6[1];
                                                                                                                        v32 = v6[2];
                                                                                                                        yBottom = v6[3];
                                                                                                                        SetRect(&rc, -v32, yTop, -v30, yBottom);
                                                                                                                        sub_475950(v36, rc.left, rc.top, rc.right, rc.bottom, 1, 0);
                                                                                                                        v7 = sub_4758D0(v36, 0);
                                                                                                                        sub_475990(v36, -v7, 1);
                                                                                                                        v8 = sub_4758F0(v36, 0);
                                                                                                                        sub_4759B0(v36, -v8, 1);
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                            for (i = 0; i < (unsigned __int16)word_4B92EC; ++i)
                                                                                                            {
                                                                                                                v26 = (char*)(140 * i + dword_4B92E8);
                                                                                                                v25 = sub_47EF20(v26);
                                                                                                                v22 = unknown_libname_2((_DWORD*)v25);
                                                                                                                LOBYTE(v24) = unknown_libname_3(v25);
                                                                                                                v24 = (unsigned __int8)v24;
                                                                                                                for (m = 0; m < v24; ++m)
                                                                                                                {
                                                                                                                    LOBYTE(v21) = sub_425F50((_BYTE*)(12
                                                                                                                        * *(unsigned __int16*)(v22 + 8 * m)
                                                                                                                        + dword_4B92F0));
                                                                                                                    v21 = (unsigned __int8)v21;
                                                                                                                    LOBYTE(v20) = sub_425F90((_BYTE*)(12
                                                                                                                        * *(unsigned __int16*)(v22 + 8 * m)
                                                                                                                        + dword_4B92F0));
                                                                                                                    v20 = (unsigned __int8)v20;
                                                                                                                    *(_BYTE*)(v22 + 8 * m + 3) = -*(_BYTE*)(v22 + 8 * m + 2)
                                                                                                                        - 8 * v21;
                                                                                                                    *(_BYTE*)(v22 + 8 * m + 5) = -*(_BYTE*)(v22 + 8 * m + 4)
                                                                                                                        - 8 * v20;
                                                                                                                    v9 = sub_47EE20(v26, (_DWORD*)v12, 0, 0);
                                                                                                                    v16 = *v9;
                                                                                                                    v17 = v9[1];
                                                                                                                    v18 = v9[2];
                                                                                                                    v19 = v9[3];
                                                                                                                    SetRect(&v15, -v18, v17, -v16, v19);
                                                                                                                    sub_47EEA0(v26, v15.left, v15.top, v15.right, v15.bottom, 1, 0);
                                                                                                                    v10 = sub_47EE60(v26, (_DWORD*)v11, 0, 0);
                                                                                                                    v16 = *v10;
                                                                                                                    v17 = v10[1];
                                                                                                                    v18 = v10[2];
                                                                                                                    v19 = v10[3];
                                                                                                                    SetRect(&v15, -v18, v17, -v16, v19);
                                                                                                                    sub_47EEE0(v26,v15.left, v15.top, v15.right, v15.bottom, 1, 0);
                                                                                                                }
                                                                                                            }
                                                                                                            sub_47732A();
                                                                                                            sub_476F0D();
                                                                                                            byte_4B91D9 = 0;
                                                                                                            byte_4B91D8 = 0;
                                                                                                            return 1;
                                                                                                        }
                                                                                                        else
                                                                                                        {
                                                                                                            sub_47B2C4();
                                                                                                            return 0;
                                                                                                        }
                                                                                                    }
                                                                                                    else
                                                                                                    {
                                                                                                        MessageBoxA(hWnd, byte_4B65A4, aError_37, 0);
                                                                                                        return 0;
                                                                                                    }
                                                                                                }
                                                                                                else
                                                                                                {
                                                                                                    MessageBoxA(hWnd, byte_4B6554, aError_36, 0);
                                                                                                    return 0;
                                                                                                }
                                                                                            }
                                                                                            else
                                                                                            {
                                                                                                MessageBoxA(hWnd, byte_4B64FC, aError_35, 0);
                                                                                                return 0;
                                                                                            }
                                                                                        }
                                                                                        else
                                                                                        {
                                                                                            MessageBoxA(hWnd, byte_4B64A4, aError_34, 0);
                                                                                            return 0;
                                                                                        }
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                        MessageBoxA(hWnd, byte_4B6460, aError_33, 0);
                                                                                        return 0;
                                                                                    }
                                                                                }
                                                                                else
                                                                                {
                                                                                    MessageBoxA(hWnd, byte_4B6420, aError_32, 0);
                                                                                    return 0;
                                                                                }
                                                                            }
                                                                            else
                                                                            {
                                                                                MessageBoxA(hWnd, byte_4B63E0, aError_31, 0);
                                                                                return 0;
                                                                            }
                                                                        }
                                                                        else
                                                                        {
                                                                            MessageBoxA(hWnd, byte_4B63A0, aError_30, 0);
                                                                            return 0;
                                                                        }
                                                                    }
                                                                    else
                                                                    {
                                                                        MessageBoxA(hWnd, byte_4B635C, aError_29, 0);
                                                                        return 0;
                                                                    }
                                                                }
                                                                else
                                                                {
                                                                    MessageBoxA(hWnd, byte_4B6304, aError_28, 0);
                                                                    return 0;
                                                                }
                                                            }
                                                            else
                                                            {
                                                                MessageBoxA(hWnd, byte_4B62AC, aError_27, 0);
                                                                return 0;
                                                            }
                                                        }
                                                        else
                                                        {
                                                            MessageBoxA(hWnd, byte_4B6258, aError_26, 0);
                                                            return 0;
                                                        }
                                                    }
                                                    else
                                                    {
                                                        MessageBoxA(hWnd, byte_4B6210, aError_25, 0);
                                                        return 0;
                                                    }
                                                }
                                                else
                                                {
                                                    MessageBoxA(hWnd, byte_4B61C8, aError_24, 0);
                                                    return 0;
                                                }
                                            }
                                            else
                                            {
                                                MessageBoxA(hWnd, byte_4B6160, aError_23, 0);
                                                return 0;
                                            }
                                        }
                                        else
                                        {
                                            MessageBoxA(hWnd, byte_4B6110, aError_22, 0);
                                            return 0;
                                        }
                                    }
                                    else
                                    {
                                        MessageBoxA(hWnd, byte_4B60C0, aError_21, 0);
                                        return 0;
                                    }
                                }
                                else
                                {
                                    MessageBoxA(hWnd, byte_4B6070, aError_20, 0);
                                    return 0;
                                }
                            }
                            else
                            {
                                MessageBoxA(hWnd, byte_4B6020, aError_19, 0);
                                return 0;
                            }
                        }
                        else
                        {
                            MessageBoxA(hWnd, byte_4B5FD0, aError_18, 0);
                            return 0;
                        }
                    }
                    else
                    {
                        MessageBoxA(hWnd, byte_4B5F80, aError_17, 0);
                        return 0;
                    }
                }
                else
                {
                    MessageBoxA(hWnd, byte_4B5F34, aError_16, 0);
                    return 0;
                }
            }
            else
            {
                MessageBoxA(hWnd, byte_4B5EE4, aError_15, 0);
                return 0;
            }
        }
        else
        {
            MessageBoxA(hWnd, byte_4B5E9C, aError_14, 0);
            return 0;
        }
    }
    else
    {
        MessageBoxA(hWnd, byte_4B5E58, aError_13, 0);
        return 0;
    }
} 

//¶Ô³ÌÐòÊµÀý×öÒ»Ð©ÅäÖÃ£¬²»ÓÃ¹Ü
int __cdecl ÉèÖÃ_WNDCLASSA(HINSTANCE hInstance)
{
    WNDCLASSA WndClass; // [esp+0h] [ebp-28h] BYREF

    WndClass.style = 3;
    WndClass.lpfnWndProc = sub_47E7B6;
    WndClass.cbClsExtra = 0;
    WndClass.cbWndExtra = 0;
    WndClass.hInstance = hInstance;
    WndClass.hIcon = LoadIconA(hInstance, (LPCSTR)0x69);
    WndClass.hCursor = LoadCursorA(0, (LPCSTR)0x7F00);
    WndClass.hbrBackground = (HBRUSH)GetStockObject(4);
    WndClass.lpszMenuName = 0;
    WndClass.lpszClassName = aLegendOfBurnin;
    return RegisterClassA(&WndClass);
}
 
int __cdecl sub_47E5AC(HINSTANCE hInstance, int nCmdShow)
{
    struct tagRECT rc; // [esp+10h] [ebp-38h] BYREF
    //int v4[5]; // [esp+20h] [ebp-28h] BYREF
    int v4[256]; // [esp+20h] [ebp-28h] BYREF
    char v5; // [esp+34h] [ebp-14h]
    char v6; // [esp+35h] [ebp-13h]
    int v7; // [esp+38h] [ebp-10h]
    int v8; // [esp+3Ch] [ebp-Ch]
    int v9; // [esp+40h] [ebp-8h]
    HINSTANCE v10; // [esp+44h] [ebp-4h]

    v7 = 320;
    v8 = 240;
    v9 = 100 * (unsigned __int8)byte_4B99E7;
    byte_4B91D0 = byte_4B99E8;
    byte_4B999A = 4;
    v10 = hInstance;
    if (byte_4B99E9)
    {
        hWnd = CreateWindowExA(
            0,
            ClassName,
            WindowName,
            0x80000000,
            0x80000000,
            0x80000000,
            v9 * v7 / 100 + 10,
            v9 * v8 / 100 + 28,
            0,
            0,
            hInstance,
            0);
    }
    else
    {
        SetRect(&rc, 0, 0, v9 * v7 / 100, v9 * v8 / 100);
        AdjustWindowRectEx(&rc, 0xC80000u, 0, 0x300u);
        hWnd = CreateWindowExA(
            0x300u,
            aLegendOfBurnin_3,
            aLegendOfBurnin_2,
            0xC80000u,
            0x80000000,
            0x80000000,
            rc.right - rc.left,
            rc.bottom - rc.top,
            0,
            0,
            hInstance,
            0);
    }
    if (!hWnd)
        return 0;
    ShowWindow(hWnd, nCmdShow);//ÏÔÊ¾´°¿Ú
    UpdateWindow(hWnd);
    if (sub_43F7F7((long*)unk_4BDB28, (int)hWnd))
    {
        sub_49DB43(v4);
        v4[0] = (int)hWnd;
        v4[4] = (unsigned __int8)byte_4B99E9;//ÕâÀï²»ÄÜÎª1Å¶£¬²»È»ºóÃæ»á±¨´í
        v4[1] = v7;
        v4[2] = v8;
        v5 = 1;
        v6 = byte_4B91D0;
        v4[3] = (v9 << 8) / 100;
        if (sub_4998E0((int)unk_4BDC60, (int)v4))//´íÎó
        {
            sub_474DB0((char*)unk_4BDC60, 1);
            return 1;
        }
        else
        {
            return 0;
        }
    }
    else
    {
        MessageBoxA(hWnd, byte_4B6B34, aError_38, 0);
        return 0;
    }
}
 
LRESULT __stdcall sub_47E7B6(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    sub_446497((_DWORD*)unk_4B9B10, 240, 32);
    sub_47EFA0((char*)unk_4B9B10);
    if (Msg > 6)
    {
        if (Msg == 32)
        {
            SetCursor(0);
            return 1;
        }
        if (Msg == 256)
        {
            switch (wParam)
            {
            case 0x1Bu:
            case 0x7Bu:
                PostMessageA(hWnd, 0x10u, 0, 0);
                break;
            case 0x70u:
                sub_453B66((int)unk_4B9B10);
                break;
            case 0x71u:
                dword_4B93A8 = dword_4B93A8 == 0;
                break;
            case 0x72u:
                sub_4685F6((_DWORD*)unk_4B9B10);
                break;
            case 0x73u:
                sub_468667((int)unk_4B9B10);
                break;
            case 0x78u:
                if (byte_4B91D9)
                    byte_4B91D1 = 1;
                break;
            case 0x7Au:
                if (byte_4B91D9)
                    dword_4B91D4 = dword_4B91D4 == 0;
                break;
            default:
                return DefWindowProcA(hWnd, Msg, wParam, lParam);
            }
        }
    }
    else if (Msg == 6)
    {
        if (wParam)
        {
            dword_4B99F8 = 1;
            sub_4A1376((char*)unk_4BDC60, 0);
            if (!byte_4B99E6)
            {
                dword_4B99EC = 1;
                if (!sub_47EF80((_DWORD*)unk_4B9B10))
                    sub_440BC2((int)unk_4BDB28);
            }
        }
        else
        {
            dword_4B99F8 = 0;
            sub_4A1376((char*)unk_4BDC60, 1);
            if (!byte_4B99E6)
            {
                dword_4B99EC = 0;
                sub_440B78((int)unk_4BDB28);
            }
        }
    }
    else if (Msg != 1 && Msg == 2)
    {
        PostQuitMessage(0);
    }
    return DefWindowProcA(hWnd, Msg, wParam, lParam);
}

 
_BYTE* sub_47EA90(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[18] = a2;
    return result;
}
 
_BYTE* sub_47EAB0(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[19] = a2;
    return result;
}
 
_BYTE* sub_47EAD0(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[20] = a2;
    return result;
}
 
_BYTE* sub_47EAF0(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[21] = a2;
    return result;
}
 
_BYTE* sub_47EB10(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[22] = a2;
    return result;
}
 
_BYTE* sub_47EB30(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[23] = a2;
    return result;
}
 
_BYTE* sub_47EB50(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[24] = a2;
    return result;
}
 
_BYTE* sub_47EB70(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[25] = a2;
    return result;
}
 
_BYTE* sub_47EB90(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[26] = a2;
    return result;
}
 
_BYTE* sub_47EBB0(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[27] = a2;
    return result;
}
 
_BYTE* sub_47EBD0(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[30] = a2;
    return result;
}
 
_BYTE* sub_47EBF0(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[31] = a2;
    return result;
}
 
char* sub_47EC10(_BYTE* thisx, int a2, char a3)
{
    char* result; // eax

    result = &thisx[a2];
    thisx[a2 + 32] = a3;
    return result;
}
 
char* sub_47EC30(char* thisx, char a2)
{
    if ((a2 & 2) != 0)
    {
        eh_vector_destructor_iterator(thisx, 0x24u, *((_DWORD *)thisx - 1), sub_40174E);
            if ((a2 & 1) != 0)
                operator delete(thisx - 4);
        return thisx - 4;
    }
    else
    {
        sub_40174E(thisx);
        if ((a2 & 1) != 0)
            operator delete(thisx);
        return thisx;
    }
}
 
int sub_47ECA0(_WORD* thisx, int a2, __int16 a3)
{
    int result; // eax

    result = a2;
    thisx[a2 + 38] = a3;
    return result;
}
 
char* sub_47ECC0(char* thisx, char a2)
{
    if ((a2 & 2) != 0)
    {
        eh_vector_destructor_iterator(thisx, 0x54u, *((_DWORD *)thisx - 1), sub_43E6E5);
            if ((a2 & 1) != 0)
                operator delete(thisx - 4);
        return thisx - 4;
    }
    else
    {
        sub_43E6E5(thisx);
        if ((a2 & 1) != 0)
            operator delete(thisx);
        return thisx;
    }
}
 
char* sub_47ED30(char* thisx, char a2)
{
    if ((a2 & 2) != 0)
    {
        eh_vector_destructor_iterator(thisx, 0x8Cu, *((_DWORD *)thisx - 1), sub_4909D5);
            if ((a2 & 1) != 0)
                operator delete(thisx - 4);
        return thisx - 4;
    }
    else
    {
        sub_4909D5(thisx);
        if ((a2 & 1) != 0)
            operator delete(thisx);
        return thisx;
    }
}
 
char* sub_47EDB0(char* thisx, char a2)
{
    if ((a2 & 2) != 0)
    {
        eh_vector_destructor_iterator(thisx, 0x18u, *((_DWORD *)thisx - 1), sub_485B78);
            if ((a2 & 1) != 0)
                operator delete(thisx - 4);
        return thisx - 4;
    }
    else
    {
        sub_485B78(thisx);
        if ((a2 & 1) != 0)
            operator delete(thisx);
        return thisx;
    }
}
 
_DWORD* sub_47EE20(char* thisx, _DWORD* a2, int a3, int a4)
{
    char* v4; // edx

    v4 = &thisx[32 * a3 + 4 + 16 * a4];
    *a2 = *(_DWORD*)v4;
    a2[1] = *((_DWORD*)v4 + 1);
    a2[2] = *((_DWORD*)v4 + 2);
    a2[3] = *((_DWORD*)v4 + 3);
    return a2;
}
 
_DWORD* sub_47EE60(char* thisx, _DWORD* a2, int a3, int a4)
{
    char* v4; // edx

    v4 = &thisx[32 * a3 + 68 + 16 * a4];
    *a2 = *(_DWORD*)v4;
    a2[1] = *((_DWORD*)v4 + 1);
    a2[2] = *((_DWORD*)v4 + 2);
    a2[3] = *((_DWORD*)v4 + 3);
    return a2;
}
 
int sub_47EEA0(char* thisx, int a2, int a3, int a4, int a5, int a6, int a7)
{
    char* v7; // edx
    int result; // eax

    v7 = &thisx[32 * a6 + 4 + 16 * a7];
    *(_DWORD*)v7 = a2;
    *((_DWORD*)v7 + 1) = a3;
    *((_DWORD*)v7 + 2) = a4;
    result = a5;
    *((_DWORD*)v7 + 3) = a5;
    return result;
}
 
int sub_47EEE0(char* thisx, int a2, int a3, int a4, int a5, int a6, int a7)
{
    char* v7; // edx
    int result; // eax

    v7 = &thisx[32 * a6 + 68 + 16 * a7];
    *(_DWORD*)v7 = a2;
    *((_DWORD*)v7 + 1) = a3;
    *((_DWORD*)v7 + 2) = a4;
    result = a5;
    *((_DWORD*)v7 + 3) = a5;
    return result;
}
 
char* sub_47EF20(char* thisx)
{
    return thisx + 132;
}
 
int sub_47EF40(_DWORD* thisx)
{
    return thisx[12288];
}


 
int sub_47EF80(_DWORD* thisx)
{
    return thisx[626];
}

 
char* sub_47EFA0(char* thisx)
{
    return thisx + 11436;
}
 
void sub_47EFC0(void* thisx)
{
    *(_DWORD*)thisx = off_4AC2E0;
    *((_BYTE*)thisx + 28) = 0;
}
 
void sub_47EFDE(void* thisx)
{
    *(_DWORD*)thisx = off_4AC2E0;
}
 
int sub_47EFF2(int thisx, int a2)
{
    int result; // eax

    if (a2)
    {
        *(_BYTE*)(thisx + 28) = *(_BYTE*)(a2 + 12);
        *(_DWORD*)(thisx + 4) = *(_DWORD*)a2;
        *(_DWORD*)(thisx + 8) = *(_DWORD*)(a2 + 4);
        *(_DWORD*)(thisx + 12) = *(_DWORD*)(a2 + 8);
        result = thisx;
        *(_DWORD*)(thisx + 32) = 0;
        *(_DWORD*)(thisx + 36) = 0;
    }
    return result;
}
 
int sub_47F04A(int thisx)
{
    int result; // eax

    result = thisx;
    if (*(_BYTE*)(thisx + 28))
    {
        if ((int)++ * (_DWORD*)(thisx + 32) >= 300)
            *(_DWORD*)(thisx + 36) = *(_DWORD*)(thisx + 32) / 5 % 2;
        result = thisx;
        if (*(_DWORD*)(thisx + 32) == 480)
            *(_BYTE*)(thisx + 28) = 0;
    }
    return result;
}
 
unsigned __int16* sub_47F0B1(int thisx)
{
    unsigned __int16* result; // eax
    int v2; // esi
    int v4[14]; // [esp+8h] [ebp-38h] BYREF

    result = (unsigned __int16*)thisx;
    if (*(_BYTE*)(thisx + 28))
    {
        if (!*(_DWORD*)(thisx + 36))
        {
            sub_49C15E((int)v4);
            v4[1] = *(_DWORD*)(thisx + 4) - sub_446465((char*)unk_4B9B10) - 8;
            v2 = *(_DWORD*)(thisx + 8) - 16 - *(_DWORD*)(thisx + 12);
            v4[2] = sub_4464BA((int)unk_4B9B10) + v2;
            v4[0] = dword_4B91EC + *(unsigned __int8*)(thisx + 28) - 1;
            return sub_49AB05((int)unk_4BDC60, v4);
        }
    }
    return result;
}
 
_BYTE* sub_47F138(_BYTE* thisx)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[28] = 0;
    return result;
}
 
_BYTE* sub_47F14A(_BYTE* thisx)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[28] = 0;
    return result;
}
 
void* sub_47F160(void* thisx, char a2)
{
    sub_47EFDE(thisx);
    if ((a2 & 1) != 0)
        operator delete(thisx);
    return thisx;
}
 
_DWORD* sub_47F190(_DWORD* thisx)
{
    *thisx = off_4AC2E4;
    thisx[68] = 4;
    thisx[69] = -1;
    thisx[138] = 0;
    memset(thisx + 1, 0, 0x100u);
    memset(thisx + 74, 0, 0x100u);
    return thisx;
}
 
_DWORD* sub_47F1FD(_DWORD* thisx)
{
    _DWORD* result; // eax

    result = thisx;
    *thisx = off_4AC2E4;
    return result;
}
 
int __fastcall sub_47F211(int a1)
{
    int result; // eax
    char* v2; // eax
    const char* v3; // eax
    CHAR String; // [esp+4h] [ebp-18h] BYREF
    char v6; // [esp+5h] [ebp-17h]
    char v7; // [esp+6h] [ebp-16h]
    int v8; // [esp+8h] [ebp-14h]
    char* v9; // [esp+Ch] [ebp-10h]
    int v10; // [esp+10h] [ebp-Ch]
    char v11; // [esp+14h] [ebp-8h]
    CHAR v12; // [esp+18h] [ebp-4h]

    result = a1;
    if (*(_DWORD*)(a1 + 276) != -1)
    {
        result = sub_47FAB0(a1);
        if (result)
        {
            result = a1;
            ++* (_DWORD*)(a1 + 552);
        }
        if (*(int*)(a1 + 268) > 0)
        {
            result = *(_DWORD*)(a1 + 268) - 1;
            *(_DWORD*)(a1 + 268) = result;
            while (!*(_DWORD*)(a1 + 268))
            {
                if (*(_DWORD*)(a1 + 292) == -1)
                {
                    result = a1;
                    if ((int)++ * (_DWORD*)(a1 + 260) >= 256
                        || (result = lstrlenA((LPCSTR)(a1 + 4)), *(_DWORD*)(a1 + 260) >= result))
                    {
                        *(_DWORD*)(a1 + 268) = -1;
                        return result;
                    }
                }
                v12 = *(_BYTE*)(a1 + *(_DWORD*)(a1 + 260) + 4);
                if (*(int*)(a1 + 292) >= 0)
                    v12 = *(_BYTE*)(a1 + *(_DWORD*)(a1 + 292) + 296);
                if (v12 == 92)
                {
                    result = a1;
                    if ((int)++ * (_DWORD*)(a1 + 260) >= 256
                        || (result = lstrlenA((LPCSTR)(a1 + 4)), *(_DWORD*)(a1 + 260) >= result))
                    {
                        *(_DWORD*)(a1 + 268) = -1;
                        return result;
                    }
                    v12 = *(_BYTE*)(a1 + *(_DWORD*)(a1 + 260) + 4);
                    result = a1;
                    v11 = *(_BYTE*)(a1 + *(_DWORD*)(a1 + 260) + 5);
                    if (v12 == 110)
                    {
                        *(_BYTE*)(a1 + 264) = 0;
                        result = a1;
                        ++* (_BYTE*)(a1 + 265);
                    }
                    else if (v12 == 46)
                    {
                        *(_DWORD*)(a1 + 268) = 15;
                    }
                    else
                    {
                        result = v12;
                        if (v12 == 124)
                        {
                            *(_DWORD*)(a1 + 268) = 60;
                        }
                        else if (v12 == 119 || (result = v12, v12 == 87))
                        {
                            result = sub_47F6B3(a1);
                            *(_DWORD*)(a1 + 268) = result;
                            if (*(int*)(a1 + 268) < 0)
                            {
                                result = a1;
                                *(_DWORD*)(a1 + 268) = 0;
                            }
                        }
                        else
                        {
                            switch (v12)
                            {
                            case 'S':
                            case 's':
                                result = sub_47F6B3(a1);
                                *(_DWORD*)(a1 + 272) = result;
                                if (*(int*)(a1 + 272) < 0)
                                {
                                    result = a1;
                                    *(_DWORD*)(a1 + 272) = 4;
                                }
                                break;
                            case 'N':
                                v10 = sub_47F6B3(a1);
                                result = sub_426590(unk_4B9B10, v10);
                                v9 = (char*)result;
                                if (result)
                                {
                                    v2 = sub_4266D0(v9);
                                    result = wsprintfA((LPSTR)(a1 + 296), "%s", v2);
                                    *(_DWORD*)(a1 + 292) = 0;
                                }
                                break;
                            case 'T':
                                result = v11;
                                if (v11 == 78)
                                {
                                    ++* (_DWORD*)(a1 + 260);
                                    v8 = sub_47F6B3(a1);
                                    v3 = (const char*)sub_471036((unsigned __int8*)unk_4B9B10, v8);
                                    wsprintfA((LPSTR)(a1 + 296), "%s", v3);
                                    result = a1;
                                    *(_DWORD*)(a1 + 292) = 0;
                                }
                                break;
                            }
                        }
                    }
                }
                else
                {
                    String = v12;
                    if (*(_DWORD*)(a1 + 292) == -1)
                    {
                        if ((int)++ * (_DWORD*)(a1 + 260) >= 256 || *(_DWORD*)(a1 + 260) >= lstrlenA((LPCSTR)(a1 + 4)))
                        {
                            result = a1;
                            *(_DWORD*)(a1 + 268) = -1;
                            return result;
                        }
                        v6 = *(_BYTE*)(a1 + *(_DWORD*)(a1 + 260) + 4);
                    }
                    else
                    {
                        ++* (_DWORD*)(a1 + 292);
                        v6 = *(_BYTE*)(a1 + (*(_DWORD*)(a1 + 292))++ + 296);
                        if (lstrlenA((LPCSTR)(a1 + 296)) <= *(_DWORD*)(a1 + 292))
                            *(_DWORD*)(a1 + 292) = -1;
                    }
                    v7 = 0;
                    if ((unsigned __int8)++ * (_BYTE*)(a1 + 264) >= 0x24u)
                    {
                        *(_BYTE*)(a1 + 264) = 0;
                        ++* (_BYTE*)(a1 + 265);
                    }
                    sub_47B91A(
                        8 * *(unsigned __int8*)(a1 + 264),
                        16 * *(unsigned __int8*)(a1 + 265) + 8,
                        &String,
                        0,
                        *(_DWORD*)(a1 + 276));
                    result = *(_DWORD*)(a1 + 272);
                    *(_DWORD*)(a1 + 268) = result;
                }
            }
        }
    }
    return result;
}
 
int sub_47F6B3(int thisx)
{
    int v3; // [esp+4h] [ebp-10Ch]
    int v4; // [esp+8h] [ebp-108h]
    CHAR String1[256]; // [esp+Ch] [ebp-104h] BYREF
    int v6; // [esp+10Ch] [ebp-4h]

    if ((int)++ * (_DWORD*)(thisx + 260) >= 256 || *(_DWORD*)(thisx + 260) >= lstrlenA((LPCSTR)(thisx + 4)))
        return -1;
    if (*(_BYTE*)(thisx + *(_DWORD*)(thisx + 260) + 4) != 91)
        return -1;
    ++* (_DWORD*)(thisx + 260);
    v3 = 0;
    if (*(_BYTE*)(thisx + *(_DWORD*)(thisx + 260) + 4) == 118 || *(_BYTE*)(thisx + *(_DWORD*)(thisx + 260) + 4) == 86)
    {
        ++* (_DWORD*)(thisx + 260);
        v3 = 1;
    }
    if (*(int*)(thisx + 260) >= 256 || *(_DWORD*)(thisx + 260) >= lstrlenA((LPCSTR)(thisx + 4)))
        return -1;
    if (*(_BYTE*)(thisx + *(_DWORD*)(thisx + 260) + 4) == 93)
        return 0;
    if (*(char*)(thisx + *(_DWORD*)(thisx + 260) + 4) < 48 || *(char*)(thisx + *(_DWORD*)(thisx + 260) + 4) > 57)
        return 0;
    v4 = *(_DWORD*)(thisx + 260);
    do
    {
        if ((int)++ * (_DWORD*)(thisx + 260) >= 256 || *(_DWORD*)(thisx + 260) >= lstrlenA((LPCSTR)(thisx + 4)))
            return -1;
    } while (*(_BYTE*)(thisx + *(_DWORD*)(thisx + 260) + 4) != 93);
    v6 = *(_DWORD*)(thisx + 260);
    lstrcpynA(String1, (LPCSTR)(thisx + v4 + 4), v6 - v4 + 1);
    if (v3)
        return dword_4B9AEC[atoi(String1)];
    else
        return atoi(String1);
}

 
int sub_47F958(_DWORD* thisx)
{
	thisx[69] = sub_49CB92((int)unk_4BDC60, -1, 288, 32, 0, 0);
	return sub_47FBA3((int)thisx);
}

 
_DWORD* sub_47F98B(_DWORD* thisx)
{
    _DWORD* result; // eax
    int v3[14]; // [esp+4h] [ebp-38h] BYREF

    result = thisx;
    if ((int)thisx[69] >= 0)
    {
        sub_49C15E((_DWORD)v3);
        v3[1] = 16;
        v3[2] = 200;
        v3[0] = thisx[69];
        return (_DWORD*)sub_49AB05((int)unk_4BDC60, v3);
    }
    return result;
}
 
void sub_47F9D6(int thisx, LPCSTR lpString, int a3)
{
    int iMaxLength; // [esp+4h] [ebp-4h]

    if (lpString)
    {
        sub_47FBA3(thisx);
        iMaxLength = lstrlenA(lpString) + 1;
        if (iMaxLength > 256)
            iMaxLength = 256;
        lstrcpynA((LPSTR)(thisx + 4), lpString, iMaxLength);
        *(_DWORD*)(thisx + 272) = a3;
        *(_BYTE*)(thisx + 264) = 0;
        *(_BYTE*)(thisx + 265) = 0;
        *(_DWORD*)(thisx + 260) = -1;
        *(_DWORD*)(thisx + 268) = *(_DWORD*)(thisx + 272);
        *(_DWORD*)(thisx + 552) = 0;
        sub_47FA81((_DWORD*)thisx);
    }
}
 
int*  sub_47FA81(int* thisx)
{
    int* result; // eax

    result = thisx;
    if (thisx[69] >= 0)
        return sub_4A02E9((_DWORD*)unk_4BDC60, thisx[69], 0, 0, thisx[69]);
    return result;
} 
BOOL sub_47FAB0(int thisx)
{
    return lstrlenA((LPCSTR)(thisx + 4)) <= *(_DWORD*)(thisx + 260);
}
 
void sub_47FADE(int thisx, LPCSTR lpString)
{
    int iMaxLength; // [esp+4h] [ebp-8h]
    int v4; // [esp+8h] [ebp-4h]

    if (lpString)
    {
        v4 = lstrlenA((LPCSTR)(thisx + 4));
        if (v4)
        {
            iMaxLength = v4 + lstrlenA(lpString) + 1;
            if (iMaxLength > 256)
                iMaxLength = 256;
            lstrcpynA((LPSTR)(thisx + v4 + 4), lpString, iMaxLength - v4);
            if (v4 == *(_DWORD*)(thisx + 260))
                *(_DWORD*)(thisx + 260) = v4 - 1;
            *(_DWORD*)(thisx + 268) = *(_DWORD*)(thisx + 272);
            *(_DWORD*)(thisx + 552) = 0;
        }
        else
        {
            sub_47F9D6(thisx, lpString, 4);
        }
    }
}
 
int sub_47FBA3(int thisx)
{
    int result; // eax

    memset((void*)(thisx + 4), 0, 0x100u);
    memset((void*)(thisx + 296), 0, 0x100u);
    *(_BYTE*)(thisx + 264) = 0;
    *(_BYTE*)(thisx + 265) = 0;
    *(_DWORD*)(thisx + 260) = 0;
    *(_DWORD*)(thisx + 272) = 4;
    result = thisx;
    *(_DWORD*)(thisx + 268) = 0;
    *(_DWORD*)(thisx + 292) = -1;
    *(_DWORD*)(thisx + 552) = 0;
    return result;
}

 
_DWORD* sub_47FC40(_DWORD* thisx, char a2)
{
    sub_47F1FD(thisx);
    if ((a2 & 1) != 0)
        operator delete(thisx);
    return thisx;
}
 
void sub_47FC70(void* thisx)
{
    sub_480A00((char*)thisx);
    *(_DWORD*)thisx = off_4AC2E8;
    *((_DWORD*)thisx + 4) = 0;
    *((_DWORD*)thisx + 5) = 0;
    *((_DWORD*)thisx + 6) = 0;
    *((_DWORD*)thisx + 3) = 0;
    *((_BYTE*)thisx + 28) = 3;
    *((_BYTE*)thisx + 29) = 0;
    *((_DWORD*)thisx + 8) = 1;
}

 
void sub_47FCCF(void* thisx)
{
    *(_DWORD*)thisx = off_4AC2E8;
    if (*((_DWORD*)thisx + 3))
        sub_480950(*((char**)thisx + 3), 3);
    sub_480A3D((_DWORD*)thisx);
}

 
void sub_47FD4E(void* thisx)
{
    *((_DWORD*)thisx + 1) = 0;
    *((_DWORD*)thisx + 6) = 0;
    *((_DWORD*)thisx + 5) = 0;
    *((_DWORD*)thisx + 4) = 0;
    *((_DWORD*)thisx + 7) = 1;
    *(_DWORD*)thisx = 0;
    *((_DWORD*)thisx + 2) = 0;
    *((_DWORD*)thisx + 3) = 0;
}

 
void sub_47FDAB(void* thisx)
{
    if (*(_DWORD*)thisx)
        operator delete(*(void**)thisx);
    if (*((_DWORD*)thisx + 2))
        operator delete(*((void**)thisx + 2));
    if (*((_DWORD*)thisx + 3))
        operator delete(*((void**)thisx + 3));
}

 //ÆäÊµÕâ¸öthis¾ÍÊÇ¸øµ¥Ö¸Õë£¬¸ù±¾Ã»ÓÃµ½**thisÕâ¸öÓÃ·¨
LPSTR sub_47FE10(void** thisx, LPCSTR lpString)
{
    int v4; // [esp+Ch] [ebp-4h]

    if (*thisx)
        operator delete(*thisx);//¿ÉÄÜÄÚ´æÐ¹Â¶
    v4 = lstrlenA(lpString);
    *thisx = operator new(v4 + 1);
    return lstrcpyA((LPSTR)*thisx, lpString);
}

 //»ã±àµÄpush»¹ÊÇ´Ó×óµ½ÓÒµÄË³ÐòµÄ
int  sub_47FE72(_DWORD* thisx, LPCSTR lpString, int a3, int a4, int a5, int a6)
{
	sub_47FE10((void**)thisx, lpString);
	thisx[1] = a3;
	thisx[5] = a4;
	thisx[6] = a5;
	return sub_480016(thisx, a6);
}

 
int  sub_47FEB2(int thisx, LPCSTR lpString, void* Src, int a4)
{
    int v6; // [esp+14h] [ebp-10h]
    int v7; // [esp+18h] [ebp-Ch]
    int v8; // [esp+18h] [ebp-Ch]
    int i; // [esp+1Ch] [ebp-8h]
    int j; // [esp+20h] [ebp-4h]

    sub_47FE10((void**)thisx, lpString);
    if (*(_DWORD*)(thisx + 8))
        operator delete(*(void**)(thisx + 8));
    if (*(_DWORD*)(thisx + 12))
        operator delete(*(void**)(thisx + 12));
    v7 = 0;
    for (i = 0; ; ++i)
    {
        v6 = lstrlenA((LPCSTR)Src + v7);
        if (!v6)
            break;
        v7 += v6 + 1;
    }
    *(_DWORD*)(thisx + 8) = (_DWORD)operator new(v7 + 1);
    *(_DWORD*)(thisx + 12) = (_DWORD)operator new(2 * i);
    memcpy(*(void**)(thisx + 8), Src, v7 + 1);
    v8 = 0;
    for (j = 0; j < i; ++j)
    {
        *(_WORD*)(*(_DWORD*)(thisx + 12) + 2 * j) = v8;
        v8 += lstrlenA((LPCSTR)Src + v8) + 1;
    }
    *(_DWORD*)(thisx + 4) = 1;
    *(_DWORD*)(thisx + 20) = 0;
    *(_DWORD*)(thisx + 24) = i - 1;
    return sub_480016((_DWORD*)thisx, a4);
} 
int sub_480016(_DWORD* thisx, int a2)
{
    int result; // eax

    if (a2 < thisx[5])
        a2 = thisx[5];
    if (a2 > thisx[6])
        a2 = thisx[6];
    result = a2;
    thisx[4] = a2;
    return result;
}

 
int sub_480054(int thisx, int a2)
{
    int result; // eax
    _DWORD* v3; // [esp+0h] [ebp-40h]
    int* Block; // [esp+Ch] [ebp-34h]
    int v6; // [esp+1Ch] [ebp-24h]
    int v7; // [esp+20h] [ebp-20h]
    int v8; // [esp+20h] [ebp-20h]
    int i; // [esp+24h] [ebp-1Ch]
    int v10; // [esp+28h] [ebp-18h]
    int j; // [esp+2Ch] [ebp-14h]
    int v12; // [esp+30h] [ebp-10h]

    if (*(_DWORD*)(thisx + 12))
        sub_480950(*(char**)(thisx + 12), 3);
    *(_DWORD*)(thisx + 20) = 0;
    *(_DWORD*)(thisx + 24) = 0;
    *(_BYTE*)(thisx + 28) = 3;
    v10 = 0;
    v7 = 0;
    for (i = 0; ; ++i)
    {
        v6 = lstrlenA((LPCSTR)(v7 + a2));
        if (!v6)
            break;
        v7 += v6 + 1;
        if (v10 < v6)
            v10 = v6;
    }
    *(_DWORD*)(thisx + 16) = i;
    v12 = *(_DWORD*)(thisx + 16);
    Block = (int*)operator new(32 * v12 + 4);
    if (Block)
    {
        *Block = v12;
        eh_vector_constructor_iterator(Block + 1, 0x20u, v12, sub_47FD4E, sub_47FDAB);
            v3 = Block + 1;
    }
    else
    {
        v3 = 0;
    }
    *(_DWORD*)(thisx + 12) = (_DWORD)v3;
    v8 = 0;
    for (j = 0; j < i; ++j)
    {
        sub_47FE72((int*)(*(_DWORD*)(thisx + 12) + 32 * j), (LPCSTR)(v8 + a2), 0, 0, 0, 0);
        v8 += lstrlenA((LPCSTR)(v8 + a2)) + 1;
    }
    *(_BYTE*)(thisx + 6) = v10 / 2 + 5;
    result = 2 * i + 2;
    *(_BYTE*)(thisx + 7) = result;
    return result;
}

 
int sub_480227(_DWORD* thisx)
{
    int v1; // esi
    int v2; // esi
    int v5; // [esp+8h] [ebp-18h]
    int v6; // [esp+Ch] [ebp-14h]
    int v7; // [esp+10h] [ebp-10h]
    int v8; // [esp+14h] [ebp-Ch]
    int v9; // [esp+1Ch] [ebp-4h]

    v1 = sub_476D78(0);
    v8 = v1 - sub_476D29(0);
    v2 = sub_476CDA(0);
    v7 = v2 - sub_476C8B(0);
    v5 = sub_476DC7(0, 0);
    v9 = sub_476DC7(0, 1);
    v6 = 0;
    if (v5)
    {
        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
        return 1;
    }
    else if (v9)
    {
        return 2;
    }
    else
    {
        if (v8)
        {
            sub_480374((_DWORD*)(32 * thisx[5] + thisx[3]), v8);
            sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
            return 4;
        }
        else if (v7)
        {
            thisx[5] = (thisx[4] + v7 + thisx[5]) % thisx[4];
            sub_48089C((int)thisx, thisx[5]);
            sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
            return 3;
        }
        return v6;
    }
}
 
_DWORD* sub_480374(_DWORD* thisx, int a2)
{
    _DWORD* result; // eax

    result = thisx;
    if (thisx[1])
    {
        thisx[4] += thisx[7] * a2;
        if (thisx[4] > thisx[6])
            thisx[4] = thisx[5];
        result = thisx;
        if (thisx[4] < thisx[5])
        {
            result = thisx;
            thisx[4] = thisx[6];
        }
    }
    return result;
}
 
int sub_4803D8(int thisx)
{
    int result; // eax
    const CHAR* v2; // eax
    const CHAR* v3; // eax
    struct _CancellationTokenState* Token; // eax
    int v5; // [esp-4h] [ebp-120h]
    int v6; // [esp-4h] [ebp-120h]
    _CancellationTokenRegistration* v8; // [esp+4h] [ebp-118h]
    int v9; // [esp+8h] [ebp-114h]
    int v10; // [esp+Ch] [ebp-110h]
    int i; // [esp+10h] [ebp-10Ch]
    int v12; // [esp+14h] [ebp-108h]
    int v13; // [esp+18h] [ebp-104h]
    CHAR String[256]; // [esp+1Ch] [ebp-100h] BYREF

    sub_480A51((unsigned char*)thisx);
    v12 = (*(unsigned __int8*)(thisx + 7) - 2) / 2;
    v10 = 8 * *(unsigned __int8*)(thisx + 28) + 8 * *(unsigned __int8*)(thisx + 4);
    v9 = 8 * *(unsigned __int8*)(thisx + 5) + 12;
    v13 = 8 * *(unsigned __int8*)(thisx + 29) + 8 * *(unsigned __int8*)(thisx + 4);
    for (i = *(_DWORD*)(thisx + 24); ; ++i)
    {
        result = thisx;
        if (i >= v12 + *(_DWORD*)(thisx + 24))
            break;
        result = i;
        if (i >= *(_DWORD*)(thisx + 16))
            break;
        v8 = (_CancellationTokenRegistration*)(32 * i + *(_DWORD*)(thisx + 12));
        v5 = dword_4B9248;
        v2 = (const CHAR*)unknown_libname_30((_DWORD*)v8);
        sub_47B91A(v10, v9, v2, 0, v5);
        if (unknown_libname_22((_DWORD*)v8))
        {
            if (sub_4805AD((_DWORD*)v8))
            {
                v6 = dword_4B9248;
                v3 = (const CHAR*)sub_4805AD((_DWORD*)v8);
                sub_47B91A(v13, v9, v3, 0, v6);
            }
            else
            {
                Token = _GetToken(v8);
                wsprintfA(String, "%d", Token);
                sub_47BC5A(v13, v9, String, 0, dword_4B9248);
            }
        }
        v9 += 16;
    }
    return result;
}

 
int sub_4805AD(_DWORD* thisx)
{
    if (thisx[2])
        return thisx[2] + *(unsigned __int16*)(thisx[3] + 2 * thisx[4]);
    else
        return 0;
}
 
unsigned int sub_4805DF(unsigned int thisx)
{
    unsigned int result; // eax

    result = unknown_libname_23((_DWORD*)thisx);
    if (result)
    {
        sub_47B91A(
            8 * *(unsigned __int8*)(thisx + 28) + 8 * *(unsigned __int8*)(thisx + 4) - 12,
            16 * (*(_DWORD*)(thisx + 20) - *(_DWORD*)(thisx + 24)) + 8 * *(unsigned __int8*)(thisx + 5) + 12,
            asc_4B6B6C,
            0,
            -1);
        result = dword_4B93B0 / 5u / 2;
        if (!(dword_4B93B0 / 5u % 2))
        {
            if (*(int*)(thisx + 24) > 0)
                sub_47B91A(
                    4 * *(unsigned __int8*)(thisx + 6) + 8 * *(unsigned __int8*)(thisx + 4),
                    8 * *(unsigned __int8*)(thisx + 5),
                    byte_4B6B70,
                    0,
                    -1);
            result = thisx;
            if ((*(unsigned __int8*)(thisx + 7) - 2) / 2 + *(_DWORD*)(thisx + 24) < *(_DWORD*)(thisx + 16))
                return sub_47B91A(
                    4 * *(unsigned __int8*)(thisx + 6) + 8 * *(unsigned __int8*)(thisx + 4),
                    8 * *(unsigned __int8*)(thisx + 7) + 8 * *(unsigned __int8*)(thisx + 5) - 11,
                    byte_4B6B74,
                    0,
                    -1);
        }
    }
    return result;
}

 
void sub_48070C(streambuf* thisx, int a2)
{
    sub_475670((_DWORD*)thisx, a2);
    streambuf::unbuffered(thisx, a2 == 0);
}
 
int sub_480737(_DWORD* thisx, int a2)
{
    _DWORD* v3; // [esp+0h] [ebp-2Ch]
    _DWORD* Block; // [esp+Ch] [ebp-20h]

    if (thisx[3])
        sub_480950((char*)thisx[3], 3);
    thisx[5] = 0;
    thisx[6] = 0;
    Block = (_DWORD*)operator new(32 * a2 + 4);
    if (Block)
    {
        *Block = a2;
        eh_vector_constructor_iterator(Block + 1, 0x20u, a2, sub_47FD4E, sub_47FDAB);
            v3 = Block + 1;
    }
    else
    {
        v3 = 0;
    }
    thisx[3] = (_DWORD)v3;
    if (!thisx[3])
        return 0;
    thisx[4] = a2;
    return 1;
}
 
_DWORD* sub_48083C(_DWORD* thisx, int a2)
{
    _DWORD* result; // eax

    thisx[6] = a2;
    result = thisx;
    if (thisx[4] > thisx[6])
    {
        result = thisx;
        thisx[4] = thisx[6];
    }
    return result;
}
 
int sub_48089C(int thisx, int a2)
{
    int result; // eax
    int v3; // [esp+4h] [ebp-4h]

    if (a2 >= 0)
    {
        result = thisx;
        if (a2 < *(_DWORD*)(thisx + 16))
        {
            v3 = (*(unsigned __int8*)(thisx + 7) - 2) / 2;
            *(_DWORD*)(thisx + 20) = a2;
            if (*(_DWORD*)(thisx + 24) <= *(_DWORD*)(thisx + 20))
            {
                result = thisx;
                if (v3 + *(_DWORD*)(thisx + 24) <= *(_DWORD*)(thisx + 20))
                {
                    result = thisx;
                    *(_DWORD*)(thisx + 24) = *(_DWORD*)(thisx + 20) - v3 + 1;
                }
            }
            else
            {
                result = thisx;
                *(_DWORD*)(thisx + 24) = *(_DWORD*)(thisx + 20);
            }
        }
    }
    return result;
}
 
void* sub_480920(void* thisx, char a2)
{
    sub_47FCCF(thisx);
    if ((a2 & 1) != 0)
        operator delete(thisx);
    return thisx;
}

 
char* sub_480950(char* thisx, char a2)
{
    if ((a2 & 2) != 0)
    {
        eh_vector_destructor_iterator(thisx, 0x20u, *((_DWORD *)thisx - 1), sub_47FDAB);
            if ((a2 & 1) != 0)
                operator delete(thisx - 4);
        return thisx - 4;
    }
    else
    {
        sub_47FDAB(thisx);
        if ((a2 & 1) != 0)
            operator delete(thisx);
        return thisx;
    }
}

 
_BYTE* sub_480A00(_BYTE* thisx)
{
    *(_DWORD*)thisx = off_4AC2FC;
    thisx[7] = 0;
    thisx[6] = 0;
    thisx[4] = 0;
    thisx[5] = 0;
    *((_DWORD*)thisx + 2) = 0;
    return thisx;
}
 
_DWORD* sub_480A3D(_DWORD* thisx)
{
    _DWORD* result; // eax

    result = thisx;
    *thisx = off_4AC2FC;
    return result;
}

 
int sub_480A51(unsigned __int8* thisx)
{
    return sub_452045((char*)unk_4B9B10, thisx[4], thisx[5], thisx[6], thisx[7]);
}
 
void* sub_480A90(void* thisx, char a2)
{
    sub_480A3D((_DWORD*)thisx);
    if ((a2 & 1) != 0)
        operator delete(thisx);
    return thisx;
}

 
_DWORD* sub_480AEA(_DWORD* thisx)
{
    _DWORD* result; // eax

    result = thisx;
    *thisx = off_4AC300;
    return result;
}
 
_DWORD* sub_480B90(_DWORD* thisx, char a2)
{
    sub_480AEA(thisx);
    if ((a2 & 1) != 0)
        operator delete(thisx);
    return thisx;
}
 
_DWORD* sub_480BC0(_DWORD* thisx)
{
    sub_47FC70(thisx);
    *thisx = off_4AC304;
    sub_480737(thisx, 8);
    sub_47FE72((int*)thisx[3], (LPCSTR)&byte_4AF907, 1, 1, 9, 3);
    sub_47FEB2(thisx[3] + 32, (LPCSTR)&byte_4AF949, &unk_4AF9BB, 0);
    sub_47FE72((int*)(thisx[3] + 64), (LPCSTR)&byte_4AF9CC, 1, 1, 4, 1);
    sub_47FEB2(thisx[3] + 96, (LPCSTR)&byte_4AFA1C, &unk_4AFA76, 1);
    sub_47FE72((int*)(thisx[3] + 128), (LPCSTR)&byte_4AFA83, 1, 0, 8, 4);
    sub_47FEB2(thisx[3] + 160, (LPCSTR)&byte_4AFAD7, &unk_4AFB11, 0);
    sub_47FEB2(thisx[3] + 192, (LPCSTR)&byte_4AFB1E, &unk_4AFB11, 1);
    sub_47FEB2(thisx[3] + 224, (LPCSTR)&byte_4AFB6C, &unk_4AFC02, 0);
    *((_BYTE*)thisx + 4) = 10;
    *((_BYTE*)thisx + 5) = 8;
    *((_BYTE*)thisx + 6) = 19;
    *((_BYTE*)thisx + 7) = 14;
    *((_BYTE*)thisx + 29) = 14;
    return thisx;
}

 
void sub_480D15(_DWORD* thisx)
{
    *thisx = off_4AC304;
    sub_47FCCF(thisx);
}
 
int sub_480D31(_DWORD* thisx)
{
    int v3; // [esp+18h] [ebp-4h]

    sub_476D78(0);
    sub_476D29(0);
    sub_476CDA(0);
    sub_476C8B(0);
    sub_476DC7(0, 0);
    sub_476DC7(0, 1);
    v3 = sub_480227(thisx);
    if (_GetToken((_CancellationTokenRegistration*)(thisx[3] + 32)))
        sub_48083C((_DWORD*)(thisx[3] + 64), 8);
    else
        sub_48083C((_DWORD*)(thisx[3] + 64), 4);
    return v3;
}
 
int sub_480DDD(streambuf* thisx, int a2)
{
    int v4; // [esp+4h] [ebp-4h]

    sub_48070C(thisx, a2);
    v4 = (_DWORD)sub_480F10((char*)unk_4B9B10);
    sub_480016(*((_DWORD**)thisx + 3), *(unsigned __int8*)(v4 + 1085));
    sub_480016((_DWORD*)(*((_DWORD*)thisx + 3) + 32), *(_DWORD*)(v4 + 976));
    sub_480016((_DWORD*)(*((_DWORD*)thisx + 3) + 64), *(unsigned __int8*)(v4 + 990));
    sub_480016((_DWORD*)(*((_DWORD*)thisx + 3) + 96), *(unsigned __int8*)(v4 + 1059));
    sub_480016((_DWORD*)(*((_DWORD*)thisx + 3) + 128), *(unsigned __int8*)(v4 + 1010));
    sub_480016((_DWORD*)(*((_DWORD*)thisx + 3) + 160), *(_DWORD*)(v4 + 980));
    sub_480016((_DWORD*)(*((_DWORD*)thisx + 3) + 192), *(unsigned __int8*)(v4 + 1079));
    return sub_480016((_DWORD*)(*((_DWORD*)thisx + 3) + 224), *(unsigned __int8*)(v4 + 1080));
}

 
_DWORD* sub_480EE0(_DWORD* thisx, char a2)
{
    sub_480D15(thisx);
    if ((a2 & 1) != 0)
        operator delete(thisx);
    return thisx;
}

 
char* sub_480F10(char* thisx)
{
    return thisx + 1392;
}
 
_DWORD* sub_480F30(_DWORD* thisx)
{
    sub_47FC70(thisx);
    *thisx = off_4AC318;
    sub_480737(thisx, 4);
    sub_47FE72((int*)thisx[3], (LPCSTR)&byte_4AFC1A, 0, 0, 0, 0);
    sub_47FEB2(thisx[3] + 32, (LPCSTR)&byte_4AFC4C, &unk_4AFB11, 1);
    sub_47FEB2(thisx[3] + 64, (LPCSTR)&byte_4AFCA0, &unk_4AFD14, 0);
    sub_47FE72((int*)(thisx[3] + 96), (LPCSTR)&byte_4AFD21, 0, 0, 0, 0);
    *((_BYTE*)thisx + 4) = 9;
    *((_BYTE*)thisx + 5) = 10;
    *((_BYTE*)thisx + 6) = 21;
    *((_BYTE*)thisx + 7) = 10;
    *((_BYTE*)thisx + 29) = 15;
    return thisx;
}

 
void sub_481010(_DWORD* thisx)
{
    *thisx = off_4AC318;
    sub_47FCCF(thisx);
}

 
int sub_48102C(streambuf* thisx, int a2)
{
    char* v4; // [esp+4h] [ebp-4h]

    sub_48070C(thisx, a2);
    v4 = sub_480F10((char*)unk_4B9B10);
    sub_480016((_DWORD*)(*((_DWORD*)thisx + 3) + 32), (unsigned __int8)v4[1056]);
    return sub_480016((_DWORD*)(*((_DWORD*)thisx + 3) + 64), (unsigned __int8)v4[1060]);
}

 
_DWORD* sub_481090(_DWORD* thisx, char a2)
{
    sub_481010(thisx);
    if ((a2 & 1) != 0)
        operator delete(thisx);
    return thisx;
}

 
void* sub_4810C0(void* thisx)
{
    memset(thisx, 0, 0x38u);
    return thisx;
}

 
BOOL sub_4810DE(int thisx, HANDLE hFile, int a3)
{
    DWORD NumberOfBytesRead; // [esp+4h] [ebp-4h] BYREF

    ReadFile(hFile, (LPVOID)(thisx + 10), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    if (NumberOfBytesRead != 1)
        return 0;
    ReadFile(hFile, (LPVOID)(thisx + 6), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    if (NumberOfBytesRead != 1)
        return 0;
    ReadFile(hFile, (LPVOID)(thisx + 8), 2u, (LPDWORD)&NumberOfBytesRead, 0);
    if (NumberOfBytesRead != 2)
        return 0;
    ReadFile(hFile, (LPVOID)thisx, 2u, (LPDWORD)&NumberOfBytesRead, 0);
    if (NumberOfBytesRead != 2)
        return 0;
    ReadFile(hFile, (LPVOID)(thisx + 2), 2u, (LPDWORD)&NumberOfBytesRead, 0);
    if (NumberOfBytesRead != 2)
        return 0;
    ReadFile(hFile, (LPVOID)(thisx + 4), 2u, (LPDWORD)&NumberOfBytesRead, 0);
    if (NumberOfBytesRead != 2)
        return 0;
    ReadFile(hFile, (LPVOID)(thisx + 52), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    if (NumberOfBytesRead != 1)
        return 0;
    ReadFile(hFile, (LPVOID)(thisx + 44), 4u, (LPDWORD)&NumberOfBytesRead, 0);
    if (NumberOfBytesRead != 4)
        return 0;
    ReadFile(hFile, (LPVOID)(thisx + 48), 4u, (LPDWORD)&NumberOfBytesRead, 0);
    if (NumberOfBytesRead != 4)
        return 0;
    ReadFile(hFile, (LPVOID)(thisx + 11), 6u, (LPDWORD)&NumberOfBytesRead, 0);
    if (NumberOfBytesRead != 6)
        return 0;
    ReadFile(hFile, (LPVOID)(thisx + 20), 0x18u, (LPDWORD)&NumberOfBytesRead, 0);
    return NumberOfBytesRead == 24;
}

 
BOOL sub_481285(int thisx, HANDLE hFile)
{
    DWORD NumberOfBytesWritten; // [esp+4h] [ebp-4h] BYREF

    WriteFile(hFile, (LPCVOID)(thisx + 10), 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    if (NumberOfBytesWritten != 1)
        return 0;
    WriteFile(hFile, (LPCVOID)(thisx + 6), 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    if (NumberOfBytesWritten != 1)
        return 0;
    WriteFile(hFile, (LPCVOID)(thisx + 8), 2u, (LPDWORD)&NumberOfBytesWritten, 0);
    if (NumberOfBytesWritten != 2)
        return 0;
    WriteFile(hFile, (LPCVOID)thisx, 2u, (LPDWORD)&NumberOfBytesWritten, 0);
    if (NumberOfBytesWritten != 2)
        return 0;
    WriteFile(hFile, (LPCVOID)(thisx + 2), 2u, (LPDWORD)&NumberOfBytesWritten, 0);
    if (NumberOfBytesWritten != 2)
        return 0;
    WriteFile(hFile, (LPCVOID)(thisx + 4), 2u, (LPDWORD)&NumberOfBytesWritten, 0);
    if (NumberOfBytesWritten != 2)
        return 0;
    WriteFile(hFile, (LPCVOID)(thisx + 52), 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    if (NumberOfBytesWritten != 1)
        return 0;
    WriteFile(hFile, (LPCVOID)(thisx + 44), 4u, (LPDWORD)&NumberOfBytesWritten, 0);
    if (NumberOfBytesWritten != 4)
        return 0;
    WriteFile(hFile, (LPCVOID)(thisx + 48), 4u, (LPDWORD)&NumberOfBytesWritten, 0);
    if (NumberOfBytesWritten != 4)
        return 0;
    WriteFile(hFile, (LPCVOID)(thisx + 11), 6u, (LPDWORD)&NumberOfBytesWritten, 0);
    if (NumberOfBytesWritten != 6)
        return 0;
    WriteFile(hFile, (LPCVOID)(thisx + 20), 0x18u, (LPDWORD)&NumberOfBytesWritten, 0);
    return NumberOfBytesWritten == 24;
}

 
void sub_48142C(void* thisx)
{
    *(_DWORD*)thisx = off_4AC32C;
    *((_BYTE*)thisx + 4) = 0;
    *((_BYTE*)thisx + 8) = 0;
    *((_BYTE*)thisx + 9) = 0;
    *((_WORD*)thisx + 5) = 0;
    *((_WORD*)thisx + 6) = 0;
    *((_BYTE*)thisx + 14) = 0;
    *((_BYTE*)thisx + 15) = 2;
    *((_BYTE*)thisx + 16) = 50;
    *((_BYTE*)thisx + 17) = 100;
    *((_WORD*)thisx + 3) = 0;
}
 
void sub_48148F(void* thisx)
{
    *(_DWORD*)thisx = off_4AC32C;
}
 
_DWORD* sub_4814A3(_DWORD* thisx)
{
    *thisx = off_4AC330;
    thisx[1] = 0;
    thisx[2] = 0;
    *((_BYTE*)thisx + 13) = 0;
    *((_BYTE*)thisx + 12) = 0;
    *((_BYTE*)thisx + 14) = 0;
    thisx[4] = 0;
    *((_WORD*)thisx + 10) = 0;
    return thisx;
}
 
int sub_4814F6(_DWORD* thisx)
{
    *thisx = off_4AC330;
    sub_48151A((_DWORD)thisx);
    return sub_4823E9((_DWORD)thisx);
}
 
int sub_48151A(int thisx)
{
    int result; // eax

    if (*(_DWORD*)(thisx + 4))
        (***(void(****)(_DWORD, int))(thisx + 4))(*(_DWORD*)(thisx + 4), 3);
    if (*(_DWORD*)(thisx + 8))
        operator delete(*(void**)(thisx + 8));
    *(_DWORD*)(thisx + 4) = 0;
    *(_DWORD*)(thisx + 8) = 0;
    result = thisx;
    *(_BYTE*)(thisx + 13) = 0;
    *(_BYTE*)(thisx + 12) = 0;
    return result;
}
 
int sub_48159D(int thisx, char a2, char a3)
{
    _DWORD* v4; // [esp+0h] [ebp-24h]
    int* Block; // [esp+Ch] [ebp-18h]
    int v7; // [esp+14h] [ebp-10h]

    if (!a2 || !a3)
        return 0;
    sub_48151A(thisx);
    *(_BYTE*)(thisx + 12) = a2;
    *(_BYTE*)(thisx + 13) = a3;
    v7 = *(unsigned __int8*)(thisx + 13) * *(unsigned __int8*)(thisx + 12);
    Block = (int*)operator new(20 * v7 + 4);
    if (Block)
    {
        *Block = v7;
        eh_vector_constructor_iterator(Block + 1, 0x14u, v7, sub_48142C, sub_48148F);
            v4 = Block + 1;
    }
    else
    {
        v4 = 0;
    }
    *(_DWORD*)(thisx + 4) = (_DWORD)v4;
    if (!*(_DWORD*)(thisx + 4))
        return 0;
    *(_DWORD*)(thisx + 8) = (_DWORD)operator new(*(unsigned __int8*)(thisx + 13) * *(unsigned __int8*)(thisx + 12));
    if (!*(_DWORD*)(thisx + 8))
        return 0;
    memset(*(void**)(thisx + 8), 0, *(unsigned __int8*)(thisx + 13) * *(unsigned __int8*)(thisx + 12));
    return 1;
}
 
int sub_4816F5(int thisx, unsigned __int8 a2, unsigned __int8 a3)
{
    if (*(unsigned __int8*)(thisx + 12) > (int)a2 && *(unsigned __int8*)(thisx + 13) > (int)a3)
        return *(_DWORD*)(thisx + 4) + 20 * (*(unsigned __int8*)(thisx + 12) * a3 + a2);
    else
        return 0;
}

 
int sub_48176C(int thisx, unsigned __int8 a2, unsigned __int8 a3)
{
    _DWORD* v4; // [esp+0h] [ebp-34h]
    int* Block; // [esp+Ch] [ebp-28h]
    int i; // [esp+14h] [ebp-20h]
    unsigned __int8 v8; // [esp+18h] [ebp-1Ch]
    unsigned __int8 v9; // [esp+1Ch] [ebp-18h]
    int v10; // [esp+24h] [ebp-10h]

    if (a2 == *(unsigned __int8*)(thisx + 12) && a3 == *(unsigned __int8*)(thisx + 13))
        return 1;
    if (!a2 || !a3)
        return 0;
    v10 = a3 * a2;
    Block = (int*)operator new(20 * v10 + 4);
    if (Block)
    {
        *Block = v10;
        eh_vector_constructor_iterator(Block + 1, 0x14u, v10, sub_48142C, sub_48148F);
            v4 = Block + 1;
    }
    else
    {
        v4 = 0;
    }
    if (!v4)
        return 0;
    if (*(_DWORD*)(thisx + 4))
    {
        v9 = *(_BYTE*)(thisx + 12);
        v8 = *(_BYTE*)(thisx + 13);
        if (v9 > (int)a2)
            v9 = a2;
        if (v8 > (int)a3)
            v8 = a3;
        for (i = 0; i < v8; ++i)
            memcpy(&v4[5 * a2 * i], (const void*)(20 * *(unsigned __int8*)(thisx + 12) * i + *(_DWORD*)(thisx + 4)), v9);
        sub_48151A(thisx);
    }
    *(_DWORD*)(thisx + 4) = (_DWORD)v4;
    *(_BYTE*)(thisx + 12) = a2;
    *(_BYTE*)(thisx + 13) = a3;
    *(_DWORD*)(thisx + 8) = (_DWORD)operator new(a3 * a2);
    memset(*(void**)(thisx + 8), 0, a3 * a2);
    return 1;
}

 
int sub_481A91(int thisx, HANDLE hFile)
{
    DWORD NumberOfBytesWritten; // [esp+4h] [ebp-4h] BYREF

    WriteFile(hFile, (LPCVOID)(thisx + 4), 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, (LPCVOID)(thisx + 8), 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, (LPCVOID)(thisx + 9), 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, (LPCVOID)(thisx + 10), 2u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, (LPCVOID)(thisx + 12), 2u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, (LPCVOID)(thisx + 14), 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, (LPCVOID)(thisx + 15), 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, (LPCVOID)(thisx + 16), 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, (LPCVOID)(thisx + 17), 1u, (LPDWORD)&NumberOfBytesWritten, 0);
    WriteFile(hFile, (LPCVOID)(thisx + 6), 2u, (LPDWORD)&NumberOfBytesWritten, 0);
    return 1;
}
 
int sub_481B9F(int thisx, HANDLE hFile)
{
    int v3; // eax
    int v4; // edx
    _DWORD* v5; // [esp+0h] [ebp-140h]
    _DWORD* Block; // [esp+Ch] [ebp-134h]
    bool RuntimeOwnsLifetime; // [esp+14h] [ebp-12Ch]
    int v9; // [esp+18h] [ebp-128h]
    int v10; // [esp+1Ch] [ebp-124h] BYREF
    int v11; // [esp+20h] [ebp-120h] BYREF
    int i; // [esp+24h] [ebp-11Ch]
    int v13; // [esp+28h] [ebp-118h] BYREF
    DWORD NumberOfBytesRead; // [esp+2Ch] [ebp-114h] BYREF
    CHAR Buffer[256]; // [esp+30h] [ebp-110h] BYREF
    int v16; // [esp+130h] [ebp-10h]
    int v17; // [esp+13Ch] [ebp-4h]

    LOWORD(v13) = 0;
    ReadFile(hFile, Buffer, 0xBu, (LPDWORD)&NumberOfBytesRead, 0);
    if (lstrcmpiA(Buffer, aKdMapdata))
    {
        SetFilePointer(hFile, 0, 0, 0);
        *(_BYTE*)(thisx + 14) = 0;
    }
    else
    {
        ReadFile(hFile, &v13, 2u, (LPDWORD)&NumberOfBytesRead, 0);
        ReadFile(hFile, (LPVOID)(thisx + 14), 1u, (LPDWORD)&NumberOfBytesRead, 0);
    }
    ReadFile(hFile, &v11, 1u, (LPDWORD)&NumberOfBytesRead, 0);
    ReadFile(hFile, &v10, 1u, (LPDWORD)&NumberOfBytesRead, 0);
    if (!(_BYTE)v11 || !(_BYTE)v10 || (unsigned __int8)v10 > 0x16u)
        return 0;
    if ((unsigned __int8)v11 != *(unsigned __int8*)(thisx + 12)
        || (unsigned __int8)v10 != *(unsigned __int8*)(thisx + 13))
    {
        sub_48151A(thisx);
        *(_BYTE*)(thisx + 13) = v10;
        *(_BYTE*)(thisx + 12) = v11;
        v9 = *(unsigned __int8*)(thisx + 13) * *(unsigned __int8*)(thisx + 12);
        Block = (int*)operator new(20 * v9 + 4);
        v17 = 0;
        if (Block)
        {
            *Block = v9;
            eh_vector_constructor_iterator(Block + 1, 0x14u, v9, sub_48142C, sub_48148F);
                v5 = Block + 1;
        }
        else
        {
            v5 = 0;
        }
        v17 = -1;
        *(_DWORD*)(thisx + 4) = (_DWORD)v5;
        if (!*(_DWORD*)(thisx + 4))
            return 0;
        *(_DWORD*)(thisx + 8) = (_DWORD)operator new(*(unsigned __int8*)(thisx + 13) * *(unsigned __int8*)(thisx + 12));
        memset(*(void**)(thisx + 8), 0, *(unsigned __int8*)(thisx + 13) * *(unsigned __int8*)(thisx + 12));
    }
    v3 = *(unsigned __int8*)(thisx + 13);
    v16 = v3 * *(unsigned __int8*)(thisx + 12);
    for (i = 0; ; ++i)
    {
        HIWORD(v4) = HIWORD(i);
        if (i >= v16)
            break;
        LOWORD(v3) = v13;
        v3 = sub_481F98((_WORD*)(20 * i + *(_DWORD*)(thisx + 4)), hFile, v3);
    }
    if ((unsigned __int16)v13 < 2u)
    {
        if (!sub_482427((void*)thisx))
            return 0;
    }
    else
    {
        LOWORD(v4) = v13;
        if (!sub_482900((int*)thisx, hFile, v4))
            return 0;
    }
    *(_BYTE*)(thisx + 15) = 0;
    for (i = 0; i < v16; ++i)
    {
        RuntimeOwnsLifetime = Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime((Concurrency::details::_UnrealizedChore*)(*(_DWORD*)(thisx + 4) + 20 * i));
        if (RuntimeOwnsLifetime > (int)*(unsigned __int8*)(thisx + 15))
            *(_BYTE*)(thisx + 15) = RuntimeOwnsLifetime;
    }
    return 1;
}
 
int sub_481F98(_WORD* thisx, HANDLE hFile, int a3)
{
    char v5; // [esp+4h] [ebp-14h]
    int v6; // [esp+8h] [ebp-10h]
    char v7; // [esp+Ch] [ebp-Ch]
    int v8; // [esp+10h] [ebp-8h]
    DWORD NumberOfBytesRead; // [esp+14h] [ebp-4h] BYREF

    ReadFile(hFile, thisx + 2, 1u, (LPDWORD)&NumberOfBytesRead, 0);
    ReadFile(hFile, thisx + 4, 1u, (LPDWORD)&NumberOfBytesRead, 0);
    ReadFile(hFile, (char*)thisx + 9, 1u, (LPDWORD)&NumberOfBytesRead, 0);
    if ((_WORD)a3)
    {
        ReadFile(hFile, thisx + 5, 2u, (LPDWORD)&NumberOfBytesRead, 0);
        ReadFile(hFile, thisx + 6, 2u, (LPDWORD)&NumberOfBytesRead, 0);
        ReadFile(hFile, thisx + 7, 1u, (LPDWORD)&NumberOfBytesRead, 0);
        ReadFile(hFile, (char*)thisx + 15, 1u, (LPDWORD)&NumberOfBytesRead, 0);
        ReadFile(hFile, thisx + 8, 1u, (LPDWORD)&NumberOfBytesRead, 0);
        ReadFile(hFile, (char*)thisx + 17, 1u, (LPDWORD)&NumberOfBytesRead, 0);
    }
    else
    {
        v7 = 0;
        v8 = 0;
        v5 = 1;
        v6 = 0;
        thisx[5] = 0;
        thisx[6] = 0;
        *((_BYTE*)thisx + 14) = 0;
        *((_BYTE*)thisx + 15) = 0;
        *((_BYTE*)thisx + 16) = 50;
        *((_BYTE*)thisx + 17) = 100;
        switch (*((_BYTE*)thisx + 4))
        {
        case 7:
            v8 = 1;
            thisx[5] = -30;
            break;
        case 8:
            v8 = 1;
            thisx[5] = 30;
            break;
        case 0xB:
            *((_BYTE*)thisx + 14) = 8;
            thisx[5] = -30;
            v5 = 2;
            v6 = 1;
            break;
        case 0xC:
            v8 = 1;
            v7 = 11;
            *((_BYTE*)thisx + 14) = 8;
            thisx[5] = 30;
            v5 = 2;
            v6 = 1;
            break;
        case 0xD:
            *((_BYTE*)thisx + 16) = 90;
            *((_BYTE*)thisx + 17) = 10;
            break;
        }
        *((_BYTE*)thisx + 15) = 2 * v5;
        if (v6)
            *((_BYTE*)thisx + 15) |= 8u;
        if (v8)
            *((_BYTE*)thisx + 4) = v7;
    }
    if ((unsigned __int16)a3 < 2u)
    {
        switch (*((_BYTE*)thisx + 4))
        {
        case 2:
            thisx[3] = 1;
            break;
        case 3:
            thisx[3] = 2;
            break;
        case 4:
            thisx[3] = 3;
            break;
        case 9:
            thisx[3] = 4;
            break;
        case 0xE:
            thisx[3] = 5;
            break;
        case 0xF:
            thisx[3] = 6;
            break;
        default:
            thisx[3] = 0;
            break;
        }
        if (thisx[3])
            *((_BYTE*)thisx + 4) = 0;
    }
    else
    {
        ReadFile(hFile, thisx + 3, 2u, (LPDWORD)&NumberOfBytesRead, 0);
    }
    return 1;
}

 
_BYTE* sub_4822B3(_BYTE* thisx, int a2)
{
    _BYTE* result; // eax
    char v3; // cl

    result = thisx;
    if (a2)
        v3 = thisx[15] | 1;
    else
        v3 = thisx[15] & 0xFE;
    thisx[15] = v3;
    return result;
}

 
int sub_4822EC(int thisx, unsigned __int16 a2)
{
    void* v3; // [esp+0h] [ebp-20h]
    void* Block; // [esp+8h] [ebp-18h]

    if (a2 == *(unsigned __int16*)(thisx + 20))
    {
        memset(*(void**)(thisx + 16), 0, 56 * *(unsigned __int16*)(thisx + 20));
        return 1;
    }
    else
    {
        sub_4823E9(thisx);
        Block = operator new(56 * a2);
        if (Block)
        {
            sub_402080((int)Block, 56, a2, (void(*)(int))sub_4810C0);
            v3 = Block;
        }
        else
        {
            v3 = 0;
        }
        *(_DWORD*)(thisx + 16) = (_DWORD)v3;
        *(_WORD*)(thisx + 20) = a2;
        if (*(_DWORD*)(thisx + 16))
        {
            return 1;
        }
        else
        {
            *(_WORD*)(thisx + 20) = 0;
            return 0;
        }
    }
}

 
int sub_4823E9(int thisx)
{
    int result; // eax

    result = thisx;
    if (*(_DWORD*)(thisx + 16))
        operator delete(*(void**)(thisx + 16));
    *(_DWORD*)(thisx + 16) = 0;
    *(_WORD*)(thisx + 20) = 0;
    return result;
}

 
int sub_482427(void* thisx)
{
    int v2; // eax
    int v3; // eax
    int v4; // eax
    int v5; // eax
    int v6; // eax
    int v8; // [esp+4h] [ebp-8h]

    if (!sub_4822EC((int)thisx, 6u))
        return 0;
    v2 = sub_4828CD((int)thisx, 0);
    *(_BYTE*)(v2 + 10) = 2;
    *(_BYTE*)(v2 + 6) = 0;
    *(_WORD*)(v2 + 8) = 19;
    *(_BYTE*)(v2 + 52) = 2;
    *(_WORD*)v2 = 14;
    *(_WORD*)(v2 + 2) = 0;
    *(_WORD*)(v2 + 4) = 1;
    *(_BYTE*)(v2 + 11) = 21;
    *(_DWORD*)(v2 + 20) = 300;
    *(_BYTE*)(v2 + 12) = 0;
    *(_DWORD*)(v2 + 24) = 0;
    *(_BYTE*)(v2 + 13) = 11;
    *(_DWORD*)(v2 + 28) = -550;
    *(_BYTE*)(v2 + 14) = 11;
    *(_DWORD*)(v2 + 32) = 0;
    *(_BYTE*)(v2 + 15) = 0;
    *(_DWORD*)(v2 + 36) = 0;
    *(_BYTE*)(v2 + 16) = 11;
    *(_DWORD*)(v2 + 40) = 30;
    *(_DWORD*)(v2 + 44) = 0;
    *(_DWORD*)(v2 + 48) = 0;
    v3 = sub_4828CD((int)thisx, 1);
    *(_BYTE*)(v3 + 10) = 1;
    *(_BYTE*)(v3 + 6) = 0;
    *(_WORD*)(v3 + 8) = 14;
    *(_BYTE*)(v3 + 52) = 5;
    *(_WORD*)v3 = 40;
    *(_WORD*)(v3 + 2) = 0;
    *(_WORD*)(v3 + 4) = 1;
    *(_BYTE*)(v3 + 11) = 42;
    *(_DWORD*)(v3 + 20) = 100;
    *(_BYTE*)(v3 + 12) = 0;
    *(_DWORD*)(v3 + 24) = 0;
    *(_BYTE*)(v3 + 13) = 11;
    *(_DWORD*)(v3 + 28) = -500;
    *(_BYTE*)(v3 + 14) = 11;
    *(_DWORD*)(v3 + 32) = 0;
    *(_BYTE*)(v3 + 15) = 0;
    *(_DWORD*)(v3 + 36) = 0;
    *(_BYTE*)(v3 + 16) = 11;
    *(_DWORD*)(v3 + 40) = 30;
    *(_DWORD*)(v3 + 44) = 300;
    *(_DWORD*)(v3 + 48) = 0;
    v4 = sub_4828CD((int)thisx, 2);
    *(_BYTE*)(v4 + 10) = 1;
    *(_BYTE*)(v4 + 6) = 0;
    *(_WORD*)(v4 + 8) = 14;
    *(_BYTE*)(v4 + 52) = 9;
    *(_WORD*)v4 = 40;
    *(_WORD*)(v4 + 2) = 0;
    *(_WORD*)(v4 + 4) = 1;
    *(_BYTE*)(v4 + 11) = 42;
    *(_DWORD*)(v4 + 20) = 100;
    *(_BYTE*)(v4 + 12) = 0;
    *(_DWORD*)(v4 + 24) = 0;
    *(_BYTE*)(v4 + 13) = 11;
    *(_DWORD*)(v4 + 28) = -500;
    *(_BYTE*)(v4 + 14) = 11;
    *(_DWORD*)(v4 + 32) = 0;
    *(_BYTE*)(v4 + 15) = 0;
    *(_DWORD*)(v4 + 36) = 0;
    *(_BYTE*)(v4 + 16) = 11;
    *(_DWORD*)(v4 + 40) = 30;
    *(_DWORD*)(v4 + 44) = 300;
    *(_DWORD*)(v4 + 48) = 0;
    v5 = sub_4828CD((int)thisx, 3);
    *(_BYTE*)(v5 + 10) = 1;
    *(_BYTE*)(v5 + 6) = 0;
    *(_WORD*)(v5 + 8) = 19;
    *(_BYTE*)(v5 + 52) = 3;
    *(_WORD*)v5 = 9;
    *(_WORD*)(v5 + 2) = 0;
    *(_WORD*)(v5 + 4) = 1;
    *(_BYTE*)(v5 + 11) = 21;
    *(_DWORD*)(v5 + 20) = 400;
    *(_BYTE*)(v5 + 12) = 0;
    *(_DWORD*)(v5 + 24) = 0;
    *(_BYTE*)(v5 + 13) = 11;
    *(_DWORD*)(v5 + 28) = -700;
    *(_BYTE*)(v5 + 14) = 11;
    *(_DWORD*)(v5 + 32) = 0;
    *(_BYTE*)(v5 + 15) = 0;
    *(_DWORD*)(v5 + 36) = 0;
    *(_BYTE*)(v5 + 16) = 11;
    *(_DWORD*)(v5 + 40) = 30;
    *(_DWORD*)(v5 + 44) = 0;
    *(_DWORD*)(v5 + 48) = 0;
    v8 = sub_4828CD((int)thisx, 4);
    *(_BYTE*)(v8 + 10) = 1;
    *(_BYTE*)(v8 + 6) = 0;
    *(_WORD*)(v8 + 8) = 19;
    *(_BYTE*)(v8 + 52) = 3;
    *(_WORD*)v8 = 9;
    *(_WORD*)(v8 + 2) = 0;
    *(_WORD*)(v8 + 4) = 1;
    *(_BYTE*)(v8 + 11) = 0;
    *(_DWORD*)(v8 + 20) = 0;
    *(_BYTE*)(v8 + 12) = 11;
    *(_DWORD*)(v8 + 24) = 100;
    *(_BYTE*)(v8 + 13) = 11;
    *(_DWORD*)(v8 + 28) = -500;
    *(_BYTE*)(v8 + 14) = 11;
    *(_DWORD*)(v8 + 32) = 0;
    *(_BYTE*)(v8 + 15) = 0;
    *(_DWORD*)(v8 + 36) = 0;
    *(_BYTE*)(v8 + 16) = 11;
    *(_DWORD*)(v8 + 40) = 30;
    *(_DWORD*)(v8 + 44) = 0;
    *(_DWORD*)(v8 + 48) = 0;
    v6 = sub_4828CD((int)thisx, 5);
    *(_BYTE*)(v6 + 10) = 1;
    *(_BYTE*)(v6 + 6) = 0;
    *(_WORD*)(v6 + 8) = 19;
    *(_BYTE*)(v6 + 52) = 3;
    *(_WORD*)v6 = 9;
    *(_WORD*)(v6 + 2) = 0;
    *(_WORD*)(v6 + 4) = 1;
    *(_BYTE*)(v6 + 11) = 21;
    *(_DWORD*)(v6 + 20) = 200;
    *(_BYTE*)(v6 + 12) = 0;
    *(_DWORD*)(v6 + 24) = 0;
    *(_BYTE*)(v6 + 13) = 11;
    *(_DWORD*)(v6 + 28) = -500;
    *(_BYTE*)(v6 + 14) = 11;
    *(_DWORD*)(v6 + 32) = 0;
    *(_BYTE*)(v6 + 15) = 0;
    *(_DWORD*)(v6 + 36) = 0;
    *(_BYTE*)(v6 + 16) = 11;
    *(_DWORD*)(v6 + 40) = 30;
    *(_DWORD*)(v6 + 44) = 0;
    *(_DWORD*)(v6 + 48) = 0;
    return 1;
} 
int sub_4828CD(int thisx, int a2)
{
    if (a2 >= 0 && *(unsigned __int16*)(thisx + 20) > a2)
        return 56 * a2 + *(_DWORD*)(thisx + 16);
    else
        return 0;
}
 
int sub_482900(_DWORD* thisx, HANDLE hFile, int a3)
{
    int v3; // ecx
    unsigned __int16 i; // [esp+4h] [ebp-Ch]
    int Buffer[2]; // [esp+8h] [ebp-8h] BYREF

    ReadFile(hFile, Buffer, 2u, (LPDWORD)&Buffer[1], 0);
    if (!sub_4822EC((int)thisx, Buffer[0]))
        return 0;
    for (i = 0; i < (int)LOWORD(Buffer[0]); ++i)
    {
        LOWORD(v3) = a3;
        if (!sub_4810DE(56 * i + thisx[4], hFile, v3))
            return 0;
    }
    return 1;
}
 
int sub_482993(_DWORD* thisx, HANDLE hFile)
{
    DWORD NumberOfBytesWritten; // [esp+4h] [ebp-8h] BYREF
    int v5; // [esp+8h] [ebp-4h]

    WriteFile(hFile, thisx + 5, 2u, (LPDWORD)&NumberOfBytesWritten, 0);
    if (NumberOfBytesWritten != 2)
        return 0;
    LOWORD(v5) = 0;
    while ((unsigned __int16)v5 < (int)*((unsigned __int16*)thisx + 10))
    {
        if (!sub_481285(56 * (unsigned __int16)v5 + thisx[4], hFile))
            return 0;
        LOWORD(v5) = v5 + 1;
    }
    return 1;
}
 
int sub_482A1B(int thisx, unsigned __int8 a2, unsigned __int8 a3, char a4)
{
    int result; // eax

    result = a2;
    if (a2 < (int)*(unsigned __int8*)(thisx + 12))
    {
        result = a3;
        if (a3 < (int)*(unsigned __int8*)(thisx + 13))
        {
            result = *(unsigned __int8*)(thisx + 12) * a3 + a2;
            *(_BYTE*)(*(_DWORD*)(thisx + 8) + result) = a4;
        }
    }
    return result;
}
 
char sub_482A7E(int thisx, unsigned __int8 a2, unsigned __int8 a3)
{
    if (a2 < (int)*(unsigned __int8*)(thisx + 12) && a3 < (int)*(unsigned __int8*)(thisx + 13))
        return *(_BYTE*)(*(_DWORD*)(thisx + 8) + *(unsigned __int8*)(thisx + 12) * a3 + a2);
    else
        return 0;
}
 
_BYTE* sub_482AE0(_BYTE* thisx, unsigned __int8 a2)
{
    _BYTE* result; // eax

    thisx[15] &= 0xF9u;
    result = thisx;
    thisx[15] |= 2 * (a2 % 3);
    return result;
}
 
_BYTE* sub_482B1C(_BYTE* thisx, int a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[15] &= ~8u;
    if (a2)
    {
        result = thisx;
        thisx[15] |= 8u;
    }
    return result;
}
 
_DWORD* sub_482B50(_DWORD* thisx, char a2)
{
    sub_4814F6(thisx);
    if ((a2 & 1) != 0)
        operator delete(thisx);
    return thisx;
}
 
char* sub_482B80(char* thisx, char a2)
{
    if ((a2 & 2) != 0)
    {
        eh_vector_destructor_iterator(thisx, 0x14u, *((_DWORD *)thisx - 1), sub_48148F);
            if ((a2 & 1) != 0)
                operator delete(thisx - 4);
        return thisx - 4;
    }
    else
    {
        sub_48148F(thisx);
        if ((a2 & 1) != 0)
            operator delete(thisx);
        return thisx;
    }
}
 
_DWORD* sub_482BF0(_DWORD* thisx)
{
    *thisx = 0;
    thisx[1] = 0;
    thisx[2] = 0;
    thisx[3] = 0;
    dword_4CA1D0 = 0;
    return thisx;
}
 
void sub_482C2F(void* thisx)
{
	sub_482C42((void**)thisx);
}
 
void sub_482C42(void** thisx)
{
    if (*thisx)
    {
        operator delete(*thisx);
        *thisx = 0;
    }
}
 
int sub_482C74(int thisx, LPCSTR lpFileName)
{
    HANDLE hFile; // [esp+8h] [ebp-8h]
    DWORD NumberOfBytesRead; // [esp+Ch] [ebp-4h] BYREF

    hFile = CreateFileA(lpFileName, 0x80000000, 0, 0, 3u, 0x80u, 0);
    if (hFile == (HANDLE)-1)
        return 0;
    *(_DWORD*)(thisx + 4) = GetFileSize(hFile, 0);
    sub_482C42((void**)thisx);
    *(_DWORD*)thisx = (_DWORD)operator new(*(_DWORD*)(thisx + 4));
    ReadFile(hFile, *(LPVOID*)thisx, *(_DWORD*)(thisx + 4), (LPDWORD)&NumberOfBytesRead, 0);
    if (NumberOfBytesRead == *(_DWORD*)(thisx + 4))
    {
        CloseHandle(hFile);
        *(_DWORD*)(thisx + 8) = 0;
        *(_DWORD*)(thisx + 12) = 0;
        dword_4CA1D0 = 0;
        return 1;
    }
    else
    {
        sub_482C42((void**)thisx);
        return 0;
    }
}
 //Õâ¸ö¶ÑÕ»Òç³öÊÇÎÞÏÞµ÷ÓÃº¯Êýµ¼ÖÂµÄ£¿
int sub_482D44(_DWORD* thisx, LPSTR lpString1)
{
    CHAR v4[21]; // [esp+4h] [ebp-24h] BYREF
    //CHAR v4[20]; // [esp+4h] [ebp-24h] BYREF,ÊÇÕâ¸öÊý×éÔ½½çµ¼ÖÂµÄ
    char v5; // [esp+18h] [ebp-10h]
    int v6; // [esp+1Ch] [ebp-Ch]
    int v7; // [esp+20h] [ebp-8h]
    int v8; // [esp+24h] [ebp-4h]

    if (!*thisx)
        return 0;
    v7 = 0;
    v8 = thisx[2];
    v6 = 0;
    while (1)
    {
        if (v6)
        {
            v6 = 0;
            *lpString1 = 0;
            v7 = 0;
            v8 = thisx[2];
        }
        if (thisx[2] >= thisx[1])
            break;
        v5 = *(_BYTE*)(*thisx + thisx[2]);
        if (v5 == 9)
            v5 = 32;
        switch (v5)
        {
        case 47:
            if (thisx[3] && !v7)
            {
                sub_482FAA(thisx);
                *lpString1 = 110;
                lpString1[1] = 0;
                thisx[3] = 0;
                dword_4CA1D0 = 0;
                return 1;
            }
            if (!sub_482FAA(thisx))
                return 0;
            v6 = 1;
            break;
        case 13:
        case 10:
            if (thisx[3] && v7)
                goto LABEL_35;
            ++thisx[2];
            if (thisx[3] && !v7)
            {
                *lpString1 = 110;
                lpString1[1] = 0;
                thisx[3] = 0;
                return 1;
            }
            v6 = 1;
            break;
        case 44:
            ++thisx[2];
            goto LABEL_35;
        default:
            if (v5 == 32 && v7)
            {
                ++thisx[2];
                goto LABEL_35;
            }
            if (v5 != 32 || v7)
            {
                ++v7;
                ++thisx[2];
                thisx[3] = 1;
            }
            else
            {
                v8 = ++thisx[2];
            }
            break;
        }
    }
    if (!v7)
    {
        wsprintfA(v4, " pos %d size %d ", thisx[2], thisx[1]);
        return 0;
    }
LABEL_35:
    LPSTR res = lstrcpynA(lpString1, (LPCSTR)(v8 + *thisx), v7 + 1);
    //StringCchCopy((STRSAFE_LPWSTR)lpString1, v7 + 1,(STRSAFE_LPWSTR)(v8 + *thisx));
    return 1;
}

 
int sub_482FAA(_DWORD* thisx)
{
    unsigned int i; // [esp+8h] [ebp-4h]

    dword_4CA1D0 = 0;
    if (!*thisx)
        return 0;
    for (i = thisx[2]; i < thisx[1]; ++i)
    {
        if (*(_BYTE*)(*thisx + i) == 10)
        {
            thisx[2] = i + 1;
            thisx[3] = 0;
            return 1;
        }
    }
    return 0;
}

 
int __stdcall sub_48307F(LPCSTR lpString)
{
    int v2; // [esp+4h] [ebp-18h]
    int v3; // [esp+8h] [ebp-14h]
    int v4; // [esp+Ch] [ebp-10h]
    int v5; // [esp+10h] [ebp-Ch]
    int i; // [esp+14h] [ebp-8h]
    int j; // [esp+14h] [ebp-8h]
    int v8; // [esp+18h] [ebp-4h]

    v8 = 0;
    v2 = 0;
    v5 = lstrlenA(lpString);
    if (*lpString == 45)
    {
        v8 = 1;
        v2 = 1;
    }
    v3 = 0;
    v4 = 1;
    for (i = v2 + 1; i < v5; ++i)
        v4 *= 10;
    for (j = v2; j < v5; ++j)
    {
        v3 += v4 * (lpString[j] - 48);
        v4 /= 10;
    }
    if (v8)
        return -v3;
    return v3;
}


 
_DWORD* sub_48314A(_DWORD* thisx)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[2] = 0;
    thisx[3] = 0;
    dword_4CA1D0 = 0;
    return result;
}
 
_DWORD* sub_483173(_DWORD* thisx, _DWORD* a2)
{
    _DWORD* result; // eax

    if (thisx[1] <= (unsigned int)a2)
        return sub_48314A(thisx);
    result = a2;
    thisx[2] = (_DWORD)a2;
    thisx[3] = 0;
    dword_4CA1D0 = 0;
    return result;
}

 
int sub_4831B2(_DWORD* thisx, LPCSTR a2, LPCSTR lpString1)
{
    _DWORD* v5; // [esp+4h] [ebp-108h]
    CHAR String2[256]; // [esp+8h] [ebp-104h] BYREF
    int v7; // [esp+108h] [ebp-4h]

    v5 = (_DWORD*)thisx[2];
    v7 = 0;
    if (!lpString1)
        return -1;
    if (!a2)
        goto LABEL_7;
    if (!sub_48328F(thisx,a2))
        return -1;
    sub_482FAA(thisx);
    while (1)
    {
    LABEL_7:
        if (!sub_482D44(thisx, String2))
        {
            sub_483173(thisx, v5);
            return -1;
        }
        if (!lstrcmpiA(lpString1, String2))
            break;
        ++v7;
        sub_482FAA(thisx);
    }
    sub_483173(thisx, v5);
    return v7;
}
 
int sub_48328F(_DWORD* thisx, LPCSTR lpString1)
{
    CHAR String2[256]; // [esp+8h] [ebp-100h] BYREF

    while (1)
    {
        if (!sub_482D44(thisx, String2))
            return 0;
        if (!lstrcmpiA(lpString1, String2))
            break;
        sub_482FAA(thisx);
    }
    sub_48330A(thisx);
    return 1;
}
 
_DWORD* sub_48330A(_DWORD* thisx)
{
    _DWORD* result; // eax
    int i; // [esp+4h] [ebp-4h]

    for (i = thisx[2] - 1; i >= 0; --i)
    {
        if (*(_BYTE*)(*thisx + i) == 13 || *(_BYTE*)(*thisx + i) == 10)
        {
            ++i;
            break;
        }
    }
    if (i < 0)
        i = 0;
    result = thisx;
    thisx[2] = i;
    thisx[3] = 0;
    dword_4CA1D0 = 0;
    return result;
}

 
_DWORD* sub_483390(_DWORD* thisx)
{
    //this + 3µÄÄÜÊÇ8¸ö¶ÓÔ±µÄÄÚ´æÎ»ÖÃ£¬ÕâÀï½øÐÐÄ³ÖÖ³õÊ¼»¯
    eh_vector_constructor_iterator(thisx + 3, /*0x114u*/276, 8, sub_4837D1, sub_4837E7);
        * thisx = off_4AC334;
    thisx[1] = 0;
    return thisx;
}

 
void sub_4833CE(_DWORD* thisx)
{
    *thisx = off_4AC334;
    sub_484175((_DWORD)thisx);
    eh_vector_destructor_iterator(thisx + 3, 0x114u, 8, sub_4837E7);
}

 
unsigned __int8 __fastcall sub_48342F(int a1, int a2, unsigned __int8 a3, char a4)
{
    unsigned __int8 result; // al
    int v5; // ecx
    unsigned __int8 v7; // [esp+Ch] [ebp-20h]
    char v8; // [esp+10h] [ebp-1Ch]
    unsigned __int8* v9; // [esp+18h] [ebp-14h]
    unsigned __int8* v10; // [esp+18h] [ebp-14h]
    char v11; // [esp+1Ch] [ebp-10h]
    char v12; // [esp+20h] [ebp-Ch]
    int i; // [esp+24h] [ebp-8h]
    int v14; // [esp+28h] [ebp-4h]
    BOOL v15; // [esp+28h] [ebp-4h]

    v9 = (unsigned __int8*)(a1 + 2 * *(unsigned __int8*)(a1 + 24) + 29);
    if (!*v9)
        *v9 = a3;
    result = *v9 != (char)a3;
    v14 = result;
    if (*v9 == (char)a3)
    {
        result = (unsigned __int8)v9;
        if (v9[1] == 255)
        {
            v14 = 1;
        }
        else
        {
            result = v9[1] + 1;
            v9[1] = result;
        }
    }
    if (v14)
    {
        *(_BYTE*)(a1 + 24) = (*(unsigned __int8*)(a1 + 24) + 1) % 32;
        v10 = (unsigned __int8*)(a1 + 2 * *(unsigned __int8*)(a1 + 24) + 29);
        *v10 = a3;
        v10[1] = 1;
        result = a1;
        ++* (_DWORD*)(a1 + 4);
    }
    v12 = 1;
    for (i = 0; i < 4; ++i)
    {
        v11 = *(_BYTE*)(a1 + 32 * i + 93 + *(unsigned __int8*)(i + a1 + 25));
        v8 = v11 & 0x7F;
        v7 = (unsigned __int8)(v12 & a4) != 0;
        v5 = (v11 & 0x80) != 0;
        v15 = v5 != v7;
        if (v5 != v7 && !v8)
        {
            v15 = 0;
            *(_BYTE*)(a1 + 32 * i + 93 + *(unsigned __int8*)(i + a1 + 25)) = v7 << 7;
            *(_DWORD*)(a1 + 4 * i + 8) = 1;
        }
        if (!v15)
        {
            if (v8 == 127)
                v15 = 1;
            else
                ++* (_BYTE*)(a1 + 32 * i + 93 + *(unsigned __int8*)(i + a1 + 25));
        }
        if (v15)
        {
            *(_BYTE*)(i + a1 + 25) = (*(unsigned __int8*)(i + a1 + 25) + 1) % 32;
            *(_BYTE*)(a1 + 32 * i + 93 + *(unsigned __int8*)(i + a1 + 25)) = (v7 << 7) | 1;
            ++* (_DWORD*)(a1 + 4 * i + 8);
        }
        v12 *= 2;
        result = i + 1;
    }
    return result;
}
 
char* sub_4836CD(char* thisx)
{
    char* result; // eax
    int i; // [esp+4h] [ebp-4h]

    thisx[24] = 0;
    *(_DWORD*)thisx = 0;
    *((_DWORD*)thisx + 1) = 0;
    memset(thisx + 8, 0, 0x10u);
    memset(thisx + 25, 0, 4u);
    memset(thisx + 29, 0, 0x40u);
    memset(thisx + 93, 0, 0x80u);
    *((_DWORD*)thisx + 57) = 0;
    *((_DWORD*)thisx + 56) = 0;
    result = thisx;
    thisx[264] = 0;
    thisx[269] = 0;
    thisx[270] = 0;
    for (i = 0; i < 4; ++i)
    {
        *(_DWORD*)&thisx[4 * i + 248] = 0;
        thisx[i + 265] = 0;
        *(_DWORD*)&thisx[4 * i + 232] = 0;
        thisx[i + 271] = 0;
        result = (char*)(i + 1);
    }
    return result;
}
 
void sub_4837D1(void* thisx)
{
    sub_4836CD((char*)thisx);
}
 
void sub_4837E7(void* thisx)
{
    sub_4842BE((int)thisx);
}
 
char  sub_4837FA(int* thisx, int a2)
{
    int v2; // edx
    int v3; // eax
    int v5; // [esp+0h] [ebp-24h]
    int v6; // [esp+4h] [ebp-20h]
    int i; // [esp+Ch] [ebp-18h]
    unsigned __int8 v9; // [esp+14h] [ebp-10h]
    unsigned __int8 v10; // [esp+1Ch] [ebp-8h]
    char v11; // [esp+20h] [ebp-4h]

    v9 = sub_425EF0((char*)a2);
    if ((char)sub_485120((char*)a2) <= 0)
        v6 = ((sub_485120((char*)a2) & 0x80u) == 0) - 1;
    else
        v6 = 1;
    if ((char)sub_485140((char*)a2) <= 0)
        v5 = ((sub_485140((char*)a2) & 0x80u) == 0) - 1;
    else
        v5 = 1;
    v2 = 3 * (v6 + 1);
    v10 = byte_4B6CED[v2 + v5];
    v11 = 0;
    for (i = 0; i < 4; ++i)
    {
        if (sub_485100((_BYTE*)a2, i))
            v11 |= 1 << i;
        v2 = i + 1;
    }
    LOBYTE(v2) = v10;
    LOBYTE(v3) = sub_48342F((int)&thisx[69 * v9 + 3], v2, v10, v11);
    if (thisx[1])
    {
        LOBYTE(v3) = v9;
        LOBYTE(v3) = sub_483927((int)&thisx[69 * v9 + 3], thisx[1], (HANDLE)thisx[1], v3, 0);
    }
    return v3;
} 
int __fastcall sub_483927(int a1, int a2, HANDLE hFile, int a4, int a5)
{
    int result; // eax
    int v7; // [esp+4h] [ebp-1Ch]
    unsigned __int8 v8; // [esp+8h] [ebp-18h]
    int v9; // [esp+Ch] [ebp-14h]
    char Buffer[4]; // [esp+10h] [ebp-10h] BYREF
    DWORD NumberOfBytesWritten; // [esp+14h] [ebp-Ch] BYREF
    unsigned int v12; // [esp+18h] [ebp-8h]
    int i; // [esp+1Ch] [ebp-4h]

    v12 = 0;
    result = a1;
    if ((*(_BYTE*)(a1 + 24) & 0xF) == 0 || a5)
    {
        v9 = *(unsigned __int8*)(a1 + 24);
        if (a5)
            v9 += 16;
        v12 = (16 * (v9 / 16) + 16) % 0x20u;
        result = a1;
        if (*(_BYTE*)(a1 + 2 * v12 + 30))
        {
            Buffer[0] = a4;
            WriteFile(hFile, Buffer, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
            WriteFile(hFile, (LPCVOID)(a1 + 2 * v12 + 29), 0x20u, (LPDWORD)&NumberOfBytesWritten, 0);
            result = (int)memset((void*)(a1 + 2 * v12 + 29), 0, 0x20u);
        }
    }
    for (i = 0; i < 4; ++i)
    {
        result = i + a1;
        if ((*(_BYTE*)(i + a1 + 25) & 0xF) == 0 || a5)
        {
            v7 = *(unsigned __int8*)(i + a1 + 25);
            if (a5)
                v7 += 16;
            v12 = (16 * (v7 / 16) + 16) % 0x20u;
            v8 = *(_BYTE*)(a1 + 32 * i + v12 + 93) & 0x7F;
            result = v8;
            if (v8)
            {
                Buffer[0] = a4 | (16 * (i + 1));
                WriteFile(hFile, Buffer, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
                WriteFile(hFile, (LPCVOID)(a1 + 32 * i + v12 + 93), 0x10u, (LPDWORD)&NumberOfBytesWritten, 0);
                result = (int)memset((void*)(a1 + 32 * i + v12 + 93), 0, 0x10u);
            }
        }
    }
    return result;
}
 
int sub_483B1D(int thisx, LPCSTR lpFileName)
{
    int v3; // eax
    const void* v4; // eax
    int v6; // [esp+4h] [ebp-12Ch] BYREF
    unsigned __int16* v7; // [esp+8h] [ebp-128h]
    DWORD NumberOfBytesWritten; // [esp+Ch] [ebp-124h] BYREF
    int v9; // [esp+10h] [ebp-120h] BYREF
    int v10; // [esp+14h] [ebp-11Ch] BYREF
    int i; // [esp+18h] [ebp-118h]
    char v12[4]; // [esp+1Ch] [ebp-114h] BYREF
    char Buffer[4]; // [esp+20h] [ebp-110h] BYREF
    int v14; // [esp+24h] [ebp-10Ch] BYREF
    int v15; // [esp+28h] [ebp-108h] BYREF
    CHAR String[256]; // [esp+30h] [ebp-100h] BYREF

    sub_484175(thisx);
    for (i = 0; i < 8; ++i)
    {
        sub_4842BE(thisx + 276 * i + 12);
        sub_4836CD((char*)thisx + 276 * i + 12);
    }
    *(_DWORD*)(thisx + 4) = (int)CreateFileA(lpFileName, 0x40000000u, 0, 0, 2u, 0x80u, 0);
    if (*(_DWORD*)(thisx + 4) == -1)
    {
        *(_DWORD*)(thisx + 4) = 0;
        return 0;
    }
    else
    {
        wsprintfA(String, aKdReplayFile);
        v3 = lstrlenA(String);
        WriteFile(*(HANDLE*)(thisx + 4), String, v3 + 1, (LPDWORD)&NumberOfBytesWritten, 0);
        Buffer[0] = 3;
        WriteFile(*(HANDLE*)(thisx + 4), Buffer, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
        v14 = dword_4B9980;
        WriteFile(*(HANDLE*)(thisx + 4), &v14, 4u, (LPDWORD)&NumberOfBytesWritten, 0);
        LOBYTE(v9) = byte_4B9985;
        WriteFile(*(HANDLE*)(thisx + 4), &v9, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
        LOBYTE(v10) = byte_4B9986;
        WriteFile(*(HANDLE*)(thisx + 4), &v10, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
        for (i = 0; i < (unsigned __int8)v10; ++i)
        {
            v12[0] = byte_4B9988[i];
            WriteFile(*(HANDLE*)(thisx + 4), v12, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
        }
        v12[0] = byte_4B9990;
        WriteFile(*(HANDLE*)(thisx + 4), v12, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
        v12[0] = sub_425CD0((_DWORD*)unk_4B9B10);
        WriteFile(*(HANDLE*)(thisx + 4), v12, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
        WriteFile(*(HANDLE*)(thisx + 4), &byte_4B9984, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
        WriteFile(*(HANDLE*)(thisx + 4), &byte_4B9998, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
        v12[0] = byte_4B9999;
        WriteFile(*(HANDLE*)(thisx + 4), v12, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
        WriteFile(*(HANDLE*)(thisx + 4), &byte_4B999A, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
        WriteFile(*(HANDLE*)(thisx + 4), (LPVOID)byte_4B999B, 8u, (LPDWORD)&NumberOfBytesWritten, 0);
        WriteFile(*(HANDLE*)(thisx + 4), (LPVOID)byte_4B99A3, 8u, (LPDWORD)&NumberOfBytesWritten, 0);
        LOBYTE(v15) = 14;
        WriteFile(*(HANDLE*)(thisx + 4), &v15, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
        for (i = 0; i < (unsigned __int8)v15; ++i)
            WriteFile(*(HANDLE*)(thisx + 4), (LPCVOID)(2 * i + 4954540), 2u, (LPDWORD)&NumberOfBytesWritten, 0);
        v12[0] = byte_4B99C8;
        WriteFile(*(HANDLE*)(thisx + 4), v12, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
        v12[0] = byte_4B99C9;
        WriteFile(*(HANDLE*)(thisx + 4), v12, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
        v12[0] = byte_4B99CA;
        WriteFile(*(HANDLE*)(thisx + 4), v12, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
        WriteFile(*(HANDLE*)(thisx + 4), &byte_4B99CB, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
        WriteFile(*(HANDLE*)(thisx + 4), &byte_4B99CC, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
        v12[0] = byte_4B99CD;
        WriteFile(*(HANDLE*)(thisx + 4), v12, 1u, (LPDWORD)&NumberOfBytesWritten, 0);
        v4 = (const void*)sub_485160((char*)unk_4B9B10);
        WriteFile(*(HANDLE*)(thisx + 4), v4, 8u, (LPDWORD)&NumberOfBytesWritten, 0);
        for (i = 0; i < (unsigned __int8)v9; ++i)
        {
            v7 = (unsigned __int16*)sub_446714(unk_4B9B10, i);
            sub_4231E6(v7, *(HANDLE*)(thisx + 4));
        }
        *(_DWORD*)(thisx + 8) = SetFilePointer(*(HANDLE*)(thisx + 4), 0, 0, 1u);
        for (i = 0; i < (unsigned __int8)v10; ++i)
        {
            v6 = 0;
            WriteFile(*(HANDLE*)(thisx + 4), &v6, 4u, (LPDWORD)&NumberOfBytesWritten, 0);
            WriteFile(*(HANDLE*)(thisx + 4), &v6, 4u, (LPDWORD)&NumberOfBytesWritten, 0);
            WriteFile(*(HANDLE*)(thisx + 4), &v6, 4u, (LPDWORD)&NumberOfBytesWritten, 0);
            WriteFile(*(HANDLE*)(thisx + 4), &v6, 4u, (LPDWORD)&NumberOfBytesWritten, 0);
            WriteFile(*(HANDLE*)(thisx + 4), &v6, 4u, (LPDWORD)&NumberOfBytesWritten, 0);
        }
        return 1;
    }
}
 
BOOL __fastcall sub_484175(int a1)
{
    BOOL result; // eax
    int v2; // [esp+4h] [ebp-1Ch]
    DWORD NumberOfBytesWritten; // [esp+8h] [ebp-18h] BYREF
    unsigned int Buffer; // [esp+Ch] [ebp-14h] BYREF
    int j; // [esp+10h] [ebp-10h]
    _DWORD* v6; // [esp+14h] [ebp-Ch]
    int v7; // [esp+18h] [ebp-8h]
    int i; // [esp+1Ch] [ebp-4h]

    v2 = a1;
    result = a1;
    if (*(_DWORD*)(a1 + 4))
    {
        LOBYTE(v7) = byte_4B9986;
        for (i = 0; i < (unsigned __int8)v7; ++i)
        {
            LOBYTE(a1) = i;
            sub_483927(v2 + 276 * i + 12, v2, *(HANDLE*)(v2 + 4), a1, 1);
        }
        SetFilePointer(*(HANDLE*)(v2 + 4), *(_DWORD*)(v2 + 8), 0, 0);
        for (i = 0; i < (unsigned __int8)v7; ++i)
        {
            v6 = (_DWORD*)(v2 + 276 * i + 12);
            for (j = 0; j < 5; ++j)
            {
                Buffer = 0;
                if (j)
                    Buffer = sub_485180(v6, j - 1);
                else
                    Buffer = unknown_libname_22(v6);
                Buffer = Buffer + 16 - Buffer % 0x10;
                WriteFile(*(HANDLE*)(v2 + 4), &Buffer, 4u, (LPDWORD)&NumberOfBytesWritten, 0);
            }
        }
        result = CloseHandle(*(HANDLE*)(v2 + 4));
        *(_DWORD*)(v2 + 4) = 0;
    }
    return result;
}
 
void sub_4842BE(int thisx)
{
    int i; // [esp+Ch] [ebp-4h]

    if (*(_DWORD*)(thisx + 228))
        operator delete(*(void**)(thisx + 228));
    *(_DWORD*)(thisx + 228) = 0;
    *(_DWORD*)(thisx + 4) = 0;
    for (i = 0; i < 4; ++i)
    {
        if (*(_DWORD*)(thisx + 4 * i + 248))
            operator delete(*(void**)(thisx + 4 * i + 248));
        *(_DWORD*)(thisx + 4 * i + 248) = 0;
        *(_DWORD*)(thisx + 4 * i + 8) = 0;
    }
}
 
int sub_48436B(_DWORD* thisx, int a2, size_t Size)
{
    if (a2 < 0 || a2 > 4)
        return 0;
    if (a2)
    {
        thisx[a2 + 61] = (_DWORD)operator new(Size);
        if (!thisx[a2 + 61])
            return 0;
        thisx[a2 + 1] = Size;
    }
    else
    {
        thisx[57] = (_DWORD)operator new(2 * Size);
        if (!thisx[57])
            return 0;
        thisx[1] = Size;
    }
    return 1;
}

 
int sub_484410(_DWORD* thisx, unsigned int a2, char a3, char a4)
{
    if (a2 >= thisx[1])
        return 0;
    *(_BYTE*)(thisx[57] + 2 * a2) = a3;
    *(_BYTE*)(thisx[57] + 2 * a2 + 1) = a4;
    return 1;
}

 
int sub_484456(_DWORD* thisx, unsigned __int8 a2, unsigned int a3, char a4)
{
    if (a2 >= 4u)
        return 0;
    if (a3 >= thisx[a2 + 2])
        return 0;
    *(_BYTE*)(thisx[a2 + 62] + a3) = a4;
    return 1;
}
 
unsigned int __fastcall sub_4844AE(unsigned int a1)
{
    unsigned int result; // eax
    bool v2; // [esp+4h] [ebp-20h]
    bool v3; // [esp+8h] [ebp-1Ch]
    bool v4; // [esp+Ch] [ebp-18h]
    bool v5; // [esp+10h] [ebp-14h]
    char v6; // [esp+18h] [ebp-Ch]
    unsigned __int8* v7; // [esp+1Ch] [ebp-8h]
    int i; // [esp+20h] [ebp-4h]

    if (*(_BYTE*)(a1 + 264))
        --* (_BYTE*)(a1 + 264);
    result = *(unsigned __int8*)(a1 + 264);
    if (!*(_BYTE*)(a1 + 264))
    {
        *(_BYTE*)(a1 + 269) = 0;
        *(_BYTE*)(a1 + 270) = 0;
        result = a1;
        if (*(_DWORD*)(a1 + 224) < *(_DWORD*)(a1 + 4))
        {
            ++* (_DWORD*)(a1 + 224);
            v7 = (unsigned __int8*)(*(_DWORD*)(a1 + 228) + 2 * *(_DWORD*)(a1 + 224));
            *(_BYTE*)(a1 + 264) = v7[1];
            v5 = *v7 >= 3u && *v7 <= 5u;
            v4 = *v7 >= 7u && *v7 <= 9u;
            *(_BYTE*)(a1 + 269) = v5 - v4;
            result = (unsigned int)v7;
            v3 = 0;
            if (*v7 >= 5u)
            {
                result = *v7;
                if (result <= 7)
                    v3 = 1;
            }
            v2 = 1;
            if (*v7 != 2)
            {
                result = (unsigned int)v7;
                if (*v7 != 3)
                {
                    result = *v7;
                    if (result != 9)
                        v2 = 0;
                }
            }
            *(_BYTE*)(a1 + 270) = v3 - v2;
        }
    }
    for (i = 0; i < 4; ++i)
    {
        if (*(_BYTE*)(i + a1 + 265))
            --* (_BYTE*)(i + a1 + 265);
        if (!*(_BYTE*)(i + a1 + 265))
        {
            *(_BYTE*)(i + a1 + 271) = 0;
            if (*(_DWORD*)(a1 + 4 * i + 232) < *(_DWORD*)(a1 + 4 * i + 8))
            {
                ++* (_DWORD*)(a1 + 4 * i + 232);
                v6 = *(_BYTE*)(*(_DWORD*)(a1 + 4 * i + 248) + *(_DWORD*)(a1 + 4 * i + 232));
                *(_BYTE*)(i + a1 + 265) = v6 & 0x7F;
                *(_BYTE*)(i + a1 + 271) = (v6 & 0x80) != 0;
            }
        }
        result = i + 1;
    }
    return result;
}

 
int sub_484723(int thisx, LPCSTR lpFileName)
{
    void* v3; // eax
    char v5[4]; // [esp+4h] [ebp-1E8h] BYREF
    char v6[4]; // [esp+8h] [ebp-1E4h] BYREF
    int k; // [esp+Ch] [ebp-1E0h]
    _DWORD* v8; // [esp+10h] [ebp-1DCh]
    int j; // [esp+14h] [ebp-1D8h]
    _DWORD* v10; // [esp+18h] [ebp-1D4h]
    int v11; // [esp+1Ch] [ebp-1D0h]
    unsigned int v12; // [esp+20h] [ebp-1CCh]
    HANDLE hFile; // [esp+24h] [ebp-1C8h]
    int v14; // [esp+28h] [ebp-1C4h]
    _OWORD v15[8]; // [esp+2Ch] [ebp-1C0h] BYREF
    int v16; // [esp+ACh] [ebp-140h]
    int i; // [esp+B0h] [ebp-13Ch]
    int v18; // [esp+B4h] [ebp-138h]
    int v19; // [esp+B8h] [ebp-134h] BYREF
    int v20; // [esp+BCh] [ebp-130h] BYREF
    unsigned int v21; // [esp+C0h] [ebp-12Ch]
    DWORD NumberOfBytesRead; // [esp+C4h] [ebp-128h] BYREF
    int v23[8]; // [esp+C8h] [ebp-124h] BYREF
    CHAR Buffer[256]; // [esp+E8h] [ebp-104h] BYREF
    size_t Size; // [esp+1E8h] [ebp-4h] BYREF

    hFile = CreateFileA(lpFileName, 0x80000000, 0, 0, 3u, 0x80u, 0);
    if (hFile == (HANDLE)-1)
    {
        hFile = 0;
        return 0;
    }
    else
    {
        v21 = 0;
        ReadFile(hFile, Buffer, 0xFu, (LPDWORD)&NumberOfBytesRead, 0);
        if (lstrcmpiA(Buffer, aKdReplayFile_0))
        {
            CloseHandle(hFile);
            return 0;
        }
        else
        {
            LOBYTE(v20) = 0;
            ReadFile(hFile, &v20, 1u, (LPDWORD)&NumberOfBytesRead, 0);
            ReadFile(hFile, &dword_4B9980, 4u, (LPDWORD)&NumberOfBytesRead, 0);
            ReadFile(hFile, &byte_4B9985, 1u, (LPDWORD)&NumberOfBytesRead, 0);
            ReadFile(hFile, &byte_4B9986, 1u, (LPDWORD)&NumberOfBytesRead, 0);
            LOBYTE(v16) = byte_4B9986;
            ReadFile(hFile, byte_4B9988, (unsigned __int8)byte_4B9986, (LPDWORD)&NumberOfBytesRead, 0);
            ReadFile(hFile, &byte_4B9990, 1u, (LPDWORD)&NumberOfBytesRead, 0);
            ReadFile(hFile, (LPVOID)(thisx + 2220), 1u, (LPDWORD)&NumberOfBytesRead, 0);
            if ((unsigned __int8)v20 < 2u)
                byte_4B9984 = 0;
            else
                ReadFile(hFile, &byte_4B9984, 1u, (LPDWORD)&NumberOfBytesRead, 0);
            ReadFile(hFile, &byte_4B9998, 1u, (LPDWORD)&NumberOfBytesRead, 0);
            ReadFile(hFile, &byte_4B9999, 1u, (LPDWORD)&NumberOfBytesRead, 0);
            ReadFile(hFile, &byte_4B999A, 1u, (LPDWORD)&NumberOfBytesRead, 0);
            ReadFile(hFile, byte_4B999B, 8u, (LPDWORD)&NumberOfBytesRead, 0);
            ReadFile(hFile, byte_4B99A3, 8u, (LPDWORD)&NumberOfBytesRead, 0);
            ReadFile(hFile, (LPVOID)(thisx + 2225), 1u, (LPDWORD)&NumberOfBytesRead, 0);
            for (i = 0; i < *(unsigned __int8*)(thisx + 2225); ++i)
                ReadFile(hFile, (LPVOID)(2 * i + 4954540), 2u, (LPDWORD)&NumberOfBytesRead, 0);
            ReadFile(hFile, &byte_4B99C8, 1u, (LPDWORD)&NumberOfBytesRead, 0);
            ReadFile(hFile, &byte_4B99C9, 1u, (LPDWORD)&NumberOfBytesRead, 0);
            ReadFile(hFile, &byte_4B99CA, 1u, (LPDWORD)&NumberOfBytesRead, 0);
            ReadFile(hFile, &byte_4B99CB, 1u, (LPDWORD)&NumberOfBytesRead, 0);
            ReadFile(hFile, &byte_4B99CC, 1u, (LPDWORD)&NumberOfBytesRead, 0);
            ReadFile(hFile, &byte_4B99CD, 1u, (LPDWORD)&NumberOfBytesRead, 0);
            if ((_BYTE)v20)
            {
                v3 = (void*)sub_485160((char*)unk_4B9B10);
                ReadFile(hFile, v3, 8u, (LPDWORD)&NumberOfBytesRead, 0);
            }
            for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
            {
                v11 = sub_446714(unk_4B9B10, i);
                sub_422C3A(v11, hFile, (unsigned __int8)v20);
            }
            for (i = 0; i < 8; ++i)
            {
                sub_4842BE(thisx + 276 * i + 12);
                sub_4836CD((char*)thisx + 276 * i + 12);
            }
            for (i = 0; i < (unsigned __int8)v16; ++i)
            {
                v10 = (_DWORD*)(thisx + 276 * i + 12);
                for (j = 0; j < 5; ++j)
                {
                    ReadFile(hFile, &Size, 4u, (LPDWORD)&NumberOfBytesRead, 0);
                    v21 += Size;
                    if (!sub_48436B(v10, j, Size))
                    {
                        CloseHandle(hFile);
                        return 0;
                    }
                }
            }
            memset(v23, 0, sizeof(v23));
            memset(v15, 0, sizeof(v15));
            v12 = 0;
            do
            {
                if (!(_BYTE)v16)
                    break;
                ReadFile(hFile, &v19, 1u, (LPDWORD)&NumberOfBytesRead, 0);
                LOBYTE(v18) = v19 & 0xF;
                LOBYTE(v14) = (v19 & 0xF0) >> 4;
                v8 = (_DWORD*)(thisx + 276 * (v19 & 0xF) + 12);
                for (k = 0; k < 16; ++k)
                {
                    if ((_BYTE)v14)
                    {
                        if ((unsigned __int8)v14 > 4u)
                        {
                            CloseHandle(hFile);
                            return 0;
                        }
                        ReadFile(hFile, &v19, 1u, (LPDWORD)&NumberOfBytesRead, 0);
                        sub_484456(v8, v14 - 1, *((_DWORD*)&v15[(unsigned __int8)v18 - 1] + (unsigned __int8)v14 + 3), v19);
                        ++* ((_DWORD*)&v15[(unsigned __int8)v18 - 1] + (unsigned __int8)v14 + 3);
                    }
                    else
                    {
                        ReadFile(hFile, v6, 1u, (LPDWORD)&NumberOfBytesRead, 0);
                        ReadFile(hFile, v5, 1u, (LPDWORD)&NumberOfBytesRead, 0);
                        sub_484410(v8, v23[(unsigned __int8)v18]++, v6[0], v5[0]);
                    }
                    ++v12;
                }
            } while (v12 < v21);
            CloseHandle(hFile);
            for (i = 0; i < (unsigned __int8)v16; ++i)
                sub_484F5F(thisx + 276 * i + 12);
            return 1;
        }
    }
}
 
unsigned int sub_484F5F(int thisx)
{
    unsigned int result; // eax
    bool v2; // [esp+0h] [ebp-20h]
    bool v3; // [esp+4h] [ebp-1Ch]
    bool v4; // [esp+8h] [ebp-18h]
    bool v5; // [esp+Ch] [ebp-14h]
    char v6; // [esp+14h] [ebp-Ch]
    int i; // [esp+18h] [ebp-8h]
    unsigned __int8* v8; // [esp+1Ch] [ebp-4h]

    v8 = (unsigned __int8*)(*(_DWORD*)(thisx + 228) + 2 * *(_DWORD*)(thisx + 224));
    *(_BYTE*)(thisx + 264) = v8[1];
    v5 = *v8 >= 3u && *v8 <= 5u;
    v4 = *v8 >= 7u && *v8 <= 9u;
    *(_BYTE*)(thisx + 269) = v5 - v4;
    result = (unsigned int)v8;
    v3 = 0;
    if (*v8 >= 5u)
    {
        result = *v8;
        if (result <= 7)
            v3 = 1;
    }
    v2 = 1;
    if (*v8 != 2)
    {
        result = (unsigned int)v8;
        if (*v8 != 3)
        {
            result = *v8;
            if (result != 9)
                v2 = 0;
        }
    }
    *(_BYTE*)(thisx + 270) = v3 - v2;
    for (i = 0; i < 4; ++i)
    {
        v6 = *(_BYTE*)(*(_DWORD*)(thisx + 4 * i + 248) + *(_DWORD*)(thisx + 4 * i + 232));
        *(_BYTE*)(i + thisx + 265) = v6 & 0x7F;
        *(_BYTE*)(i + thisx + 271) = (v6 & 0x80) != 0;
        result = i + 1;
    }
    return result;
}
 
_DWORD* sub_4850D0(_DWORD* thisx, char a2)
{
    sub_4833CE(thisx);
    if ((a2 & 1) != 0)
        operator delete(thisx);
    return thisx;
}
 
char sub_485100(_BYTE* thisx, unsigned __int8 a2)
{
    return thisx[a2 + 226];
}
 
char sub_485120(_BYTE* thisx)
{
    return thisx[224];
}
 
char sub_485140(_BYTE* thisx)
{
    return thisx[225];
}
 
char* sub_485160(char* thisx)
{
    return thisx + 2612;
}

 
int sub_485180(_DWORD* thisx, int a2)
{
    return thisx[a2 + 2];
}
 
_BYTE* sub_4851A0(_BYTE* thisx)
{
    sub_47FC70(thisx);
    *(_DWORD*)thisx = off_4AC338;
    thisx[4] = 10;
    thisx[5] = 14;
    thisx[6] = 19;
    thisx[7] = 6;
    return thisx;
}

 
void sub_4851DB(_DWORD* thisx)
{
    *thisx = off_4AC338;
    sub_47FCCF(thisx);
}
 
int sub_4851F7(_DWORD* thisx)
{
    BOOL v1; // esi
    BOOL v2; // esi
    int v5; // [esp+8h] [ebp-2Ch]
    int v6; // [esp+Ch] [ebp-28h]
    int v7; // [esp+10h] [ebp-24h]
    int v8; // [esp+14h] [ebp-20h]
    int v9; // [esp+18h] [ebp-1Ch]
    int v10; // [esp+1Ch] [ebp-18h]
    BOOL v11; // [esp+20h] [ebp-14h]
    int v12; // [esp+24h] [ebp-10h]
    int v13; // [esp+28h] [ebp-Ch]
    BOOL v14; // [esp+2Ch] [ebp-8h]
    int v15; // [esp+30h] [ebp-4h]

    v1 = sub_476D78(0);
    v13 = v1 - sub_476D29(0);
    v2 = sub_476CDA(0);
    v12 = v2 - sub_476C8B(0);
    v11 = sub_476DC7(0, 0);
    v14 = sub_476DC7(0, 1);
    v15 = 0;
    if (v11)
    {
        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
        return 1;
    }
    else if (v14)
    {
        return 2;
    }
    else
    {
        if (v13 || v12)
        {
            sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
            if (v13)
            {
                thisx[5] = (thisx[5] + v13 + 3) % 3;
                return 4;
            }
            else if (v12)
            {
                v15 = 3;
                v10 = sub_425CD0((_DWORD*)unk_4B9B10);
                if (thisx[5])
                {
                    if (thisx[5] == 1)
                    {
                        v6 = v12 + (unsigned __int8)byte_4B9986;
                        if (v10 == 1)
                        {
                            if (v6 >= 0)
                            {
                                if (v6 > (unsigned __int8)byte_4B9985)
                                    v6 = (unsigned __int8)byte_4B9985;
                            }
                            else
                            {
                                v6 = 0;
                            }
                        }
                        else if (v10 == 2)
                        {
                            if (v6 >= 1)
                            {
                                if (v6 > (unsigned __int8)byte_4B9985 - 1)
                                    v6 = (unsigned __int8)byte_4B9985 - 1;
                            }
                            else
                            {
                                v6 = 1;
                            }
                        }
                        if ((unsigned __int8)byte_4B9986 != v6)
                            byte_4B9987 = byte_4B9985 - v6;
                        byte_4B9986 = v6;
                    }
                    else if (thisx[5] == 2)
                    {
                        v5 = v12 + (unsigned __int8)byte_4B9987;
                        if (v10 == 1)
                        {
                            if (v5 >= 0)
                            {
                                if (v5 > (unsigned __int8)byte_4B9985)
                                    v5 = (unsigned __int8)byte_4B9985;
                            }
                            else
                            {
                                v5 = 0;
                            }
                        }
                        else if (v10 == 2)
                        {
                            if (v5 >= 1)
                            {
                                if (v5 > (unsigned __int8)byte_4B9985 - 1)
                                    v5 = (unsigned __int8)byte_4B9985 - 1;
                            }
                            else
                            {
                                v5 = 1;
                            }
                        }
                        if ((unsigned __int8)byte_4B9987 != v5)
                            byte_4B9986 = byte_4B9985 - v5;
                        byte_4B9987 = v5;
                    }
                }
                else
                {
                    v9 = v12 + (unsigned __int8)byte_4B9985;
                    if (v9 >= 2)
                    {
                        if (v9 > 8)
                            v9 = 8;
                    }
                    else
                    {
                        v9 = 2;
                    }
                    if ((unsigned __int8)byte_4B9985 != v9)
                    {
                        v8 = 0;
                        v7 = 8;
                        if (v10 == 2)
                        {
                            v8 = 1;
                            v7 = 7;
                        }
                        if ((v12 >= 0 || (unsigned __int8)byte_4B9987 <= v8) && (v12 <= 0 || (unsigned __int8)byte_4B9987 >= v7))
                            byte_4B9986 += v12;
                        else
                            byte_4B9987 += v12;
                    }
                    byte_4B9985 = v9;
                }
            }
        }
        return v15;
    }
}
 
int sub_485510(unsigned __int8* thisx)
{
    int v3; // [esp+4h] [ebp-108h]
    int v4; // [esp+4h] [ebp-108h]
    int v5; // [esp+8h] [ebp-104h]
    int v6; // [esp+8h] [ebp-104h]
    CHAR String[256]; // [esp+Ch] [ebp-100h] BYREF

    sub_480A51(thisx);
    v5 = thisx[4];
    v3 = thisx[5];
    sub_47B91A(8 * v5 + 16, 8 * v3 + 16, (LPCSTR)dword_4ABAEC, 0, dword_4B9248);
    v6 = 8 * v5 + 16;
    v4 = 8 * v3 + 32;
    wsprintfA(String, (LPCSTR)dword_4ABB0C, (unsigned __int8)byte_4B9985);
    sub_47BC5A(v6 + 16, v4, String, 0, dword_4B9248);
    sub_47B91A(v6 + 8, v4, (LPCSTR)dword_4ABB10, 0, dword_4B9248);
    wsprintfA(String, (LPCSTR)dword_4ABB0C, (unsigned __int8)byte_4B9986);
    sub_47BC5A(v6 + 64, v4, String, 0, dword_4B9248);
    sub_47B91A(v6 + 56, v4, (LPCSTR)dword_4ABB10, 0, dword_4B9248);
    wsprintfA(String, (LPCSTR)dword_4ABB0C, (unsigned __int8)byte_4B9987);
    sub_47BC5A(v6 + 112, v4, String, 0, dword_4B9248);
    return sub_47B91A(v6 + 104, v4, (LPCSTR)dword_4ABB10, 0, dword_4B9248);
}
 
int sub_4856EF(_DWORD* thisx)
{
    return sub_47B91A(48 * thisx[5] + 92, 144, asc_4B6D50, 0, -1);
}
 
_DWORD* sub_485720(_DWORD* thisx, char a2)
{
    sub_4851DB(thisx);
    if ((a2 & 1) != 0)
        operator delete(thisx);
    return thisx;
}

 
_BYTE* sub_485750(_BYTE* thisx)
{
    sub_47FC70(thisx);
    *(_DWORD*)thisx = off_4AC34C;
    thisx[4] = 23;
    thisx[5] = 8;
    thisx[6] = 15;
    thisx[7] = 14;
    return thisx;
}
 
void sub_48578B(_DWORD* thisx)
{
    *thisx = off_4AC34C;
    sub_47FCCF(thisx);
}

 
int sub_4857A7(unsigned __int8* thisx)
{
    int result; // eax
    CHAR String[256]; // [esp+4h] [ebp-10Ch] BYREF
    int i; // [esp+104h] [ebp-Ch]
    int v5; // [esp+108h] [ebp-8h]
    int v6; // [esp+10Ch] [ebp-4h]

    sub_480A51(thisx);
    v6 = 8 * thisx[4];
    v5 = 8 * thisx[5];
    sub_47B91A(v6 + 24, v5 + 10, (LPCSTR)&byte_4B2D45, 0, dword_4B9248);
    sub_47B91A(v6 + 24, v5 + 30, (LPCSTR)&byte_4B17DC, 0, dword_4B9248);
    sub_47B91A(v6 + 24, v5 + 46, (LPCSTR)&byte_4B17E6, 0, dword_4B9248);
    sub_47B91A(v6 + 24, v5 + 62, (LPCSTR)&byte_4B2E1E, 0, dword_4B9248);
    sub_47B91A(v6 + 24, v5 + 78, (LPCSTR)&byte_4B2EF6, 0, dword_4B9248);
    result = sub_47B91A(v6 + 24, v5 + 94, byte_4B2F00, 0, dword_4B9248);
    for (i = 0; i < 5; ++i)
    {
        wsprintfA(String, "%3d", *(_DWORD*)&thisx[4 * i + 36]);
        sub_47B7ED(v6 + 80, v5 + 16 * i + 30, String, 0, dword_4B9248);
        result = sub_47B91A(v6 + 96, v5 + 16 * i + 30, (LPCSTR)&byte_4B17D4, 0, dword_4B9248);
    }
    return result;
}
 
int sub_485955(_DWORD* thisx)
{
    BOOL v1; // esi
    BOOL v4; // [esp+8h] [ebp-14h]
    int v5; // [esp+Ch] [ebp-10h]
    int v6; // [esp+14h] [ebp-8h]
    BOOL v7; // [esp+18h] [ebp-4h]

    v6 = 0;
    sub_476D78(0);
    sub_476D29(0);
    v1 = sub_476CDA(0);
    v5 = v1 - sub_476C8B(0);
    v4 = sub_476DC7(0, 0);
    v7 = sub_476DC7(0, 1);
    if (v5)
    {
        thisx[5] = (thisx[5] + v5 + 5) % 5;
        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
        return 3;
    }
    else if (v4)
    {
        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
        return 1;
    }
    else if (v7)
    {
        return 2;
    }
    return v6;
}


 
int sub_485A3A(int thisx)
{
    return sub_47B91A(
        8 * *(unsigned __int8*)(thisx + 4) + 12,
        16 * *(_DWORD*)(thisx + 20) + 8 * *(unsigned __int8*)(thisx + 5) + 30,
        asc_4B17D8,
        0,
        -1);
}

 
int sub_485A7C(streambuf* thisx, int a2)
{
    int result; // eax
    int v4; // [esp+8h] [ebp-8h]
    int i; // [esp+Ch] [ebp-4h]

    sub_48070C(thisx, a2);
    result = (_DWORD)sub_485B10((char*)unk_4B9B10);
    v4 = result;
    for (i = 0; i < 5; ++i)
    {
        result = (int)thisx;
        *((_DWORD*)thisx + i + 9) = *(_DWORD*)(v4 + 4 * i);
    }
    return result;
}
 
_DWORD* sub_485AE0(_DWORD* thisx, char a2)
{
    sub_48578B(thisx);
    if ((a2 & 1) != 0)
        operator delete(thisx);
    return thisx;
}
 
char* sub_485B10(char* thisx)
{
    return thisx + 11380;
}

 
void sub_485B30(void* thisx)
{
    *(_DWORD*)thisx = off_4AC360;
    *((_DWORD*)thisx + 4) = 0;
    *((_DWORD*)thisx + 5) = 0;
    *((_DWORD*)thisx + 1) = 0;
    *((_WORD*)thisx + 6) = 0;
    *((_DWORD*)thisx + 2) = 0;
}
 
void sub_485B78(void* thisx)
{
    *(_DWORD*)thisx = off_4AC360;
    if (*((_DWORD*)thisx + 4))
        operator delete(*((void**)thisx + 4));
    if (*((_DWORD*)thisx + 5))
        operator delete(*((void**)thisx + 5));
}
 
int sub_485BCA(int thisx, _DWORD* a2)
{
    int v4; // [esp+10h] [ebp-108h]
    int v5; // [esp+14h] [ebp-104h]
    char String[256]; // [esp+18h] [ebp-100h] BYREF

    if (!a2)
        return 0;
    v5 = 0;
    v4 = 0;
    while (1)
    {
        if (!sub_482D44(a2, String))
            return 0;
        if (String[0] == 110)
            return 1;
        switch (v5)
        {
        case 0:
            *(_DWORD*)(thisx + 4) = atoi(String);
            break;
        case 1:
            *(_WORD*)(thisx + 12) = atoi(String);
            if (*(_WORD*)(thisx + 12))
            {
                *(_DWORD*)(thisx + 16) = (_DWORD)operator new(*(unsigned __int16*)(thisx + 12));
                *(_DWORD*)(thisx + 20) = (_DWORD)operator new(4 * *(unsigned __int16*)(thisx + 12));
            }
            break;
        case 2:
            *(_BYTE*)(*(_DWORD*)(thisx + 16) + v4) = atoi(String);
            break;
        case 3:
            *(_BYTE*)(*(_DWORD*)(thisx + 20) + 4 * v4 + 2) = atoi(String);
            break;
        case 4:
            *(_BYTE*)(*(_DWORD*)(thisx + 20) + 4 * v4 + 1) = atoi(String);
            break;
        case 5:
            *(_BYTE*)(*(_DWORD*)(thisx + 20) + 4 * v4) = atoi(String);
            break;
        default:
            break;
        }
        if (++v5 == 6)
        {
            v5 = 2;
            if (++v4 >= *(unsigned __int16*)(thisx + 12))
            {
                sub_482FAA(a2);
                return 1;
            }
        }
    }
}
 
int sub_485DFD(int thisx, int a2)
{
    int result; // eax
    int i; // [esp+4h] [ebp-4h]

    for (i = 0; i < *(unsigned __int16*)(thisx + 12); ++i)
    {
        memcpy(
            (void*)(a2 + 4 * *(unsigned __int8*)(*(_DWORD*)(thisx + 16) + i)),
            (const void*)(*(_DWORD*)(thisx + 20) + 4 * i),
            4u);
        result = i + 1;
    }
    return result;
}
 
int sub_485E5A(int thisx, unsigned __int16* a2)
{
    int result; // eax
    int i; // [esp+4h] [ebp-8h]

    for (i = 0; i < *(unsigned __int16*)(thisx + 12); ++i)
    {
        sub_4A0B26(
            a2,
            *(_BYTE*)(*(_DWORD*)(thisx + 16) + i),
            *(_BYTE*)(*(_DWORD*)(thisx + 20) + 4 * i + 2),
            *(_BYTE*)(*(_DWORD*)(thisx + 20) + 4 * i + 1),
            *(_BYTE*)(*(_DWORD*)(thisx + 20) + 4 * i));
        result = i + 1;
    }
    return result;
}
 
int __cdecl sub_485ED0(int a1, int a2, char* Source, int a4)
{
    CHAR Text[256]; // [esp+0h] [ebp-134h] BYREF
    int j; // [esp+100h] [ebp-34h]
    int v7; // [esp+104h] [ebp-30h]
    CHAR String1[32]; // [esp+108h] [ebp-2Ch] BYREF
    int i; // [esp+128h] [ebp-Ch]
    int v10; // [esp+12Ch] [ebp-8h]
    int v11; // [esp+130h] [ebp-4h]

    strcpy(String1, Source);
    v11 = strlen(Source);
    v10 = 0;
    v7 = 1;
    for (i = v11 - 2; i >= 0; --i)
    {
        if (Source[i] == 43 || Source[i] == 45)
        {
            for (j = i + 1; j < v11; ++j)
            {
                v10 += v7 * (Source[j] - 48);
                v7 /= 10;
            }
            if (Source[i] == 45)
                v10 = -v10;
            String1[i] = 0;
            break;
        }
        v7 *= 10;
    }
    if (a4 >= 0 && !lstrcmpiA(String1, aThis))
        return v10 + a4;
    for (i = 0; i < a2; ++i)
    {
        if (!lstrcmpiA((LPCSTR)(20 * i + a1), String1))
            return v10 + *(_DWORD*)(a1 + 20 * i + 16);
    }
    if (byte_4B91D9)
    {
        wsprintfA(Text, aS_11, String1);
        MessageBoxA(0, Text, byte_4B6DD4, 0);
    }
    return -1;
}
 
_DWORD* sub_486060(_DWORD* thisx)
{
    sub_4814A3(thisx + 1);
    eh_vector_constructor_iterator(thisx + 128, 0x20u, 3, sub_401390, sub_4013E8);
        * thisx = off_4AC364;
    thisx[77] = 0;
    thisx[82] = 0;
    thisx[84] = 0;
    thisx[83] = 0;
    thisx[88] = 0;
    thisx[87] = 0;
    return thisx;
}

 
int sub_486119(_DWORD* thisx)
{
    *thisx = off_4AC364;
    sub_4869CF((_DWORD)thisx);
    eh_vector_destructor_iterator(thisx + 128, 0x20u, 3, sub_4013E8);
        return sub_4814F6(thisx + 1);
}
 
int sub_486189(int thisx, int a2, char* Source)
{
    int v4; // esi
    HANDLE hObject; // [esp+8h] [ebp-144h]
    int v7[15]; // [esp+Ch] [ebp-140h] BYREF
    CHAR FileName[260]; // [esp+48h] [ebp-104h] BYREF

    *(_WORD*)(thisx + 300) = a2;
    *(_DWORD*)(thisx + 340) = 100;
    *(_DWORD*)(thisx + 344) = 0;
    if (Source)
        strcpy((char*)(thisx + 40), Source);
    else
        wsprintfA((LPSTR)(thisx + 40), "Stage%02d.wav", a2);
    wsprintfA(FileName, "Stage\\Stage%02d.bmp", a2);
    sub_49DB90(v7);
    v7[1] = 0;
    v7[2] = 0;
    v7[3] = -1;
    v7[4] = -1;
    v7[5] = 1;
    v7[9] = -1;
    if (sub_49DA45((_DWORD*)unk_4BDC60, FileName, (int)v7))
    {
        *(_DWORD*)(thisx + 32) = v7[0];
        wsprintfA(FileName, "Stage\\Stage%02d.dat", a2);
        hObject = CreateFileA(FileName, 0x80000000, 0, 0, 3u, 0x80u, 0);
        if (hObject == (HANDLE)-1)
        {
            return 0;
        }
        else if (sub_481B9F(thisx + 4, hObject))
        {
            CloseHandle(hObject);
            *(_DWORD*)(thisx + 312) = 4 * (unsigned __int8)unknown_libname_25((_BYTE*)(thisx + 4));
            *(_DWORD*)(thisx + 316) = 4 * (unsigned __int8)sub_4261F0((char*)thisx + 4);
            *(_DWORD*)(thisx + 320) = 9 * (8 * (unsigned __int8)sub_4261F0((char*)thisx + 4) / 10);
            *(_DWORD*)(thisx + 324) = 3 * (8 * (unsigned __int8)sub_4261F0((char*)thisx + 4) / 10);
            sub_4869CF(thisx);
            wsprintfA(FileName, "Stage\\Stage%02d_Obj.txt", a2);
            sub_486B0E(thisx, FileName);
            *(_DWORD*)(thisx + 28) = *(_DWORD*)(thisx + 312) - 160;
            v4 = 176 - 8 * (unsigned __int8)sub_4261F0((char*)thisx + 4);
            *(_DWORD*)(thisx + 36) = v4 + 4 * (char)sub_489D40((char*)thisx + 4);
            sub_489C36((const CHAR*)thisx);
            return 1;
        }
        else
        {
            CloseHandle(hObject);
            return 0;
        }
    }
    else
    {
        MessageBoxA(hWnd, byte_4B6E10, aError_39, 0);
        return 0;
    }
}
 
_DWORD* sub_486476(_DWORD* thisx)
{
    _DWORD* result; // eax
    int i; // [esp+4h] [ebp-3Ch]
    int v4[14]; // [esp+8h] [ebp-38h] BYREF

    sub_49C15E((int)v4);
    v4[1] = -thisx[7];
    v4[2] = 0;
    v4[0] = thisx[8];
    sub_49AB05((int)unk_4BDC60, v4);
    for (i = 0; ; ++i)
    {
        result = thisx;
        if (i >= thisx[77])
            break;
        if (unknown_libname_6((_BYTE*)(432 * i + thisx[82])) != 2)
            sub_48D421(432 * i + thisx[82], thisx[76]);
    }
    return result;
}

 
void sub_48651C(_DWORD* thisx, _DWORD* a2, _DWORD* a3)
{
    int v3; // eax
    int v4; // [esp-Ch] [ebp-10h]
    int v5; // [esp-8h] [ebp-Ch]

    if (a2)
    {
        if (a3)
        {
            v5 = sub_4260D0(a2);
            v4 = sub_4260B0(a2);
            v3 = sub_426090(a2);
            sub_48977D(thisx, v3, v4, v5, a3);
        }
    }
}

 
void sub_48655E(int thisx, _DWORD* a2, _DWORD* a3)
{
    int v4; // [esp+4h] [ebp-8h]
    int v5; // [esp+8h] [ebp-4h]

    if (a3 && a2)
    {
        v5 = *(_DWORD*)(thisx + 28) + *a2;
        v4 = a2[1] - *(_DWORD*)(thisx + 36);
        if (v5 >= 0)
        {
            if (v5 >= 8 * (unsigned __int8)unknown_libname_25((char*)thisx + 4))
                v5 = 8 * (unsigned __int8)unknown_libname_25((char*)thisx + 4) - 1;
        }
        else
        {
            v5 = 0;
        }
        if (v4 >= 0)
        {
            if (v4 >= 8 * (unsigned __int8)sub_4261F0((_BYTE*)(thisx + 4)))
                v4 = 8 * (unsigned __int8)sub_4261F0((_BYTE*)(thisx + 4)) - 1;
        }
        else
        {
            v4 = 0;
        }
        sub_41C432(a3, 100 * v5, 100 * v4);
    }
}
 
int sub_486633(_DWORD* thisx, int a2, int a3)
{
    _BYTE* v4; // eax
    char v5; // al
    int v7; // [esp+Ch] [ebp-24h]
    int v8; // [esp+10h] [ebp-20h]
    int v9; // [esp+14h] [ebp-1Ch]
    int v10; // [esp+18h] [ebp-18h]
    _BYTE* v11; // [esp+1Ch] [ebp-14h]
    unsigned __int8 v12; // [esp+20h] [ebp-10h]
    unsigned __int8 v13; // [esp+28h] [ebp-8h]

    if (!unknown_libname_24(thisx + 1))
        return 0;
    v10 = a2 / 8;
    v9 = a3 / 8;
    if (a2 < 0)
        --v10;
    if (a3 < 0)
        --v9;
    v11 = (_BYTE*)sub_4816F5((int)(thisx + 1), v10, v9);
    if (v11)
    {
        v13 = unknown_libname_6(v11);
        if (unknown_libname_5(v11) == 7 && v13 == 255)
        {
            return -1020;
        }
        else
        {
            v5 = sub_425FD0(v11);
            v12 = 1;
            if (v5 == 3 || v5 == 4)
            {
                v12 = 2;
            }
            else if (v5 == 5 || v5 == 6)
            {
                v12 = 4;
            }
            if (v5)
            {
                if ((v5 & 1) == 1)
                {
                    return v12 * (a2 % 8) / 2 + 4 * v13;
                }
                else if ((v5 & 1) != 0)
                {
                    return 4 * (unsigned __int8)unknown_libname_6(v11);
                }
                else
                {
                    return v12 * (8 - a2 % 8) / 2 + 4 * v13;
                }
            }
            else
            {
                return 4 * v13;
            }
        }
    }
    else
    {
        v8 = (unsigned __int8)unknown_libname_25((_BYTE*)thisx + 1);
        v7 = (unsigned __int8)sub_4261F0((_BYTE*)thisx + 4);
        if (v10 >= 0)
        {
            if (v10 >= v8)
                LOBYTE(v10) = v8 - 1;
        }
        else
        {
            LOBYTE(v10) = 0;
        }
        if (v9 >= 0)
        {
            if (v9 >= v7)
                LOBYTE(v9) = v7 - 1;
            v4 = (_BYTE*)sub_4816F5((int)(thisx + 1), v10, v9);
        }
        else
        {
            v4 = (_BYTE*)sub_4816F5((int)(thisx + 1), v10, 0);
        }
        if (v4 && unknown_libname_5(v4) == 7)
            return -1020;
        else
            return 1020;
    }
}
 
char sub_4868C1(void* thisx, unsigned __int8 a2, unsigned __int8 a3)
{
    _BYTE* v4; // [esp+4h] [ebp-4h]

    v4 = (_BYTE*)sub_4816F5((int)thisx + 4, a2, a3);
    if (v4)
        return sub_425FD0(v4);
    else
        return 0;
}
 
char sub_4868F8(_DWORD* thisx, unsigned __int8 a2, unsigned __int8 a3)
{
    _BYTE* v5; // [esp+4h] [ebp-4h]

    if (!unknown_libname_24(thisx + 1))
        return 0;
    v5 = (_BYTE*)sub_4816F5((int)(thisx + 1), a2, a3);
    if (v5)
        return unknown_libname_5(v5);
    else
        return -1;
}
 
void sub_486947(_DWORD* thisx, int a2, int a3)
{
    if (a3)
    {
        if (a2 > 160)
        {
            if (a2 + 160 < 8 * (unsigned __int8)unknown_libname_25((char*)thisx + 1))
                thisx[7] = a2 - 160;
            else
                thisx[7] = 8 * (unsigned __int8)unknown_libname_25((char*)thisx + 1) - 320;
        }
        else
        {
            thisx[7] = 0;
        }
    }
    else
    {
        thisx[7] = a2 - 160;
    }
}
 
int(***  sub_4869CF(int thisx))(_DWORD, int)
{
    int( * **result)(_DWORD, int); // eax
    char* v3; // [esp+1Ch] [ebp-10h]

    if (*(_DWORD*)(thisx + 328))
        (***(void(****)(_DWORD, int))(thisx + 328))(*(_DWORD*)(thisx + 328), 3);
    *(_DWORD*)(thisx + 328) = 0;
    *(_DWORD*)(thisx + 308) = 0;
    if (dword_4CA1D8)
        operator delete((void*)dword_4CA1D8);
    dword_4CA1D8 = 0;
    dword_4CA1D4 = 0;
    if (*(_DWORD*)(thisx + 332))
    {
        v3 = *(char**)(thisx + 332);
        if (v3)
            sub_489D60(v3, 3);
    }
    *(_DWORD*)(thisx + 332) = 0;
    result = (int(***)(_DWORD, int))thisx;
    *(_DWORD*)(thisx + 336) = 0;
    if (*(_DWORD*)(thisx + 348))
    {
        result = *(int(****)(_DWORD, int))(thisx + 348);
        if (result)
            result = (int(***)(_DWORD, int))(**result)((int)result, 3);
    }
    *(_DWORD*)(thisx + 348) = 0;
    *(_DWORD*)(thisx + 352) = 0;
    return result;
} 
int sub_486B0E(int thisx, LPCSTR lpFileName)
{
    void* v2; // esp
    unsigned __int16 Group; // ax
    char v5; // al
    _DWORD* v6; // [esp+Ch] [ebp-2790h]
    int v7; // [esp+10h] [ebp-278Ch]
    _DWORD* v8; // [esp+14h] [ebp-2788h]
    _DWORD* v9; // [esp+18h] [ebp-2784h]
    _DWORD* v11; // [esp+34h] [ebp-2768h]
    _DWORD* v12; // [esp+3Ch] [ebp-2760h]
    _DWORD* v13; // [esp+48h] [ebp-2754h]
    _DWORD* Block; // [esp+54h] [ebp-2748h]
    int v15; // [esp+60h] [ebp-273Ch]
    int v16; // [esp+64h] [ebp-2738h]
    int v17; // [esp+68h] [ebp-2734h]
    int i2; // [esp+6Ch] [ebp-2730h]
    char v19; // [esp+70h] [ebp-272Ch]
    char v20; // [esp+74h] [ebp-2728h]
    int i3; // [esp+78h] [ebp-2724h]
    char v22; // [esp+7Ch] [ebp-2720h]
    char v23; // [esp+80h] [ebp-271Ch]
    char v24; // [esp+84h] [ebp-2718h]
    int v25; // [esp+8Ch] [ebp-2710h]
    int v26; // [esp+90h] [ebp-270Ch]
    int v27; // [esp+94h] [ebp-2708h]
    char v28; // [esp+98h] [ebp-2704h]
    int v29; // [esp+9Ch] [ebp-2700h]
    int v30; // [esp+A0h] [ebp-26FCh]
    int v31; // [esp+A4h] [ebp-26F8h]
    int v32; // [esp+A8h] [ebp-26F4h]
    int nn; // [esp+ACh] [ebp-26F0h]
    char v34; // [esp+B0h] [ebp-26ECh]
    int v35; // [esp+B4h] [ebp-26E8h]
    int mm; // [esp+B8h] [ebp-26E4h]
    int v37; // [esp+BCh] [ebp-26E0h]
    __int16 v38; // [esp+C4h] [ebp-26D8h]
    __int16 v39; // [esp+C4h] [ebp-26D8h]
    __int16 v40; // [esp+C4h] [ebp-26D8h]
    _WORD* v41; // [esp+CCh] [ebp-26D0h]
    unsigned __int8 v42; // [esp+D0h] [ebp-26CCh]
    int v43; // [esp+D4h] [ebp-26C8h]
    struct Concurrency::details::SchedulingNode* v44; // [esp+D8h] [ebp-26C4h]
    int v45; // [esp+DCh] [ebp-26C0h]
    int jj; // [esp+E0h] [ebp-26BCh]
    int v47; // [esp+E4h] [ebp-26B8h]
    int v48; // [esp+E8h] [ebp-26B4h]
    int ii; // [esp+ECh] [ebp-26B0h]
    int v50; // [esp+F0h] [ebp-26ACh]
    int i; // [esp+F8h] [ebp-26A4h]
    int v52; // [esp+104h] [ebp-2698h]
    int v53; // [esp+108h] [ebp-2694h]
    int j; // [esp+10Ch] [ebp-2690h]
    _BYTE* v55; // [esp+110h] [ebp-268Ch]
    CHAR v56[260]; // [esp+114h] [ebp-2688h] BYREF
    int k; // [esp+218h] [ebp-2584h]
    char v58; // [esp+21Ch] [ebp-2580h]
    char v59; // [esp+220h] [ebp-257Ch]
    CHAR v60[260]; // [esp+224h] [ebp-2578h] BYREF
    int v61[15]; // [esp+328h] [ebp-2474h] BYREF
    char v62[1024]; // [esp+364h] [ebp-2438h] BYREF
    void* v63; // [esp+764h] [ebp-2038h]
    void* v64[339]; // [esp+768h] [ebp-2034h] BYREF
    _DWORD* v65; // [esp+CB4h] [ebp-1AE8h]
    int v66[15]; // [esp+CB8h] [ebp-1AE4h] BYREF
    CHAR v67[260]; // [esp+CF4h] [ebp-1AA8h] BYREF
    CHAR FileName[260]; // [esp+DF8h] [ebp-19A4h] BYREF
    CHAR v69[260]; // [esp+EFCh] [ebp-18A0h] BYREF
    int m; // [esp+1000h] [ebp-179Ch]
    char v71; // [esp+1004h] [ebp-1798h]
    char v72; // [esp+1008h] [ebp-1794h]
    char v73; // [esp+100Ch] [ebp-1790h]
    CHAR String2[260]; // [esp+1010h] [ebp-178Ch] BYREF
    int v75; // [esp+1114h] [ebp-1688h]
    int v76; // [esp+1118h] [ebp-1684h]
    int n; // [esp+111Ch] [ebp-1680h]
    int v78[15]; // [esp+1120h] [ebp-167Ch] BYREF
    int v79; // [esp+115Ch] [ebp-1640h]
    int v80[4]; // [esp+1160h] [ebp-163Ch] BYREF
    int v81; // [esp+1170h] [ebp-162Ch] BYREF
    int v82[1280]; // [esp+1174h] [ebp-1628h] BYREF
    int kk; // [esp+2574h] [ebp-228h]
    int v84; // [esp+2578h] [ebp-224h]
    int i1; // [esp+257Ch] [ebp-220h]
    CHAR v86[260]; // [esp+2580h] [ebp-21Ch] BYREF
    CHAR String1; // [esp+2684h] [ebp-118h] BYREF
    char String[255]; // [esp+2685h] [ebp-117h] BYREF
    int v89; // [esp+2784h] [ebp-18h]
    int v90; // [esp+2788h] [ebp-14h]
    int v91; // [esp+278Ch] [ebp-10h]
    int v92; // [esp+2798h] [ebp-4h]

    v2 = alloca(10128);
    sub_482BF0(v80);
    v92 = 0;
    if (!sub_482C74((int)v80, lpFileName))
    {
        sub_455541((int)unk_4B9B10, 0);
        v92 = -1;
        sub_482C2F(v80);
        return 0;
    }
    String1 = 0;
    LOBYTE(v89) = 0;
    *(_DWORD*)(thisx + 304) = -1;
    while (sub_482D44(v80, &String1))
    {
        if (lstrcmpiA(&String1, aInit))
        {
            if (!lstrcmpiA(&String1, aInitend))
                break;
            if ((unsigned __int8)v89 == 1)
            {
                if (lstrcmpiA(&String1, aLoadbmp))
                {
                    if (lstrcmpiA(&String1, aEntrypat))
                    {
                        if (lstrcmpiA(&String1, aLoadchargraphi))
                        {
                            if (lstrcmpiA(&String1, aLoadcgtp))
                            {
                                if (lstrcmpiA(&String1, aStartpos))
                                {
                                    if (lstrcmpiA(&String1, aStartline))
                                    {
                                        if (lstrcmpiA(&String1, aLoadbackbmp))
                                        {
                                            if (lstrcmpiA(&String1, aNextdemofilena))
                                            {
                                                if (lstrcmpiA(&String1, aCopypalettes))
                                                {
                                                    if (!lstrcmpiA(&String1, aBgmfilename))
                                                        sub_482D44(v80, (LPSTR)(thisx + 40));
                                                }
                                                else
                                                {
                                                    v53 = 0;
                                                    v52 = 0;
                                                    for (i = 0; i < 5 && sub_482D44(v80, &String1) && lstrcmpiA(&String1, aN_3); ++i)
                                                    {
                                                        switch (i)
                                                        {
                                                        case 0:
                                                            v53 = sub_48307F(&String1);
                                                            break;
                                                        case 1:
                                                            v52 = sub_48307F(&String1);
                                                            break;
                                                        case 2:
                                                        case 3:
                                                        case 4:
                                                            sub_48307F(&String1);
                                                            break;
                                                        default:
                                                            continue;
                                                        }
                                                    }
                                                    if (i >= 2)
                                                    {
                                                        Group = GetGroup((Concurrency::details::HardwareAffinity*)(8 * v53 + 4952720));
                                                        sub_4A0A7B(8 * v52 + 4952720, Group);
                                                        sub_4A1307(8 * v52 + 4952720, (Concurrency::details::HardwareAffinity*)(8 * v53 + 4952720));
                                                    }
                                                }
                                            }
                                            else if (sub_482D44(v80, &String1))
                                            {
                                                sub_474011((char*)unk_4B9B10, &String1);
                                            }
                                        }
                                        else if (sub_482D44(v80, &String1))
                                        {
                                            sub_48941E((_DWORD*)thisx, &String1);
                                        }
                                    }
                                    else
                                    {
                                        for (j = 0; j != 3; ++j)
                                        {
                                            if (!sub_482D44(v80, &String1))
                                                break;
                                            if (String1 == 110)
                                                break;
                                            *(_DWORD*)(thisx + 4 * j + 316) = atoi(&String1);
                                        }
                                    }
                                }
                                else
                                {
                                    sub_482D44(v80, &String1);
                                    *(_DWORD*)(thisx + 312) = atoi(&String1);
                                }
                            }
                            else
                            {
                                v58 = 0;
                                v59 = 0;
                                for (k = 0; k < 4 && sub_482D44(v80, &String1) && lstrcmpiA(&String1, aN_2); ++k)
                                {
                                    switch (k)
                                    {
                                    case 0:
                                        v58 = sub_48307F(&String1);
                                        break;
                                    case 1:
                                        lstrcpyA(v56, &String1);
                                        break;
                                    case 2:
                                        lstrcpyA(v60, &String1);
                                        break;
                                    case 3:
                                        v59 = sub_48307F(&String1);
                                        break;
                                    default:
                                        continue;
                                    }
                                }
                                if (k >= 3)
                                {
                                    if (v58 < 0 || v58 >= 3)
                                        v58 = 0;
                                    v55 = (_BYTE*)(thisx + 32 * v58 + 512);
                                    sub_4014A3(v55, v60, v56);
                                    if (k >= 4)
                                        sub_489E30(v55, v59);
                                }
                            }
                        }
                        else
                        {
                            v71 = 0;
                            v72 = -1;
                            v73 = 0;
                            for (m = 0; m < 7 && sub_482D44(v80, &String1) && lstrcmpiA(&String1, aN_1); ++m)
                            {
                                switch (m)
                                {
                                case 0:
                                    v71 = sub_48307F(&String1);
                                    break;
                                case 1:
                                    lstrcpyA(FileName, &String1);
                                    break;
                                case 2:
                                    lstrcpyA(v69, &String1);
                                    break;
                                case 3:
                                    lstrcpyA(String2, &String1);
                                    break;
                                case 4:
                                    v73 = sub_48307F(&String1);
                                    break;
                                case 5:
                                    v72 = sub_48307F(&String1);
                                    break;
                                case 6:
                                    lstrcpyA(v67, &String1);
                                    break;
                                default:
                                    continue;
                                }
                            }
                            if (m >= 3)
                            {
                                if (v71 < 0 || v71 >= 3)
                                    v71 = 0;
                                v65 = (_DWORD*)(thisx + 32 * v71 + 512);
                                sub_49DB90(v66);
                                if (v72 >= 0)
                                {
                                    v63 = (void*)(8 * v72 + 4952720);
                                    v66[14] = (int)v63;
                                    sub_4A1450((_DWORD*)v64);
                                    LOBYTE(v92) = 1;
                                    if (sub_4A14C0((short*)v64, FileName))
                                    {
                                        sub_4A1AA5((int)v64, v62);
                                        sub_4A0AE7(v63, (int)v62, 256);
                                    }
                                    LOBYTE(v92) = 0;
                                    sub_4A148B(v64);
                                }
                                sub_401531(v65, FileName, (int)v66);
                                sub_4014A3(v65, String2, v69);
                                if (m >= 5)
                                    sub_489E30((char*)v65, v73);
                                if (m >= 7)
                                {
                                    sub_49DB90(v61);
                                    sub_401568(v65, v67, (int)v61);
                                }
                            }
                        }
                    }
                    else
                    {
                        sub_49DB90(v78);
                        v78[0] = -1;
                        for (n = 0; n < 6 && sub_482D44(v80, &String1) && lstrcmpiA(&String1, aN_0); ++n)
                        {
                            v76 = atoi(&String1);
                            switch (n)
                            {
                            case 0:
                                v78[1] = v76;
                                break;
                            case 1:
                                v78[2] = v76;
                                break;
                            case 2:
                                v78[3] = v76;
                                break;
                            case 3:
                                v78[4] = v76;
                                break;
                            case 4:
                                v78[9] = v76;
                                break;
                            case 5:
                                v78[5] = v76;
                                break;
                            default:
                                continue;
                            }
                        }
                        if (n == 6)
                        {
                            v75 = sub_49D318((int)unk_4BDC60, (int)v78);//±¨´í
                            if (v75 > 0 && *(_DWORD*)(thisx + 304) == -1)
                                *(_DWORD*)(thisx + 304) = v78[0];
                        }
                    }
                }
                else if (sub_482D44(v80, &String1))
                {
                    wsprintfA(v86, "%s", &String1);
                    sub_49B9E0((_DWORD*)unk_4BDC60, v86);
                }
                if (String1 != 110 || String[0])
                    sub_482D44(v80, &String1);
            }
        }
        else
        {
            LOBYTE(v89) = 1;
            sub_482FAA(v80);
        }
    }
    sub_48314A(v80);
    LOBYTE(v89) = 0;
    *(_DWORD*)(thisx + 336) = 0;
    while (sub_482D44(v80, &String1))
    {
        if (lstrcmpiA(&String1, aString))
        {
            if (!lstrcmpiA(&String1, aStringend))
                break;
            if ((unsigned __int8)v89 == 1)
            {
                ++* (_DWORD*)(thisx + 336);
                sub_482FAA(v80);
            }
            else if (!(_BYTE)v89)
            {
                sub_482FAA(v80);
            }
        }
        else
        {
            LOBYTE(v89) = 1;
            sub_482FAA(v80);
        }
    }
    if (*(int*)(thisx + 336) > 0)
    {
        v50 = *(_DWORD*)(thisx + 336);
        Block = (_DWORD*)operator new(8 * v50 + 4);
        LOBYTE(v92) = 2;
        if (Block)
        {
            *Block = v50;
            eh_vector_constructor_iterator(
                Block + 1,
                8u,
                v50,
                (void(*)(void*)) new_DNameNode, //(void(*)(void*))DNameNode::DNameNode,
                sub_4892EE);
                v9 = Block + 1;
        }
        else
        {
            v9 = 0;
        }
        LOBYTE(v92) = 0;
        *(_DWORD*)(thisx + 332) = (_DWORD)v9;
        if (!*(_DWORD*)(thisx + 332))
            goto LABEL_127;
        sub_48314A(v80);
        while (sub_482D44(v80, &String1))
        {
            if (!lstrcmpiA(&String1, aString_0))
            {
                sub_482FAA(v80);
                break;
            }
            sub_482FAA(v80);
        }
        for (ii = 0; ii < *(_DWORD*)(thisx + 336); ++ii)
        {
            if (!sub_482D44(v80, &String1))
                break;
            v48 = atoi(&String1);
            if (!sub_482D44(v80, &String1))
                break;
            sub_48933F(*(_DWORD*)(thisx + 332) + 8 * ii, v48, &String1);
            sub_482FAA(v80);
        }
    }
    sub_48314A(v80);
    LOBYTE(v89) = 0;
    *(_DWORD*)(thisx + 352) = 0;
    while (sub_482D44(v80, &String1))
    {
        if (lstrcmpiA(&String1, aSound))
        {
            if (!lstrcmpiA(&String1, aSoundend))
                break;
            if ((unsigned __int8)v89 == 1)
            {
                ++* (_DWORD*)(thisx + 352);
                sub_482FAA(v80);
            }
            else if (!(_BYTE)v89)
            {
                sub_482FAA(v80);
            }
        }
        else
        {
            LOBYTE(v89) = 1;
            sub_482FAA(v80);
        }
    }
    if (*(int*)(thisx + 352) > 0)
    {
        v47 = *(_DWORD*)(thisx + 352);
        v13 = (_DWORD*)operator new(12 * v47 + 4);
        LOBYTE(v92) = 3;
        if (v13)
        {
            *v13 = v47;
            eh_vector_constructor_iterator(v13 + 1, 0xCu, v47, sub_48E1B0, sub_48E1C7);
                v8 = v13 + 1;
        }
        else
        {
            v8 = 0;
        }
        LOBYTE(v92) = 0;
        *(_DWORD*)(thisx + 348) = (_DWORD)v8;
        if (!*(_DWORD*)(thisx + 348))
        {
        LABEL_127:
            v92 = -1;
            sub_482C2F(v80);
            return 0;
        }
        sub_48314A(v80);
        while (sub_482D44(v80, &String1))
        {
            if (!lstrcmpiA(&String1, aSound_0))
            {
                sub_482FAA(v80);
                break;
            }
            sub_482FAA(v80);
        }
        for (jj = 0; jj < *(_DWORD*)(thisx + 352); ++jj)
        {
            if (!sub_482D44(v80, &String1))
                break;
            v44 = (struct Concurrency::details::SchedulingNode*)atoi(&String1);
            if (!sub_482D44(v80, &String1))
                break;
            v45 = sub_43FC18((_DWORD*)unk_4BDB28, &String1);
            Concurrency::details::SchedulingRing::SetOwningNode(
                (Concurrency::details::SchedulingRing*)(*(_DWORD*)(thisx + 348) + 12 * jj),
                v44);
            streambuf::unbuffered((streambuf*)(12 * jj + *(_DWORD*)(thisx + 348)), v45);
            sub_482FAA(v80);
        }
    }
    sub_48314A(v80);
    sub_402080((int)v82, 20, 256, (void(*)(int))sub_48A44E);
    v81 = 0;
    v90 = sub_489927((void*)thisx, (int)v80, (int)v82, 256, &v81);
    sub_48314A(v80);
    dword_4CA1D4 = v90;
    if (v90 > 0)
    {
        v43 = dword_4CA1D4;
        v12 = (_DWORD*)operator new(50 * dword_4CA1D4);
        LOBYTE(v92) = 4;
        if (v12)
        {
            sub_402080((int)v12, 50, v43, (void(*)(int))sub_48A54F);
            v7 = (int)v12;
        }
        else
        {
            v7 = 0;
        }
        LOBYTE(v92) = 0;
        dword_4CA1D8 = v7;
    }
    for (kk = 0; kk < dword_4CA1D4; ++kk)
        sub_48A596((char*)(50 * kk + dword_4CA1D8));
    if (dword_4CA1D8)
    {
        LOBYTE(v89) = 0;
        v90 = 0;
        while (sub_482D44(v80, &String1))
        {
            if (lstrcmpiA(&String1, aMove))
            {
                if (!lstrcmpiA(&String1, aMoveend))
                    break;
                if ((unsigned __int8)v89 == 1)
                {
                    while (String1 == 42)
                    {
                        sub_482D44(v80, &String1);
                        while (String1 == 110)
                        {
                            sub_482D44(v80, &String1);
                            ++v90;
                        }
                    }
                    v41 = (_WORD*)(50 * v90 + dword_4CA1D8);
                    *(_BYTE*)v41 = atoi(&String1);
                    v42 = 0;
                    while (sub_482D44(v80, &String1) && String1 != 110)
                    {
                        if (String1 == 42)
                        {
                            v38 = sub_485ED0((int)v82, 256, &String1, v90);
                            sub_48A49F(v41, v42, v38, 0);
                        }
                        else if (String1 == 118)
                        {
                            v39 = atoi(String);
                            sub_48A49F(v41, v42, v39, 1);
                        }
                        else
                        {
                            v40 = atoi(&String1);
                            sub_48A49F(v41, v42, v40, 0);
                        }
                        ++v42;
                    }
                    ++v90;
                }
                else if (!(_BYTE)v89)
                {
                    sub_482FAA(v80);
                }
            }
            else
            {
                LOBYTE(v89) = 1;
                sub_482FAA(v80);
            }
        }
    }
    sub_48314A(v80);
    v79 = 0;
    v91 = 0;
    LOBYTE(v89) = 0;
    while (sub_482D44(v80, &String1))
    {
        if (lstrcmpiA(&String1, aPut))
        {
            if (!lstrcmpiA(&String1, aPutend))
                break;
            if ((unsigned __int8)v89 == 1)
            {
                ++v79;
                if (atoi(&String1) == 2)
                    ++v91;
                sub_482FAA(v80);
            }
            else if (!(_BYTE)v89)
            {
                sub_482FAA(v80);
            }
        }
        else
        {
            LOBYTE(v89) = 1;
            sub_482FAA(v80);
        }
    }
    if (v79 > 0)
    {
        v37 = v79;
        v11 = (_DWORD*)operator new(432 * v79 + 4);
        LOBYTE(v92) = 5;
        if (v11)
        {
            *v11 = v37;
            eh_vector_constructor_iterator(v11 + 1, 0x1B0u, v37, sub_48A3F0, sub_48A43A);
                v6 = v11 + 1;
        }
        else
        {
            v6 = 0;
        }
        LOBYTE(v92) = 0;
        *(_DWORD*)(thisx + 328) = (_DWORD)v6;
        *(_DWORD*)(thisx + 308) = v79;
    }
    sub_455541((int)unk_4B9B10, v91);
    sub_48314A(v80);
    LOBYTE(v89) = 0;
    v84 = 0;
    if (*(_DWORD*)(thisx + 328))
    {
        while (sub_482D44(v80, &String1))
        {
            if (!lstrcmpiA(&String1, aPut_0))
            {
                LOBYTE(v89) = 1;
                sub_482FAA(v80);
                break;
            }
            if (!lstrcmpiA(&String1, aPutend_0))
                break;
            if (!(_BYTE)v89)
                sub_482FAA(v80);
        }
        if ((unsigned __int8)v89 == 1)
        {
            for (mm = 0; mm < v79; ++mm)
            {
                v31 = 0;
                v29 = 0;
                v32 = 0;
                v35 = 0;
                v26 = 0;
                v30 = 0;
                v27 = 0;
                v34 = -1;
                for (nn = 0; nn < 9 && sub_482D44(v80, &String1) && String1 != 110; ++nn)
                {
                    if (String1 == 42)
                        v25 = sub_485ED0((int)v82, 256, &String1, -1);
                    else
                        v25 = atoi(&String1);
                    switch (nn)
                    {
                    case 0:
                        v28 = v25;
                        break;
                    case 1:
                        v31 = v25;
                        break;
                    case 2:
                        v29 = v25;
                        break;
                    case 3:
                        v32 = v25;
                        break;
                    case 4:
                        v35 = v25;
                        break;
                    case 5:
                        v26 = v25;
                        break;
                    case 6:
                        v30 = v25;
                        break;
                    case 7:
                        v27 = v25;
                        break;
                    case 8:
                        v34 = v25;
                        break;
                    default:
                        continue;
                    }
                }
                sub_48A5DA(432 * mm + *(_DWORD*)(thisx + 328), v28, v31, v29, v32, v35, v26, v30, v27, v34);
                if (v28 == 2)
                    sub_455722((int)unk_4B9B10, v84++, mm);
                sub_48A700(432 * mm + *(_DWORD*)(thisx + 328));
                sub_482FAA(v80);
            }
        }
    }
    sub_48314A(v80);
    LOBYTE(v89) = 0;
    for (i1 = 0; i1 < 8; ++i1)
    {
        sub_488E57((char*)thisx + 3 * i1 + 358);
        sub_488E76((int*)thisx + 16 * i1 + 384);
    }
    *(_BYTE*)(thisx + 356) = 0;
    *(_BYTE*)(thisx + 357) = 0;
    int size = 0;
    while (sub_482D44(v80, &String1))
    {
        size++;
        if (lstrcmpiA(&String1, aEtcdata))
        {
            if (!lstrcmpiA(&String1, aEtcdataend))
                break;
            if ((_BYTE)v89)
            {
                if ((unsigned __int8)v89 == 1)
                {
                    v5 = atoi(&String1);
                    if (v5)
                    {
                        if (v5 == 1)
                        {
                            v16 = 0;
                            v15 = 0;
                            v17 = 0;
                            v20 = 0;
                            v19 = 0;
                            for (i2 = 0; i2 < 5 && sub_482D44(v80, &String1) && String1 != 110; ++i2)
                            {
                                switch (i2)
                                {
                                case 0:
                                    v16 = atoi(&String1);
                                    break;
                                case 1:
                                    v15 = atoi(&String1);
                                    break;
                                case 2:
                                    v17 = atoi(&String1);
                                    break;
                                case 3:
                                    v20 = atoi(&String1);
                                    break;
                                case 4:
                                    v19 = atoi(&String1);
                                    break;
                                default:
                                    continue;
                                }
                            }
                            if (*(unsigned __int8*)(thisx + 357) < 8u)
                            {
                                *(_DWORD*)(thisx + 16 * *(unsigned __int8*)(thisx + 357) + 384) = v16;
                                *(_DWORD*)(thisx + 16 * *(unsigned __int8*)(thisx + 357) + 388) = v15;
                                *(_DWORD*)(thisx + 16 * *(unsigned __int8*)(thisx + 357) + 392) = v17;
                                *(_BYTE*)(thisx + 16 * *(unsigned __int8*)(thisx + 357) + 397) = v20;
                                *(_BYTE*)(thisx + 16 * (unsigned __int8)(*(_BYTE*)(thisx + 357))++ + 396) = v19;
                                if (String1 != 110)
                                    sub_482FAA(v80);
                            }
                        }
                    }
                    else
                    {
                        v24 = 0;
                        v23 = 0;
                        v22 = 0;
                        for (i3 = 0; i3 < 3 && sub_482D44(v80, &String1) && String1 != 110; ++i3)
                        {
                            if (i3)
                            {
                                if (i3 == 1)
                                {
                                    v23 = atoi(&String1);
                                }
                                else if (i3 == 2)
                                {
                                    v22 = atoi(&String1);
                                }
                            }
                            else
                            {
                                v24 = atoi(&String1);
                            }
                        }
                        if (*(unsigned __int8*)(thisx + 356) < 8u)
                        {
                            *(_BYTE*)(thisx + 3 * *(unsigned __int8*)(thisx + 356) + 358) = v24;
                            *(_BYTE*)(thisx + 3 * *(unsigned __int8*)(thisx + 356) + 359) = v23;
                            *(_BYTE*)(thisx + 3 * (unsigned __int8)(*(_BYTE*)(thisx + 356))++ + 360) = v22;
                            if (String1 != 110)
                                sub_482FAA(v80);
                        }
                    }
                }
            }
            else
            {
                sub_482FAA(v80);
            }
        }
        else
        {
            LOBYTE(v89) = 1;
            sub_482FAA(v80);
        }
    }
    v92 = -1;
    sub_482C2F(v80);
    return 1;
} 
_DWORD* sub_488981(_DWORD* thisx)
{
    _DWORD* result; // eax
    int i; // [esp+4h] [ebp-4h]

    result = thisx;
    thisx[86] += thisx[85];
    while ((int)thisx[86] >= 100)
    {
        thisx[86] -= 100;
        for (i = 0; ; ++i)
        {
            result = thisx;
            if (i >= thisx[77])
                break;
            sub_48CD23(432 * i + thisx[82]);
        }
    }
    return result;
}
 
struct tagRECT* sub_488A07(_DWORD* thisx, struct tagRECT* a2, unsigned __int8 a3, unsigned __int8 a4)
{
    int v4; // eax
    unsigned __int8 v7; // [esp+8h] [ebp-2Ch]
    int v8; // [esp+Ch] [ebp-28h]
    int v9; // [esp+Ch] [ebp-28h]
    LONG v10; // [esp+10h] [ebp-24h]
    _WORD* v11; // [esp+14h] [ebp-20h]
    int i; // [esp+18h] [ebp-1Ch]
    __int16 v13; // [esp+1Ch] [ebp-18h]
    __int16 v14; // [esp+1Ch] [ebp-18h]
    int v15; // [esp+20h] [ebp-14h]
    struct tagRECT rc; // [esp+24h] [ebp-10h] BYREF

    SetRect(&rc, 0, 0, 0, 0);
    v10 = a3;
    v15 = 0;
    while (1)
    {
        v11 = (_WORD*)sub_4816F5((int)(thisx + 1), v10, a4);
        if (!v11)
            break;
        v13 = sub_4260F0(v11);
        if (!v13)
            break;
        v8 = sub_489C74(thisx, v13 - 1);
        if (!v8)
            break;
        v15 = 1;
        if ((*(_BYTE*)(v8 + 52) & 0xC) == 4 || !v10)
            break;
        --v10;
    }
    if (v15)
    {
        rc.left = v10;
        rc.top = a4;
        rc.bottom = a4 + 1;
        do
        {
            sub_489F40(v11, 0);
            v11 = (_WORD*)sub_4816F5((int)(thisx + 1), ++v10, a4);
            if (!v11)
                break;
            v14 = sub_4260F0(v11);
            if (!v14)
                break;
            v9 = sub_489C74(thisx, v14 - 1);
            if (!v9)
                break;
        } while ((*(_BYTE*)(v9 + 52) & 8) == 8);
        rc.right = v10;
        for (i = 0; i < thisx[77]; ++i)
        {
            if (unknown_libname_6((_BYTE*)(thisx[82] + 432 * i)) == 1)
            {
                v7 = sub_475F40((_DWORD*)(thisx[82] + 432 * i)) / 8;
                v4 = sub_474DD0((_DWORD*)(thisx[82] + 432 * i));
                if (rc.left - 1 <= v7 && rc.right > v7 && a4 == (unsigned __int8)((v4 - thisx[9]) / 8))
                    sub_489F60((_BYTE*)(thisx[82] + 432 * i), 0);
            }
        }
    }
    *a2 = rc;
    return a2;
} 
HANDLE sub_488CCB(int thisx)
{
    HANDLE result; // eax
    HANDLE hObject; // [esp+4h] [ebp-114h]
    int i; // [esp+8h] [ebp-110h]
    CHAR FileName[260]; // [esp+Ch] [ebp-10Ch] BYREF
    int v6; // [esp+110h] [ebp-8h]
    int v7; // [esp+114h] [ebp-4h]

    v7 = (unsigned __int8)unknown_libname_25((char*)thisx + 4);
    v6 = (unsigned __int8)sub_4261F0((_BYTE*)(thisx + 4));
    for (i = 0; i < *(_DWORD*)(thisx + 308); ++i)
    {
        sub_489F60((_BYTE*)(432 * i + *(_DWORD*)(thisx + 328)), 1);
        sub_48A700(432 * i + *(_DWORD*)(thisx + 328));
    }
    *(_DWORD*)(thisx + 28) = *(_DWORD*)(thisx + 312) - 160;
    wsprintfA(FileName, "Stage\\Stage%02d.dat", *(__int16*)(thisx + 300));
    result = CreateFileA(FileName, 0x80000000, 0, 0, 3u, 0x80u, 0);
    hObject = result;
    if (result != (HANDLE)-1)
    {
        sub_481B9F(thisx + 4, result);
        return (HANDLE)CloseHandle(hObject);
    }
    return result;
}
 
int sub_488E1E(_DWORD* thisx, int a2)
{
    if (a2 >= 0 && a2 < thisx[77])
        return 432 * a2 + thisx[82];
    else
        return 0;
}
 
_BYTE* sub_488E57(_BYTE* thisx)
{
    _BYTE* result; // eax

    result = thisx;
    *thisx = 0;
    thisx[1] = 0;
    thisx[2] = 0;
    return result;
}
 
_DWORD* sub_488E76(_DWORD* thisx)
{
    _DWORD* result; // eax

    *thisx = 0;
    thisx[1] = 0;
    thisx[2] = 0;
    result = thisx;
    *((_BYTE*)thisx + 13) = 0;
    *((_BYTE*)thisx + 12) = 0;
    return result;
}

 
unsigned __int8* sub_488EAC(unsigned __int8* thisx, int a2, int a3)
{
    int v5; // [esp+4h] [ebp-Ch]
    int i; // [esp+8h] [ebp-8h]
    unsigned __int8 v7; // [esp+Ch] [ebp-4h]

    for (i = 0; i < thisx[356]; ++i)
    {
        v5 = thisx[3 * i + 358] - a2;
        if ((!v5 || v5 == -1) && thisx[3 * i + 359] == a3)
            break;
    }
    if (i >= thisx[356])
        return 0;
    v7 = thisx[3 * i + 360];
    if (v7)
    {
        if (v7 > (int)thisx[357])
            return 0;
    }
    else
    {
        v7 = rand() % thisx[357] + 1;
    }
    return &thisx[16 * v7 + 368];
}
 
_UnrealizedChore* sub_488FA2(
    void* thisx,
    unsigned __int8 a2,
    unsigned __int8 a3,
    int a4,
    int a5,
    int a6)
{
    Concurrency::details::_UnrealizedChore* result; // eax
    unsigned __int8 v8; // [esp+4h] [ebp-24h]
    Concurrency::details::_UnrealizedChore* v9; // [esp+8h] [ebp-20h]
    char v10; // [esp+Ch] [ebp-1Ch]
    char v11; // [esp+10h] [ebp-18h]
    char v12; // [esp+14h] [ebp-14h]
    int v13; // [esp+18h] [ebp-10h]
    __int16 v14; // [esp+1Ch] [ebp-Ch]
    __int16 v15; // [esp+24h] [ebp-4h]

    result = (Concurrency::details::_UnrealizedChore*)sub_4816F5((int)thisx + 4, a2, a3);
    v9 = result;
    if (result)
    {
        result = (Concurrency::details::_UnrealizedChore*)sub_482A1B((int)thisx + 4, a2, a3, 1);
        v15 = 0;
        v10 = 50;
        v12 = 100;
        v11 = 0;
        v8 = 1;
        v13 = 0;
        v14 = 0;
        if (a4 >= 0)
        {
            switch (a4)
            {
            case 2:
                LOBYTE(a4) = 0;
                v14 = 1;
                break;
            case 3:
                LOBYTE(a4) = 0;
                v14 = 2;
                break;
            case 4:
                LOBYTE(a4) = 0;
                v14 = 3;
                break;
            case 7:
            case 8:
                v15 = 30 * (a4 == 8) - 30 * (a4 == 7);
                LOBYTE(a4) = 0;
                break;
            case 9:
                LOBYTE(a4) = 0;
                v14 = 4;
                break;
            case 11:
            case 12:
                v15 = 30 * (a4 == 12) - 30 * (a4 == 11);
                v11 = 8;
                v8 = 2;
                v13 = 1;
                LOBYTE(a4) = 11;
                break;
            case 13:
                v10 = 90;
                v12 = 10;
                break;
            case 14:
                LOBYTE(a4) = 0;
                v14 = 5;
                break;
            case 15:
                LOBYTE(a4) = 0;
                v14 = 6;
                break;
            }
            sub_489F80((char*)v9, a4);
            sub_489FE0((short*)v9, v15);
            sub_48A000((short*)v9, 0);
            _SetRuntimeOwnsLifetime(v9, v10);
            _SetDetached(v9, v12);
            sub_48A020((char*)v9, v11);
            sub_482AE0((char*)v9, v8);
            sub_482B1C((char*)v9, v13);
            result = (Concurrency::details::_UnrealizedChore*)sub_489F40((short*)v9, v14);
        }
        if (a5 != -1)
            result = (Concurrency::details::_UnrealizedChore*)sub_489FA0((char*)v9, a5);
        if (a6 != -1)
            return (Concurrency::details::_UnrealizedChore*)sub_489FC0((char*)v9, a6);
    }
    return result;
} 
int sub_4891BA(_DWORD* thisx, int a2)
{
    if (a2 >= 0 && a2 <= 2)
        return thisx[a2 + 79];
    else
        return 0;
}
 
int sub_4891E4(_DWORD* thisx, LPCSTR lpFileName)
{
    int v4; // [esp+4h] [ebp-4h]

    sub_48151A((int)(thisx + 1));
    thisx[7] = 0;
    thisx[85] = 100;
    thisx[86] = 0;
    v4 = sub_49CB92((int)unk_4BDC60, -1, 320, 240, 0, 0);
    if (v4 < 0)
        return 0;
    thisx[8] = v4;
    sub_489289(thisx);
    if (!sub_486B0E((int)thisx, lpFileName))//±¨´í
        return 0;
    thisx[9] = 0;
    sub_46259F((char*)unk_4B9B10);
    return 1;
}
 
int(*** sub_489289(void* thisx))(_DWORD, int)
{
    int( * **result)(_DWORD, int); // eax
    int i; // [esp+4h] [ebp-4h]

    result = sub_4869CF((int)thisx);
    for (i = 0; i < 3; ++i)
    {
        sub_401404((int)thisx + 32 * i + 512);
        result = (int(***)(_DWORD, int))(i + 1);
    }
    return result;
}
 
void sub_4892EE(void* thisx)
{
    sub_489301((void**)thisx);
}
 
void** sub_489301(void** thisx)
{
    void** result; // eax

    result = thisx;
    if (thisx[1])
        operator delete(thisx[1]);
    thisx[1] = 0;
    *thisx = (void*)-1;
    return result;
}
 
int sub_48933F(int thisx, int a2, LPCSTR lpString)
{
    int v5; // [esp+8h] [ebp-4h]

    if (!lpString)
        return 0;
    sub_489301((void**)thisx);
    *(_DWORD*)thisx = a2;
    v5 = lstrlenA(lpString);
    *(_DWORD*)(thisx + 4) = (_DWORD)operator new(v5 + 1);
    if (*(_DWORD*)(thisx + 4))
    {
        lstrcpyA(*(LPSTR*)(thisx + 4), lpString);
        return 1;
    }
    else
    {
        *(_DWORD*)thisx = -1;
        return 0;
    }
}
 
int sub_4893BC(_DWORD* thisx, int a2)
{
    int i; // [esp+4h] [ebp-4h]

    for (i = 0; i < thisx[84]; ++i)
    {
        if (unknown_libname_30((_DWORD*)thisx[83] + 8 * i) == a2)
            return unknown_libname_22((_DWORD*)(thisx[83] + 8 * i));
    }
    return 0;
}
 
int sub_48941E(_DWORD* thisx, LPCSTR lpFileName)
{
    int v4[15]; // [esp+4h] [ebp-3Ch] BYREF

    sub_49DB90(v4);
    v4[1] = 0;
    v4[2] = 0;
    v4[3] = -1;
    v4[4] = -1;
    v4[9] = -1;
    v4[0] = thisx[8];
    return sub_49DA45((_DWORD*)unk_4BDC60, lpFileName, (int)v4);
}
 
void sub_489473(_DWORD* thisx, int a2, int a3, int a4, int a5)
{
    int i; // [esp+4h] [ebp-4h]

    for (i = 0; i < thisx[88]; ++i)
    {
        if (unknown_libname_22((_DWORD*)(12 * i + thisx[87])) == a2)
        {
            sub_48E1DB((int*)(12 * i + thisx[87]), a3, a4, a5);
            return;
        }
    }
}

 
int sub_4894E3(_DWORD* thisx, int a2)
{
    if (!thisx[88])
        return -1;
    if (a2 >= 0 && a2 < thisx[88])
        return unknown_libname_26(12 * a2 + (_DWORD*)thisx[87]);
    return -1;
}
 
void sub_489530(_DWORD* thisx, int a2, int a3, int a4, int a5)
{
    int j; // [esp+4h] [ebp-8h]
    int i; // [esp+8h] [ebp-4h]

    if (a4 == -1)
    {
        for (i = 0; i < thisx[77]; ++i)
        {
            if (unknown_libname_22((_DWORD*)(432 * i + thisx[82])) == a5)
            {
                sub_48A0A0((_DWORD*)(432 * i + thisx[82]), a2);
                sub_48A0C0((_DWORD*)(432 * i + thisx[82]), a3);
            }
        }
    }
    else
    {
        for (j = a4; j < a5 + 1 && j < thisx[77]; ++j)
        {
            sub_48A0A0((_DWORD*)(432 * j + thisx[82]), a2);
            sub_48A0C0((_DWORD*)(432 * j + thisx[82]), a3);
        }
    }
}

 
void sub_489629(_DWORD* thisx, int a2, int a3, int a4)
{
    int j; // [esp+4h] [ebp-8h]
    int i; // [esp+8h] [ebp-4h]

    if (a2 == -1)
    {
        for (i = 0; i < thisx[77]; ++i)
        {
            if (unknown_libname_22((_DWORD*)(432 * i + thisx[82])) == a3)
                sub_48DC0D(432 * i + thisx[82], a4);
        }
    }
    else
    {
        for (j = a2; j < a3 + 1 && j < thisx[77]; ++j)
            sub_48DC0D(432 * j + thisx[82], a4);
    }
}
 
int sub_4896E8(_DWORD* thisx, int a2, Concurrency::details::UMSFreeVirtualProcessorRoot* a3)
{
    int result; // eax
    int v5; // [esp+4h] [ebp-10h]
    struct Concurrency::details::UMSThreadProxy* ExecutingProxy; // [esp+8h] [ebp-Ch]
    int v7; // [esp+Ch] [ebp-8h]
    int i; // [esp+10h] [ebp-4h]

    ExecutingProxy = Concurrency::details::UMSFreeVirtualProcessorRoot::GetExecutingProxy(a3);
    v5 = sub_48A0E0((_DWORD*)a3);
    result = unknown_libname_19((_DWORD*)a3);
    v7 = result;
    for (i = 0; i < thisx[77]; ++i)
    {
        if (unknown_libname_22((_DWORD*)(432 * i + thisx[82])) == a2)
            sub_48DC4E((_DWORD*)(432 * i + thisx[82]), (int)ExecutingProxy, v5, v7);
        result = i + 1;
    }
    return result;
}
 
_DWORD* sub_48977D(_DWORD* thisx, int a2, int a3, int a4, _DWORD* a5)
{
    _DWORD* result; // eax

    if (a5)
    {
        *a5 = a2 / 100 - thisx[7];
        result = a5;
        a5[1] = thisx[9] + a4 / 100 + a3 / 100;
    }
    return result;
}
 
int sub_4897D0(char* thisx)
{
    return 8 * (unsigned __int8)unknown_libname_25(thisx + 4);
}
 
void sub_4897EE(void* a1, double a2, char a3, char a4)
{
    int v4; // [esp+18h] [ebp-Ch]
    int v5; // [esp+1Ch] [ebp-8h]
    char v6; // [esp+20h] [ebp-4h]

    v6 = sub_4868C1(a1, a3, a4);
    v4 = 0;
    switch (v6)
    {
    case 0:
        v5 = 1;
        v4 = 0;
        break;
    case 1:
    case 2:
        v5 = 2;
        v4 = 1;
        break;
    case 3:
    case 4:
        v5 = 1;
        v4 = 1;
        break;
    case 5:
        v5 = 1;
        v4 = 2;
        break;
    default:
        break;
    }
    if (v6 && (v6 & 1) == 0)
        v5 = -v5;
    sub_4A3090((double)v4, (double)v4, (double)v5);
} 
int(*** sub_4898D3(_DWORD* thisx))(_DWORD, int)
{
	thisx[7] = 0;
	thisx[9] = 0;
	thisx[85] = 100;
	thisx[86] = 0;
	sub_48151A((int)(thisx + 1));
	sub_4869CF((int)thisx);
	return sub_489289(thisx);
}
 
int sub_489927(void* thisx, int a2, int a3, int a4, _DWORD* a5)
{
    int v6; // [esp+4h] [ebp-10Ch]
    CHAR String1[256]; // [esp+8h] [ebp-108h] BYREF
    int v8; // [esp+108h] [ebp-8h]
    int v9; // [esp+10Ch] [ebp-4h]

    if (!a2 || !a3)
        return -1;
    v6 = 0;
    v8 = 0;
    LOBYTE(v9) = 0;
    while (sub_482D44((_DWORD*)a2, String1))
    {
        if (lstrcmpiA(String1, aMove_0))
        {
            if (!lstrcmpiA(String1, aMoveend_0))
                break;
            if ((unsigned __int8)v9 == 1)
            {
                if (String1[0] == 42)
                {
                    sub_48A46C((CHAR*)(a3 + 20 * v6), String1);
                    unknown_libname_27((_DWORD*)(a3 + 20 * v6++), v8);
                    if (v6 >= a4)
                        break;
                }
                sub_482FAA((_DWORD*)a2);
                ++v8;
            }
            else if (!(_BYTE)v9)
            {
                sub_482FAA((_DWORD*)a2);
            }
        }
        else
        {
            LOBYTE(v9) = 1;
            sub_482FAA((_DWORD*)a2);
        }
    }
    if (a5)
        *a5 = v6;
    return v8;
}

 
int sub_489A73(void* thisx, int a2)
{
    if (a2 >= 0 && a2 < 3)
        return (int)thisx + 32 * a2 + 512;
    else
        return 0;
}
 
void sub_489B1D(_DWORD* thisx, int a2, int a3, _BYTE* a4, int a5)
{
    int j; // [esp+4h] [ebp-8h]
    int i; // [esp+8h] [ebp-4h]

    if (a2 == -1)
    {
        for (i = 0; i < thisx[77]; ++i)
        {
            if (unknown_libname_22((_DWORD*)(432 * i + thisx[82])) == a3)
                sub_48A94C(thisx[82] + 432 * i, a4, a5);
        }
    }
    else
    {
        for (j = a2; j < a3 + 1 && j < thisx[77]; ++j)
            sub_48A94C(432 * j + thisx[82], a4, a5);
    }
}
 
int sub_489C16(void* thisx, unsigned __int8 a2, unsigned __int8 a3)
{
    return sub_4816F5((int)thisx + 4, a2, a3);
}

 
int sub_489C36(const CHAR* thisx)
{
    int result; // eax

    result = sub_456D33((char*)unk_4B9B10, thisx + 40, 1, 1);
    if (!result)
        return sub_456D33((char*)unk_4B9B10, aStage00Wav, 1, 1);
    return result;
}
 
int sub_489C74(void* thisx, unsigned __int16 a1)
{
	return sub_4828CD((int)thisx + 4, a1);
}

 
__int16 sub_489C95(_DWORD* thisx, unsigned __int8 a2, unsigned __int8 a3)
{
    int v5; // [esp+4h] [ebp-4h]

    if (!unknown_libname_24(thisx + 1))
        return 0;
    v5 = sub_4816F5((int)(thisx + 1), a2, a3);
    if (v5)
        return sub_4260F0((short*)v5);
    else
        return 0;
}
 
_DWORD* sub_489CF0(_DWORD* thisx, char a2)
{
    sub_486119(thisx);
    if ((a2 & 1) != 0)
        operator delete(thisx);
    return thisx;
}

 
char sub_489D40(_BYTE* thisx)
{
    return thisx[14];
}
 
char* sub_489D60(char* thisx, char a2)
{
    if ((a2 & 2) != 0)
    {
        eh_vector_destructor_iterator(thisx, 8u, *((_DWORD *)thisx - 1), sub_4892EE);
            if ((a2 & 1) != 0)
                operator delete(thisx - 4);
        return thisx - 4;
    }
    else
    {
        sub_4892EE(thisx);
        if ((a2 & 1) != 0)
            operator delete(thisx);
        return thisx;
    }
}
 
_BYTE* sub_489E30(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[28] = a2;
    return result;
}
 
char* sub_489EC0(char* thisx, char a2)
{
    if ((a2 & 2) != 0)
    {
        eh_vector_destructor_iterator(thisx, 0x1B0u, *((_DWORD *)thisx - 1), sub_48A43A);
            if ((a2 & 1) != 0)
                operator delete(thisx - 4);
        return thisx - 4;
    }
    else
    {
        sub_48A43A(thisx);
        if ((a2 & 1) != 0)
            operator delete(thisx);
        return thisx;
    }
}
 
_WORD* sub_489F40(_WORD* thisx, __int16 a2)
{
    _WORD* result; // eax

    result = thisx;
    thisx[3] = a2;
    return result;
}
 
_BYTE* sub_489F60(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[12] = a2;
    return result;
}

 
_BYTE* sub_489F80(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[4] = a2;
    return result;
}
 
_BYTE* sub_489FA0(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[8] = a2;
    return result;
}
 
_BYTE* sub_489FC0(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[9] = a2;
    return result;
}

 
_WORD* sub_489FE0(_WORD* thisx, __int16 a2)
{
    _WORD* result; // eax

    result = thisx;
    thisx[5] = a2;
    return result;
}
 
_WORD* sub_48A000(_WORD* thisx, __int16 a2)
{
    _WORD* result; // eax

    result = thisx;
    thisx[6] = a2;
    return result;
}
 
_BYTE* sub_48A020(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[14] = a2;
    return result;
}

 
_DWORD* sub_48A0A0(_DWORD* thisx, int a2)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[24] = a2;
    return result;
}

 
_DWORD* sub_48A0C0(_DWORD* thisx, int a2)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[25] = a2;
    return result;
}
 
int sub_48A0E0(_DWORD* thisx)
{
    return thisx[27];
}

 
void sub_48A100(void* thisx)
{
    *(_DWORD*)thisx = off_4AC368;
    *((_DWORD*)thisx + 3) = 0;
    *((_DWORD*)thisx + 2) = 0;
    *((_WORD*)thisx + 8) = -1;
}

 
void sub_48A134(void* thisx)
{
	*(_DWORD*)thisx = off_4AC368;
	sub_48A150((void**)thisx);
}
 
void** sub_48A150(void** thisx)
{
    void** result; // eax

    if (thisx[3])
        operator delete(thisx[3]);
    if (thisx[2])
        operator delete(thisx[2]);
    thisx[3] = 0;
    result = thisx;
    thisx[2] = 0;
    return result;
}
 
void sub_48A1AD(void** thisx, int a2)
{
    int v2; // eax
    int v3; // eax
    int v5[4]; // [esp+18h] [ebp-120h] BYREF
    char v6; // [esp+28h] [ebp-110h]
    CHAR String1[256]; // [esp+2Ch] [ebp-10Ch] BYREF
    int v8; // [esp+134h] [ebp-4h]

    sub_48A150(thisx);
    wsprintfA(String1, "Stage\\Stage%02d_data.txt", a2);
    sub_482BF0(v5);
    v8 = 0;
    if (sub_482C74((int)v5, String1))
    {
        v6 = 0;
        while (sub_482D44(v5, String1))
        {
            if (v6)
            {
                if (v6 == 1)
                {
                    if (thisx[3])
                        operator delete(thisx[3]);
                    v2 = lstrlenA(String1);
                    thisx[3] = operator new(v2 + 1);
                    lstrcpyA((LPSTR)thisx[3], String1);
                    v6 = 0;
                }
                else if (v6 == 2)
                {
                    if (thisx[2])
                        operator delete(thisx[2]);
                    v3 = lstrlenA(String1);
                    thisx[2] = operator new(v3 + 1);
                    lstrcpyA((LPSTR)thisx[2], String1);
                    v6 = 0;
                }
            }
            else if (lstrcmpiA(String1, aHelp_0))
            {
                if (!lstrcmpiA(String1, aName))
                    v6 = 2;
            }
            else
            {
                v6 = 1;
            }
        }
    }
    v8 = -1;
    sub_482C2F(v5);
} 
void sub_48A3F0(void* thisx)
{
    sub_402080((int)thisx + 168, 8, 7, (void(*)(int))sub_48E070);
    sub_4810C0((char*)thisx + 228);
    sub_4020B0((_DWORD*)thisx + 71);
    *(_DWORD*)thisx = (_DWORD)&off_4AC36C;
}

 
void sub_48A43A(void* thisx)
{
    *(_DWORD*)thisx = (_DWORD)&off_4AC36C;
}
 
_DWORD* sub_48A44E(_DWORD* thisx)
{
    *(_BYTE*)thisx = 0;
    thisx[4] = -1;
    return thisx;
}
 
LPSTR sub_48A46C(CHAR* thisx, LPCSTR lpString2)
{
    return lstrcpynA(thisx, lpString2, 16);
}

 
char sub_48A49F(_WORD* thisx, unsigned __int8 a2, __int16 a3, char a4)
{
    char result; // al

    result = a2;
    if (a2 < 0x10u)
    {
        thisx[a2 + 1] = a3;
        result = a4;
        *((_BYTE*)thisx + a2 + 34) = a4;
    }
    return result;
}

 
int sub_48A4E3(__int16* thisx, unsigned __int8 a2)
{
    if (a2 >= 0x10u)
        return 0;
    if (*((_BYTE*)thisx + a2 + 34))
        return dword_4B9AEC[thisx[a2 + 1]];
    return thisx[a2 + 1];
}
 
_BYTE* sub_48A54F(_BYTE* thisx)
{
    int i; // [esp+4h] [ebp-4h]

    *thisx = 0;
    for (i = 0; i < 16; ++i)
    {
        *(_WORD*)&thisx[2 * i + 2] = 0;
        thisx[i + 34] = 0;
    }
    return thisx;
}
 
_BYTE* sub_48A596(_BYTE* thisx)
{
    _BYTE* result; // eax
    int i; // [esp+4h] [ebp-4h]

    result = thisx;
    *thisx = 0;
    for (i = 0; i < 16; ++i)
    {
        result = thisx;
        *(_WORD*)&thisx[2 * i + 2] = 0;
        thisx[i + 34] = 0;
    }
    return result;
}
 
int sub_48A5DA(int thisx, char a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, char a10)
{
    int result; // eax

    *(_BYTE*)(thisx + 8) = a2;
    *(_DWORD*)(thisx + 104) = 100 * a3;
    *(_DWORD*)(thisx + 20) = *(_DWORD*)(thisx + 104);
    *(_DWORD*)(thisx + 108) = 100 * a4;
    *(_DWORD*)(thisx + 24) = *(_DWORD*)(thisx + 108);
    *(_DWORD*)(thisx + 112) = 100 * a5;
    *(_DWORD*)(thisx + 28) = *(_DWORD*)(thisx + 112);
    *(_DWORD*)(thisx + 116) = 0;
    *(_DWORD*)(thisx + 120) = 0;
    *(_DWORD*)(thisx + 124) = 0;
    *(_DWORD*)(thisx + 128) = 0;
    *(_DWORD*)(thisx + 132) = 0;
    *(_DWORD*)(thisx + 136) = 0;
    *(_DWORD*)(thisx + 16) = a6;
    *(_DWORD*)(thisx + 140) = a7;
    *(_DWORD*)(thisx + 32) = a7;
    *(_DWORD*)(thisx + 144) = a8;
    *(_DWORD*)(thisx + 36) = a8;
    *(_DWORD*)(thisx + 4) = a9;
    *(_BYTE*)(thisx + 86) = a10;
    *(_BYTE*)(thisx + 85) = a10;
    *(_BYTE*)(thisx + 148) = 0;
    *(_DWORD*)(thisx + 156) = 0;
    *(_DWORD*)(thisx + 52) = 0;
    result = thisx;
    *(_DWORD*)(thisx + 100) = 0;
    *(_DWORD*)(thisx + 96) = 0;
    return result;
}
 
int sub_48A700(int thisx)
{
    *(_BYTE*)(thisx + 12) = 1;
    *(_WORD*)(thisx + 10) = -1;
    *(_DWORD*)(thisx + 44) = -1;
    *(_DWORD*)(thisx + 40) = *(_DWORD*)(thisx + 16);
    *(_DWORD*)(thisx + 104) = *(_DWORD*)(thisx + 20);
    *(_DWORD*)(thisx + 108) = *(_DWORD*)(thisx + 24);
    *(_DWORD*)(thisx + 112) = *(_DWORD*)(thisx + 28);
    *(_DWORD*)(thisx + 140) = *(_DWORD*)(thisx + 32);
    *(_DWORD*)(thisx + 144) = *(_DWORD*)(thisx + 36);
    *(_BYTE*)(thisx + 148) = 0;
    *(_DWORD*)(thisx + 152) = 0;
    *(_DWORD*)(thisx + 156) = 0;
    *(_DWORD*)(thisx + 52) = 0;
    *(_DWORD*)(thisx + 56) = 0;
    *(_DWORD*)(thisx + 60) = 0;
    *(_DWORD*)(thisx + 96) = 0;
    *(_DWORD*)(thisx + 100) = 0;
    *(_BYTE*)(thisx + 48) = 0;
    *(_DWORD*)(thisx + 92) = 0;
    *(_DWORD*)(thisx + 80) = 0;
    *(_BYTE*)(thisx + 84) = 0;
    *(_BYTE*)(thisx + 76) = 0;
    *(_BYTE*)(thisx + 86) = *(_BYTE*)(thisx + 85);
    *(_DWORD*)(thisx + 88) = -1;
    *(_DWORD*)(thisx + 164) = 0;
    *(_DWORD*)(thisx + 116) = 0;
    *(_DWORD*)(thisx + 120) = 0;
    *(_DWORD*)(thisx + 124) = 0;
    *(_DWORD*)(thisx + 128) = 0;
    *(_DWORD*)(thisx + 132) = 0;
    *(_DWORD*)(thisx + 136) = 0;
    *(_DWORD*)(thisx + 64) = 0;
    *(_DWORD*)(thisx + 68) = 0;
    *(_WORD*)(thisx + 72) = 100;
    *(_WORD*)(thisx + 74) = 100;
    *(_BYTE*)(thisx + 224) = 0;
    memset((void*)(thisx + 228), 0, 0x38u);
    memset((void*)(thisx + 284), 0, 0x34u);
    *(_DWORD*)(thisx + 332) = 83;
    memset((void*)(thisx + 336), 0, 8u);
    *(_BYTE*)(thisx + 346) = 0;
    memset((void*)(thisx + 348), 0, 0x20u);
    memset((void*)(thisx + 380), 0, 8u);
    *(_BYTE*)(thisx + 388) = 0;
    memset((void*)(thisx + 392), 0, 0x20u);
    memset((void*)(thisx + 424), 0, 8u);
    return sub_48E02B((_DWORD*)thisx);
}
 
void sub_48A94C(int thisx, _BYTE* a2, int a3)
{
    int* v3; // esi
    _DWORD* v4; // esi
    _DWORD* v5; // esi
    int v6; // eax
    int v7; // ecx
    int v8; // edx
    int v9; // eax
    int v10; // eax
    const CHAR* v11; // eax
    int v12; // eax
    const CHAR* v13; // eax
    int v14; // eax
    const CHAR* v15; // eax
    int v16; // eax
    int v17; // eax
    int v18; // esi
    int v19; // eax
    const CHAR* v20; // eax
    int v21; // esi
    int v22; // esi
    unsigned __int8 v23; // al
    char v24; // al
    char* v25; // eax
    int v26; // esi
    int v27; // edi
    unsigned __int16 v28; // ax
    int v29; // eax
    const CHAR* v30; // eax
    int v31; // [esp-Ch] [ebp-1E4h]
    int v32; // [esp-8h] [ebp-1E0h]
    int v33; // [esp-8h] [ebp-1E0h]
    unsigned __int8 v34; // [esp-8h] [ebp-1E0h]
    int v35; // [esp-4h] [ebp-1DCh]
    int v36; // [esp-4h] [ebp-1DCh]
    unsigned __int8 v37; // [esp-4h] [ebp-1DCh]
    int v38; // [esp-4h] [ebp-1DCh]
    int v39; // [esp+10h] [ebp-1C8h]
    char* v41; // [esp+20h] [ebp-1B8h]
    int jj; // [esp+24h] [ebp-1B4h]
    int v43; // [esp+28h] [ebp-1B0h]
    int v44; // [esp+2Ch] [ebp-1ACh]
    int v45; // [esp+34h] [ebp-1A4h]
    int ii; // [esp+38h] [ebp-1A0h]
    int v47; // [esp+3Ch] [ebp-19Ch]
    Concurrency::details::_UnrealizedChore* v48; // [esp+40h] [ebp-198h]
    int v49; // [esp+44h] [ebp-194h]
    int v50; // [esp+48h] [ebp-190h]
    int v51; // [esp+48h] [ebp-190h]
    int RuntimeOwnsLifetime; // [esp+4Ch] [ebp-18Ch]
    int n; // [esp+50h] [ebp-188h]
    int m; // [esp+54h] [ebp-184h]
    int v55; // [esp+58h] [ebp-180h]
    char* v56; // [esp+5Ch] [ebp-17Ch]
    int v57; // [esp+60h] [ebp-178h]
    int v58; // [esp+64h] [ebp-174h]
    int v59; // [esp+68h] [ebp-170h]
    int k; // [esp+6Ch] [ebp-16Ch]
    int v61; // [esp+70h] [ebp-168h]
    int v62; // [esp+74h] [ebp-164h]
    int v63; // [esp+78h] [ebp-160h]
    char* v64; // [esp+7Ch] [ebp-15Ch]
    int v65; // [esp+80h] [ebp-158h]
    int v66; // [esp+84h] [ebp-154h]
    int v67; // [esp+88h] [ebp-150h]
    char* v68; // [esp+8Ch] [ebp-14Ch]
    int v69; // [esp+90h] [ebp-148h]
    int v70; // [esp+94h] [ebp-144h]
    int v71; // [esp+98h] [ebp-140h]
    int v72; // [esp+9Ch] [ebp-13Ch]
    int v73; // [esp+A4h] [ebp-134h]
    int v74; // [esp+A8h] [ebp-130h]
    int v75; // [esp+ACh] [ebp-12Ch]
    int v76; // [esp+B0h] [ebp-128h]
    int v77; // [esp+B4h] [ebp-124h]
    int v78; // [esp+B8h] [ebp-120h]
    int v79; // [esp+BCh] [ebp-11Ch]
    int v80; // [esp+C0h] [ebp-118h]
    int v81; // [esp+C4h] [ebp-114h]
    int v82; // [esp+C8h] [ebp-110h] BYREF
    int v83; // [esp+CCh] [ebp-10Ch]
    char v84; // [esp+D0h] [ebp-108h]
    int v85; // [esp+DCh] [ebp-FCh]
    char* v86; // [esp+E0h] [ebp-F8h]
    char* v87; // [esp+E4h] [ebp-F4h]
    int v88; // [esp+E8h] [ebp-F0h]
    int v89; // [esp+ECh] [ebp-ECh]
    int v90; // [esp+F0h] [ebp-E8h]
    int v91; // [esp+F4h] [ebp-E4h]
    int v92; // [esp+F8h] [ebp-E0h]
    int v93; // [esp+FCh] [ebp-DCh]
    BOOL v94; // [esp+100h] [ebp-D8h]
    int v95; // [esp+104h] [ebp-D4h]
    int v96; // [esp+108h] [ebp-D0h]
    char* v97; // [esp+10Ch] [ebp-CCh]
    int v98; // [esp+110h] [ebp-C8h]
    int v99; // [esp+114h] [ebp-C4h]
    char v100; // [esp+118h] [ebp-C0h]
    int v101; // [esp+11Ch] [ebp-BCh]
    int v102; // [esp+120h] [ebp-B8h]
    int* v103; // [esp+124h] [ebp-B4h]
    char* v104; // [esp+128h] [ebp-B0h]
    int v105; // [esp+12Ch] [ebp-ACh]
    int v106; // [esp+130h] [ebp-A8h]
    int v107; // [esp+134h] [ebp-A4h]
    int v108; // [esp+138h] [ebp-A0h]
    int v109; // [esp+13Ch] [ebp-9Ch]
    char* v110; // [esp+140h] [ebp-98h]
    int v111; // [esp+144h] [ebp-94h]
    int v112; // [esp+148h] [ebp-90h]
    int v113; // [esp+14Ch] [ebp-8Ch]
    int v114; // [esp+150h] [ebp-88h]
    char* v115; // [esp+154h] [ebp-84h]
    int* v116; // [esp+158h] [ebp-80h]
    char* v117; // [esp+15Ch] [ebp-7Ch]
    char* v118; // [esp+160h] [ebp-78h]
    int v119; // [esp+164h] [ebp-74h]
    int v120; // [esp+168h] [ebp-70h]
    struct tagRECT rc; // [esp+16Ch] [ebp-6Ch] BYREF
    char* v122; // [esp+17Ch] [ebp-5Ch]
    char v123; // [esp+180h] [ebp-58h]
    char v124; // [esp+184h] [ebp-54h]
    char v125; // [esp+188h] [ebp-50h]
    int v126; // [esp+18Ch] [ebp-4Ch]
    int j; // [esp+190h] [ebp-48h]
    char v128; // [esp+194h] [ebp-44h]
    char v129; // [esp+195h] [ebp-43h]
    char v130; // [esp+196h] [ebp-42h]
    char v131; // [esp+197h] [ebp-41h]
    char v132; // [esp+198h] [ebp-40h]
    char v133; // [esp+199h] [ebp-3Fh]
    char v134; // [esp+19Ah] [ebp-3Eh]
    int i; // [esp+19Ch] [ebp-3Ch]
    int v136[6]; // [esp+1A0h] [ebp-38h]
    int v137; // [esp+1B8h] [ebp-20h]
    int v138; // [esp+1BCh] [ebp-1Ch]
    int v139; // [esp+1C0h] [ebp-18h]
    int v140; // [esp+1C4h] [ebp-14h]
    int v141; // [esp+1C8h] [ebp-10h]
    int v142; // [esp+1CCh] [ebp-Ch]
    int v143; // [esp+1D0h] [ebp-8h]
    __int16* v144; // [esp+1D4h] [ebp-4h]
    int v145; // [esp+1E4h] [ebp+Ch]

    if (a2 || *(int*)(thisx + 40) >= 0 && *(_DWORD*)(thisx + 40) < dword_4CA1D4)
    {
        if (a2)
            v144 = (__int16*)a2;
        else
            v144 = (__int16*)(50 * *(_DWORD*)(thisx + 40) + dword_4CA1D8);
        LOBYTE(v142) = *(_BYTE*)v144;
        v143 = 1;
        switch ((unsigned __int8)v142)
        {
        case 1u:
            *(_DWORD*)(thisx + 44) = sub_48A4E3(v144, 0);
            *(_WORD*)(thisx + 10) = sub_48A4E3(v144, 1u);
            v143 = 0;
            break;
        case 2u:
            v138 = sub_48A4E3(v144, 0);
            v137 = sub_48A4E3(v144, 1u);
            v139 = sub_48A4E3(v144, 2u);
            v140 = sub_48A4E3(v144, 3u);
            v141 = sub_48A4E3(v144, 4u);
            sub_45612D((_DWORD*)unk_4B9B10, v138, v137, v139, v140, v141);
            break;
        case 3u:
            v136[0] = thisx + 116;
            v136[1] = thisx + 120;
            v136[2] = thisx + 124;
            v136[3] = thisx + 128;
            v136[4] = thisx + 132;
            v136[5] = thisx + 136;
            for (i = 0; i < 6; ++i)
            {
                if (sub_48A4E3(v144, 2 * i) == 1)
                {
                    *(_DWORD*)v136[i] = sub_48A4E3(v144, 2 * i + 1);
                }
                else if (sub_48A4E3(v144, 2 * i) == 2)
                {
                    v3 = (int*)v136[i];
                    *v3 = *v3 * sub_48A4E3(v144, 2 * i + 1) / 100;
                }
                else if (sub_48A4E3(v144, 2 * i) == 3)
                {
                    v4 = (_DWORD*)v136[i];
                    *v4 += sub_48A4E3(v144, 2 * i + 1);
                }
                else if (sub_48A4E3(v144, 2 * i) == 4)
                {
                    v5 = (_DWORD*)v136[i];
                    *v5 *= sub_48A4E3(v144, 2 * i + 1);
                }
                else if (sub_48A4E3(v144, 2 * i) == 5)
                {
                    if (i && i != 3)
                    {
                        *(_DWORD*)v136[i] = sub_48A4E3(v144, 2 * i + 1);
                    }
                    else
                    {
                        *(_DWORD*)v136[i] = sub_48A4E3(v144, 2 * i + 1);
                        if (*(_DWORD*)(thisx + 52))
                            *(_DWORD*)v136[i] = -sub_48A4E3(v144, 2 * i + 1);
                    }
                }
            }
            break;
        case 4u:
            if (sub_48A4E3(v144, 0) || sub_48A4E3(v144, 1u))
            {
                v128 = 0;
                v129 = 5;
                v130 = 1;
                v131 = 2;
                v132 = 3;
                v133 = 4;
                v134 = 6;
                for (j = 0; j < 8; ++j)
                {
                    v126 = sub_48A4E3(v144, 2 * j);
                    if (v126 > 0 && v126 <= 7)
                    {
                        *(_BYTE*)(thisx + 8 * v126 + 160) = v126;
                        *(_DWORD*)(thisx + 8 * v126 + 164) = sub_48A4E3(v144, 2 * j + 1);
                    }
                }
            }
            else
            {
                sub_48E02B((_DWORD*)thisx);
            }
            break;
        case 8u:
            v123 = sub_48A4E3(v144, 0);
            v125 = sub_48A4E3(v144, 1u);
            v124 = sub_48A4E3(v144, 2u);
            v122 = sub_426210((char*)unk_4B9B10);
            if (v122)
            {
                v6 = unknown_libname_10((_DWORD*)v122);
                v119 = v6;
                LOBYTE(v6) = v124;
                LOBYTE(v7) = v125;
                LOBYTE(v8) = v123;
                v120 = sub_49FFEC(v8, v7, v6);
                v35 = sub_48A4E3(v144, 6u);
                v32 = sub_48A4E3(v144, 5u);
                v31 = sub_48A4E3(v144, 4u);
                v9 = sub_48A4E3(v144, 3u);
                SetRect(&rc, v9, v31, v32, v35);
                if (rc.top || rc.left || rc.bottom || rc.right)
                    sub_4A02E9((_DWORD*)unk_4BDC60, (int)&rc, (int)&rc, v120, v119);
                else
                    sub_4A02E9((_DWORD*)unk_4BDC60, v120, 0, v120, v119);
            }
            break;
        case 9u:
            if (sub_48A4E3(v144, 0) == -1)
            {
                sub_440B78((int)unk_4BDB28);
            }
            else
            {
                v118 = sub_426210((char*)unk_4B9B10);
                if (v118)
                {
                    v33 = sub_48A4E3(v144, 1u);
                    v10 = sub_48A4E3(v144, 0);
                    v11 = (const CHAR*)sub_4893BC((_DWORD*)v118, v10);
                    sub_456D33((char*)unk_4B9B10, v11, v33, 0);
                }
            }
            break;
        case 0xAu:
            v117 = sub_426210((char*)unk_4B9B10);
            if (v117)
            {
                v12 = sub_48A4E3(v144, 0);
                v13 = (const CHAR*)sub_4893BC((_DWORD*)v117, v12);
                sub_48941E((_DWORD*)v117, v13);
            }
            break;
        case 0xBu:
            *(_DWORD*)(thisx + 156) = *(_DWORD*)(thisx + 40);
            *(_DWORD*)(thisx + 40) = sub_48A4E3(v144, 0);
            *(_DWORD*)(thisx + 160) = *(_DWORD*)(thisx + 40);
            *(_BYTE*)(thisx + 148) = sub_48A4E3(v144, 1u);
            *(_DWORD*)(thisx + 152) = sub_48A4E3(v144, 2u);
            sub_48A94C(thisx, 0, 1);
            v143 = 0;
            break;
        case 0xCu:
            *(_DWORD*)(thisx + 140) = sub_48A4E3(v144, 0);
            *(_DWORD*)(thisx + 144) = sub_48A4E3(v144, 1u);
            if (sub_48A4E3(v144, 2u) == 1)
            {
                *(_DWORD*)(thisx + 52) = *(_DWORD*)(thisx + 52) == 0;
            }
            else if (sub_48A4E3(v144, 2u) == 2)
            {
                *(_DWORD*)(thisx + 52) = 0;
            }
            else if (sub_48A4E3(v144, 2u) == 3)
            {
                *(_DWORD*)(thisx + 52) = 1;
            }
            break;
        case 0xDu:
            if (sub_48A4E3(v144, 3u))
            {
                *(_DWORD*)(thisx + 104) += 100 * sub_48A4E3(v144, 0);
                *(_DWORD*)(thisx + 108) += 100 * sub_48A4E3(v144, 1u);
                *(_DWORD*)(thisx + 112) += 100 * sub_48A4E3(v144, 2u);
            }
            else
            {
                *(_DWORD*)(thisx + 104) = 100 * sub_48A4E3(v144, 0);
                *(_DWORD*)(thisx + 108) = 100 * sub_48A4E3(v144, 1u);
                *(_DWORD*)(thisx + 112) = 100 * sub_48A4E3(v144, 2u);
            }
            break;
        case 0xEu:
            v116 = (int*)sub_48E0B0((char*)unk_4B9B10);
            if (sub_48A4E3(v144, 0) < 0)
            {
                sub_47FA81(v116);
            }
            else
            {
                v115 = sub_426210((char*)unk_4B9B10);
                v14 = sub_48A4E3(v144, 0);
                v15 = (const CHAR*)sub_4893BC((_DWORD*)v115, v14);
                sub_47F9D6((int)v116, v15, 4);
            }
            if (sub_48A4E3(v144, 1u) > 0)
            {
                *(_WORD*)(thisx + 10) = sub_48A4E3(v144, 1u);
                v143 = 0;
            }
            break;
        case 0xFu:
            v16 = sub_48A4E3(v144, 0);
            sub_48E0D0((_DWORD*)unk_4B9B10, v16);
            break;
        case 0x10u:
            v112 = sub_48A4E3(v144, 1u);
            v111 = sub_48A4E3(v144, 2u);
            v113 = sub_48A4E3(v144, 3u);
            v114 = sub_48A4E3(v144, 4u) == 1;
            if (v112 >= 0)
            {
                if (v112 >= 60)
                    v112 = 59;
            }
            else
            {
                v112 = 0;
            }
            if (!v111)
                v111 = 100;
            if (!v113)
                v113 = 100;
            if (sub_48A4E3(v144, 0))
            {
                v110 = sub_426210((char*)unk_4B9B10);
                sub_489473((_DWORD*)v110, v112, v111, v113, v114);
            }
            else
            {
                sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[v112], -1, v111, v113, v114);
            }
            break;
        case 0x11u:
            if (*(_DWORD*)(thisx + 40) != sub_48A4E3(v144, 0))
            {
                *(_DWORD*)(thisx + 40) = sub_48A4E3(v144, 0);
                v143 = 0;
                sub_48A94C(thisx, 0, 1);
            }
            break;
        case 0x12u:
            v107 = sub_48A4E3(v144, 0);
            v105 = sub_48A4E3(v144, 1u);
            v108 = sub_48A4E3(v144, 2u);
            v106 = sub_48A4E3(v144, 3u);
            if (v107)
            {
                v109 = 1;
            }
            else
            {
                v109 = 0;
                if (v105 == 2)
                    v107 = 1;
            }
            v104 = sub_426210((char*)unk_4B9B10);
            sub_489530((_DWORD*)v104, v107 == 0, v109 == 0, v108, v106);
            break;
        case 0x13u:
            v103 = (int*)sub_48E0B0((char*)unk_4B9B10);
            sub_47FA81(v103);
            sub_47FBA3((int)v103);
            break;
        case 0x14u:
            v100 = sub_48A4E3(v144, 0) + 1;
            v102 = sub_48A4E3(v144, 1u);
            if (v102 == -1)
                v102 = 8;
            v101 = sub_48A4E3(v144, 2u);
            sub_4573CB((int)unk_4B9B10, v100, v102, v101);
            break;
        case 0x15u:
            *(_BYTE*)(thisx + 48) = sub_48A4E3(v144, 0);
            break;
        case 0x16u:
            v98 = sub_48A4E3(v144, 0);
            v99 = sub_48A4E3(v144, 1u);
            if (v99 > 6)
            {
                if (v99 == 7)
                {
                    v18 = rand();
                    dword_4B9AEC[v98] = v18 % sub_48A4E3(v144, 2u);
                }
                else if (v99 == 8)
                {
                    v97 = sub_426210((char*)unk_4B9B10);
                    v19 = sub_48A4E3(v144, 2u);
                    v20 = (const CHAR*)sub_4893BC((_DWORD*)v97, v19);
                    dword_4B9AEC[v98] = sub_476DEE(v20);
                }
            }
            else
            {
                v36 = sub_48A4E3(v144, 1u);
                v17 = sub_48A4E3(v144, 0);
                sub_4623AC((int)unk_4B9B10, v17, v36);
            }
            break;
        case 0x17u:
            v95 = sub_48A4E3(v144, 0);
            LOBYTE(v93) = sub_48A4E3(v144, 1u);
            v96 = sub_48A4E3(v144, 2u);
            v94 = 0;
            switch ((char)v93)
            {
            case 0:
                v94 = v95 == v96;
                break;
            case 1:
                v94 = v95 != v96;
                break;
            case 2:
                v94 = v95 < v96;
                break;
            case 3:
                v94 = v95 > v96;
                break;
            case 4:
                v94 = v95 <= v96;
                break;
            case 5:
                v94 = v95 >= v96;
                break;
            default:
                break;
            }
            if (v94 && *(_DWORD*)(thisx + 40) != sub_48A4E3(v144, 3u))
            {
                *(_DWORD*)(thisx + 40) = sub_48A4E3(v144, 3u);
                v143 = 0;
                sub_48A94C(thisx, 0, 1);
            }
            break;
        case 0x18u:
            LOBYTE(v92) = sub_48A4E3(v144, 0);
            v91 = sub_48A4E3(v144, 2u);
            switch (sub_48A4E3(v144, 1u))
            {
            case 0:
                dword_4B9AEC[(unsigned __int8)v92] = v91;
                break;
            case 1:
                dword_4B9AEC[(unsigned __int8)v92] += v91;
                break;
            case 2:
                dword_4B9AEC[(unsigned __int8)v92] -= v91;
                break;
            case 3:
                dword_4B9AEC[(unsigned __int8)v92] *= v91;
                break;
            case 4:
                if (!v91)
                    v91 = 1;
                dword_4B9AEC[(unsigned __int8)v92] /= v91;
                break;
            case 5:
                if (!v91)
                    v91 = 1;
                dword_4B9AEC[(unsigned __int8)v92] %= v91;
                break;
            default:
                goto LABEL_327;
            }
            break;
        case 0x19u:
            v90 = sub_48A4E3(v144, 0);
            v89 = sub_48A4E3(v144, 1u);
            v88 = sub_48A4E3(v144, 2u);
            v87 = sub_426210((char*)unk_4B9B10);
            sub_489629((_DWORD*)v87, v90, v89, v88);
            break;
        case 0x1Au:
            v85 = sub_48A4E3(v144, 0);
            v86 = sub_426210((char*)unk_4B9B10);
            sub_4896E8((_DWORD*)v86, v85, (Concurrency::details::UMSFreeVirtualProcessorRoot*)thisx);
            break;
        case 0x1Bu:
            sub_442863(&v82);
            v84 = sub_48A4E3(v144, 0);
            if (sub_48A4E3(v144, 1u))
            {
                v82 = sub_48A4E3(v144, 2u);
                v83 = sub_48A4E3(v144, 3u);
            }
            else
            {
                v21 = *(_DWORD*)(thisx + 104) / 100;
                v82 = sub_48A4E3(v144, 2u) + v21;
                v22 = *(_DWORD*)(thisx + 108) / 100;
                v83 = sub_48A4E3(v144, 3u) + v22;
            }
            sub_4561A5((char*)unk_4B9B10, (int)&v82);
            break;
        case 0x1Cu:
            *(_DWORD*)(thisx + 92) = sub_48A4E3(v144, 0);
            break;
        case 0x1Du:
            *(_BYTE*)(thisx + 86) = sub_48A4E3(v144, 0);
            break;
        case 0x1Eu:
            v79 = sub_48A4E3(v144, 0);
            v76 = 100 * sub_48A4E3(v144, 1u);
            v78 = sub_48A4E3(v144, 2u);
            v75 = 100 * sub_48A4E3(v144, 3u);
            v80 = sub_48A4E3(v144, 4u);
            v77 = 100 * sub_48A4E3(v144, 5u);
            v81 = sub_48A4E3(v144, 6u);
            if (!v81)
                v81 = 1;
            if (v79)
                *(_DWORD*)(thisx + 116) = (v76 - *(_DWORD*)(thisx + 104)) / v81;
            if (v78)
                *(_DWORD*)(thisx + 120) = (v75 - *(_DWORD*)(thisx + 108)) / v81;
            if (v80)
                *(_DWORD*)(thisx + 124) = (v77 - *(_DWORD*)(thisx + 112)) / v81;
            if (sub_48A4E3(v144, 7u))
            {
                if (v81 <= 0)
                    v39 = -v81;
                else
                    v39 = v81;
                *(_DWORD*)(thisx + 164) = v39;
            }
            break;
        case 0x1Fu:
            if (sub_48A4E3(v144, 0) == 2)
            {
                *(_DWORD*)(thisx + 52) = *(_DWORD*)(thisx + 52) == 0;
            }
            else if (sub_48A4E3(v144, 0) != 3)
            {
                *(_DWORD*)(thisx + 52) = sub_48A4E3(v144, 0) == 1;
            }
            if (sub_48A4E3(v144, 1u) == 1)
            {
                *(_DWORD*)(thisx + 56) = *(_DWORD*)(thisx + 56) == 0;
            }
            else if (sub_48A4E3(v144, 1u))
            {
                *(_DWORD*)(thisx + 56) = sub_48A4E3(v144, 1u) == 3;
            }
            if (sub_48A4E3(v144, 2u) == 1)
            {
                *(_DWORD*)(thisx + 60) = *(_DWORD*)(thisx + 60) == 0;
            }
            else if (sub_48A4E3(v144, 2u))
            {
                *(_DWORD*)(thisx + 60) = sub_48A4E3(v144, 2u) == 3;
            }
            break;
        case 0x20u:
            v73 = sub_48A4E3(v144, 0);
            if (v73 < 0)
                v73 = *(char*)(thisx + 86);
            v74 = sub_48A4E3(v144, 1u);
            if (v73 >= 0 && v74 >= 0 && v74 <= 255)
            {
                v37 = sub_48A4E3(v144, 4u);
                v34 = sub_48A4E3(v144, 3u);
                v23 = sub_48A4E3(v144, 2u);
                sub_4A0B26((unsigned __int16*)(8 * v73 + 4952720), v74, v23, v34, v37);
            }
            break;
        case 0x21u:
            v71 = sub_48A4E3(v144, 0);
            v70 = sub_48A4E3(v144, 1u);
            v72 = sub_48A4E3(v144, 2u);
            if (v72 <= 0)
                v72 = 1;
            v69 = *(_DWORD*)(thisx + 40) + 1;
            if (v69 < dword_4CA1D4)
            {
                v68 = sub_426210((char*)unk_4B9B10);
                sub_489B1D((_DWORD*)v68, v71, v70, (char*)(50 * v69 + dword_4CA1D8), v72);
            }
            ++* (_DWORD*)(thisx + 40);
            break;
        case 0x22u:
            v64 = sub_426210((char*)unk_4B9B10);
            v67 = unknown_libname_11((_DWORD*)v64);
            v66 = sub_48A4E3(v144, 0);
            v65 = sub_48A4E3(v144, 1u);
            if (v66 == 1)
            {
                sub_486947((int*)v64, v65, 0);
            }
            else if (v66 == 2)
            {
                sub_486947((int*)v64, v65 + v67 + 160, 0);
            }
            break;
        case 0x23u:
            v63 = sub_48A4E3(v144, 0);
            v62 = sub_48A4E3(v144, 1u);
            if (v63 > 0)
            {
                if (v63 == 3)
                    *(_DWORD*)(thisx + 64) = *(_DWORD*)(thisx + 64) == 0;
                else
                    *(_DWORD*)(thisx + 64) = v63 == 1;
            }
            if (v62 > 0)
            {
                if (v62 == 3)
                    *(_DWORD*)(thisx + 68) = *(_DWORD*)(thisx + 68) == 0;
                else
                    *(_DWORD*)(thisx + 68) = v62 == 1;
            }
            break;
        case 0x24u:
            if (sub_48A4E3(v144, 0))
                *(_WORD*)(thisx + 72) = sub_48A4E3(v144, 1u);
            if (sub_48A4E3(v144, 2u))
                *(_WORD*)(thisx + 74) = sub_48A4E3(v144, 3u);
            break;
        case 0x25u:
            *(_BYTE*)(thisx + 84) = sub_48A4E3(v144, 0);
            break;
        case 0x26u:
            *(_DWORD*)(thisx + 80) = sub_48A4E3(v144, 0);
            break;
        case 0x27u:
            v38 = sub_48A4E3(v144, 1u);
            v24 = sub_48A4E3(v144, 0);
            sub_440D69((int)unk_4BDB28, v24 + 1, v38);
            break;
        case 0x28u:
            v58 = sub_48A4E3(v144, 0);
            v57 = sub_48A4E3(v144, 1u);
            v61 = v58 + 1;
            v59 = v57 + 1;
            if (v58 == -1 && v57 == -1)
            {
                v58 = dword_4CA1E0;
                v57 = dword_4CA1E4;
                v61 = dword_4CA1E8 + 1;
                v59 = dword_4CA1EC + 1;
            }
            for (k = 0; k < 4; ++k)
            {
                v55 = sub_48A4E3(v144, 3 * k + 2);
                if (v55)
                {
                    sub_4744CC((_DWORD*)unk_4B9B10, 1);
                    v25 = sub_426210((char*)unk_4B9B10);
                    v56 = unknown_libname_20(v25);
                    for (m = v57; m < v59; ++m)
                    {
                        for (n = v58; n < v61; ++n)
                        {
                            v48 = (Concurrency::details::_UnrealizedChore*)sub_4741F8((int)unk_4B9B10, n, m);
                            if (v48)
                            {
                                sub_482A1B((int)v56, n, m, 1);
                                RuntimeOwnsLifetime = 0;
                                v49 = sub_48A4E3(v144, 3 * k + 4);
                                v50 = 0;
                                if (sub_48A4E3(v144, 3 * k + 3) == 1)
                                {
                                    switch (v55)
                                    {
                                    case 1:
                                        RuntimeOwnsLifetime = (unsigned __int8)unknown_libname_5((char*)v48);
                                        break;
                                    case 2:
                                        RuntimeOwnsLifetime = (unsigned __int8)unknown_libname_6((char*)v48);
                                        break;
                                    case 3:
                                        RuntimeOwnsLifetime = (unsigned __int8)sub_425FD0((char*)v48);
                                        break;
                                    case 4:
                                        RuntimeOwnsLifetime = (__int16)sub_426110((short*)v48);
                                        break;
                                    case 5:
                                        RuntimeOwnsLifetime = (__int16)sub_426130((short*)v48);
                                        break;
                                    case 6:
                                        RuntimeOwnsLifetime = (unsigned __int8)sub_425C30((char*)v48);
                                        break;
                                    case 7:
                                        RuntimeOwnsLifetime = sub_425C50((char*)v48);
                                        break;
                                    case 8:
                                        RuntimeOwnsLifetime = Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime(v48);
                                        break;
                                    case 9:
                                        RuntimeOwnsLifetime = (unsigned __int8)sub_426150((char*)v48);
                                        break;
                                    case 10:
                                        RuntimeOwnsLifetime = (unsigned __int16)sub_4260F0((short*)v48);
                                        break;
                                    case 11:
                                        RuntimeOwnsLifetime = (unsigned __int8)sub_425C70((char*)v48);
                                        v50 = sub_425C90((char*)v48);
                                        break;
                                    default:
                                        break;
                                    }
                                }
                                switch (v55)
                                {
                                case 1:
                                    sub_489F80((char*)v48, v49 + RuntimeOwnsLifetime);
                                    break;
                                case 2:
                                    sub_489FA0((char*)v48, v49 + RuntimeOwnsLifetime);
                                    break;
                                case 3:
                                    sub_489FC0((char*)v48, v49 + RuntimeOwnsLifetime);
                                    break;
                                case 4:
                                    sub_489FE0((short*)v48, v49 + RuntimeOwnsLifetime);
                                    break;
                                case 5:
                                    sub_48A000((short*)v48, v49 + RuntimeOwnsLifetime);
                                    break;
                                case 6:
                                    sub_48A020((char*)v48, v49 + RuntimeOwnsLifetime);
                                    break;
                                case 7:
                                    sub_4822B3((char*)v48, v49 + RuntimeOwnsLifetime != 0);
                                    break;
                                case 8:
                                    _SetRuntimeOwnsLifetime(v48, v49 + RuntimeOwnsLifetime);
                                    break;
                                case 9:
                                    _SetDetached(v48, v49 + RuntimeOwnsLifetime);
                                    break;
                                case 10:
                                    sub_489F40((short*)v48, v49 + RuntimeOwnsLifetime);
                                    break;
                                case 11:
                                    if (v50)
                                        v51 = v49 / -10 == 0;
                                    else
                                        v51 = v49 / 10;
                                    sub_482AE0((char*)v48, v49 % 10 + RuntimeOwnsLifetime);
                                    sub_482B1C((char*)v48, v51);
                                    break;
                                default:
                                    continue;
                                }
                            }
                        }
                    }
                }
            }
            break;
        case 0x29u:
            dword_4CA1E0 = sub_48A4E3(v144, 0);
            dword_4CA1E4 = sub_48A4E3(v144, 1u);
            dword_4CA1E8 = sub_48A4E3(v144, 2u);
            dword_4CA1EC = sub_48A4E3(v144, 3u);
            break;
        case 0x2Au:
            v47 = sub_48A4E3(v144, 0);
            if (v47)
            {
                switch (v47)
                {
                case 1:
                    *(_BYTE*)(thisx + 224) = sub_48A4E3(v144, 1u);
                    *(_BYTE*)(thisx + 238) = sub_48A4E3(v144, 2u);
                    *(_DWORD*)(thisx + 304) = sub_48A4E3(v144, 3u);
                    *(_WORD*)(thisx + 344) = sub_48A4E3(v144, 4u);
                    *(_BYTE*)(thisx + 313) = sub_48A4E3(v144, 5u);
                    *(_BYTE*)(thisx + 234) = sub_48A4E3(v144, 6u);
                    *(_WORD*)(thisx + 236) = sub_48A4E3(v144, 7u);
                    break;
                case 2:
                    for (ii = 0; ii < 6; ++ii)
                    {
                        *(_BYTE*)(ii + thisx + 239) = sub_48A4E3(v144, 2 * ii + 1);
                        *(_DWORD*)(thisx + 4 * ii + 248) = sub_48A4E3(v144, 2 * ii + 2);
                    }
                    *(_DWORD*)(thisx + 272) = sub_48A4E3(v144, 0xDu);
                    *(_DWORD*)(thisx + 276) = sub_48A4E3(v144, 0xEu);
                    break;
                case 3:
                    v45 = sub_48A4E3(v144, 3u);
                    if (!v45)
                        v45 = 1;
                    v26 = sub_48A4E3(v144, 1u);
                    v27 = sub_48A4E3(v144, 2u);
                    *(_DWORD*)(thisx + 284) = v27 * sub_426970((_DWORD*)unk_4B9B10) / v45 + v26;
                    break;
                default:
                    if (v47 == 4 && sub_48A4E3(v144, 1u) == 1)
                        memset((void*)(thisx + 336), 0, 8u);
                    break;
                }
            }
            else
            {
                *(_BYTE*)(thisx + 346) = sub_48A4E3(v144, 1u);
                *(_DWORD*)(thisx + 348) = sub_48A4E3(v144, 2u);
                *(_DWORD*)(thisx + 352) = sub_48A4E3(v144, 3u);
                *(_DWORD*)(thisx + 356) = sub_48A4E3(v144, 4u);
                *(_DWORD*)(thisx + 360) = sub_48A4E3(v144, 5u);
                *(_DWORD*)(thisx + 380) = sub_48A4E3(v144, 6u);
                *(_DWORD*)(thisx + 384) = sub_48A4E3(v144, 7u);
                if (*(_BYTE*)(thisx + 346) == 2)
                {
                    *(_DWORD*)(thisx + 364) = -sub_48A4E3(v144, 4u);
                    *(_DWORD*)(thisx + 368) = -sub_48A4E3(v144, 5u);
                    *(_DWORD*)(thisx + 372) = -sub_48A4E3(v144, 2u) - *(_DWORD*)(thisx + 364);
                    *(_DWORD*)(thisx + 376) = -sub_48A4E3(v144, 3u) - *(_DWORD*)(thisx + 368);
                }
                else
                {
                    memcpy((void*)(thisx + 364), (const void*)(thisx + 348), 0x10u);
                }
            }
            break;
        case 0x2Bu:
            v28 = sub_48A4E3(v144, 0);
            if (v28)
            {
                v44 = sub_474471((int)unk_4B9B10, v28);
                if (v44)
                {
                    v43 = sub_48A4E3(v144, 1u);
                    if (v43)
                    {
                        if (v43 == 1)
                        {
                            *(_BYTE*)(v44 + 10) = sub_48A4E3(v144, 2u);
                            *(_BYTE*)(v44 + 6) = sub_48A4E3(v144, 3u);
                            *(_WORD*)(v44 + 8) = sub_48A4E3(v144, 4u);
                            *(_BYTE*)(v44 + 52) = sub_48A4E3(v144, 5u);
                        }
                        else if (v43 == 3)
                        {
                            *(_WORD*)v44 = sub_48A4E3(v144, 2u);
                            *(_WORD*)(v44 + 2) = sub_48A4E3(v144, 3u);
                            *(_WORD*)(v44 + 4) = sub_48A4E3(v144, 4u);
                        }
                    }
                    else
                    {
                        for (jj = 0; jj < 6; ++jj)
                        {
                            *(_BYTE*)(jj + v44 + 11) = sub_48A4E3(v144, 2 * jj + 2);
                            *(_DWORD*)(v44 + 4 * jj + 20) = sub_48A4E3(v144, 2 * jj + 3);
                        }
                        *(_DWORD*)(v44 + 44) = sub_48A4E3(v144, 0xEu);
                        *(_DWORD*)(v44 + 48) = sub_48A4E3(v144, 0xFu);
                    }
                }
            }
            break;
        case 0xFDu:
            v41 = sub_426210((char*)unk_4B9B10);
            v29 = sub_48A4E3(v144, 0);
            v30 = (const CHAR*)sub_4893BC((_DWORD*)v41, v29);
            sub_474011((char*)unk_4B9B10, v30);
            sub_48E090((_DWORD*)unk_4B9B10, 1);
            *(_BYTE*)(thisx + 12) = 0;
            return;
        case 0xFEu:
            sub_48E090((_DWORD*)unk_4B9B10, 1);
            *(_BYTE*)(thisx + 12) = 0;
            return;
        case 0xFFu:
            if (*(_BYTE*)(thisx + 148))
            {
                if (*(unsigned __int8*)(thisx + 148) != 255)
                    --* (_BYTE*)(thisx + 148);
                if (*(_BYTE*)(thisx + 148))
                    *(_DWORD*)(thisx + 40) = *(_DWORD*)(thisx + 160);
                else
                    *(_DWORD*)(thisx + 40) = *(_DWORD*)(thisx + 156) + 1;
            }
            else
            {
                *(_DWORD*)(thisx + 40) = *(_DWORD*)(thisx + 16);
            }
            sub_48A94C(thisx, 0, 1);
            v143 = 0;
            break;
        }
    LABEL_327:
        if (v143)
        {
            if (a2)
            {
                v145 = a3 - 1;
                if (v145 > 0)
                    sub_48A94C(thisx, a2 + 50, v145);
            }
            else
            {
                ++* (_DWORD*)(thisx + 40);
                sub_48A94C(thisx, 0, 1);
            }
        }
    }
} 
void sub_48CD23(int thisx)
{
    BOOL v1; // [esp+0h] [ebp-78h]
    BOOL v2; // [esp+4h] [ebp-74h]
    BOOL v3; // [esp+8h] [ebp-70h]
    BOOL v4; // [esp+Ch] [ebp-6Ch]
    BOOL v5; // [esp+10h] [ebp-68h]
    int v7; // [esp+18h] [ebp-60h]
    int v8; // [esp+1Ch] [ebp-5Ch]
    char* v9; // [esp+28h] [ebp-50h]
    int v10; // [esp+30h] [ebp-48h]
    int v11; // [esp+34h] [ebp-44h]
    int v12; // [esp+38h] [ebp-40h]
    int v13; // [esp+3Ch] [ebp-3Ch]
    int i; // [esp+4Ch] [ebp-2Ch]
    int j; // [esp+4Ch] [ebp-2Ch]
    int v16; // [esp+50h] [ebp-28h]
    int v17; // [esp+58h] [ebp-20h]
    int v18; // [esp+5Ch] [ebp-1Ch]
    int v19; // [esp+60h] [ebp-18h]
    int v20; // [esp+64h] [ebp-14h]
    int v21; // [esp+70h] [ebp-8h]

    if (*(_BYTE*)(thisx + 12) && !*(_DWORD*)(thisx + 100))
    {
        for (i = 0; i < (unsigned __int8)byte_4B9985; ++i)
        {
            if (*(_BYTE*)(i + thisx + 336))
                --* (_BYTE*)(i + thisx + 336);
        }
        v9 = sub_426210((char*)unk_4B9B10);
        v21 = sub_486633((_DWORD*)v9, *(_DWORD*)(thisx + 104) / 100, *(_DWORD*)(thisx + 108) / 100);
        v13 = *(_DWORD*)(thisx + 104);
        v11 = *(_DWORD*)(thisx + 108);
        *(_DWORD*)(thisx + 104) = *(_DWORD*)(thisx + 116) + v13;
        *(_DWORD*)(thisx + 108) += *(_DWORD*)(thisx + 120);
        *(_DWORD*)(thisx + 112) += *(_DWORD*)(thisx + 124);
        *(_DWORD*)(thisx + 116) += *(_DWORD*)(thisx + 128);
        *(_DWORD*)(thisx + 120) += *(_DWORD*)(thisx + 132);
        *(_DWORD*)(thisx + 124) += *(_DWORD*)(thisx + 136);
        if (*(int*)(thisx + 164) > 0 && (int)-- * (_DWORD*)(thisx + 164) <= 0)
        {
            *(_DWORD*)(thisx + 116) = 0;
            *(_DWORD*)(thisx + 120) = 0;
            *(_DWORD*)(thisx + 124) = 0;
        }
        v17 = sub_486633((_DWORD*)v9, *(_DWORD*)(thisx + 104) / 100, *(_DWORD*)(thisx + 108) / 100);
        v16 = sub_486633((_DWORD*)v9, *(_DWORD*)(thisx + 104) / 100, v11 / 100);
        v18 = sub_486633((_DWORD*)v9, v13 / 100, *(_DWORD*)(thisx + 108) / 100);
        sub_4868C1(v9, *(_DWORD*)(thisx + 104) / 800, *(_DWORD*)(thisx + 108) / 800);
        v12 = 0;
        v10 = 0;
        v19 = 100 * sub_4897D0(v9);
        v20 = 800 * sub_4261D0(v9);
        v5 = *(int*)(thisx + 104) <= 0 && *(int*)(thisx + 116) < 0
            || *(_DWORD*)(thisx + 104) >= v19 && *(int*)(thisx + 116) > 0;
        v4 = *(int*)(thisx + 108) <= 0 && *(int*)(thisx + 120) < 0
            || *(_DWORD*)(thisx + 108) >= v20 && *(int*)(thisx + 120) > 0;
        v3 = *(_DWORD*)(thisx + 116) && v21 < v16&& v16 - v21 >= 8 && *(_DWORD*)(thisx + 112) <= 100 * v17;
        v2 = *(_DWORD*)(thisx + 120) && v21 < v18&& v18 - v21 >= 8 && *(_DWORD*)(thisx + 112) <= 100 * v17;
        v1 = !v3
            && !v2
            && *(_DWORD*)(thisx + 116)
            && *(_DWORD*)(thisx + 120)
            && v21 < v17
            && v17 - v21 >= 8
            && *(_DWORD*)(thisx + 112) <= 100 * v17;
        for (j = 0; j < 7; ++j)
        {
            if (*(int*)(thisx + 8 * j + 172) >= 0)
            {
                v8 = 0;
                if (j || !v5)
                {
                    if (j == 3 && v4)
                    {
                        if (*(int*)(thisx + 108) > 0)
                            *(_DWORD*)(thisx + 108) = v20 - 1;
                        else
                            *(_DWORD*)(thisx + 108) = 0;
                        v8 = 1;
                    }
                    else if (j == 4 && !v5 && (v3 || v1))
                    {
                        *(_DWORD*)(thisx + 104) = 800 * (*(_DWORD*)(thisx + 104) / 800);
                        *(_DWORD*)(thisx + 104) += 800 * (*(int*)(thisx + 116) < 0) - (*(_DWORD*)(thisx + 116) > 0);
                        v8 = 1;
                    }
                    else if (j == 5 && !v4 && (v2 || v1))
                    {
                        *(_DWORD*)(thisx + 108) = 800 * (*(_DWORD*)(thisx + 108) / 800);
                        *(_DWORD*)(thisx + 108) += 800 * (*(int*)(thisx + 120) < 0) - (*(_DWORD*)(thisx + 120) > 0);
                        v8 = 1;
                    }
                    else if (j == 1)
                    {
                        v7 = sub_486633((_DWORD*)v9, *(_DWORD*)(thisx + 104) / 100, *(_DWORD*)(thisx + 108) / 100);
                        if (*(int*)(thisx + 104) <= 0
                            || *(_DWORD*)(thisx + 104) >= v19
                            || *(int*)(thisx + 108) <= 0
                            || *(_DWORD*)(thisx + 108) >= v20)
                        {
                            v7 = 0;
                        }
                        if (*(int*)(thisx + 124) < 0 && *(_DWORD*)(thisx + 112) <= 100 * v7)
                        {
                            *(_DWORD*)(thisx + 112) = 100 * v7;
                            v8 = 1;
                        }
                    }
                }
                else
                {
                    if (*(int*)(thisx + 104) > 0)
                        *(_DWORD*)(thisx + 104) = v19;
                    else
                        *(_DWORD*)(thisx + 104) = 0;
                    v8 = 1;
                }
                if (v8)
                {
                    *(_DWORD*)(thisx + 40) = *(_DWORD*)(thisx + 8 * j + 172);
                    *(_DWORD*)(thisx + 8 * j + 172) = -1;
                    *(_BYTE*)(thisx + 148) = 0;
                    *(_DWORD*)(thisx + 152) = 0;
                    sub_48A94C(thisx, 0, 1);
                    v10 = 1;
                }
            }
        }
        if (!v10)
        {
            if (*(int*)(thisx + 152) > 0 && !-- * (_DWORD*)(thisx + 152))
            {
                *(_BYTE*)(thisx + 148) = 0;
                *(_DWORD*)(thisx + 40) = *(_DWORD*)(thisx + 156) + 1;
                v12 = 1;
            }
            if (!v12 && *(_WORD*)(thisx + 10))
            {
                if (*(__int16*)(thisx + 10) > 0)
                    --* (_WORD*)(thisx + 10);
                if (*(__int16*)(thisx + 10) <= 0)
                {
                    if (!*(_WORD*)(thisx + 10))
                        ++* (_DWORD*)(thisx + 40);
                    if (*(_DWORD*)(thisx + 40) >= dword_4CA1D4)
                        *(_DWORD*)(thisx + 40) = *(_DWORD*)(thisx + 16);
                    v12 = 1;
                }
            }
            if (v12)
                sub_48A94C(thisx, 0, 1);
        }
    }
}
 
unsigned __int16* sub_48D421(int thisx, int a2)
{
    unsigned __int16* result; // eax
    int v3; // esi
    int v4; // esi
    int v5; // eax
    int j; // [esp+8h] [ebp-B8h]
    unsigned __int16 v8; // [esp+Ch] [ebp-B4h]
    int v9; // [esp+10h] [ebp-B0h]
    unsigned __int16 v10; // [esp+14h] [ebp-ACh]
    int v11; // [esp+18h] [ebp-A8h]
    int i; // [esp+1Ch] [ebp-A4h]
    int v13; // [esp+20h] [ebp-A0h]
    int v14; // [esp+24h] [ebp-9Ch]
    int v15; // [esp+28h] [ebp-98h]
    int v16; // [esp+2Ch] [ebp-94h]
    int v17; // [esp+30h] [ebp-90h]
    char* v18; // [esp+34h] [ebp-8Ch]
    _DWORD* v19; // [esp+38h] [ebp-88h]
    int v20[2]; // [esp+3Ch] [ebp-84h] BYREF
    unsigned int v21; // [esp+44h] [ebp-7Ch]
    int v22; // [esp+74h] [ebp-4Ch]
    int v23; // [esp+78h] [ebp-48h]
    int v24; // [esp+7Ch] [ebp-44h]
    _BYTE* v25; // [esp+80h] [ebp-40h]
    int v26; // [esp+84h] [ebp-3Ch]
    int v27; // [esp+88h] [ebp-38h] BYREF
    int v28; // [esp+8Ch] [ebp-34h]
    int v29; // [esp+90h] [ebp-30h]
    int v30; // [esp+A0h] [ebp-20h]
    int v31; // [esp+A4h] [ebp-1Ch]
    int v32; // [esp+BCh] [ebp-4h]

    result = (unsigned __int16*)thisx;
    if (*(_BYTE*)(thisx + 12))
    {
        if (*(_DWORD*)(thisx + 44) == -1 || *(_DWORD*)(thisx + 96))
        {
            return sub_48DD3C(thisx);
        }
        else
        {
            sub_49C15E((int)&v27);
            v26 = *(__int16*)(thisx + 72) * sub_446465((char*)unk_4B9B10) / 100;
            if (*(_BYTE*)(thisx + 8) && *(_BYTE*)(thisx + 8) != 1)
            {
                if (*(_BYTE*)(thisx + 8) == 2)
                {
                    v28 = *(_DWORD*)(thisx + 140) + *(_DWORD*)(thisx + 104) / 100 - v26;
                    v3 = *(_DWORD*)(thisx + 108) / 100 - *(_DWORD*)(thisx + 112) / 100;
                    v29 = *(_DWORD*)(thisx + 144) + sub_4464BA((int)unk_4B9B10) + v3;
                }
                else if (*(_BYTE*)(thisx + 8) == 3)
                {
                    v28 = *(_DWORD*)(thisx + 140) + *(_DWORD*)(thisx + 104) / 100;
                    v29 = *(_DWORD*)(thisx + 144) + *(_DWORD*)(thisx + 108) / 100;
                }
            }
            else
            {
                v28 = *(_DWORD*)(thisx + 140) + *(_DWORD*)(thisx + 104) / 100 - v26;
                v29 = *(_DWORD*)(thisx + 144) + *(_DWORD*)(thisx + 108) / 100 - *(_DWORD*)(thisx + 112) / 100;
            }
            if (*(_DWORD*)(thisx + 92))
            {
                v25 = (_BYTE*)sub_4741F8((int)unk_4B9B10, *(_DWORD*)(thisx + 104) / 800, *(_DWORD*)(thisx + 108) / 800);
                v24 = sub_446497((int*)unk_4B9B10, *(_DWORD*)(thisx + 104) / 100, *(_DWORD*)(thisx + 108) / 100);
                if (v25 && sub_425C50(v25))
                    v24 = 4 * (unsigned __int8)unknown_libname_6(v25);
                if (100 * v24 < *(_DWORD*)(thisx + 112))
                {
                    v22 = 0;
                    if (v25)
                        v22 = (unsigned __int8)sub_425C30(v25);
                    LOBYTE(v23) = sub_4464F6((_DWORD*)unk_4B9B10, *(_DWORD*)(thisx + 104) / 800, *(_DWORD*)(thisx + 108) / 800);
                    sub_49C15E((int)v20);
                    v20[0] = dword_4B9214;
                    v20[1] = v28 - *(_DWORD*)(thisx + 140) - 8;
                    v4 = *(_DWORD*)(thisx + 108) / 100 - v24;
                    v21 = v4 + sub_4464BA((int)unk_4B9B10) - 2;
                    if ((unsigned __int8)v23 == 11)
                    {
                        if (!(dword_4B93B0 % 2u))
                        {
                            if (v25)
                                v21 -= v22;
                            sub_49AB05((int)unk_4BDC60, v20);
                        }
                    }
                    else if (!v22)
                    {
                        sub_49AB05((int)unk_4BDC60, v20);
                    }
                }
            }
            v30 = *(_DWORD*)(thisx + 52);
            if (*(_DWORD*)(thisx + 56))
                v30 = *(_DWORD*)(thisx + 52) == 0;
            v31 = *(_DWORD*)(thisx + 60);
            if (*(_BYTE*)(thisx + 48) == 1)
            {
                v18 = sub_426210((char*)unk_4B9B10);
                v19 = (_DWORD*)sub_489A73(v18, *(unsigned __int8*)(thisx + 76));
                if (*(char*)(thisx + 86) >= 0)
                    v32 = 8 * *(char*)(thisx + 86) + 4952720;
                if (v19)
                {
                    if (*(int*)(thisx + 88) < 0)
                        sub_40159F(v19, (int)&v27, *(_DWORD*)(thisx + 44), *(_DWORD*)(thisx + 80));
                    else
                        sub_4015C7((int)v19, (int)&v27, *(_DWORD*)(thisx + 44), *(_DWORD*)(thisx + 88), *(_DWORD*)(thisx + 80));
                }
            }
            else if (*(unsigned __int8*)(thisx + 48) <= 1u)
            {
                v9 = 1;
                v11 = 1;
                v27 = a2 + *(_DWORD*)(thisx + 44);
                if (*(_DWORD*)(thisx + 64))
                {
                    v10 = sub_48E0F0((char*)unk_4BDC60, v27);
                    v9 = (320 % v10 != 0) + 320 / v10;
                    if (v28 % v10)
                    {
                        v28 = v28 % v10 - (v28 > 0) * v10;
                        ++v9;
                    }
                    else
                    {
                        v28 = 0;
                    }
                }
                if (*(_DWORD*)(thisx + 68))
                {
                    v8 = sub_48E110((char*)unk_4BDC60, v27);
                    v11 = (240 % v8 != 0) + 240 / v8;
                    if (v29 % v8)
                    {
                        v29 = v29 % v8 - (v29 > 0) * v8;
                        ++v11;
                    }
                    else
                    {
                        v29 = 0;
                    }
                }
                for (i = 0; i < v11; ++i)
                {
                    for (j = 0; j < v9; ++j)
                    {
                        sub_49AB05((int)unk_4BDC60, &v27);
                        v28 += v10;
                    }
                    v28 -= v10 * v9;
                    v29 += v8;
                }
            }
            else
            {
                v13 = sub_462234((_DWORD*)unk_4B9B10, *(unsigned __int8*)(thisx + 48) - 1, *(_DWORD*)(thisx + 44));
                v14 = sub_46231F((_DWORD*)unk_4B9B10, *(unsigned __int8*)(thisx + 48) - 1);
                v27 = sub_462556((_DWORD*)unk_4B9B10, *(unsigned __int8*)(thisx + 48) - 1 - 2 * (*(unsigned __int8*)(thisx + 48) >= 4u));
                v16 = sub_426590(unk_4B9B10, (*(unsigned __int8*)(thisx + 48) - 2) % 2);
                v15 = (unsigned __int16)sub_4266F0((short*)v16);
                v5 = sub_4682AC((unsigned char*)v16);
                v17 = v5;
                LOBYTE(v5) = *(_BYTE*)(thisx + 84);
                sub_4788FA(&v27, (char*)v13, v14, v15, v17, v5);
            }
            return sub_48DD3C(thisx);
        }
    }
    return result;
}

 
void sub_48DC0D(int thisx, int a2)
{
    if (a2 >= 0)
    {
        *(_DWORD*)(thisx + 40) = a2;
        *(_BYTE*)(thisx + 148) = 0;
        *(_DWORD*)(thisx + 152) = 0;
        sub_48A94C(thisx, 0, 1);
    }
}

 
int sub_48DC4E(_DWORD* thisx, int a2, int a3, int a4)
{
    int result; // eax

    thisx[26] = a2;
    result = a3;
    thisx[27] = a3;
    thisx[28] = a4;
    return result;
}

 
void sub_48DC76(int thisx, int a2, int a3)
{
    int v3; // [esp+4h] [ebp-4h]

    if (!a2)
    {
        if ((*(_BYTE*)(thisx + *(unsigned __int8*)(a3 + 40) + 336) = *(_BYTE*)(thisx + 313), !*(_DWORD*)(a3 + 24))
            && *(int*)(thisx + 188) >= 0
            || *(_DWORD*)(a3 + 24) && *(int*)(thisx + 220) >= 0)
        {
            if (*(_DWORD*)(a3 + 24))
                v3 = 6;
            else
                v3 = 2;
            *(_DWORD*)(thisx + 40) = *(_DWORD*)(thisx + 8 * v3 + 172);
            *(_DWORD*)(thisx + 8 * v3 + 172) = -1;
            *(_BYTE*)(thisx + 148) = 0;
            *(_DWORD*)(thisx + 152) = 0;
            sub_48A94C(thisx, 0, 1);
        }
    }
}
 
unsigned __int16* sub_48DD3C(int thisx)
{
    int v1; // esi
    unsigned __int16* result; // eax
    int* v3; // eax
    int* v4; // eax
    int v5; // esi
    int v7[4]; // [esp+8h] [ebp-84h] BYREF
    char v8[16]; // [esp+18h] [ebp-74h] BYREF
    int v9; // [esp+28h] [ebp-64h]
    int v10; // [esp+2Ch] [ebp-60h]
    int v11; // [esp+30h] [ebp-5Ch]
    int i; // [esp+34h] [ebp-58h]
    int v13; // [esp+38h] [ebp-54h]
    int v14; // [esp+3Ch] [ebp-50h]
    int v15; // [esp+40h] [ebp-4Ch]
    int v16; // [esp+44h] [ebp-48h]
    unsigned int v17; // [esp+48h] [ebp-44h]
    int v18; // [esp+4Ch] [ebp-40h]
    int v19; // [esp+50h] [ebp-3Ch]
    int v20; // [esp+54h] [ebp-38h] BYREF
    int v21; // [esp+58h] [ebp-34h]
    unsigned int v22; // [esp+5Ch] [ebp-30h]
    int v23; // [esp+6Ch] [ebp-20h]
    int v24; // [esp+70h] [ebp-1Ch]

    v19 = *(__int16*)(thisx + 72) * sub_446465((char*)unk_4B9B10) / 100;
    v18 = *(_DWORD*)(thisx + 104) / 100 - v19;
    v1 = *(_DWORD*)(thisx + 108) / 100 - *(_DWORD*)(thisx + 112) / 100;
    v17 = sub_4464BA((int)unk_4B9B10) + v1;
    result = (unsigned __int16*)sub_49C15E((int)&v20);
    if (dword_4B93A8)
    {
        v23 = 0;
        v24 = 0;
        for (i = 0; i < 2; ++i)
        {
            if (i)
            {
                if (i == 1)
                {
                    LOBYTE(v11) = sub_4754B0((_BYTE*)thisx);
                    v4 = sub_475F00((_DWORD*)thisx, v7, *(_DWORD*)(thisx + 52));
                    v13 = *v4;
                    v14 = v4[1];
                    v15 = v4[2];
                    v16 = v4[3];
                }
            }
            else
            {
                LOBYTE(v11) = sub_48E190((char*)thisx);
                v3 = sub_48E150((_DWORD*)thisx, (_DWORD*)v8, *(_DWORD*)(thisx + 52));
                v13 = *v3;
                v14 = v3[1];
                v15 = v3[2];
                v16 = v3[3];
            }
            result = (unsigned __int16*)(unsigned __int8)v11;
            if ((_BYTE)v11 && (v13 || v14 || v15 || v16))
            {
                if ((unsigned __int8)v11 == 1)
                {
                    v18 = -v19;
                    v17 = sub_4464BA((int)unk_4B9B10);
                }
                else
                {
                    v18 = *(_DWORD*)(thisx + 104) / 100 - v19;
                    v5 = *(_DWORD*)(thisx + 108) / 100 - *(_DWORD*)(thisx + 112) / 100;
                    v17 = sub_4464BA((int)unk_4B9B10) + v5;
                }
                if (v13 > v15)
                {
                    v10 = v13;
                    v13 = v15;
                    v15 = v10;
                }
                if (v14 > v16)
                {
                    v9 = v14;
                    v14 = v16;
                    v16 = v9;
                }
                v21 = v13 + v18;
                v22 = v14 + v17;
                v20 = dword_4B9210 + 4 * i;
                sub_49AB05((int)unk_4BDC60, &v20);
                v21 = v18 + v15 - 8;
                v22 = v14 + v17;
                v20 = dword_4B9210 + 4 * i + 1;
                sub_49AB05((int)unk_4BDC60, &v20);
                v21 = v13 + v18;
                v22 = v17 + v16 - 8;
                v20 = dword_4B9210 + 4 * i + 2;
                sub_49AB05((int)unk_4BDC60, &v20);
                v21 = v18 + v15 - 8;
                v22 = v17 + v16 - 8;
                v20 = dword_4B9210 + 4 * i + 3;
                result = sub_49AB05((int)unk_4BDC60, &v20);
            }
        }
    }
    return result;
}
 
int sub_48E02B(_DWORD* thisx)
{
    int result; // eax
    int i; // [esp+4h] [ebp-4h]

    for (i = 0; i < 7; ++i)
    {
        thisx[2 * i + 43] = -1;
        result = i + 1;
    }
    return result;
}

 
_DWORD* sub_48E070(_DWORD* thisx)
{
    *(_BYTE*)thisx = 0;
    thisx[1] = -1;
    return thisx;
}

 
_DWORD* sub_48E090(_DWORD* thisx, int a2)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[324] = a2;
    return result;
}

 
char* sub_48E0B0(char* thisx)
{
    return thisx + 736;
}

 
_DWORD* sub_48E0D0(_DWORD* thisx, int a2)
{
    _DWORD* result; // eax

    result = thisx;
    thisx[323] = a2;
    return result;
}
 
int sub_48E0F0(char* thisx, int a2)
{
    return sub_4260F0((short*)&thisx[24 * a2]);
}

 
__int16 sub_48E110(char* thisx, int a2)
{
    return sub_48E130((short*)&thisx[24 * a2]);
}
 
__int16 sub_48E130(_WORD* thisx)
{
    return thisx[4];
}

 
_DWORD* sub_48E150(_DWORD* thisx, _DWORD* a2, int a3)
{
    *a2 = thisx[4 * a3 + 98];
    a2[1] = thisx[4 * a3 + 99];
    a2[2] = thisx[4 * a3 + 100];
    a2[3] = thisx[4 * a3 + 101];
    return a2;
}
 
char sub_48E190(_BYTE* thisx)
{
    return thisx[388];
}
 
void sub_48E1B0(void* thisx)
{
    *(_DWORD*)thisx = (_DWORD)&off_4AC370;
}
 
void sub_48E1C7(void* thisx)
{
    *(_DWORD*)thisx = (_DWORD)&off_4AC370;
}

 
int sub_48E1DB(int* thisx, int a2, int a3, int a4)
{
    return sub_43FFC3((_DWORD*)unk_4BDB28, thisx[2], -1, a2, a3, a4);
}

 //thsi = unk_4B9B10 + 15788
//_DWORD* sub_48E210(_DWORD* thisx)
//{
//    sub_47FC70(thisx);
//    *thisx = off_4AC374;
//    sub_480737(thisx, 9);
//    sub_47FEB2(thisx[3], (LPCSTR)&byte_4B1F62, &unk_4B1F9C, 2);
//    sub_47FEB2(thisx[3] + 32, (LPCSTR)&byte_4B21D4, &unk_4B0C59, 0);
//    sub_47FEB2(thisx[3] + 64, (LPCSTR)&byte_4B2246, &unk_4B1FC8, 0);
//    sub_47FE72((int*)thisx[3] + 96, (LPCSTR)&byte_4B22F2, 1, 0, 8, 4);//ÕâÀï¿ÉÄÜ²»ÊÇÈ¡µØÖ·Êý¾ÝÔÙÇ¿×ªÀàÐÍ£¬¶øÊÇÈ¡µØÖ·
//    sub_47FE72((int*)thisx[3] + 128, (LPCSTR)&byte_4B2352, 1, 2, 16, 8);
//    sub_47FE72((int*)thisx[3] + 160, byte_4B23F0, 1, 2, 4, 4);
//    sub_47FEB2(thisx[3] + 192, (LPCSTR)&byte_4B2746, &unk_4B0C59, 1);
//    sub_47FEB2(thisx[3] + 224, (LPCSTR)&byte_4B279E, &unk_4B2A50, 1);
//    sub_47FEB2(  *((_DWORD*)thisx + 3) + 256   , (LPCSTR)&byte_4B2A5D, &unk_4B2A75, 0);
//    *((_BYTE*)thisx + 7) = 16;
//    *((_BYTE*)thisx + 6) = 25;
//    *((_BYTE*)thisx + 29) = 19;
//    return thisx;
//}



//this = 0x005c440c
_BYTE*  sub_48E210(_BYTE* thisx)
{
    sub_47FC70(thisx);
    *(_DWORD*)thisx = off_4AC374;
    sub_480737((int*)thisx, 9);
    sub_47FEB2(*((_DWORD*)thisx + 3), byte_4B1F62, &unk_4B1F9C, 2);
    sub_47FEB2(*((_DWORD*)thisx + 3) + 32, byte_4B21D4, &unk_4B0C59, 0);
    sub_47FEB2(*((_DWORD*)thisx + 3) + 64, byte_4B2246, &unk_4B1FC8, 0);
    int a = *((_DWORD*)thisx + 3) + 96;
    sub_47FE72((int*)a, byte_4B22F2, 1, 0, 8, 4);
    a = *((_DWORD*)thisx + 3) + 128;
    sub_47FE72((int*)a, byte_4B2352, 1, 2, 16, 8);
    a = *((_DWORD*)thisx + 3) + 160;
    sub_47FE72((int*)a, byte_4B23F0, 1, 2, 4, 4);
    sub_47FEB2(*((_DWORD*)thisx + 3) + 192, byte_4B2746, &unk_4B0C59, 1);
    sub_47FEB2(*((_DWORD*)thisx + 3) + 224, byte_4B279E, &unk_4B2A50, 1);
    sub_47FEB2(*((_DWORD*)thisx + 3) + 256, byte_4B2A5D, &unk_4B2A75, 0);
    thisx[7] = 16;
    thisx[6] = 25;
    thisx[29] = 19;
    return thisx;
}

 
void sub_48E374(_DWORD* thisx)
{
    *thisx = off_4AC374;
    sub_47FCCF(thisx);
}

 
int sub_48E390(int thisx)
{
    struct _CancellationTokenState* v1; // esi
    struct _CancellationTokenState* v2; // esi
    int v5; // [esp+8h] [ebp-Ch]
    unsigned __int8* v6; // [esp+Ch] [ebp-8h]
    int v7; // [esp+10h] [ebp-4h]

    v6 = (unsigned __int8*)sub_47EFA0((char*)unk_4B9B10);
    sub_480016(*(_DWORD**)(thisx + 12), v6[369]);
    sub_480016((_DWORD*)(*(_DWORD*)(thisx + 12) + 32), v6[228]);
    sub_480016((_DWORD*)(*(_DWORD*)(thisx + 12) + 64), v6[371]);
    sub_480016((_DWORD*)(*(_DWORD*)(thisx + 12) + 96), v6[178]);
    sub_480016((_DWORD*)(*(_DWORD*)(thisx + 12) + 128), v6[252]);
    delbuf((ios*)(*(_DWORD*)(thisx + 12) + 128), v6[376]);
    sub_480016((_DWORD*)(*(_DWORD*)(thisx + 12) + 160), v6[376]);
    sub_480016((_DWORD*)(*(_DWORD*)(thisx + 12) + 192), v6[224]);
    sub_480016((_DWORD*)(*(_DWORD*)(thisx + 12) + 224), v6[247]);
    sub_480016((_DWORD*)(*(_DWORD*)(thisx + 12) + 256), v6[248]);
    v7 = sub_480227((_DWORD*)thisx);
    v6[369] = (unsigned __int8)_GetToken(*(_CancellationTokenRegistration**)(thisx + 12));
    v6[228] = (unsigned __int8)_GetToken((_CancellationTokenRegistration*)(*(_DWORD*)(thisx + 12) + 32));
    v6[371] = (unsigned __int8)_GetToken((_CancellationTokenRegistration*)(*(_DWORD*)(thisx + 12) + 64));
    v6[178] = (unsigned __int8)_GetToken((_CancellationTokenRegistration*)(*(_DWORD*)(thisx + 12) + 96));
    v1 = (struct _CancellationTokenState*)v6[252];
    if (v1 != _GetToken((_CancellationTokenRegistration*)(*(_DWORD*)(thisx + 12) + 128)))
    {
        v6[252] = (unsigned __int8)_GetToken((_CancellationTokenRegistration*)(*(_DWORD*)(thisx + 12) + 128));
        if (v6[252] < 2u)
            v6[252] = 2;
        if (v6[252] > dword_4B92D0)
            v6[252] = dword_4B92D0;
    }
    v2 = (struct _CancellationTokenState*)v6[376];
    if (v2 != _GetToken((_CancellationTokenRegistration*)(*(_DWORD*)(thisx + 12) + 160)))
    {
        v6[376] = (unsigned __int8)_GetToken((_CancellationTokenRegistration*)(*(_DWORD*)(thisx + 12) + 160));
        if (v6[376] >= 2u)
        {
            if (v6[376] > 4u)
                v6[376] = 4;
        }
        else
        {
            v6[376] = 2;
        }
    }
    v5 = v6[252] % (int)v6[376];
    if (v5)
        v6[252] -= v5;
    if (v6[252] < (int)v6[376])
        v6[252] = v6[376];
    sub_480016((_DWORD*)(*(_DWORD*)(thisx + 12) + 128), v6[252]);
    v6[224] = (unsigned __int8)_GetToken((_CancellationTokenRegistration*)(*(_DWORD*)(thisx + 12) + 192));
    v6[247] = (unsigned __int8)_GetToken((_CancellationTokenRegistration*)(*(_DWORD*)(thisx + 12) + 224));
    v6[248] = (unsigned __int8)_GetToken((_CancellationTokenRegistration*)(*(_DWORD*)(thisx + 12) + 256));
    return v7;
}
 
int sub_48E6E0(streambuf* thisx, int a2)
{
    unsigned __int8* v4; // [esp+4h] [ebp-4h]

    sub_48070C(thisx, a2);
    v4 = (unsigned __int8*)sub_47EFA0((char*)unk_4B9B10);
    sub_480016(*((_DWORD**)thisx + 3), v4[369]);
    sub_480016((_DWORD*)(*((_DWORD*)thisx + 3) + 32), v4[228]);
    sub_480016((_DWORD*)(*((_DWORD*)thisx + 3) + 64), v4[371]);
    sub_480016((_DWORD*)(*((_DWORD*)thisx + 3) + 96), v4[178]);
    sub_480016((_DWORD*)(*((_DWORD*)thisx + 3) + 128), v4[252]);
    delbuf((ios*)(*((_DWORD*)thisx + 3) + 128), v4[376]);
    sub_480016((_DWORD*)(*((_DWORD*)thisx + 3) + 160), v4[376]);
    sub_480016((_DWORD*)(*((_DWORD*)thisx + 3) + 192), v4[224]);
    sub_480016((_DWORD*)(*((_DWORD*)thisx + 3) + 224), v4[247]);
    return sub_480016((_DWORD*)(*((_DWORD*)thisx + 3) + 256), v4[248]);
}
 
_DWORD* sub_48E820(_DWORD* thisx, char a2)
{
    sub_48E374(thisx);
    if ((a2 & 1) != 0)
        operator delete(thisx);
    return thisx;
}

 
_DWORD* sub_48E870(_DWORD* thisx)
{
    *thisx = off_4AC388;
    memset(thisx + 1, 0, 0x51u);
    thisx[22] = 0;
    return thisx;
}
 
_DWORD* sub_48E8A4(_DWORD* thisx)
{
    _DWORD* result; // eax

    result = thisx;
    *thisx = off_4AC388;
    return result;
}
 
int sub_48E8B8(int thisx, wchar_t* Source, int a3)
{
    int result; // eax

    wcscpy((wchar_t*)(thisx + 4), Source);
    result = a3;
    *(_DWORD*)(thisx + 88) = a3;
    return result;
}
 
int sub_48E8E1(int thisx)
{
    int result; // eax
    int v2; // eax
    struct tagRECT rc; // [esp+4h] [ebp-10h] BYREF

    result = thisx;
    if (*(_DWORD*)(thisx + 88))
    {
        --* (_DWORD*)(thisx + 88);
        v2 = lstrlenA((LPCSTR)(thisx + 4));
        SetRect(&rc, 0, 228, 4 * v2, 240);
        sub_49EF70((int)unk_4BDC60, (_DWORD*)&rc, 0, 0, 0, 0x20u);
        return sub_47B91A(0, 232, (LPCSTR)(thisx + 4), 0, -1);
    }
    return result;
}

 
_DWORD* sub_48E960(_DWORD* thisx, char a2)
{
    sub_48E8A4(thisx);
    if ((a2 & 1) != 0)
        operator delete(thisx);
    return thisx;
}

 
_BYTE* sub_48E990(_BYTE* thisx)
{
    sub_47FC70(thisx);
    *(_DWORD*)thisx = off_4AC38C;
    thisx[4] = 3;
    thisx[5] = 13;
    thisx[6] = 32;
    thisx[7] = 9;
    return thisx;
}
 
void sub_48E9CB(_DWORD* thisx)
{
    *thisx = off_4AC38C;
    sub_47FCCF(thisx);
}
 
int sub_48E9E7(_DWORD* thisx)
{
    BOOL v1; // esi
    BOOL v2; // esi
    BOOL v5; // [esp+8h] [ebp-14h]
    int v6; // [esp+Ch] [ebp-10h]
    int v7; // [esp+10h] [ebp-Ch]
    BOOL v8; // [esp+14h] [ebp-8h]
    int v9; // [esp+18h] [ebp-4h]

    v1 = sub_476D78(0);
    v7 = v1 - sub_476D29(0);
    v2 = sub_476CDA(0);
    v6 = v2 - sub_476C8B(0);
    v5 = sub_476DC7(0, 0);
    v8 = sub_476DC7(0, 1);
    v9 = 0;
    if (v7)
    {
        *((_BYTE*)thisx + thisx[5] + 36) = ((unsigned __int8)byte_4B9990 + v7 + *((unsigned __int8*)thisx + thisx[5] + 36))
            % (unsigned __int8)byte_4B9990;
        v9 = 3;
        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
    }
    else if (v6)
    {
        thisx[5] = ((unsigned __int8)byte_4B9986 + v6 + thisx[5]) % (unsigned __int8)byte_4B9986;
        v9 = 4;
        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
    }
    else if (v5)
    {
        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
        return sub_48EB7C((unsigned __int8*)thisx) == 0;
    }
    else if (v8)
    {
        return 2;
    }
    return v9;
}

 
BOOL sub_48EB7C(unsigned __int8* thisx)
{
    int i; // [esp+4h] [ebp-Ch]
    int j; // [esp+4h] [ebp-Ch]
    char v5[8]; // [esp+8h] [ebp-8h] BYREF

    memset(v5, 0, sizeof(v5));
    for (i = 0; i < (unsigned __int8)byte_4B9986; ++i)
        ++v5[thisx[i + 36]];
    for (j = 0; j < (unsigned __int8)byte_4B9990 && (unsigned __int8)v5[j] <= (int)thisx[j + 44]; ++j)
        ;
    return j < (unsigned __int8)byte_4B9990;
}

 
int __fastcall sub_48EC25(int a1, int a2, unsigned __int8 a3, unsigned __int8 a4)
{
    int result; // eax

    result = a3;
    if (a3 < 8u && a4 < 8u)
    {
        result = a1;
        *(_BYTE*)(a1 + a3 + 44) = a4;
    }
    return result;
}
 
int sub_48EC62(_BYTE* thisx)
{
    int result; // eax
    int j; // [esp+8h] [ebp-Ch]
    int v3; // [esp+Ch] [ebp-8h]
    int i; // [esp+10h] [ebp-4h]

    for (i = 0; i < 8; ++i)
    {
        v3 = i;
        for (j = 0; j < 8; ++j)
        {
            v3 -= (unsigned __int8)thisx[j + 44];
            if (v3 < 0)
                break;
        }
        thisx[(unsigned __int8)byte_4B9988[i] + 36] = j;
        result = i + 1;
    }
    return result;
}
 
int sub_48ECDE(int thisx)
{
    int result; // eax
    int k; // [esp+4h] [ebp-124h]
    int v4; // [esp+8h] [ebp-120h]
    unsigned __int8 v5; // [esp+Ch] [ebp-11Ch]
    unsigned __int8 v6; // [esp+10h] [ebp-118h]
    int v7; // [esp+14h] [ebp-114h]
    int i; // [esp+18h] [ebp-110h]
    int j; // [esp+18h] [ebp-110h]
    int v10; // [esp+1Ch] [ebp-10Ch]
    int v11; // [esp+1Ch] [ebp-10Ch]
    CHAR String[256]; // [esp+20h] [ebp-108h] BYREF
    int v13; // [esp+120h] [ebp-8h]
    int v14; // [esp+124h] [ebp-4h]

    sub_480A51((unsigned __int8*)thisx);
    v13 = *(unsigned __int8*)(thisx + 4);
    v10 = *(unsigned __int8*)(thisx + 5);
    v13 = 8 * v13 + 16;
    v11 = 8 * v10 + 16;
    v14 = 224 / (unsigned __int8)byte_4B9990;
    for (i = 0; i < (unsigned __int8)byte_4B9990; ++i)
    {
        wsprintfA(String, "%d", *(unsigned __int8*)(i + thisx + 44));
        sub_47B7ED(v14 / 2 + v13 + v14 * i - 4, v11, String, 0, dword_4B9248);
        if (i < (unsigned __int8)byte_4B9990 - 1)
            sub_47B91A(v14 + v13 + v14 * i - 4, v11, (LPCSTR)aVs, 0, dword_4B9248);
    }
    v7 = v14 / 24;
    if (!(v14 / 24))
        v7 = 1;
    for (j = 0; ; ++j)
    {
        result = (unsigned __int8)byte_4B9986;
        if (j >= (unsigned __int8)byte_4B9986)
            break;
        v5 = *(_BYTE*)(j + thisx + 36);
        v6 = 0;
        for (k = 0; k < j; ++k)
        {
            if (*(unsigned __int8*)(k + thisx + 36) == v5)
                ++v6;
        }
        v4 = 24 * (v6 % v7) + v14 * v5 + v14 / 2 + v13 - 12 * v7;
        wsprintfA(String, "%dP", j + 1);
        sub_47B7ED(v4 + 4, v11 + 8 * (v6 / v7) + 16, String, 0, dword_4B9248);
        if (j == *(_DWORD*)(thisx + 20))
        {
            *(_DWORD*)(thisx + 52) = v4 - 4;
            *(_DWORD*)(thisx + 56) = v11 + 8 * (v6 / v7) + 16;
        }
    }
    return result;
}
 
int sub_48EFF1(int* thisx)
{
    return sub_47B91A(thisx[13], thisx[14], asc_4B7140, 0, dword_4B9248);
}

 
_DWORD* sub_48F020(_DWORD* thisx, char a2)
{
    sub_48E9CB(thisx);
    if ((a2 & 1) != 0)
        operator delete(thisx);
    return thisx;
}

 
_BYTE* sub_48F050(_BYTE* thisx)
{
    sub_47FC70(thisx);
    *(_DWORD*)thisx = off_4AC3A0;
    thisx[4] = 5;
    thisx[5] = 14;
    thisx[6] = 28;
    thisx[7] = 8;
    return thisx;
}

 
void sub_48F08B(_DWORD* thisx)
{
    *thisx = off_4AC3A0;
    sub_47FCCF(thisx);
}

 
int sub_48F0A7(_DWORD* thisx)
{
    BOOL v1; // esi
    BOOL v2; // esi
    int v3; // eax
    int v6; // [esp+8h] [ebp-38h]
    int k; // [esp+Ch] [ebp-34h]
    int v8; // [esp+10h] [ebp-30h]
    int v9; // [esp+14h] [ebp-2Ch]
    int v10; // [esp+18h] [ebp-28h]
    int i; // [esp+1Ch] [ebp-24h]
    int j; // [esp+20h] [ebp-20h]
    int v13; // [esp+24h] [ebp-1Ch]
    char* v14; // [esp+28h] [ebp-18h]
    BOOL v15; // [esp+2Ch] [ebp-14h]
    int v16; // [esp+30h] [ebp-10h]
    int v17; // [esp+34h] [ebp-Ch]
    BOOL v18; // [esp+38h] [ebp-8h]
    int v19; // [esp+3Ch] [ebp-4h]

    v1 = sub_476D78(0);
    v17 = v1 - sub_476D29(0);
    v2 = sub_476CDA(0);
    v16 = v2 - sub_476C8B(0);
    v15 = sub_476DC7(0, 0);
    v18 = sub_476DC7(0, 1);
    v19 = 0;
    if (v17)
    {
        thisx[5] = (v17 + thisx[5] + (unsigned __int8)byte_4B9990 + 1) % ((unsigned __int8)byte_4B9990 + 1);
        v19 = 3;
        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
    }
    else if (v16)
    {
        v19 = 4;
        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B99FC[0], -1, 100, 100, 0);
        v14 = (char*)sub_48F610((char*)unk_4B9B10);
        if (thisx[5])
        {
            v10 = v16 + (unsigned __int8)v14[thisx[5] - 1];
            if (v10 < 1)
                v10 = 1;
            v9 = 0;
            for (i = 0; i < (unsigned __int8)byte_4B9990; ++i)
            {
                if (i == thisx[5] - 1)
                    v9 += v10;
                else
                    v9 += (unsigned __int8)v14[i];
            }
            if (v9 <= (unsigned __int8)byte_4B9985)
                v14[thisx[5] - 1] = v10;
        }
        else
        {
            v13 = v16 + (unsigned __int8)byte_4B9990;
            if (v13 >= 2)
            {
                if (v13 > (unsigned __int8)byte_4B9985)
                    LOBYTE(v13) = byte_4B9985;
            }
            else
            {
                LOBYTE(v13) = 2;
            }
            byte_4B9990 = v13;
            memset(v14, 0, 8u);
            for (j = 0; j < (unsigned __int8)byte_4B9990; ++j)
            {
                if (j + 1 > (unsigned __int8)byte_4B9985 % (int)(unsigned __int8)byte_4B9990)
                    LOWORD(v3) = (unsigned __int8)byte_4B9985 / (__int16)(unsigned __int8)byte_4B9990;
                else
                    v3 = (unsigned __int8)byte_4B9985 / (int)(unsigned __int8)byte_4B9990 + 1;
                v14[j] = v3;
            }
        }
    }
    else if (v15 || v18)
    {
        if (v15)
        {
            v19 = 1;
            sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A00, -1, 100, 100, 0);
        }
        else
        {
            v19 = 2;
        }
        v6 = 0;
        v8 = (_DWORD)sub_48F610((char*)unk_4B9B10);
        for (k = 0; k < (unsigned __int8)byte_4B9990; ++k)
            v6 += *(unsigned __int8*)(k + v8);
        if (v6 != (unsigned __int8)byte_4B9985)
        {
            v19 = 0;
            sub_47B91A(16, 224, (LPCSTR)dword_4ABC40, 0, dword_4B9248);
        }
    }
    return v19;
}


 
int sub_48F3C5(unsigned __int8* thisx)
{
    int result; // eax
    int i; // [esp+4h] [ebp-110h]
    int v4; // [esp+8h] [ebp-10Ch]
    int v5; // [esp+Ch] [ebp-108h]
    CHAR String[256]; // [esp+10h] [ebp-104h] BYREF
    int v7; // [esp+110h] [ebp-4h]

    sub_480A51(thisx);
    v5 = 8 * thisx[4] + 16;
    v4 = 8 * thisx[5] + 16;
    sub_47B91A(v5, v4, (LPCSTR)word_4ABBFE, 0, dword_4B9248);
    wsprintfA(String, "%d", (unsigned __int8)byte_4B9990);
    sub_47B7ED(v5 + 16, v4 + 24, String, 0, dword_4B9248);
    result = (_DWORD)sub_48F610((char*)unk_4B9B10);
    v7 = result;
    for (i = 0; i < (unsigned __int8)byte_4B9990; ++i)
    {
        wsprintfA(String, "%d", *(unsigned __int8*)(i + v7));
        sub_47B7ED(v5 + 20 * i + 48, v4 + 24, String, 0, dword_4B9248);
        if (i < (unsigned __int8)byte_4B9990 - 1)
            sub_47B91A(v5 + 20 * i + 58, v4 + 24, aVs_0, 0, dword_4B9248);
        result = i + 1;
    }
    return result;
}

 
int sub_48F55F(int thisx)
{
    if (*(_DWORD*)(thisx + 20))
        return sub_47B91A(
            20 * (*(_DWORD*)(thisx + 20) - 1) + 8 * *(unsigned __int8*)(thisx + 4) + 64,
            8 * *(unsigned __int8*)(thisx + 5) + 30,
            (LPCSTR)dword_4B7180,
            0,
            -1);
    else
        return sub_47B91A(
            8 * *(unsigned __int8*)(thisx + 4) + 32,
            8 * *(unsigned __int8*)(thisx + 5) + 30,
            byte_4B717C,
            0,
            -1);
}
 
_DWORD* sub_48F5E0(_DWORD* thisx, char a2)
{
    sub_48F08B(thisx);
    if ((a2 & 1) != 0)
        operator delete(thisx);
    return thisx;
}
 
char* sub_48F610(char* thisx)
{
    return thisx + 2546;
}
 
void sub_48F630(void* thisx)
{
    *(_DWORD*)thisx = (_DWORD)&off_4AC3B4;
    *((_BYTE*)thisx + 4) = 0;
    *((_BYTE*)thisx + 5) = 0;
    *((_BYTE*)thisx + 6) = 0;
    *((_DWORD*)thisx + 2) = 0;
}
 
void sub_48F666(void* thisx)
{
    *(_DWORD*)thisx = (_DWORD)&off_4AC3B4;
    sub_48F682((int)thisx);
}
 
int sub_48F682(int thisx)
{
    int result; // eax

    if (*(_DWORD*)(thisx + 8))
        operator delete(*(void**)(thisx + 8));
    *(_DWORD*)(thisx + 8) = 0;
    *(_BYTE*)(thisx + 5) = 0;
    result = thisx;
    *(_BYTE*)(thisx + 6) = 0;
    return result;
}
 
int sub_48F6C5(LPVOID* thisx, HANDLE hFile)
{
    DWORD NumberOfBytesRead; // [esp+8h] [ebp-4h] BYREF

    sub_48F682((int)thisx);
    if (!ReadFile(hFile, thisx + 1, 1u, (LPDWORD)&NumberOfBytesRead, 0))
        return 0;
    if (!ReadFile(hFile, (char*)thisx + 6, 1u, (LPDWORD)&NumberOfBytesRead, 0))
        return 0;
    if (!ReadFile(hFile, (char*)thisx + 5, 1u, (LPDWORD)&NumberOfBytesRead, 0))
        return 0;
    int size = 2 * *((unsigned __int8*)thisx + 5) * *((unsigned __int8*)thisx + 6);
    thisx[2] = operator new(size);
    if (!thisx[2])
        return 0;
    if (ReadFile(
        hFile,
        thisx[2],
        *((unsigned __int8*)thisx + 5) * 2 * *((unsigned __int8*)thisx + 6),
        (LPDWORD)&NumberOfBytesRead,
        0))
    {
        return 1;
    }
    sub_48F682((int)thisx);
    return 0;
}
 
int __fastcall sub_48FB00(int a1, int a2, int a3, void* Src, int yTop)
{
    int result; // eax
    unsigned __int16 v7; // [esp+4h] [ebp-6Ch]
    int j; // [esp+8h] [ebp-68h]
    int v9; // [esp+10h] [ebp-60h]
    int v10; // [esp+14h] [ebp-5Ch]
    int v11; // [esp+18h] [ebp-58h]
    int i; // [esp+1Ch] [ebp-54h]
    int v13; // [esp+20h] [ebp-50h]
    int v14; // [esp+24h] [ebp-4Ch]
    int v15[14]; // [esp+28h] [ebp-48h] BYREF
    struct tagRECT rc; // [esp+60h] [ebp-10h] BYREF

    if (yTop < 0)
        yTop = 0;
    if (a3)
    {
        if (Src)
        {
            result = a1;
            if (*(_DWORD*)(a1 + 8))
            {
                sub_49C15E((_DWORD)v15);
                memcpy(v15, Src, sizeof(v15));
                v14 = 8;
                v13 = 8;
                v9 = *((_DWORD*)Src + 1);
                if (*((_DWORD*)Src + 6))
                {
                    v15[1] = v15[1] + 8 * *(unsigned __int8*)(a1 + 6) - 8;
                    v9 = v15[1];
                    v14 = -8;
                }
                if (*((_DWORD*)Src + 7))
                {
                    v15[2] = v15[2] + 8 * *(unsigned __int8*)(a1 + 5) - 8;
                    v13 = -8;
                }
                SetRect(&rc, 0, 0, 8, 8);
                v10 = 0;
                v11 = *(unsigned __int8*)(a1 + 5);
                if (*((_DWORD*)Src + 7))
                {
                    v10 = yTop / 8;
                    yTop &= 0x80000007;
                    result = 8 * v10;
                    v15[2] -= 8 * v10;
                }
                else
                {
                    result = yTop / 8;
                    v11 = *(unsigned __int8*)(a1 + 5) - yTop / 8;
                }
                for (i = v10; i < v11; ++i)
                {
                    if (*((_DWORD*)Src + 7))
                    {
                        if (i == v10)
                        {
                            SetRect(&rc, 0, yTop, 8, 8 - yTop);
                        }
                        else if (i == v10 + 1)
                        {
                            SetRect(&rc, 0, 0, 8, 8);
                        }
                    }
                    else if (8 * i + 8 > 8 * *(unsigned __int8*)(a1 + 5) - yTop)
                    {
                        SetRect(&rc, 0, 0, 8, 8 - yTop % 8);
                    }
                    for (j = 0; j < *(unsigned __int8*)(a1 + 6); ++j)
                    {
                        v7 = *(_WORD*)(*(_DWORD*)(a1 + 8) + 2 * (*(unsigned __int8*)(a1 + 6) * i + j));
                        if (v7)
                            sub_4A00C6(a3, v15, v7 - 1, (_DWORD*)&rc);
                        v15[1] += v14;
                    }
                    v15[1] = v9;
                    v15[2] += v13;
                    result = i + 1;
                }
            }
        }
    }
    return result;
}
 
MMRESULT __cdecl sub_48FD80(LPSTR pszFileName, int a2, int a3, LPMMCKINFO pmmcki)
{
    LONG v4; // eax
    char v6[4]; // [esp+0h] [ebp-30h] BYREF
    unsigned __int16 pch[8]; // [esp+4h] [ebp-2Ch] BYREF
    HMMIO hmmio; // [esp+14h] [ebp-1Ch]
    struct _MMCKINFO v9; // [esp+18h] [ebp-18h] BYREF
    MMRESULT v10; // [esp+2Ch] [ebp-4h]

    *(_DWORD*)a3 = 0;
    v10 = 0;
    hmmio = mmioOpenA(pszFileName, 0, 0x10000u);
    if (hmmio)
    {
        v10 = mmioDescend(hmmio, pmmcki, 0, 0);
        if (!v10)
        {
            if (pmmcki->ckid == 1179011410 && pmmcki->fccType == 1163280727)
            {
                v9.ckid = 544501094;
                v10 = mmioDescend(hmmio, &v9, pmmcki, 0x10u);
                if (!v10)
                {
                    if (v9.cksize >= 0x10)
                    {
                        if (mmioRead(hmmio, (HPSTR)pch, 16) == 16)
                        {
                            if (pch[0] == 1)
                            {
                                *(_WORD*)v6 = 0;
                            }
                            else if (mmioRead(hmmio, v6, 2) != 2)
                            {
                                v10 = 57602;
                                goto LABEL_22;
                            }
                            *(_DWORD*)a3 = (_DWORD)GlobalAlloc(0, *(unsigned __int16*)v6 + 18);
                            if (*(_DWORD*)a3)
                            {
                                memcpy(*(void**)a3, pch, 0x10u);
                                *(_WORD*)(*(_DWORD*)a3 + 16) = *(_WORD*)v6;
                                if (!*(_WORD*)v6
                                    || (v4 = mmioRead(hmmio, (HPSTR)(*(_DWORD*)a3 + 18), *(unsigned __int16*)v6),
                                        v4 == *(unsigned __int16*)v6))
                                {
                                    v10 = mmioAscend(hmmio, &v9, 0);
                                    if (!v10)
                                        goto LABEL_26;
                                }
                                else
                                {
                                    v10 = 57601;
                                }
                            }
                            else
                            {
                                v10 = 57344;
                            }
                        }
                        else
                        {
                            v10 = 57602;
                        }
                    }
                    else
                    {
                        v10 = 57601;
                    }
                }
            }
            else
            {
                v10 = 57601;
            }
        }
    }
    else
    {
        v10 = 57600;
    }
LABEL_22:
    if (*(_DWORD*)a3)
    {
        GlobalFree(*(HGLOBAL*)a3);
        *(_DWORD*)a3 = 0;
    }
    if (hmmio)
    {
        mmioClose(hmmio, 0);
        hmmio = 0;
    }
LABEL_26:
    *(_DWORD*)a2 = (_DWORD)hmmio;
    return v10;
}
 
MMRESULT __cdecl sub_48FF86(int a1, LPMMCKINFO pmmcki, MMCKINFO* pmmckiParent)
{
    mmioSeek(*(HMMIO*)a1, pmmckiParent->dwDataOffset + 4, 0);
    pmmcki->ckid = 1635017060;
    return mmioDescend(*(HMMIO*)a1, pmmcki, pmmckiParent, 0x10u);
}
 
MMRESULT __cdecl sub_48FFDC(HMMIO hmmio, int a2, int a3, int a4)
{
    MMRESULT Info; // eax
    struct _MMIOINFO pmmioinfo; // [esp+0h] [ebp-54h] BYREF
    unsigned int v7; // [esp+48h] [ebp-Ch]
    unsigned int i; // [esp+4Ch] [ebp-8h]
    MMRESULT v9; // [esp+50h] [ebp-4h]

    v9 = 0;
    Info = mmioGetInfo(hmmio, &pmmioinfo, 0);
    v9 = Info != 0;
    if (Info)
        goto LABEL_13;
    v7 = a2;
    if ((unsigned int)a2 > *(_DWORD*)(a3 + 4))
        v7 = *(_DWORD*)(a3 + 4);
    *(_DWORD*)(a3 + 4) -= v7;
    for (i = 0; i < v7; ++i)
    {
        if (pmmioinfo.pchNext == pmmioinfo.pchEndRead)
        {
            v9 = mmioAdvance(hmmio, &pmmioinfo, 0);
            if (v9)
                goto LABEL_13;
            if (pmmioinfo.pchNext == pmmioinfo.pchEndRead)
            {
                v9 = 57603;
                goto LABEL_13;
            }
        }
        ++pmmioinfo.pchNext;
    }
    v9 = mmioSetInfo(hmmio, &pmmioinfo, 0);
    if (v9)
        LABEL_13:
    *(_DWORD*)a4 = 0;
    else
        *(_DWORD*)a4 = v7;
    return v9;
}
 
MMRESULT __cdecl sub_4900C4(HMMIO hmmio, int a2, int a3, int a4, int a5)
{
    MMRESULT Info; // eax
    struct _MMIOINFO pmmioinfo; // [esp+0h] [ebp-54h] BYREF
    unsigned int v8; // [esp+48h] [ebp-Ch]
    unsigned int i; // [esp+4Ch] [ebp-8h]
    MMRESULT v10; // [esp+50h] [ebp-4h]

    v10 = 0;
    Info = mmioGetInfo(hmmio, &pmmioinfo, 0);
    v10 = Info != 0;
    if (Info)
        goto LABEL_13;
    v8 = a2;
    if ((unsigned int)a2 > *(_DWORD*)(a4 + 4))
        v8 = *(_DWORD*)(a4 + 4);
    *(_DWORD*)(a4 + 4) -= v8;
    for (i = 0; i < v8; ++i)
    {
        if (pmmioinfo.pchNext == pmmioinfo.pchEndRead)
        {
            v10 = mmioAdvance(hmmio, &pmmioinfo, 0);
            if (v10)
                goto LABEL_13;
            if (pmmioinfo.pchNext == pmmioinfo.pchEndRead)
            {
                v10 = 57603;
                goto LABEL_13;
            }
        }
        *(_BYTE*)(i + a3) = *pmmioinfo.pchNext++;
    }
    v10 = mmioSetInfo(hmmio, &pmmioinfo, 0);
    if (v10)
        LABEL_13:
    *(_DWORD*)a5 = 0;
    else
        *(_DWORD*)a5 = v8;
    return v10;
}
 
int __cdecl sub_4901B9(HMMIO* a1, HGLOBAL* a2)
{
    if (*a2)
    {
        GlobalFree(*a2);
        *a2 = 0;
    }
    if (*a1)
    {
        mmioClose(*a1, 0);
        *a1 = 0;
    }
    return 0;
}
 
MMRESULT __cdecl sub_4901FC(LPSTR pszFileName, int a2, char* pch, LPMMCKINFO a4, LPMMCKINFO pmmcki)
{
    struct _MMCKINFO v6; // [esp+0h] [ebp-1Ch] BYREF
    char v7[4]; // [esp+14h] [ebp-8h] BYREF
    MMRESULT Chunk; // [esp+18h] [ebp-4h]

    *(_DWORD*)v7 = -1;
    Chunk = 0;
    *(_DWORD*)a2 = (unsigned int)mmioOpenA(pszFileName, 0, 0x11002u);
    if (!*(_DWORD*)a2)
        return 57604;
    pmmcki->fccType = 1163280727;
    pmmcki->cksize = 0;
    Chunk = mmioCreateChunk(*(HMMIO*)a2, pmmcki, 0x20u);
    if (!Chunk)
    {
        a4->ckid = 544501094;
        a4->cksize = 16;
        Chunk = mmioCreateChunk(*(HMMIO*)a2, a4, 0);
        if (!Chunk)
        {
            if (*(_WORD*)pch == 1)
            {
                if (mmioWrite(*(HMMIO*)a2, pch, 16) != 16)
                    return 57604;
            }
            else if (mmioWrite(*(HMMIO*)a2, pch, *((unsigned __int16*)pch + 8) + 18) != *((unsigned __int16*)pch + 8) + 18)
            {
                return 57604;
            }
            Chunk = mmioAscend(*(HMMIO*)a2, a4, 0);
            if (!Chunk)
            {
                v6.ckid = 1952670054;
                v6.cksize = 0;
                Chunk = mmioCreateChunk(*(HMMIO*)a2, &v6, 0);
                if (!Chunk)
                {
                    if (mmioWrite(*(HMMIO*)a2, v7, 4) == 4)
                    {
                        Chunk = mmioAscend(*(HMMIO*)a2, &v6, 0);
                        if (Chunk)
                            return 57604;
                    }
                    else
                    {
                        return 57604;
                    }
                }
            }
        }
    }
    return Chunk;
}
 
MMRESULT __cdecl sub_49039D(int a1, LPMMCKINFO pmmcki, LPMMIOINFO pmmioinfo)
{
    MMRESULT Chunk; // [esp+0h] [ebp-4h]

    pmmcki->ckid = 1635017060;
    pmmcki->cksize = 0;
    Chunk = mmioCreateChunk(*(HMMIO*)a1, pmmcki, 0);
    if (!Chunk)
        return mmioGetInfo(*(HMMIO*)a1, pmmioinfo, 0);
    return Chunk;
}
 
MMRESULT __cdecl sub_4903F4(HMMIO hmmio, int a2, int a3, int a4, int a5, LPMMIOINFO pmmioinfo)
{
    unsigned int i; // [esp+0h] [ebp-8h]
    MMRESULT v8; // [esp+4h] [ebp-4h]

    v8 = 0;
    *(_DWORD*)a5 = 0;
    for (i = 0; i < a2; ++i)
    {
        if (pmmioinfo->pchNext == pmmioinfo->pchEndWrite)
        {
            pmmioinfo->dwFlags |= 0x10000000u;
            v8 = mmioAdvance(hmmio, pmmioinfo, 1u);
            if (v8)
                break;
        }
        *pmmioinfo->pchNext++ = *(_BYTE*)(i + a3);
        ++* (_DWORD*)a5;
    }
    return v8;
}
 
MMRESULT sub_490492(int a1, LPMMCKINFO pmmcki, LPMMCKINFO pmmckiParent, LPCMMIOINFO pmmioinfo, ...)
{
    MMRESULT v5; // [esp+0h] [ebp-4h]
    va_list va; // [esp+1Ch] [ebp+18h] BYREF

    va_start(va, pmmioinfo);
    if (!*(_DWORD*)a1)
        return 0;
    //pmmioinfo->dwFlags |= 0x10000000u; ???
    v5 = mmioSetInfo(*(HMMIO*)a1, pmmioinfo, 0);
    if (!v5)
    {
        v5 = mmioAscend(*(HMMIO*)a1, pmmcki, 0);
        if (!v5)
        {
            v5 = mmioAscend(*(HMMIO*)a1, pmmckiParent, 0);
            if (!v5)
            {
                mmioSeek(*(HMMIO*)a1, 0, 0);
                v5 = mmioDescend(*(HMMIO*)a1, pmmckiParent, 0, 0);
                if (!v5)
                {
                    pmmcki->ckid = 1952670054;
                    if (!mmioDescend(*(HMMIO*)a1, pmmcki, pmmckiParent, 0x10u))
                    {
                        mmioWrite(*(HMMIO*)a1, va, 4);
                        mmioAscend(*(HMMIO*)a1, pmmcki, 0);
                    }
                    v5 = mmioAscend(*(HMMIO*)a1, pmmckiParent, 0);
                }
            }
        }
    }
    if (*(_DWORD*)a1)
    {
        mmioClose(*(HMMIO*)a1, 0);
        *(_DWORD*)a1 = 0;
    }
    return v5;
}
 
int __cdecl sub_4906F6(HMMIO a1, HMMIO hmmio, int a3)
{
    HGLOBAL v3; // eax
    HGLOBAL v5; // eax
    HGLOBAL v6; // eax
    HGLOBAL v7; // eax
    HGLOBAL v8; // eax
    struct _MMCKINFO pmmcki; // [esp+0h] [ebp-18h] BYREF
    HPSTR pch; // [esp+14h] [ebp-4h]

    v3 = GlobalAlloc(0x42u, *(_DWORD*)(a3 + 4));
    pch = (HPSTR)GlobalLock(v3);
    if (!pch)
        return 0;
    pmmcki.ckid = *(_DWORD*)a3;
    pmmcki.cksize = *(_DWORD*)(a3 + 4);
    if (mmioCreateChunk(hmmio, &pmmcki, 0)
        || mmioRead(a1, pch, *(_DWORD*)(a3 + 4)) != *(_DWORD*)(a3 + 4)
        || mmioWrite(hmmio, pch, *(_DWORD*)(a3 + 4)) != *(_DWORD*)(a3 + 4)
        || mmioAscend(hmmio, &pmmcki, 0))
    {
        if (pch)
        {
            v7 = GlobalHandle(pch);
            GlobalUnlock(v7);
            v8 = GlobalHandle(pch);
            GlobalFree(v8);
        }
        return 0;
    }
    else
    {
        if (pch)
        {
            v5 = GlobalHandle(pch);
            GlobalUnlock(v5);
            v6 = GlobalHandle(pch);
            GlobalFree(v6);
        }
        return 1;
    }
}
 
void sub_4909B0(void* thisx)
{
    sub_401E17((_DWORD*)thisx + 33);
    *(_DWORD*)thisx = off_4AC3B8;
}
 
void sub_4909D5(void* thisx)
{
    *(_DWORD*)thisx = off_4AC3B8;
    sub_401E35((void**)(char*)thisx + 132);
}
 
int sub_4909F7(unsigned __int8* thisx, HANDLE hFile, int a3)
{
    DWORD NumberOfBytesRead; // [esp+4h] [ebp-4h] BYREF

    if (!sub_401ED9((char*)thisx + 132, hFile, a3))
        return 0;
    ReadFile(hFile, thisx + 4, 0x10u, (LPDWORD)&NumberOfBytesRead, 0);
    ReadFile(hFile, thisx + 68, 0x10u, (LPDWORD)&NumberOfBytesRead, 0);
    return 1;
}

 
int sub_490A5B(void* thisx, void* Src)
{
    int result; // eax
    int v4; // [esp+4h] [ebp-54h]
    int v5; // [esp+8h] [ebp-50h]
    int v6; // [esp+Ch] [ebp-4Ch]
    int i; // [esp+10h] [ebp-48h]
    int v8; // [esp+14h] [ebp-44h]
    int v9; // [esp+18h] [ebp-40h]
    char* v10; // [esp+1Ch] [ebp-3Ch]
    int v11[14]; // [esp+20h] [ebp-38h] BYREF

    sub_49C15E((int)v11);
    memcpy(v11, Src, sizeof(v11));
    v11[0] = dword_4B91E8;
    v10 = sub_47EF20((char*)thisx);
    v5 = unknown_libname_2((_DWORD*)v10);
    v9 = (unsigned __int8)unknown_libname_3(v10);
    v4 = v11[1];
    v6 = v11[2];
    for (i = 0; ; ++i)
    {
        result = i;
        if (i >= v9)
            break;
        v8 = 12 * *(unsigned __int16*)(v5 + 8 * i) + dword_4B92F0;
        v11[1] = *(char*)(v5 + 8 * i + *((_DWORD*)Src + 6) + 2) + v4;
        v11[2] = *(char*)(v5 + 8 * i + 4) + v6;
        if (*(_BYTE*)(v5 + 8 * i + 6))
            v11[6] = *((_DWORD*)Src + 6) == 0;
        else
            v11[6] = *((_DWORD*)Src + 6);
        v11[7] = *(unsigned __int8*)(v5 + 8 * i + 7);
        sub_48FB00(v8, (int)v11, (int)unk_4BDC60, v11, 0);
    }
    return result;
}
 
void sub_490B80(void* thisx)
{
    *(_DWORD*)thisx = (_DWORD)&off_4AC3BC;
    *((_DWORD*)thisx + 1) = 0;
    *((_DWORD*)thisx + 35) = 1;
    *((_DWORD*)thisx + 34) = 1;
    *((_DWORD*)thisx + 33) = 1;
}
 
void sub_490BC8(void* thisx)
{
    *(_DWORD*)thisx = (_DWORD)&off_4AC3BC;
}
 
void sub_490BDC(int a1, double a2, double a3, double a4, int a5)
{
    *(_DWORD*)(a1 + 96) = *(_DWORD*)(a5 + 4);
    *(_DWORD*)(a1 + 100) = *(_DWORD*)(a5 + 8);
    if (*(_DWORD*)(a5 + 16))
    {
        *(_DWORD*)(a1 + 104) = -100 * sub_446497((int*)unk_4B9B10, *(_DWORD*)(a1 + 96) / 100, *(_DWORD*)(a1 + 100) / 100);
        *(_DWORD*)(a1 + 16) = 0;
        *(_DWORD*)(a1 + 12) = 0;
    }
    else
    {
        *(_DWORD*)(a1 + 104) = *(_DWORD*)(a5 + 12);
    }
    if (*(_BYTE*)a5)
    {
        *(_BYTE*)(a1 + 72) = *(_BYTE*)a5 - 1;
    }
    else
    {
        *(_DWORD*)(a1 + 96) = -32000;
        *(_DWORD*)(a1 + 100) = -24000;
    }
    if (*(_DWORD*)(a5 + 24))
        sub_4950AF(a1);
    else
        *(_WORD*)(a1 + 190) = *(_WORD*)(a5 + 20);
    *(_DWORD*)(a1 + 4) = 1;
    memset((void*)(a1 + 181), 0, 8u);
    *(_DWORD*)(a1 + 116) = 0;
    *(_DWORD*)(a1 + 112) = 0;
    *(_DWORD*)(a1 + 108) = 0;
    *(_DWORD*)(a1 + 156) = 0;
    *(_DWORD*)(a1 + 160) = 0;
    *(_BYTE*)(a1 + 22) = 0;
    *(_DWORD*)(a1 + 84) = -1;
    sub_4914CC(a1, a3, a2, a4);
} 
int __fastcall sub_490D23(int a1)
{
    int result; // eax
    int v2; // esi
    unsigned int v3; // eax
    int v4; // esi
    int* v5; // eax
    int* v6; // eax
    char v8[16]; // [esp+8h] [ebp-CCh] BYREF
    char v9[16]; // [esp+18h] [ebp-BCh] BYREF
    int k; // [esp+28h] [ebp-ACh]
    int v11; // [esp+2Ch] [ebp-A8h]
    int v12; // [esp+30h] [ebp-A4h]
    int v13; // [esp+34h] [ebp-A0h]
    int v14; // [esp+38h] [ebp-9Ch]
    char v15; // [esp+3Ch] [ebp-98h]
    char v16; // [esp+40h] [ebp-94h]
    int yTop; // [esp+44h] [ebp-90h]
    int v18; // [esp+48h] [ebp-8Ch]
    int v19; // [esp+4Ch] [ebp-88h]
    int v20; // [esp+50h] [ebp-84h]
    int j; // [esp+54h] [ebp-80h]
    int v22; // [esp+58h] [ebp-7Ch]
    _BYTE* v23; // [esp+5Ch] [ebp-78h]
    int v24; // [esp+60h] [ebp-74h]
    char* v25; // [esp+64h] [ebp-70h]
    char* v26; // [esp+68h] [ebp-6Ch]
    unsigned int v27; // [esp+6Ch] [ebp-68h]
    int v28[2]; // [esp+70h] [ebp-64h] BYREF
    int v29; // [esp+78h] [ebp-5Ch]
    int v30; // [esp+7Ch] [ebp-58h]
    int v31; // [esp+80h] [ebp-54h]
    int v32; // [esp+84h] [ebp-50h]
    int i; // [esp+88h] [ebp-4Ch]
    int v34; // [esp+8Ch] [ebp-48h]
    int v35; // [esp+90h] [ebp-44h]
    char v36; // [esp+94h] [ebp-40h]
    _BYTE* v37; // [esp+98h] [ebp-3Ch]
    int Src; // [esp+9Ch] [ebp-38h] BYREF
    int v39; // [esp+A0h] [ebp-34h]
    int v40; // [esp+A4h] [ebp-30h]
    int v41; // [esp+B4h] [ebp-20h]
    int v42; // [esp+B8h] [ebp-1Ch]
    char v43; // [esp+C9h] [ebp-Bh]
    __int16 v44; // [esp+CAh] [ebp-Ah]
    __int16 v45; // [esp+CCh] [ebp-8h]
    __int16 v46; // [esp+CEh] [ebp-6h]

    result = a1;
    if (!*(_DWORD*)(a1 + 176))
    {
        sub_4641FE((_DWORD*)unk_4B9B10, *(_DWORD*)(a1 + 96), *(_DWORD*)(a1 + 100), *(_DWORD*)(a1 + 104), (int)v28);
        v30 = v28[0];
        v29 = v28[1];
        v35 = sub_446497((_DWORD*)unk_4B9B10, *(_DWORD*)(a1 + 96) / 100, *(_DWORD*)(a1 + 100) / 100);
        v36 = sub_4464F6((_DWORD*)unk_4B9B10, *(_DWORD*)(a1 + 96) / 800, *(_DWORD*)(a1 + 100) / 800);
        v37 = (_BYTE*)sub_4741F8((int)unk_4B9B10, *(_DWORD*)(a1 + 96) / 800, *(_DWORD*)(a1 + 100) / 800);
        if (v37 && sub_425C50(v37))
            v35 = 4 * (unsigned __int8)unknown_libname_6(v37);
        v34 = 0;
        LOBYTE(v31) = 0;
        v32 = 0;
        if (v37)
        {
            LOBYTE(v34) = sub_425C30(v37);
            v34 = (unsigned __int8)v34;
            LOBYTE(v31) = sub_425C70(v37);
            v32 = sub_425C90(v37);
        }
        sub_49C15E((int)&Src);
        if ((_BYTE)v31 && *(_DWORD*)(a1 + 12) != 1 && (*(_DWORD*)(a1 + 172) && v35 < *(_DWORD*)(a1 + 104) / -100 || v32))
        {
            v39 = v30 - 8;
            v2 = *(_DWORD*)(a1 + 100) / 100 - v35;
            v3 = sub_4464BA((int)unk_4B9B10);
            v40 = v2 + v3 - 2 - v34;
            Src = dword_4B9214;
            if ((unsigned __int8)v31 == 2)
            {
                if (!(dword_4B93B0 % 2u))
                    sub_49AB05((int)unk_4BDC60, &Src);
            }
            else if ((unsigned __int8)v31 == 1)
            {
                sub_49AB05((int)unk_4BDC60, &Src);
            }
        }
        if (*(_BYTE*)(a1 + 71) == 1)
        {
            result = ((unsigned int)dword_4B93AC >> 1) / 4;
            v27 = ((unsigned int)dword_4B93AC >> 1) % 4;
            switch (v27)
            {
            case 1u:
                v43 = 4;
                v44 = 31;
                v45 = 15;
                v46 = 0;
                break;
            case 2u:
                v43 = 1;
                v44 = 31;
                v45 = 15;
                v46 = 0;
                break;
            case 3u:
                v43 = 3;
                v44 = 31;
                v45 = 15;
                v46 = 0;
                break;
            }
        }
        else
        {
            result = *(unsigned __int8*)(a1 + 71);
            if (result == 2)
            {
                v43 = 4;
                v44 = 31;
                v45 = 15;
                v46 = 0;
            }
        }
        for (i = 0; ; ++i)
        {
            if (i >= 3)
                return result;
            Src = dword_4B91E8;
            v18 = *(_DWORD*)(a1 + 108) + v30;
            v19 = *(_DWORD*)(a1 + 116) + *(_DWORD*)(a1 + 112) + v29;
            if (i)
            {
                result = *(__int16*)(a1 + 16 * (i - 1) + 24);
                v22 = result;
                if (result == -1)
                {
                    v22 = *(unsigned __int16*)(a1 + 20);
                }
                else if (v22 == -2)
                {
                    continue;
                }
                v18 += *(_DWORD*)(a1 + 16 * (i - 1) + 28);
                result = *(_DWORD*)(a1 + 16 * (i - 1) + 36) + *(_DWORD*)(a1 + 16 * (i - 1) + 32);
                v19 += result;
            }
            else
            {
                result = *(unsigned __int16*)(a1 + 20);
                v22 = result;
            }
            if ((unsigned __int16)word_4B92EC > v22)
            {
                v26 = (char*)(140 * (*(char*)(a1 + 22) + v22) + dword_4B92E8);
                v25 = sub_47EF20(v26);
                v20 = unknown_libname_2((_DWORD*)v25);
                result = (unsigned __int8)unknown_libname_3(v25);
                v24 = result;
                for (j = 0; j < v24; ++j)
                {
                    v23 = (_BYTE*)(12 * *(unsigned __int16*)(v20 + 8 * j) + dword_4B92F0);
                    v16 = *(_BYTE*)(v20 + 8 * j + *(_DWORD*)(a1 + 164) + 2);
                    v15 = *(_BYTE*)(v20 + 8 * j + 4);
                    v39 = v16 + v18;
                    v40 = v15 + v19;
                    if (*(_BYTE*)(v20 + 8 * j + 6))
                        v41 = *(_DWORD*)(a1 + 164) == 0;
                    else
                        v41 = *(_DWORD*)(a1 + 164);
                    v42 = *(unsigned __int8*)(v20 + 8 * j + 7);
                    yTop = 0;
                    if (*(int*)(a1 + 64) > -1000)
                    {
                        v4 = v15 + *(_DWORD*)(a1 + 64);
                        yTop = v4 + 8 * (unsigned __int8)sub_425F90(v23);
                        if (i > 0)
                            yTop += *(_DWORD*)(a1 + 16 * (i - 1) + 36);
                    }
                    result = sub_48FB00((int)v23, (int)&Src, (int)unk_4BDC60, &Src, yTop);
                }
                if (dword_4B93A8)
                {
                    v41 = 0;
                    v42 = 0;
                    for (k = 0; k < 2; ++k)
                    {
                        if (k)
                        {
                            if (k == 1)
                            {
                                v6 = sub_47EE20(v26, (_DWORD*)v8, *(_DWORD*)(a1 + 164), 0);
                                v11 = *v6;
                                v12 = v6[1];
                                v13 = v6[2];
                                v14 = v6[3];
                            }
                        }
                        else
                        {
                            v5 = sub_47EE60(v26, (_DWORD*)v9, *(_DWORD*)(a1 + 164), 0);
                            v11 = *v5;
                            v12 = v5[1];
                            v13 = v5[2];
                            v14 = v5[3];
                        }
                        if (v11 || v12 || v13 || v14)
                        {
                            v39 = v11 + v18;
                            v40 = v12 + v19;
                            Src = dword_4B9210 + 4 * k;
                            sub_49AB05((int)unk_4BDC60, &Src);
                            v39 = v18 + v13 - 8;
                            v40 = v12 + v19;
                            Src = dword_4B9210 + 4 * k + 1;
                            sub_49AB05((int)unk_4BDC60, &Src);
                            v39 = v11 + v18;
                            v40 = v19 + v14 - 8;
                            Src = dword_4B9210 + 4 * k + 2;
                            sub_49AB05((int)unk_4BDC60, &Src);
                            v39 = v18 + v13 - 8;
                            v40 = v19 + v14 - 8;
                            Src = dword_4B9210 + 4 * k + 3;
                            sub_49AB05((int)unk_4BDC60, &Src);
                        }
                        result = k + 1;
                    }
                }
            }
        }
    }
    return result;
}
 
void sub_4914CC(int thisx, double a2, double st5_0, double a4)
{
    sub_4967E4(thisx, a2, st5_0, a4);
    if (*(_DWORD*)(thisx + 12) != *(_DWORD*)(thisx + 16))
    {
        *(_DWORD*)(thisx + 12) = *(_DWORD*)(thisx + 16);
        *(_DWORD*)(thisx + 156) = 0;
        sub_4967E4(thisx, a2, st5_0, a4);
    }
    if (*(_BYTE*)(thisx + 72) == 11)
    {
        if (*(int*)(thisx + 84) > 0)
        {
            if (*(int*)(thisx + 84) >= 60)
            {
                if (*(int*)(thisx + 84) >= 180)
                    *(_BYTE*)(thisx + 22) = *(_DWORD*)(thisx + 84) / 3 % 2;
                else
                    *(_BYTE*)(thisx + 22) = *(_DWORD*)(thisx + 84) / 3 % 2 + 2;
            }
            else
            {
                *(_BYTE*)(thisx + 22) = *(_DWORD*)(thisx + 84) / 3 % 2 + 4;
            }
        }
        else
        {
            *(_BYTE*)(thisx + 22) = 0;
        }
    }
    else if (*(_BYTE*)(thisx + 72) == 13)
    {
        if (*(int*)(thisx + 84) > 0)
        {
            if (*(int*)(thisx + 84) >= 60)
                *(_BYTE*)(thisx + 71) = 2 * (*(_DWORD*)(thisx + 84) % (*(_DWORD*)(thisx + 84) / 60 + 2) <= 1);
            else
                *(_BYTE*)(thisx + 71) = 2 * (*(_DWORD*)(thisx + 84) % 2);
        }
        else
        {
            *(_BYTE*)(thisx + 71) = 0;
        }
    }
    if (*(_DWORD*)(thisx + 12) != 1)
        sub_499622(thisx);
} 
int sub_491639(int thisx, int a2)
{
    *(_DWORD*)(thisx + 16) = 1;
    *(_DWORD*)(thisx + 12) = 1;
    *(_DWORD*)(thisx + 56) = a2;
    *(_DWORD*)(thisx + 172) = 0;
    *(_DWORD*)(thisx + 168) = 0;
    *(_BYTE*)(thisx + 68) = 0;
    *(_BYTE*)(thisx + 71) = 0;
    *(_DWORD*)(thisx + 76) = 0;
    if (*(_BYTE*)(thisx + 72) != 11 && *(_BYTE*)(thisx + 72) != 13)
        *(_DWORD*)(thisx + 80) = 0;
    *(_DWORD*)(thisx + 120) = 0;
    *(_DWORD*)(thisx + 124) = 0;
    *(_DWORD*)(thisx + 128) = 0;
    *(_DWORD*)(thisx + 144) = 0;
    *(_DWORD*)(thisx + 148) = 0;
    *(_DWORD*)(thisx + 152) = 0;
    return sub_4995EB((_WORD*)thisx);
}
 
struct tagRECT* sub_491709(int thisx, struct tagRECT* a2, int a3)
{
    LONG* v4; // eax
    int v5[4]; // [esp+4h] [ebp-28h] BYREF
    struct tagRECT rc; // [esp+14h] [ebp-18h] BYREF
    int v7; // [esp+24h] [ebp-8h]
    char* v8; // [esp+28h] [ebp-4h]

    if (a3)
    {
        if (a3 >= 1)
        {
            v7 = *(__int16*)(thisx + 16 * (a3 - 1) + 24);
            if (v7 == -1)
            {
                v7 = *(unsigned __int16*)(thisx + 20);
            }
            else if (v7 == -2)
            {
                SetRect(&rc, 0, 0, 0, 0);
                *a2 = rc;
                return a2;
            }
            v8 = (char*)(140 * v7 + dword_4B92E8);
        }
    }
    else
    {
        v8 = (char*)(140 * *(unsigned __int16*)(thisx + 20) + dword_4B92E8);
    }
    v4 = (LONG*)sub_47EE20(v8, (_DWORD*)v5, *(_DWORD*)(thisx + 164), 0);
    a2->left = *v4;
    a2->top = v4[1];
    a2->right = v4[2];
    a2->bottom = v4[3];
    return a2;
}
 
//int __fastcall sub_4917E7(int a1, int a2, int a3, int a4, int a5, int a6)
//{
//    __int64 v6; // rax
//    int v7; // esi
//    int v8; // esi
//    int v9; // esi
//    int v10; // esi
//    int v11; // esi
//    int v12; // esi
//    int v13; // esi
//    int v14; // esi
//    int v15; // eax
//    int v16; // esi
//    int v17; // esi
//    int v18; // esi
//    int v19; // esi
//    int v20; // esi
//    int v21; // esi
//    int v22; // esi
//    int v23; // esi
//    int v24; // esi
//    int v25; // esi
//    int v26; // esi
//    int v27; // esi
//    int v28; // esi
//    int v29; // esi
//    int v30; // esi
//    int v31; // esi
//    int v32; // esi
//    int v33; // esi
//    int v34; // esi
//    int v36; // [esp+Ch] [ebp-27Ch]
//    int v37; // [esp+2Ch] [ebp-25Ch]
//    int v38; // [esp+30h] [ebp-258h]
//    unsigned int v39; // [esp+34h] [ebp-254h]
//    int v40; // [esp+50h] [ebp-238h]
//    int v41; // [esp+54h] [ebp-234h]
//    int v42; // [esp+68h] [ebp-220h]
//    int v43; // [esp+6Ch] [ebp-21Ch]
//    int v44; // [esp+80h] [ebp-208h]
//    int v45; // [esp+84h] [ebp-204h]
//    int v46; // [esp+98h] [ebp-1F0h]
//    int v47; // [esp+9Ch] [ebp-1ECh]
//    int v48; // [esp+B8h] [ebp-1D0h]
//    int v49; // [esp+BCh] [ebp-1CCh]
//    unsigned int v50; // [esp+C0h] [ebp-1C8h]
//    int v51; // [esp+D4h] [ebp-1B4h]
//    unsigned int v52; // [esp+D8h] [ebp-1B0h]
//    int v53; // [esp+104h] [ebp-184h]
//    int v54; // [esp+108h] [ebp-180h]
//    unsigned int v55; // [esp+10Ch] [ebp-17Ch]
//    int v56; // [esp+118h] [ebp-170h]
//    int v57; // [esp+11Ch] [ebp-16Ch]
//    int v58; // [esp+120h] [ebp-168h]
//    int v59; // [esp+124h] [ebp-164h]
//    int v60; // [esp+128h] [ebp-160h]
//    int v61; // [esp+12Ch] [ebp-15Ch]
//    double v62; // [esp+144h] [ebp-144h]
//    int v63; // [esp+14Ch] [ebp-13Ch]
//    int v64; // [esp+150h] [ebp-138h]
//    int v65; // [esp+164h] [ebp-124h]
//    unsigned int v66; // [esp+168h] [ebp-120h]
//    int v68; // [esp+170h] [ebp-118h]
//    int v69; // [esp+174h] [ebp-114h]
//    int v70; // [esp+178h] [ebp-110h]
//    double v71; // [esp+17Ch] [ebp-10Ch]
//    double v72; // [esp+17Ch] [ebp-10Ch]
//    int v73; // [esp+188h] [ebp-100h]
//    int v74; // [esp+18Ch] [ebp-FCh]
//    int v75; // [esp+190h] [ebp-F8h]
//    double v76; // [esp+194h] [ebp-F4h]
//    double v77; // [esp+194h] [ebp-F4h]
//    int v78; // [esp+1A0h] [ebp-E8h]
//    int v79; // [esp+1A4h] [ebp-E4h]
//    double v80; // [esp+1A8h] [ebp-E0h]
//    int v81; // [esp+1B4h] [ebp-D4h]
//    int v82; // [esp+1B8h] [ebp-D0h]
//    double v83; // [esp+1BCh] [ebp-CCh]
//    int v84; // [esp+1C8h] [ebp-C0h]
//    int v85; // [esp+1CCh] [ebp-BCh]
//    double v86; // [esp+1D0h] [ebp-B8h]
//    int v87; // [esp+1DCh] [ebp-ACh]
//    int v88; // [esp+1E0h] [ebp-A8h]
//    int v89; // [esp+1E4h] [ebp-A4h]
//    double v90; // [esp+1E8h] [ebp-A0h]
//    double v91; // [esp+1E8h] [ebp-A0h]
//    int v92; // [esp+1F4h] [ebp-94h]
//    int v93; // [esp+1F8h] [ebp-90h]
//    double v94; // [esp+1FCh] [ebp-8Ch]
//    int v95; // [esp+208h] [ebp-80h]
//    int v96; // [esp+20Ch] [ebp-7Ch]
//    double v97; // [esp+210h] [ebp-78h]
//    int v98; // [esp+21Ch] [ebp-6Ch]
//    int v99; // [esp+220h] [ebp-68h]
//    int v100; // [esp+224h] [ebp-64h]
//    int v101; // [esp+228h] [ebp-60h]
//    double v102; // [esp+22Ch] [ebp-5Ch]
//    double v103; // [esp+22Ch] [ebp-5Ch]
//    int v104; // [esp+238h] [ebp-50h]
//    int v105; // [esp+23Ch] [ebp-4Ch]
//    int v106; // [esp+240h] [ebp-48h]
//    int v107; // [esp+244h] [ebp-44h]
//    int v108; // [esp+24Ch] [ebp-3Ch]
//    double v109; // [esp+250h] [ebp-38h]
//    double v110; // [esp+250h] [ebp-38h]
//    int v111; // [esp+25Ch] [ebp-2Ch]
//    int v112; // [esp+260h] [ebp-28h]
//    int v113; // [esp+268h] [ebp-20h]
//    double X; // [esp+26Ch] [ebp-1Ch]
//    int v115; // [esp+278h] [ebp-10h]
//    _DWORD* v116; // [esp+27Ch] [ebp-Ch]
//    int v117; // [esp+280h] [ebp-8h]
//    int v118; // [esp+284h] [ebp-4h]
//    int v119; // [esp+284h] [ebp-4h]
//
//    LODWORD(v6) = a1;
//    if (!*(_DWORD*)(a1 + 56))
//        return v6;
//    *(_DWORD*)(a1 + 16) = 2;
//    *(_DWORD*)(a1 + 12) = 2;
//    *(_DWORD*)(a1 + 8) = Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56));
//    if (sub_41BA53(135, 0) && rand() % 2 == 1)
//        a3 += 50;
//    v117 = a3;
//    if (a4)
//        v117 = a3 * (unsigned __int16)sub_41CA5F(1) / 250 + a3;
//    if (a5)
//        v117 += a3 * (unsigned __int16)sub_41D067(1) / 250;
//    v118 = *(unsigned __int16*)(a1 + 190);
//    if (sub_41BA53(133, 0) && *(_BYTE*)(a1 + 72) == 12)
//        v118 += 50;
//    switch (*(_DWORD*)(a1 + 8))
//    {
//    case 0xB8:
//        v118 += 25;
//        break;
//    case 0xBA:
//        v118 += 15;
//        break;
//    case 0xBF:
//        v118 += 10;
//        break;
//    case 0xC0:
//        v118 += 20;
//        break;
//    case 0xC2:
//        v118 += 10;
//        break;
//    case 0xC3:
//        v118 /= 2;
//        break;
//    case 0xAB:
//        v118 /= 2;
//        break;
//    case 0xAC:
//        v118 = 3 * v118 / 4;
//        break;
//    case 0xC6:
//        v118 = v118 * (10 * (rand() % 16) + 50) / 100;
//        break;
//    }
//    v119 = v117 * v118 / 100 + 50;
//    if (v119 > 0xFFFF)
//        LOWORD(v119) = -1;
//    *(_WORD*)(a1 + 192) = v119;
//    *(_BYTE*)(a1 + 195) = 5;
//    *(_BYTE*)(a1 + 194) = 0;
//    *(_BYTE*)(a1 + 69) = 1;
//    *(_DWORD*)(a1 + 156) = 0;
//    *(_DWORD*)(a1 + 160) = 0;
//    *(_DWORD*)(a1 + 88) = 0;
//    *(_BYTE*)(a1 + 180) = 0;
//    *(_DWORD*)(a1 + 104) -= 400;
//    *(_DWORD*)(a1 + 172) = 1;
//    *(_DWORD*)(a1 + 168) = 1;
//    *(_DWORD*)(a1 + 140) = 1;
//    *(_DWORD*)(a1 + 136) = 1;
//    *(_DWORD*)(a1 + 132) = 1;
//    *(_DWORD*)(a1 + 76) = 0;
//    if (*(_BYTE*)(a1 + 72) != 11 && *(_BYTE*)(a1 + 72) != 13)
//        *(_DWORD*)(a1 + 80) = 0;
//    sub_499622(a1);
//    memset((void*)(a1 + 181), 0, 8u);
//    *(_BYTE*)(a1 + (unsigned __int8)sub_425EF0(*(_DWORD*)(a1 + 56)) + 181) = 1;
//    *(_BYTE*)(a1 + 68) = 0;
//    *(_BYTE*)(a1 + 71) = 0;
//    *(_BYTE*)(a1 + 70) = -1;
//    if ((*(_BYTE*)(a1 + 72) == 11 || *(_BYTE*)(a1 + 72) == 13) && *(int*)(a1 + 84) < 0)
//    {
//        *(_DWORD*)(a1 + 84) = rand() % 300 + 300;
//        *(_DWORD*)(a1 + 80) = *(_DWORD*)(a1 + 84);
//    }
//    if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)171)
//    {
//        v116 = (_DWORD*)sub_464AC9(*(_DWORD*)(a1 + 56), 0, 1);
//        if (v116)
//        {
//            *(_DWORD*)(a1 + 96) = sub_426090(v116);
//            *(_DWORD*)(a1 + 100) = sub_4260B0(v116);
//            LODWORD(v6) = sub_4260D0(v116) - 800;
//            *(_DWORD*)(a1 + 104) = v6;
//            *(_DWORD*)(a1 + 152) = 30;
//            return v6;
//        }
//        goto LABEL_259;
//    }
//    if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)172)
//    {
//        v115 = sub_464AC9(*(_DWORD*)(a1 + 56), 0, 1);
//        if (v115)
//        {
//            *(_DWORD*)(a1 + 16) = 4;
//            *(_DWORD*)(a1 + 12) = 4;
//            *(_DWORD*)(a1 + 60) = v115;
//            HIDWORD(v6) = rand() % 60 + 120;
//            LODWORD(v6) = a1;
//            *(_DWORD*)(a1 + 76) = HIDWORD(v6);
//            *(_DWORD*)(a1 + 128) = -1500;
//            return v6;
//        }
//        goto LABEL_259;
//    }
//    if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)173)
//    {
//        *(_BYTE*)(a1 + 68) = 1;
//        *(_BYTE*)(a1 + 71) = 1;
//        *(_BYTE*)(a1 + 69) = 0;
//        *(_BYTE*)(a1 + 194) = 3;
//        goto LABEL_259;
//    }
//    if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)180)
//    {
//        *(_BYTE*)(a1 + 194) = 11;
//        *(_BYTE*)(a1 + 71) = 1;
//        *(_DWORD*)(a1 + 120) = 2 * a3 + 320;
//        if (*(int*)(a1 + 120) < 440)
//            *(_DWORD*)(a1 + 120) = 440;
//        if ((int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56)) <= 0)
//            v66 = -Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56));
//        else
//            v66 = Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56));
//        *(_DWORD*)(a1 + 120) += v66;
//        if (*(int*)(a1 + 120) > 1000)
//            *(_DWORD*)(a1 + 120) = 1000;
//        if (!*(_DWORD*)(a1 + 164))
//            *(_DWORD*)(a1 + 120) = -*(_DWORD*)(a1 + 120);
//        *(_DWORD*)(a1 + 124) = 0;
//        *(_DWORD*)(a1 + 120) *= 1000;
//        *(_DWORD*)(a1 + 140) = 1000;
//        *(_DWORD*)(a1 + 136) = 1000;
//        *(_DWORD*)(a1 + 132) = 1000;
//        if (a6)
//        {
//            if (*(int*)(a1 + 120) <= 0)
//                v65 = -*(_DWORD*)(a1 + 120);
//            else
//                v65 = *(_DWORD*)(a1 + 120);
//            v7 = sub_426090(a6);
//            v112 = v7 - sub_426470(a1);
//            v8 = sub_4260B0(a6);
//            v113 = v8 - sub_426530(a1);
//            sub_4260D0((_DWORD*)a6);
//            Concurrency::details::UMSFreeVirtualProcessorRoot::GetExecutingProxy((Concurrency::details::UMSFreeVirtualProcessorRoot*)a1);
//            X = sub_4A3090(
//                COERCE_UNSIGNED_INT64((double)v113),
//                HIDWORD(COERCE_UNSIGNED_INT64((double)v113)),
//                COERCE_UNSIGNED_INT64((double)v112),
//                HIDWORD(COERCE_UNSIGNED_INT64((double)v112)));
//            *(_DWORD*)(a1 + 120) = (__int64)(cos(X) * (double)v65);
//            *(_DWORD*)(a1 + 124) = (__int64)(sin(X) * (double)v65);
//        }
//        *(_DWORD*)(a1 + 144) = 0;
//        *(_DWORD*)(a1 + 148) = 0;
//        if (3 * *(_DWORD*)(a1 + 120) / 4 <= 0)
//            v64 = 3 * *(_DWORD*)(a1 + 120) / -4;
//        else
//            v64 = 3 * *(_DWORD*)(a1 + 120) / 4;
//        *(_DWORD*)(a1 + 128) = -v64;
//        LODWORD(v6) = -*(_DWORD*)(a1 + 128) / 30;
//        *(_DWORD*)(a1 + 152) = v6;
//        return v6;
//    }
//    if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) != (struct Concurrency::ISchedulerProxy*)183)
//    {
//        if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)184)
//        {
//            *(_BYTE*)(a1 + 71) = 1;
//            *(_BYTE*)(a1 + 194) = 11;
//            *(_BYTE*)(a1 + 70) = 5;
//        }
//        else if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)185)
//        {
//            *(_BYTE*)(a1 + 71) = 1;
//            *(_BYTE*)(a1 + 194) = 3;
//            *(_BYTE*)(a1 + 70) = 5;
//        }
//        else
//        {
//            if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)186)
//            {
//                *(_BYTE*)(a1 + 71) = 1;
//                *(_BYTE*)(a1 + 194) = 3;
//                *(_BYTE*)(a1 + 70) = 5;
//                *(_DWORD*)(a1 + 120) = 2 * a3 + 320;
//                if (*(int*)(a1 + 120) < 440)
//                    *(_DWORD*)(a1 + 120) = 440;
//                if ((int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56)) <= 0)
//                    v55 = -Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56));
//                else
//                    v55 = Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56));
//                *(_DWORD*)(a1 + 120) += v55;
//                if (*(int*)(a1 + 120) > 1000)
//                    *(_DWORD*)(a1 + 120) = 1000;
//                if (!*(_DWORD*)(a1 + 164))
//                    *(_DWORD*)(a1 + 120) = -*(_DWORD*)(a1 + 120);
//                *(_DWORD*)(a1 + 120) = 3 * *(_DWORD*)(a1 + 120) / 2;
//                *(_DWORD*)(a1 + 124) = 0;
//                if (sub_425D30(*(_DWORD*)(a1 + 56)))
//                {
//                    if (*(int*)(a1 + 120) <= 0)
//                        v54 = -*(_DWORD*)(a1 + 120);
//                    else
//                        v54 = *(_DWORD*)(a1 + 120);
//                    *(_DWORD*)(a1 + 128) = v54 / 2;
//                }
//                else
//                {
//                    *(_DWORD*)(a1 + 128) = 0;
//                }
//                LODWORD(v6) = a1;
//                *(_DWORD*)(a1 + 152) = 0;
//                *(_DWORD*)(a1 + 144) = 0;
//                *(_DWORD*)(a1 + 148) = 0;
//                if (a6)
//                {
//                    if (*(int*)(a1 + 120) <= 0)
//                        v53 = -*(_DWORD*)(a1 + 120);
//                    else
//                        v53 = *(_DWORD*)(a1 + 120);
//                    v12 = sub_426090(a6);
//                    v99 = v12 - sub_426470(a1);
//                    v13 = sub_4260B0(a6);
//                    v101 = v13 - sub_426530(a1);
//                    v14 = (sub_4260D0((_DWORD*)a6) - 1500) / 100;
//                    v100 = 100
//                        * (v14
//                            - (int)Concurrency::details::UMSFreeVirtualProcessorRoot::GetExecutingProxy((Concurrency::details::UMSFreeVirtualProcessorRoot*)a1)
//                            / 100);
//                    v102 = sub_4A3090(
//                        COERCE_UNSIGNED_INT64((double)v101),
//                        HIDWORD(COERCE_UNSIGNED_INT64((double)v101)),
//                        COERCE_UNSIGNED_INT64((double)v99),
//                        HIDWORD(COERCE_UNSIGNED_INT64((double)v99)));
//                    *(_DWORD*)(a1 + 120) = (__int64)(cos(v102) * (double)v53);
//                    *(_DWORD*)(a1 + 124) = (__int64)(sin(v102) * (double)v53);
//                    v103 = sub_4A3090(
//                        COERCE_UNSIGNED_INT64((double)v100),
//                        HIDWORD(COERCE_UNSIGNED_INT64((double)v100)),
//                        COERCE_UNSIGNED_INT64((double)v99),
//                        HIDWORD(COERCE_UNSIGNED_INT64((double)v99)));
//                    v6 = (__int64)(sin(v103) * (double)v53);
//                    *(_DWORD*)(a1 + 128) = v6;
//                }
//                return v6;
//            }
//            if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)189)
//            {
//                *(_DWORD*)(a1 + 88) = *(unsigned __int16*)(a1 + 192) / 85;
//                if (*(int*)(a1 + 88) <= 0)
//                    *(_DWORD*)(a1 + 88) = 1;
//                *(_BYTE*)(a1 + 71) = 1;
//                *(_BYTE*)(a1 + 194) = 3;
//                *(_BYTE*)(a1 + 70) = 5;
//                *(_DWORD*)(a1 + 136) = 1000;
//                *(_DWORD*)(a1 + 132) = 1000;
//                *(_DWORD*)(a1 + 140) = 1;
//                v36 = sub_426530(a1) / 100;
//                v15 = sub_426470(a1);
//                v98 = -100 * sub_446497(v15 / 100, v36);
//                if (v98 == -102000)
//                    *(_DWORD*)(a1 + 128) = -200;
//                else
//                    *(_DWORD*)(a1 + 128) = (v98
//                        - 1200
//                        - (int)Concurrency::details::UMSFreeVirtualProcessorRoot::GetExecutingProxy((Concurrency::details::UMSFreeVirtualProcessorRoot*)a1))
//                    / 30;
//                LODWORD(v6) = a1;
//                *(_DWORD*)(a1 + 120) = 0;
//                *(_DWORD*)(a1 + 144) = 10000;
//                if (!*(_DWORD*)(a1 + 164))
//                {
//                    LODWORD(v6) = a1;
//                    *(_DWORD*)(a1 + 144) = -*(_DWORD*)(a1 + 144);
//                }
//                if (a6)
//                {
//                    v16 = sub_426090(a6);
//                    v95 = v16 - sub_426470(a1);
//                    v17 = sub_4260B0(a6);
//                    v96 = v17 - sub_426530(a1);
//                    v97 = sub_4A3090(
//                        COERCE_UNSIGNED_INT64((double)v96),
//                        HIDWORD(COERCE_UNSIGNED_INT64((double)v96)),
//                        COERCE_UNSIGNED_INT64((double)v95),
//                        HIDWORD(COERCE_UNSIGNED_INT64((double)v95)));
//                    *(_DWORD*)(a1 + 120) = 0;
//                    *(_DWORD*)(a1 + 124) = 0;
//                    *(_DWORD*)(a1 + 144) = (__int64)(cos(v97) * (double)150000 / 15.0);
//                    v6 = (__int64)(sin(v97) * (double)150000 / 15.0);
//                    *(_DWORD*)(a1 + 148) = v6;
//                }
//                return v6;
//            }
//            if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)190)
//            {
//                *(_BYTE*)(a1 + 68) = 1;
//                *(_BYTE*)(a1 + 71) = 1;
//                *(_BYTE*)(a1 + 194) = 5;
//                *(_BYTE*)(a1 + 70) = 5;
//                *(_DWORD*)(a1 + 120) = 2 * a3 + 200;
//                if (*(int*)(a1 + 120) < 440)
//                    *(_DWORD*)(a1 + 120) = 440;
//                if ((int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56)) <= 0)
//                    v52 = -Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56));
//                else
//                    v52 = Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56));
//                *(_DWORD*)(a1 + 120) += v52;
//                if (*(int*)(a1 + 120) > 500)
//                    *(_DWORD*)(a1 + 120) = 500;
//                if (!*(_DWORD*)(a1 + 164))
//                    *(_DWORD*)(a1 + 120) = -*(_DWORD*)(a1 + 120);
//                *(_DWORD*)(a1 + 124) = 0;
//                *(_DWORD*)(a1 + 128) = 0;
//                *(_DWORD*)(a1 + 152) = 0;
//                LODWORD(v6) = a1;
//                *(_DWORD*)(a1 + 144) = 0;
//                *(_DWORD*)(a1 + 148) = 0;
//                if (a6)
//                {
//                    if (*(int*)(a1 + 120) <= 0)
//                        v51 = -*(_DWORD*)(a1 + 120);
//                    else
//                        v51 = *(_DWORD*)(a1 + 120);
//                    v18 = sub_426090(a6);
//                    v92 = v18 - sub_426470(a1);
//                    v19 = sub_4260B0(a6);
//                    v93 = v19 - sub_426530(a1);
//                    v94 = sub_4A3090(
//                        COERCE_UNSIGNED_INT64((double)v93),
//                        HIDWORD(COERCE_UNSIGNED_INT64((double)v93)),
//                        COERCE_UNSIGNED_INT64((double)v92),
//                        HIDWORD(COERCE_UNSIGNED_INT64((double)v92)));
//                    *(_DWORD*)(a1 + 120) = (__int64)(cos(v94) * (double)v51);
//                    v6 = (__int64)(sin(v94) * (double)v51);
//                    *(_DWORD*)(a1 + 124) = v6;
//                }
//                return v6;
//            }
//            if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)191)
//            {
//                *(_BYTE*)(a1 + 71) = 1;
//                *(_BYTE*)(a1 + 194) = 3;
//                *(_BYTE*)(a1 + 70) = 5;
//                *(_DWORD*)(a1 + 120) = 2 * a3 + 320;
//                if (*(int*)(a1 + 120) < 440)
//                    *(_DWORD*)(a1 + 120) = 440;
//                if ((int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56)) <= 0)
//                    v50 = -Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56));
//                else
//                    v50 = Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56));
//                *(_DWORD*)(a1 + 120) += v50;
//                if (*(int*)(a1 + 120) > 800)
//                    *(_DWORD*)(a1 + 120) = 800;
//                if (!*(_DWORD*)(a1 + 164))
//                    *(_DWORD*)(a1 + 120) = -*(_DWORD*)(a1 + 120);
//                *(_DWORD*)(a1 + 124) = 0;
//                if (sub_425D30(*(_DWORD*)(a1 + 56)))
//                {
//                    if (*(int*)(a1 + 120) <= 0)
//                        v49 = -*(_DWORD*)(a1 + 120);
//                    else
//                        v49 = *(_DWORD*)(a1 + 120);
//                    *(_DWORD*)(a1 + 128) = v49 / 2;
//                }
//                else
//                {
//                    *(_DWORD*)(a1 + 128) = 0;
//                }
//                LODWORD(v6) = a1;
//                *(_DWORD*)(a1 + 152) = 0;
//                *(_DWORD*)(a1 + 144) = 0;
//                *(_DWORD*)(a1 + 148) = 0;
//                if (a6)
//                {
//                    if (*(int*)(a1 + 120) <= 0)
//                        v48 = -*(_DWORD*)(a1 + 120);
//                    else
//                        v48 = *(_DWORD*)(a1 + 120);
//                    v20 = sub_426090(a6);
//                    v87 = v20 - sub_426470(a1);
//                    v21 = sub_4260B0(a6);
//                    v89 = v21 - sub_426530(a1);
//                    v22 = (sub_4260D0((_DWORD*)a6) - 1500) / 100;
//                    v88 = 100
//                        * (v22
//                            - (int)Concurrency::details::UMSFreeVirtualProcessorRoot::GetExecutingProxy((Concurrency::details::UMSFreeVirtualProcessorRoot*)a1)
//                            / 100);
//                    v90 = sub_4A3090(
//                        COERCE_UNSIGNED_INT64((double)v89),
//                        HIDWORD(COERCE_UNSIGNED_INT64((double)v89)),
//                        COERCE_UNSIGNED_INT64((double)v87),
//                        HIDWORD(COERCE_UNSIGNED_INT64((double)v87)));
//                    *(_DWORD*)(a1 + 120) = (__int64)(cos(v90) * (double)v48);
//                    *(_DWORD*)(a1 + 124) = (__int64)(sin(v90) * (double)v48);
//                    v91 = sub_4A3090(
//                        COERCE_UNSIGNED_INT64((double)v88),
//                        HIDWORD(COERCE_UNSIGNED_INT64((double)v88)),
//                        COERCE_UNSIGNED_INT64((double)v87),
//                        HIDWORD(COERCE_UNSIGNED_INT64((double)v87)));
//                    v6 = (__int64)(sin(v91) * (double)v48);
//                    *(_DWORD*)(a1 + 128) = v6;
//                }
//                return v6;
//            }
//            if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)192)
//            {
//                *(_BYTE*)(a1 + 71) = 1;
//                *(_BYTE*)(a1 + 194) = 3;
//                *(_BYTE*)(a1 + 70) = 5;
//                *(_DWORD*)(a1 + 120) = 2 * a3 + 150;
//                if (*(int*)(a1 + 120) < 200)
//                    *(_DWORD*)(a1 + 120) = 200;
//                if ((int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56)) / 2 <= 0)
//                    v47 = (int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56)) / -2;
//                else
//                    v47 = (int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56)) / 2;
//                *(_DWORD*)(a1 + 120) += v47;
//                if (*(int*)(a1 + 120) > 500)
//                    *(_DWORD*)(a1 + 120) = 500;
//                if (!*(_DWORD*)(a1 + 164))
//                    *(_DWORD*)(a1 + 120) = -*(_DWORD*)(a1 + 120);
//                *(_DWORD*)(a1 + 124) = 0;
//                *(_DWORD*)(a1 + 128) = 0;
//                *(_DWORD*)(a1 + 152) = 0;
//                *(_DWORD*)(a1 + 144) = 0;
//                LODWORD(v6) = a1;
//                *(_DWORD*)(a1 + 148) = 0;
//                if (a6)
//                {
//                    if (*(int*)(a1 + 120) <= 0)
//                        v46 = -*(_DWORD*)(a1 + 120);
//                    else
//                        v46 = *(_DWORD*)(a1 + 120);
//                    v23 = sub_426090(a6);
//                    v84 = v23 - sub_426470(a1);
//                    v24 = sub_4260B0(a6);
//                    v85 = v24 - sub_426530(a1);
//                    v86 = sub_4A3090(
//                        COERCE_UNSIGNED_INT64((double)v85),
//                        HIDWORD(COERCE_UNSIGNED_INT64((double)v85)),
//                        COERCE_UNSIGNED_INT64((double)v84),
//                        HIDWORD(COERCE_UNSIGNED_INT64((double)v84)));
//                    *(_DWORD*)(a1 + 120) = (__int64)(cos(v86) * (double)v46);
//                    v6 = (__int64)(sin(v86) * (double)v46);
//                    *(_DWORD*)(a1 + 124) = v6;
//                }
//                return v6;
//            }
//            if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) != (struct Concurrency::ISchedulerProxy*)193)
//            {
//                if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)194)
//                {
//                    *(_BYTE*)(a1 + 71) = 1;
//                    *(_BYTE*)(a1 + 194) = 3;
//                    *(_BYTE*)(a1 + 70) = 5;
//                    *(_DWORD*)(a1 + 120) = 2 * a3 + 150;
//                    if (*(int*)(a1 + 120) < 200)
//                        *(_DWORD*)(a1 + 120) = 200;
//                    if ((int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56)) / 2 <= 0)
//                        v45 = (int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56)) / -2;
//                    else
//                        v45 = (int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56)) / 2;
//                    *(_DWORD*)(a1 + 120) += v45;
//                    if (*(int*)(a1 + 120) > 500)
//                        *(_DWORD*)(a1 + 120) = 500;
//                    if (!*(_DWORD*)(a1 + 164))
//                        *(_DWORD*)(a1 + 120) = -*(_DWORD*)(a1 + 120);
//                    *(_DWORD*)(a1 + 124) = 0;
//                    *(_DWORD*)(a1 + 128) = 0;
//                    *(_DWORD*)(a1 + 152) = 0;
//                    LODWORD(v6) = a1;
//                    *(_DWORD*)(a1 + 144) = 0;
//                    *(_DWORD*)(a1 + 148) = 0;
//                    if (a6)
//                    {
//                        if (*(int*)(a1 + 120) <= 0)
//                            v44 = -*(_DWORD*)(a1 + 120);
//                        else
//                            v44 = *(_DWORD*)(a1 + 120);
//                        v25 = sub_426090(a6);
//                        v81 = v25 - sub_426470(a1);
//                        v26 = sub_4260B0(a6);
//                        v82 = v26 - sub_426530(a1);
//                        v83 = sub_4A3090(
//                            COERCE_UNSIGNED_INT64((double)v82),
//                            HIDWORD(COERCE_UNSIGNED_INT64((double)v82)),
//                            COERCE_UNSIGNED_INT64((double)v81),
//                            HIDWORD(COERCE_UNSIGNED_INT64((double)v81)));
//                        *(_DWORD*)(a1 + 120) = (__int64)(cos(v83) * (double)v44);
//                        v6 = (__int64)(sin(v83) * (double)v44);
//                        *(_DWORD*)(a1 + 124) = v6;
//                    }
//                }
//                else
//                {
//                    if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)195)
//                    {
//                        *(_DWORD*)(a1 + 60) = sub_464AC9(*(_DWORD*)(a1 + 56), 0, 1);
//                        if (*(_DWORD*)(a1 + 60))
//                        {
//                            *(_BYTE*)(a1 + 71) = 1;
//                            *(_BYTE*)(a1 + 194) = 11;
//                            *(_BYTE*)(a1 + 70) = 5;
//                            *(_DWORD*)(a1 + 120) = 10 * (*(_DWORD*)(a1 + 164) - (*(_DWORD*)(a1 + 164) == 0));
//                            if (sub_425D30(*(_DWORD*)(a1 + 56)))
//                                *(_DWORD*)(a1 + 128) = 5;
//                            else
//                                *(_DWORD*)(a1 + 128) = 1;
//                            LODWORD(v6) = a1;
//                            *(_DWORD*)(a1 + 152) = 0;
//                            return v6;
//                        }
//                        goto LABEL_259;
//                    }
//                    if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)196)
//                    {
//                        *(_BYTE*)(a1 + 71) = 1;
//                        *(_BYTE*)(a1 + 68) = 1;
//                        *(_BYTE*)(a1 + 194) = 2;
//                        *(_DWORD*)(a1 + 120) = 2 * a3 + 150;
//                        if (*(int*)(a1 + 120) < 200)
//                            *(_DWORD*)(a1 + 120) = 200;
//                        if ((int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56)) / 2 <= 0)
//                            v43 = (int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56))
//                            / -2;
//                        else
//                            v43 = (int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56)) / 2;
//                        *(_DWORD*)(a1 + 120) += v43;
//                        if (*(int*)(a1 + 120) > 500)
//                            *(_DWORD*)(a1 + 120) = 500;
//                        if (!*(_DWORD*)(a1 + 164))
//                            *(_DWORD*)(a1 + 120) = -*(_DWORD*)(a1 + 120);
//                        *(_DWORD*)(a1 + 124) = 0;
//                        *(_DWORD*)(a1 + 128) = 0;
//                        LODWORD(v6) = a1;
//                        *(_DWORD*)(a1 + 152) = 0;
//                        *(_DWORD*)(a1 + 144) = 0;
//                        *(_DWORD*)(a1 + 148) = 0;
//                        if (a6)
//                        {
//                            if (*(int*)(a1 + 120) <= 0)
//                                v42 = -*(_DWORD*)(a1 + 120);
//                            else
//                                v42 = *(_DWORD*)(a1 + 120);
//                            v27 = sub_426090(a6);
//                            v78 = v27 - sub_426470(a1);
//                            v28 = sub_4260B0(a6);
//                            v79 = v28 - sub_426530(a1);
//                            v80 = sub_4A3090(
//                                COERCE_UNSIGNED_INT64((double)v79),
//                                HIDWORD(COERCE_UNSIGNED_INT64((double)v79)),
//                                COERCE_UNSIGNED_INT64((double)v78),
//                                HIDWORD(COERCE_UNSIGNED_INT64((double)v78)));
//                            *(_DWORD*)(a1 + 120) = (__int64)(cos(v80) * (double)v42);
//                            v6 = (__int64)(sin(v80) * (double)v42);
//                            *(_DWORD*)(a1 + 124) = v6;
//                        }
//                    }
//                    else
//                    {
//                        if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) != (struct Concurrency::ISchedulerProxy*)197)
//                        {
//                            if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)198)
//                            {
//                                *(_DWORD*)(a1 + 120) = 10 * (*(_DWORD*)(a1 + 164) - (*(_DWORD*)(a1 + 164) == 0));
//                                *(_BYTE*)(a1 + 71) = 1;
//                                *(_BYTE*)(a1 + 68) = rand() % 3 == 0;
//                                HIDWORD(v6) = rand() % 14;
//                                LODWORD(v6) = a1;
//                                *(_BYTE*)(a1 + 194) = BYTE4(v6);
//                                return v6;
//                            }
//                            goto LABEL_259;
//                        }
//                        *(_BYTE*)(a1 + 71) = 1;
//                        *(_BYTE*)(a1 + 194) = 3;
//                        *(_BYTE*)(a1 + 70) = 5;
//                        *(_DWORD*)(a1 + 120) = 2 * a3 + 320;
//                        if (*(int*)(a1 + 120) < 440)
//                            *(_DWORD*)(a1 + 120) = 440;
//                        if (*(int*)(a1 + 120) > 1000)
//                            *(_DWORD*)(a1 + 120) = 1000;
//                        if (!*(_DWORD*)(a1 + 164))
//                            *(_DWORD*)(a1 + 120) = -*(_DWORD*)(a1 + 120);
//                        *(_DWORD*)(a1 + 124) = 0;
//                        if (sub_425D30(*(_DWORD*)(a1 + 56)))
//                        {
//                            if (*(int*)(a1 + 120) <= 0)
//                                v41 = -*(_DWORD*)(a1 + 120);
//                            else
//                                v41 = *(_DWORD*)(a1 + 120);
//                            *(_DWORD*)(a1 + 128) = v41 / 2;
//                        }
//                        else
//                        {
//                            *(_DWORD*)(a1 + 128) = 0;
//                        }
//                        *(_DWORD*)(a1 + 152) = 0;
//                        *(_DWORD*)(a1 + 144) = 0;
//                        *(_DWORD*)(a1 + 148) = 0;
//                        if (a6)
//                        {
//                            if (*(int*)(a1 + 120) <= 0)
//                                v40 = -*(_DWORD*)(a1 + 120);
//                            else
//                                v40 = *(_DWORD*)(a1 + 120);
//                            v29 = sub_426090(a6);
//                            v73 = v29 - sub_426470(a1);
//                            v30 = sub_4260B0(a6);
//                            v75 = v30 - sub_426530(a1);
//                            v31 = (sub_4260D0((_DWORD*)a6) - 1500) / 100;
//                            v74 = 100
//                                * (v31
//                                    - (int)Concurrency::details::UMSFreeVirtualProcessorRoot::GetExecutingProxy((Concurrency::details::UMSFreeVirtualProcessorRoot*)a1)
//                                    / 100);
//                            v76 = sub_4A3090(
//                                COERCE_UNSIGNED_INT64((double)v75),
//                                HIDWORD(COERCE_UNSIGNED_INT64((double)v75)),
//                                COERCE_UNSIGNED_INT64((double)v73),
//                                HIDWORD(COERCE_UNSIGNED_INT64((double)v73)));
//                            *(_DWORD*)(a1 + 120) = (__int64)(cos(v76) * (double)v40);
//                            *(_DWORD*)(a1 + 124) = (__int64)(sin(v76) * (double)v40);
//                            v77 = sub_4A3090(
//                                COERCE_UNSIGNED_INT64((double)v74),
//                                HIDWORD(COERCE_UNSIGNED_INT64((double)v74)),
//                                COERCE_UNSIGNED_INT64((double)v73),
//                                HIDWORD(COERCE_UNSIGNED_INT64((double)v73)));
//                            *(_DWORD*)(a1 + 128) = (__int64)(sin(v77) * (double)v40);
//                        }
//                        *(_DWORD*)(a1 + 88) = *(_DWORD*)(a1 + 120);
//                        LODWORD(v6) = a1;
//                        *(_DWORD*)(a1 + 92) = *(_DWORD*)(a1 + 124);
//                    }
//                }
//                return v6;
//            }
//            *(_BYTE*)(a1 + 71) = 1;
//            *(_BYTE*)(a1 + 194) = 3;
//            *(_BYTE*)(a1 + 70) = 5;
//        }
//    LABEL_259:
//        if (*(unsigned __int8*)(a1 + 72) < 2u
//            || *(unsigned __int8*)(a1 + 72) >= 4u && *(unsigned __int8*)(a1 + 72) <= 7u
//            || *(_BYTE*)(a1 + 72) == 11
//            || *(_BYTE*)(a1 + 72) == 12)
//        {
//            *(_DWORD*)(a1 + 120) = 2 * a3 + 320;
//            if (*(int*)(a1 + 120) < 440)
//                *(_DWORD*)(a1 + 120) = 440;
//            if ((int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56)) <= 0)
//                v39 = -Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56));
//            else
//                v39 = Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56));
//            *(_DWORD*)(a1 + 120) += v39;
//            if (*(int*)(a1 + 120) > 1000)
//                *(_DWORD*)(a1 + 120) = 1000;
//            if (!*(_DWORD*)(a1 + 164))
//                *(_DWORD*)(a1 + 120) = -*(_DWORD*)(a1 + 120);
//            if (*(_DWORD*)(a1 + 8) == 185)
//            {
//                *(int*)(a1 + 120) /= 4;
//            }
//            else if (*(_DWORD*)(a1 + 8) == 193)
//            {
//                *(int*)(a1 + 120) /= 2;
//            }
//            *(_DWORD*)(a1 + 124) = 0;
//            if (a5)
//            {
//                if (*(int*)(a1 + 120) <= 0)
//                    v38 = -*(_DWORD*)(a1 + 120);
//                else
//                    v38 = *(_DWORD*)(a1 + 120);
//                *(_DWORD*)(a1 + 128) = v38 / 2;
//                *(_DWORD*)(a1 + 152) = 0;
//            }
//            else
//            {
//                *(_DWORD*)(a1 + 128) = 0;
//                *(_DWORD*)(a1 + 152) = 0;
//            }
//            LODWORD(v6) = a1;
//            *(_DWORD*)(a1 + 144) = 0;
//            *(_DWORD*)(a1 + 148) = 0;
//            if (a6)
//            {
//                if (*(int*)(a1 + 120) <= 0)
//                    v37 = -*(_DWORD*)(a1 + 120);
//                else
//                    v37 = *(_DWORD*)(a1 + 120);
//                v32 = sub_426090(a6);
//                v68 = v32 - sub_426470(a1);
//                v33 = sub_4260B0(a6);
//                v70 = v33 - sub_426530(a1);
//                v34 = (sub_4260D0((_DWORD*)a6) - 1500) / 100;
//                v69 = 100
//                    * (v34
//                        - (int)Concurrency::details::UMSFreeVirtualProcessorRoot::GetExecutingProxy((Concurrency::details::UMSFreeVirtualProcessorRoot*)a1)
//                        / 100);
//                v71 = sub_4A3090(
//                    COERCE_UNSIGNED_INT64((double)v70),
//                    HIDWORD(COERCE_UNSIGNED_INT64((double)v70)),
//                    COERCE_UNSIGNED_INT64((double)v68),
//                    HIDWORD(COERCE_UNSIGNED_INT64((double)v68)));
//                *(_DWORD*)(a1 + 120) = (__int64)(cos(v71) * (double)v37);
//                *(_DWORD*)(a1 + 124) = (__int64)(sin(v71) * (double)v37);
//                v72 = sub_4A3090(
//                    COERCE_UNSIGNED_INT64((double)v69),
//                    HIDWORD(COERCE_UNSIGNED_INT64((double)v69)),
//                    COERCE_UNSIGNED_INT64((double)v68),
//                    HIDWORD(COERCE_UNSIGNED_INT64((double)v68)));
//                v6 = (__int64)(sin(v72) * (double)v37);
//                *(_DWORD*)(a1 + 128) = v6;
//            }
//        }
//        else if (*(_BYTE*)(a1 + 72) == 2)
//        {
//            *(_DWORD*)(a1 + 120) = 150 * (*(_DWORD*)(a1 + 164) - (*(_DWORD*)(a1 + 164) == 0));
//            *(_DWORD*)(a1 + 96) = *(_DWORD*)(a1 + 120) + sub_426090(*(_DWORD*)(a1 + 56));
//            *(_DWORD*)(a1 + 124) = 0;
//            *(_DWORD*)(a1 + 128) = -860;
//            *(_DWORD*)(a1 + 144) = 0;
//            LODWORD(v6) = a1;
//            *(_DWORD*)(a1 + 148) = 0;
//            *(_DWORD*)(a1 + 152) = 30;
//        }
//        else if (*(_BYTE*)(a1 + 72) == 3)
//        {
//            *(_DWORD*)(a1 + 120) = 250;
//            if (!*(_DWORD*)(a1 + 164))
//                *(_DWORD*)(a1 + 120) = -*(_DWORD*)(a1 + 120);
//            *(_DWORD*)(a1 + 124) = 0;
//            *(_DWORD*)(a1 + 128) = -300;
//            *(_DWORD*)(a1 + 144) = 0;
//            LODWORD(v6) = a1;
//            *(_DWORD*)(a1 + 148) = 0;
//            *(_DWORD*)(a1 + 152) = 30;
//        }
//        else if (*(_BYTE*)(a1 + 72) == 8
//            || *(_BYTE*)(a1 + 72) == 9
//            || *(_BYTE*)(a1 + 72) == 10
//            || (LODWORD(v6) = *(unsigned __int8*)(a1 + 72), (_DWORD)v6 == 13))
//        {
//            *(_DWORD*)(a1 + 120) = 300;
//            if (!*(_DWORD*)(a1 + 164))
//                *(_DWORD*)(a1 + 120) = -*(_DWORD*)(a1 + 120);
//            *(_DWORD*)(a1 + 124) = 0;
//            *(_DWORD*)(a1 + 128) = -180;
//            *(_DWORD*)(a1 + 144) = 0;
//            LODWORD(v6) = a1;
//            *(_DWORD*)(a1 + 148) = 0;
//            *(_DWORD*)(a1 + 152) = 30;
//        }
//        return v6;
//    }
//    if (!a6)
//        a6 = sub_4682D3(*(_DWORD*)(a1 + 56), 0);
//    if (!a6)
//        goto LABEL_259;
//    *(_BYTE*)(a1 + 70) = 5;
//    *(_DWORD*)(a1 + 60) = a6;
//    *(_BYTE*)(a1 + 194) = 3;
//    *(_BYTE*)(a1 + 71) = 1;
//    sub_44647E(dword_4B9B10);
//    v9 = sub_426090(a6);
//    v106 = v9 - sub_426470(a1);
//    v10 = sub_4260B0(a6);
//    v108 = v10 - sub_426530(a1);
//    v111 = sub_425D70(*(_DWORD*)(a1 + 56));
//    if (!v106)
//    {
//        if (v108 <= 0)
//            v63 = -v108;
//        else
//            v63 = v108;
//        v106 = (v111 - (v111 == 0)) * v63;
//    }
//    v11 = (sub_4260D0((_DWORD*)a6) - 1500) / 100;
//    v107 = 100
//        * (v11
//            - (int)Concurrency::details::UMSFreeVirtualProcessorRoot::GetExecutingProxy((Concurrency::details::UMSFreeVirtualProcessorRoot*)a1)
//            / 100);
//    v62 = sub_4A3090(
//        COERCE_UNSIGNED_INT64((double)v108),
//        HIDWORD(COERCE_UNSIGNED_INT64((double)v108)),
//        COERCE_UNSIGNED_INT64((double)v106),
//        HIDWORD(COERCE_UNSIGNED_INT64((double)v106)));
//    v109 = (double)(2 * (rand() % 2) - 1) * 0.2053981633 + v62;
//    *(_DWORD*)(a1 + 120) = (__int64)(cos(v109) * (double)160);
//    *(_DWORD*)(a1 + 124) = (__int64)(sin(v109) * (double)160);
//    if (*(int*)(a1 + 120) <= 0)
//        v61 = -*(_DWORD*)(a1 + 120);
//    else
//        v61 = *(_DWORD*)(a1 + 120);
//    if (*(int*)(a1 + 124) <= 0)
//        v60 = -*(_DWORD*)(a1 + 124);
//    else
//        v60 = *(_DWORD*)(a1 + 124);
//    if (v61 < v60)
//    {
//        v105 = *(_DWORD*)(a1 + 120);
//        v104 = *(_DWORD*)(a1 + 124);
//        if (v104 <= 0)
//            v59 = -v104;
//        else
//            v59 = *(_DWORD*)(a1 + 124);
//        if (v105 <= 0)
//            v58 = (v105 >= 0) - 1;
//        else
//            v58 = 1;
//        *(_DWORD*)(a1 + 120) = v58 * v59;
//        if (v105 <= 0)
//            v57 = -v105;
//        else
//            v57 = v105;
//        if (v104 <= 0)
//            v56 = (v104 >= 0) - 1;
//        else
//            v56 = 1;
//        *(_DWORD*)(a1 + 124) = v56 * v57;
//    }
//    if (!v111 && *(int*)(a1 + 120) > 0 || v111 && *(int*)(a1 + 120) < 0)
//        *(_DWORD*)(a1 + 120) = -*(_DWORD*)(a1 + 120);
//    v110 = sub_4A3090(
//        COERCE_UNSIGNED_INT64((double)v107),
//        HIDWORD(COERCE_UNSIGNED_INT64((double)v107)),
//        COERCE_UNSIGNED_INT64((double)v106),
//        HIDWORD(COERCE_UNSIGNED_INT64((double)v106)));
//    *(_DWORD*)(a1 + 128) = (__int64)(sin(v110) * (double)160);
//    LODWORD(v6) = a1;
//    if (*(int*)(a1 + 128) > 0)
//        *(_DWORD*)(a1 + 128) = 0;
//    *(_DWORD*)(a1 + 124) = 0;
//    return v6;
//}

int sub_4917E7(int a1, double a2, int a3, int a4, int a5, _DWORD* a6)
{
    int result; // eax
    int v7; // edx
    int v8; // esi
    int v9; // esi
    double v10; // st7
    double v11; // st7
    int v12; // esi
    int v13; // esi
    int v14; // esi
    double v15; // st7
    double v16; // st7
    double v17; // st7
    int v18; // esi
    int v19; // esi
    int v20; // esi
    double v21; // st7
    double v22; // st7
    double v23; // st7
    int v24; // eax
    int v25; // esi
    int v26; // esi
    double v27; // st7
    double v28; // st7
    int v29; // esi
    int v30; // esi
    double v31; // st7
    double v32; // st7
    int v33; // esi
    int v34; // esi
    int v35; // esi
    double v36; // st7
    double v37; // st7
    double v38; // st7
    int v39; // esi
    int v40; // esi
    double v41; // st7
    double v42; // st7
    int v43; // esi
    int v44; // esi
    double v45; // st7
    double v46; // st7
    int v47; // esi
    int v48; // esi
    double v49; // st7
    double v50; // st7
    int v51; // esi
    int v52; // esi
    int v53; // esi
    double v54; // st7
    double v55; // st7
    double v56; // st7
    int v57; // edx
    int v58; // esi
    int v59; // esi
    int v60; // esi
    double v61; // st7
    double v62; // st7
    double v63; // st7
    double v64; // [esp+0h] [ebp-288h]
    double v65; // [esp+0h] [ebp-288h]
    double v66; // [esp+0h] [ebp-288h]
    double v67; // [esp+0h] [ebp-288h]
    double v68; // [esp+0h] [ebp-288h]
    double v69; // [esp+0h] [ebp-288h]
    double v70; // [esp+0h] [ebp-288h]
    double v71; // [esp+0h] [ebp-288h]
    double v72; // [esp+0h] [ebp-288h]
    double v73; // [esp+0h] [ebp-288h]
    double v74; // [esp+0h] [ebp-288h]
    double v75; // [esp+0h] [ebp-288h]
    double v76; // [esp+0h] [ebp-288h]
    double v77; // [esp+0h] [ebp-288h]
    double v78; // [esp+0h] [ebp-288h]
    double v79; // [esp+0h] [ebp-288h]
    double v80; // [esp+8h] [ebp-280h]
    double v81; // [esp+8h] [ebp-280h]
    double v82; // [esp+8h] [ebp-280h]
    double v83; // [esp+8h] [ebp-280h]
    double v84; // [esp+8h] [ebp-280h]
    double v85; // [esp+8h] [ebp-280h]
    double v86; // [esp+8h] [ebp-280h]
    double v87; // [esp+8h] [ebp-280h]
    double v88; // [esp+8h] [ebp-280h]
    double v89; // [esp+8h] [ebp-280h]
    double v90; // [esp+8h] [ebp-280h]
    double v91; // [esp+8h] [ebp-280h]
    double v92; // [esp+8h] [ebp-280h]
    double v93; // [esp+8h] [ebp-280h]
    double v94; // [esp+8h] [ebp-280h]
    double v95; // [esp+8h] [ebp-280h]
    int v96; // [esp+Ch] [ebp-27Ch]
    int v100; // [esp+2Ch] [ebp-25Ch]
    int v101; // [esp+30h] [ebp-258h]
    unsigned int v102; // [esp+34h] [ebp-254h]
    int v106; // [esp+50h] [ebp-238h]
    int v107; // [esp+54h] [ebp-234h]
    int v110; // [esp+68h] [ebp-220h]
    int v111; // [esp+6Ch] [ebp-21Ch]
    int v114; // [esp+80h] [ebp-208h]
    int v115; // [esp+84h] [ebp-204h]
    int v118; // [esp+98h] [ebp-1F0h]
    int v119; // [esp+9Ch] [ebp-1ECh]
    int v123; // [esp+B8h] [ebp-1D0h]
    int v124; // [esp+BCh] [ebp-1CCh]
    unsigned int v125; // [esp+C0h] [ebp-1C8h]
    int v128; // [esp+D4h] [ebp-1B4h]
    unsigned int v129; // [esp+D8h] [ebp-1B0h]
    int v135; // [esp+104h] [ebp-184h]
    int v136; // [esp+108h] [ebp-180h]
    unsigned int v137; // [esp+10Ch] [ebp-17Ch]
    int v139; // [esp+118h] [ebp-170h]
    int v140; // [esp+11Ch] [ebp-16Ch]
    int v141; // [esp+120h] [ebp-168h]
    int v142; // [esp+124h] [ebp-164h]
    int v143; // [esp+128h] [ebp-160h]
    int v144; // [esp+12Ch] [ebp-15Ch]
    int v147; // [esp+140h] [ebp-148h]
    int v149; // [esp+14Ch] [ebp-13Ch]
    int v150; // [esp+150h] [ebp-138h]
    int v153; // [esp+164h] [ebp-124h]
    unsigned int v154; // [esp+168h] [ebp-120h]
    int v156; // [esp+170h] [ebp-118h]
    int v157; // [esp+174h] [ebp-114h]
    int v158; // [esp+178h] [ebp-110h]
    double v159; // [esp+17Ch] [ebp-10Ch]
    double v160; // [esp+17Ch] [ebp-10Ch]
    int v161; // [esp+184h] [ebp-104h]
    int v162; // [esp+188h] [ebp-100h]
    int v163; // [esp+18Ch] [ebp-FCh]
    int v164; // [esp+190h] [ebp-F8h]
    double v165; // [esp+194h] [ebp-F4h]
    double v166; // [esp+194h] [ebp-F4h]
    int v167; // [esp+19Ch] [ebp-ECh]
    int v168; // [esp+1A0h] [ebp-E8h]
    int v169; // [esp+1A4h] [ebp-E4h]
    double v170; // [esp+1A8h] [ebp-E0h]
    int v171; // [esp+1B0h] [ebp-D8h]
    int v172; // [esp+1B4h] [ebp-D4h]
    int v173; // [esp+1B8h] [ebp-D0h]
    double v174; // [esp+1BCh] [ebp-CCh]
    int v175; // [esp+1C4h] [ebp-C4h]
    int v176; // [esp+1C8h] [ebp-C0h]
    int v177; // [esp+1CCh] [ebp-BCh]
    double v178; // [esp+1D0h] [ebp-B8h]
    int v179; // [esp+1D8h] [ebp-B0h]
    int v180; // [esp+1DCh] [ebp-ACh]
    int v181; // [esp+1E0h] [ebp-A8h]
    int v182; // [esp+1E4h] [ebp-A4h]
    double v183; // [esp+1E8h] [ebp-A0h]
    double v184; // [esp+1E8h] [ebp-A0h]
    int v185; // [esp+1F0h] [ebp-98h]
    int v186; // [esp+1F4h] [ebp-94h]
    int v187; // [esp+1F8h] [ebp-90h]
    double v188; // [esp+1FCh] [ebp-8Ch]
    int v189; // [esp+204h] [ebp-84h]
    int v190; // [esp+208h] [ebp-80h]
    int v191; // [esp+20Ch] [ebp-7Ch]
    double v192; // [esp+210h] [ebp-78h]
    int v193; // [esp+218h] [ebp-70h]
    int v194; // [esp+21Ch] [ebp-6Ch]
    int v195; // [esp+220h] [ebp-68h]
    int v196; // [esp+224h] [ebp-64h]
    int v197; // [esp+228h] [ebp-60h]
    double v198; // [esp+22Ch] [ebp-5Ch]
    double v199; // [esp+22Ch] [ebp-5Ch]
    int v200; // [esp+234h] [ebp-54h]
    int v201; // [esp+238h] [ebp-50h]
    int v202; // [esp+23Ch] [ebp-4Ch]
    int v203; // [esp+240h] [ebp-48h]
    int v204; // [esp+244h] [ebp-44h]
    int v205; // [esp+24Ch] [ebp-3Ch]
    double v206; // [esp+250h] [ebp-38h]
    double v207; // [esp+250h] [ebp-38h]
    int v208; // [esp+258h] [ebp-30h]
    int v209; // [esp+25Ch] [ebp-2Ch]
    int v210; // [esp+260h] [ebp-28h]
    int v211; // [esp+268h] [ebp-20h]
    double X; // [esp+26Ch] [ebp-1Ch]
    int v213; // [esp+274h] [ebp-14h]
    char* v214; // [esp+278h] [ebp-10h]
    char* v215; // [esp+27Ch] [ebp-Ch]
    int v216; // [esp+280h] [ebp-8h]
    int v217; // [esp+284h] [ebp-4h]
    int v218; // [esp+284h] [ebp-4h]

    result = a1;
    if (!*(_DWORD*)(a1 + 56))
        return result;
    *(_DWORD*)(a1 + 16) = 2;
    *(_DWORD*)(a1 + 12) = 2;
    *(_DWORD*)(a1 + 8) = (int)Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56));
    if (sub_41BA53(*(_DWORD*)(a1 + 56), 0x87u, 0) && rand() % 2 == 1)
        a3 += 50;
    v216 = a3;
    if (a4)
        v216 = a3 * sub_41CA5F(*(_DWORD*)(a1 + 56), 1) / 250 + a3;
    if (a5)
        v216 += a3 * sub_41D067(*(_DWORD*)(a1 + 56), 1) / 250;
    v217 = *(unsigned __int16*)(a1 + 190);
    if (sub_41BA53(*(_DWORD*)(a1 + 56), 0x85u, 0) && *(_BYTE*)(a1 + 72) == 12)
        v217 += 50;
    switch (*(_DWORD*)(a1 + 8))
    {
    case 0xB8:
        v217 += 25;
        break;
    case 0xBA:
        v217 += 15;
        break;
    case 0xBF:
        v217 += 10;
        break;
    case 0xC0:
        v217 += 20;
        break;
    case 0xC2:
        v217 += 10;
        break;
    case 0xC3:
        v217 /= 2;
        break;
    case 0xAB:
        v217 /= 2;
        break;
    case 0xAC:
        v217 = 3 * v217 / 4;
        break;
    case 0xC6:
        v217 = v217 * (10 * (rand() % 16) + 50) / 100;
        break;
    }
    v218 = v216 * v217 / 100 + 50;
    if (v218 > 0xFFFF)
        LOWORD(v218) = -1;
    *(_WORD*)(a1 + 192) = v218;
    *(_BYTE*)(a1 + 195) = 5;
    *(_BYTE*)(a1 + 194) = 0;
    *(_BYTE*)(a1 + 69) = 1;
    *(_DWORD*)(a1 + 156) = 0;
    *(_DWORD*)(a1 + 160) = 0;
    *(_DWORD*)(a1 + 88) = 0;
    *(_BYTE*)(a1 + 180) = 0;
    *(_DWORD*)(a1 + 104) -= 400;
    *(_DWORD*)(a1 + 172) = 1;
    *(_DWORD*)(a1 + 168) = 1;
    *(_DWORD*)(a1 + 140) = 1;
    *(_DWORD*)(a1 + 136) = 1;
    *(_DWORD*)(a1 + 132) = 1;
    *(_DWORD*)(a1 + 76) = 0;
    if (*(_BYTE*)(a1 + 72) != 11 && *(_BYTE*)(a1 + 72) != 13)
        *(_DWORD*)(a1 + 80) = 0;
    sub_499622(a1);
    memset((void*)(a1 + 181), 0, 8u);
    *(_BYTE*)(a1 + (unsigned __int8)sub_425EF0(*(_BYTE**)(a1 + 56)) + 181) = 1;
    *(_BYTE*)(a1 + 68) = 0;
    *(_BYTE*)(a1 + 71) = 0;
    *(_BYTE*)(a1 + 70) = -1;
    if ((*(_BYTE*)(a1 + 72) == 11 || *(_BYTE*)(a1 + 72) == 13) && *(int*)(a1 + 84) < 0)
    {
        *(_DWORD*)(a1 + 84) = rand() % 300 + 300;
        *(_DWORD*)(a1 + 80) = *(_DWORD*)(a1 + 84);
    }
    if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)171)
    {
        v215 = (char*)sub_464AC9((char*)unk_4B9B10, *(_BYTE**)(a1 + 56), 0, 1);
        if (v215)
        {
            *(_DWORD*)(a1 + 96) = sub_426090((int*)v215);
            *(_DWORD*)(a1 + 100) = sub_4260B0((int*)v215);
            result = sub_4260D0((int*)v215) - 800;
            *(_DWORD*)(a1 + 104) = result;
            *(_DWORD*)(a1 + 152) = 30;
            return result;
        }
        goto LABEL_259;
    }
    if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)172)
    {
        v214 = (char*)sub_464AC9((char*)unk_4B9B10, *(_BYTE**)(a1 + 56), 0, 1);
        if (v214)
        {
            *(_DWORD*)(a1 + 16) = 4;
            *(_DWORD*)(a1 + 12) = 4;
            *(_DWORD*)(a1 + 60) = (int)v214;
            v7 = rand() % 60 + 120;
            result = a1;
            *(_DWORD*)(a1 + 76) = v7;
            *(_DWORD*)(a1 + 128) = -1500;
            return result;
        }
        goto LABEL_259;
    }
    if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)173)
    {
        *(_BYTE*)(a1 + 68) = 1;
        *(_BYTE*)(a1 + 71) = 1;
        *(_BYTE*)(a1 + 69) = 0;
        *(_BYTE*)(a1 + 194) = 3;
        goto LABEL_259;
    }
    if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)180)
    {
        *(_BYTE*)(a1 + 194) = 11;
        *(_BYTE*)(a1 + 71) = 1;
        *(_DWORD*)(a1 + 120) = 2 * a3 + 320;
        if (*(int*)(a1 + 120) < 440)
            *(_DWORD*)(a1 + 120) = 440;
        if ((int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56)) <= 0)
            v154 = -Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56));
        else
            v154 = Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56));
        *(_DWORD*)(a1 + 120) += v154;
        if (*(int*)(a1 + 120) > 1000)
            *(_DWORD*)(a1 + 120) = 1000;
        if (!*(_DWORD*)(a1 + 164))
            *(_DWORD*)(a1 + 120) = -*(_DWORD*)(a1 + 120);
        *(_DWORD*)(a1 + 124) = 0;
        *(_DWORD*)(a1 + 120) *= 1000;
        *(_DWORD*)(a1 + 140) = 1000;
        *(_DWORD*)(a1 + 136) = 1000;
        *(_DWORD*)(a1 + 132) = 1000;
        if (a6)
        {
            if (*(int*)(a1 + 120) <= 0)
                v153 = -*(_DWORD*)(a1 + 120);
            else
                v153 = *(_DWORD*)(a1 + 120);
            v213 = v153;
            v8 = sub_426090(a6);
            v210 = v8 - sub_426470((_DWORD*)a1);
            v9 = sub_4260B0(a6);
            v211 = v9 - sub_426530((_DWORD*)a1);
            sub_4260D0(a6);
            Concurrency::details::UMSFreeVirtualProcessorRoot::GetExecutingProxy((Concurrency::details::UMSFreeVirtualProcessorRoot*)a1);
            __asm
            {
               // fild[ebp + var_28]
               // fstp    qword ptr[esp + 280h + var_280]
               // fild[ebp + var_20]
               // fstp[esp + 288h + var_288]
            }
            sub_4A3090(a2, v64, v80);
            __asm
            {
                //fstp[ebp + X]
               // fild[ebp + var_14]
                //fstp[ebp + var_12C]
            }
            v10 = cos(X);
            //__asm { fmul[ebp + var_12C] }
            *(_DWORD*)(a1 + 120) = _ftol(v10);
            __asm
            {
                //fild[ebp + var_14]
                //fstp[ebp + var_134]
            }
            v11 = sin(X);
           // __asm { fmul[ebp + var_134] }
            *(_DWORD*)(a1 + 124) = _ftol(v11);
        }
        *(_DWORD*)(a1 + 144) = 0;
        *(_DWORD*)(a1 + 148) = 0;
        if (3 * *(_DWORD*)(a1 + 120) / 4 <= 0)
            v150 = 3 * *(_DWORD*)(a1 + 120) / -4;
        else
            v150 = 3 * *(_DWORD*)(a1 + 120) / 4;
        *(_DWORD*)(a1 + 128) = -v150;
        result = -*(_DWORD*)(a1 + 128) / 30;
        *(_DWORD*)(a1 + 152) = result;
        return result;
    }
    if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) != (struct Concurrency::ISchedulerProxy*)183)
    {
        if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)184)
        {
            *(_BYTE*)(a1 + 71) = 1;
            *(_BYTE*)(a1 + 194) = 11;
            *(_BYTE*)(a1 + 70) = 5;
        }
        else if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)185)
        {
            *(_BYTE*)(a1 + 71) = 1;
            *(_BYTE*)(a1 + 194) = 3;
            *(_BYTE*)(a1 + 70) = 5;
        }
        else
        {
            if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)186)
            {
                *(_BYTE*)(a1 + 71) = 1;
                *(_BYTE*)(a1 + 194) = 3;
                *(_BYTE*)(a1 + 70) = 5;
                *(_DWORD*)(a1 + 120) = 2 * a3 + 320;
                if (*(int*)(a1 + 120) < 440)
                    *(_DWORD*)(a1 + 120) = 440;
                if ((int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56)) <= 0)
                    v137 = -Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56));
                else
                    v137 = Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56));
                *(_DWORD*)(a1 + 120) += v137;
                if (*(int*)(a1 + 120) > 1000)
                    *(_DWORD*)(a1 + 120) = 1000;
                if (!*(_DWORD*)(a1 + 164))
                    *(_DWORD*)(a1 + 120) = -*(_DWORD*)(a1 + 120);
                *(_DWORD*)(a1 + 120) = 3 * *(_DWORD*)(a1 + 120) / 2;
                *(_DWORD*)(a1 + 124) = 0;
                if (sub_425D30(*(_DWORD**)(a1 + 56)))
                {
                    if (*(int*)(a1 + 120) <= 0)
                        v136 = -*(_DWORD*)(a1 + 120);
                    else
                        v136 = *(_DWORD*)(a1 + 120);
                    *(_DWORD*)(a1 + 128) = v136 / 2;
                }
                else
                {
                    *(_DWORD*)(a1 + 128) = 0;
                }
                result = a1;
                *(_DWORD*)(a1 + 152) = 0;
                *(_DWORD*)(a1 + 144) = 0;
                *(_DWORD*)(a1 + 148) = 0;
                if (a6)
                {
                    if (*(int*)(a1 + 120) <= 0)
                        v135 = -*(_DWORD*)(a1 + 120);
                    else
                        v135 = *(_DWORD*)(a1 + 120);
                    v200 = v135;
                    v18 = sub_426090(a6);
                    v195 = v18 - sub_426470((_DWORD*)a1);
                    v19 = sub_4260B0(a6);
                    v197 = v19 - sub_426530((_DWORD*)a1);
                    v20 = (sub_4260D0(a6) - 1500) / 100;
                    v196 = 100
                        * (v20
                            - (int)Concurrency::details::UMSFreeVirtualProcessorRoot::GetExecutingProxy((Concurrency::details::UMSFreeVirtualProcessorRoot*)a1)
                            / 100);
                    __asm
                    {
                       // fild[ebp + var_68]
                       // fstp    qword ptr[esp + 280h + var_280]
                       // fild[ebp + var_60]
                       // fstp[esp + 288h + var_288]
                    }
                    sub_4A3090(a2, v67, v83);
                    __asm
                    {
                       // fstp[ebp + var_5C]
                       // fild[ebp + var_54]
                       // fstp[ebp + var_18C]
                    }
                    v21 = cos(v198);
                   // __asm { fmul[ebp + var_18C] }
                    *(_DWORD*)(a1 + 120) = _ftol(v21);
                    __asm
                    {
                       // fild[ebp + var_54]
                       // fstp[ebp + var_194]
                    }
                    v22 = sin(v198);
                    //__asm { fmul[ebp + var_194] }
                    *(_DWORD*)(a1 + 124) = _ftol(v22);
                    __asm
                    {
                       // fild[ebp + var_68]
                       // fstp    qword ptr[esp + 280h + var_280]
                       // fild[ebp + var_64]
                       // fstp[esp + 288h + var_288]
                    }
                    sub_4A3090(v22, v68, v84);
                    //__asm
                    //{
                    //    fstp[ebp + var_5C]
                    //    fild[ebp + var_54]
                    //    fstp[ebp + var_19C]
                    //}
                    v23 = sin(v199);
                    //__asm { fmul[ebp + var_19C] }
                    result = _ftol(v23);
                    *(_DWORD*)(a1 + 128) = result;
                }
                return result;
            }
            if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)189)
            {
                *(_DWORD*)(a1 + 88) = *(unsigned __int16*)(a1 + 192) / 85;
                if (*(int*)(a1 + 88) <= 0)
                    *(_DWORD*)(a1 + 88) = 1;
                *(_BYTE*)(a1 + 71) = 1;
                *(_BYTE*)(a1 + 194) = 3;
                *(_BYTE*)(a1 + 70) = 5;
                *(_DWORD*)(a1 + 136) = 1000;
                *(_DWORD*)(a1 + 132) = 1000;
                *(_DWORD*)(a1 + 140) = 1;
                v96 = sub_426530((_DWORD*)a1) / 100;
                v24 = sub_426470((_DWORD*)a1);
                v194 = -100 * sub_446497((int*)unk_4B9B10, v24 / 100, v96);
                if (v194 == -102000)
                    *(_DWORD*)(a1 + 128) = -200;
                else
                    *(_DWORD*)(a1 + 128) = (v194
                        - 1200
                        - (int)Concurrency::details::UMSFreeVirtualProcessorRoot::GetExecutingProxy((Concurrency::details::UMSFreeVirtualProcessorRoot*)a1))
                    / 30;
                result = a1;
                *(_DWORD*)(a1 + 120) = 0;
                *(_DWORD*)(a1 + 144) = 10000;
                if (!*(_DWORD*)(a1 + 164))
                {
                    result = a1;
                    *(_DWORD*)(a1 + 144) = -*(_DWORD*)(a1 + 144);
                }
                if (a6)
                {
                    v193 = 150000;
                    v25 = sub_426090(a6);
                    v190 = v25 - sub_426470((_DWORD*)a1);
                    v26 = sub_4260B0(a6);
                    v191 = v26 - sub_426530((_DWORD*)a1);
                    __asm
                    {
                       // fild[ebp + var_80]
                      //  fstp    qword ptr[esp + 280h + var_280]
                      //  fild[ebp + var_7C]
                      //  fstp[esp + 288h + var_288]
                    }
                    sub_4A3090(a2, v69, v85);
                  //  __asm { fstp[ebp + var_78] }
                    *(_DWORD*)(a1 + 120) = 0;
                    *(_DWORD*)(a1 + 124) = 0;
                    __asm
                    {
                       // fild[ebp + var_70]
                       // fstp[ebp + var_1A4]
                    }
                    v27 = cos(v192);
                    __asm
                    {
                       // fmul[ebp + var_1A4]
                        fdiv    ds : dbl_4AC3C0
                    }
                    *(_DWORD*)(a1 + 144) = _ftol(v27);
                    __asm
                    {
                        //fild[ebp + var_70]
                       // fstp[ebp + var_1AC]
                    }
                    v28 = sin(v192);
                    __asm
                    {
                       // fmul[ebp + var_1AC]
                        fdiv    ds : dbl_4AC3C0
                    }
                    result = _ftol(v28);
                    *(_DWORD*)(a1 + 148) = result;
                }
                return result;
            }
            if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)190)
            {
                *(_BYTE*)(a1 + 68) = 1;
                *(_BYTE*)(a1 + 71) = 1;
                *(_BYTE*)(a1 + 194) = 5;
                *(_BYTE*)(a1 + 70) = 5;
                *(_DWORD*)(a1 + 120) = 2 * a3 + 200;
                if (*(int*)(a1 + 120) < 440)
                    *(_DWORD*)(a1 + 120) = 440;
                if ((int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56)) <= 0)
                    v129 = -Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56));
                else
                    v129 = Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56));
                *(_DWORD*)(a1 + 120) += v129;
                if (*(int*)(a1 + 120) > 500)
                    *(_DWORD*)(a1 + 120) = 500;
                if (!*(_DWORD*)(a1 + 164))
                    *(_DWORD*)(a1 + 120) = -*(_DWORD*)(a1 + 120);
                *(_DWORD*)(a1 + 124) = 0;
                *(_DWORD*)(a1 + 128) = 0;
                *(_DWORD*)(a1 + 152) = 0;
                result = a1;
                *(_DWORD*)(a1 + 144) = 0;
                *(_DWORD*)(a1 + 148) = 0;
                if (a6)
                {
                    if (*(int*)(a1 + 120) <= 0)
                        v128 = -*(_DWORD*)(a1 + 120);
                    else
                        v128 = *(_DWORD*)(a1 + 120);
                    v189 = v128;
                    v29 = sub_426090(a6);
                    v186 = v29 - sub_426470((_DWORD*)a1);
                    v30 = sub_4260B0(a6);
                    v187 = v30 - sub_426530((_DWORD*)a1);
                    //__asm
                    //{
                    //   // fild[ebp + var_94]
                    //    fstp    qword ptr[esp + 280h + var_280]
                    //   // fild[ebp + var_90]
                    //    fstp[esp + 288h + var_288]
                    //}
                    sub_4A3090(a2, v70, v86);
                    __asm
                    {
                     //   fstp[ebp + var_8C]
                       // fild[ebp + var_84]
                        //??fstp[ebp + var_1BC]
                    }
                    v31 = cos(v188);
                   // __asm { fmul[ebp + var_1BC] }
                    *(_DWORD*)(a1 + 120) = _ftol(v31);
                    __asm
                    {
                       // fild[ebp + var_84]
                       // fstp[ebp + var_1C4]
                    }
                    v32 = sin(v188);
                    //__asm { fmul[ebp + var_1C4] }
                    result = _ftol(v32);
                    *(_DWORD*)(a1 + 124) = result;
                }
                return result;
            }
            if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)191)
            {
                *(_BYTE*)(a1 + 71) = 1;
                *(_BYTE*)(a1 + 194) = 3;
                *(_BYTE*)(a1 + 70) = 5;
                *(_DWORD*)(a1 + 120) = 2 * a3 + 320;
                if (*(int*)(a1 + 120) < 440)
                    *(_DWORD*)(a1 + 120) = 440;
                if ((int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56)) <= 0)
                    v125 = -Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56));
                else
                    v125 = Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56));
                *(_DWORD*)(a1 + 120) += v125;
                if (*(int*)(a1 + 120) > 800)
                    *(_DWORD*)(a1 + 120) = 800;
                if (!*(_DWORD*)(a1 + 164))
                    *(_DWORD*)(a1 + 120) = -*(_DWORD*)(a1 + 120);
                *(_DWORD*)(a1 + 124) = 0;
                if (sub_425D30(*(_DWORD**)(a1 + 56)))
                {
                    if (*(int*)(a1 + 120) <= 0)
                        v124 = -*(_DWORD*)(a1 + 120);
                    else
                        v124 = *(_DWORD*)(a1 + 120);
                    *(_DWORD*)(a1 + 128) = v124 / 2;
                }
                else
                {
                    *(_DWORD*)(a1 + 128) = 0;
                }
                result = a1;
                *(_DWORD*)(a1 + 152) = 0;
                *(_DWORD*)(a1 + 144) = 0;
                *(_DWORD*)(a1 + 148) = 0;
                if (a6)
                {
                    if (*(int*)(a1 + 120) <= 0)
                        v123 = -*(_DWORD*)(a1 + 120);
                    else
                        v123 = *(_DWORD*)(a1 + 120);
                    v185 = v123;
                    v33 = sub_426090(a6);
                    v180 = v33 - sub_426470((_DWORD*)a1);
                    v34 = sub_4260B0(a6);
                    v182 = v34 - sub_426530((_DWORD*)a1);
                    v35 = (sub_4260D0(a6) - 1500) / 100;
                    v181 = 100
                        * (v35
                            - (int)Concurrency::details::UMSFreeVirtualProcessorRoot::GetExecutingProxy((Concurrency::details::UMSFreeVirtualProcessorRoot*)a1)
                            / 100);
                    __asm
                    {
                       // fild[ebp + var_AC]
                       // fstp    qword ptr[esp + 280h + var_280]
                      //  fild[ebp + var_A4]
                       // fstp[esp + 288h + var_288]
                    }
                    sub_4A3090(a2, v71, v87);
                    __asm
                    {
                       // fstp[ebp + var_A0]
                      //  fild[ebp + var_98]
                        //fstp[ebp + var_1D8]
                    }
                    v36 = cos(v183);
                    //__asm { fmul[ebp + var_1D8] }
                    *(_DWORD*)(a1 + 120) = _ftol(v36);
                    __asm
                    {
                      ///  fild[ebp + var_98]
                       // fstp[ebp + var_1E0]
                    }
                    v37 = sin(v183);
                   // __asm { fmul[ebp + var_1E0] }
                    *(_DWORD*)(a1 + 124) = _ftol(v37);
                    //__asm
                    //{
                    //    fild[ebp + var_AC]
                    //    fstp    qword ptr[esp + 280h + var_280]
                    //    //fild[ebp + var_A8]
                    //    fstp[esp + 288h + var_288]
                    //}
                    sub_4A3090(v37, v72, v88);
                    __asm
                    {
                        //fstp[ebp + var_A0]
                     //   fild[ebp + var_98]
                       // fstp[ebp + var_1E8]
                    }
                    v38 = sin(v184);
                    //__asm { fmul[ebp + var_1E8] }
                    result = _ftol(v38);
                    *(_DWORD*)(a1 + 128) = result;
                }
                return result;
            }
            if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)192)
            {
                *(_BYTE*)(a1 + 71) = 1;
                *(_BYTE*)(a1 + 194) = 3;
                *(_BYTE*)(a1 + 70) = 5;
                *(_DWORD*)(a1 + 120) = 2 * a3 + 150;
                if (*(int*)(a1 + 120) < 200)
                    *(_DWORD*)(a1 + 120) = 200;
                if ((int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56)) / 2 <= 0)
                    v119 = (int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56)) / -2;
                else
                    v119 = (int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56)) / 2;
                *(_DWORD*)(a1 + 120) += v119;
                if (*(int*)(a1 + 120) > 500)
                    *(_DWORD*)(a1 + 120) = 500;
                if (!*(_DWORD*)(a1 + 164))
                    *(_DWORD*)(a1 + 120) = -*(_DWORD*)(a1 + 120);
                *(_DWORD*)(a1 + 124) = 0;
                *(_DWORD*)(a1 + 128) = 0;
                *(_DWORD*)(a1 + 152) = 0;
                *(_DWORD*)(a1 + 144) = 0;
                result = a1;
                *(_DWORD*)(a1 + 148) = 0;
                if (a6)
                {
                    if (*(int*)(a1 + 120) <= 0)
                        v118 = -*(_DWORD*)(a1 + 120);
                    else
                        v118 = *(_DWORD*)(a1 + 120);
                    v179 = v118;
                    v39 = sub_426090(a6);
                    v176 = v39 - sub_426470((_DWORD*)a1);
                    v40 = sub_4260B0(a6);
                    v177 = v40 - sub_426530((_DWORD*)a1);
                    __asm
                    {
                       //?? fild[ebp + var_C0]
                        //fstp    qword ptr[esp + 280h + var_280]
                        //fild[ebp + var_BC]
                        //fstp[esp + 288h + var_288]
                    }
                    sub_4A3090(a2, v73, v89);
                    __asm
                    {
                       // fstp[ebp + var_B8]
                        //fild[ebp + var_B0]
                        //fstp[ebp + var_1F8]
                    }
                    v41 = cos(v178);
                    //__asm { fmul[ebp + var_1F8] }
                    *(_DWORD*)(a1 + 120) = _ftol(v41);
                    __asm
                    {
                        //fild[ebp + var_B0]
                       // fstp[ebp + var_200]
                    }
                    v42 = sin(v178);
                   // __asm { fmul[ebp + var_200] }
                    result = _ftol(v42);
                    *(_DWORD*)(a1 + 124) = result;
                }
                return result;
            }
            if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) != (struct Concurrency::ISchedulerProxy*)193)
            {
                if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)194)
                {
                    *(_BYTE*)(a1 + 71) = 1;
                    *(_BYTE*)(a1 + 194) = 3;
                    *(_BYTE*)(a1 + 70) = 5;
                    *(_DWORD*)(a1 + 120) = 2 * a3 + 150;
                    if (*(int*)(a1 + 120) < 200)
                        *(_DWORD*)(a1 + 120) = 200;
                    if ((int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56)) / 2 <= 0)
                        v115 = (int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56)) / -2;
                    else
                        v115 = (int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56)) / 2;
                    *(_DWORD*)(a1 + 120) += v115;
                    if (*(int*)(a1 + 120) > 500)
                        *(_DWORD*)(a1 + 120) = 500;
                    if (!*(_DWORD*)(a1 + 164))
                        *(_DWORD*)(a1 + 120) = -*(_DWORD*)(a1 + 120);
                    *(_DWORD*)(a1 + 124) = 0;
                    *(_DWORD*)(a1 + 128) = 0;
                    *(_DWORD*)(a1 + 152) = 0;
                    result = a1;
                    *(_DWORD*)(a1 + 144) = 0;
                    *(_DWORD*)(a1 + 148) = 0;
                    if (a6)
                    {
                        if (*(int*)(a1 + 120) <= 0)
                            v114 = -*(_DWORD*)(a1 + 120);
                        else
                            v114 = *(_DWORD*)(a1 + 120);
                        v175 = v114;
                        v43 = sub_426090(a6);
                        v172 = v43 - sub_426470((_DWORD*)a1);
                        v44 = sub_4260B0(a6);
                        v173 = v44 - sub_426530((_DWORD*)a1);
                        __asm
                        {
                            //??fild[ebp + var_D4]
                           // fstp    qword ptr[esp + 280h + var_280]
                           //?? fild[ebp + var_D0]
                           // fstp[esp + 288h + var_288]
                        }
                        sub_4A3090(a2, v74, v90);
                        __asm
                        {
                           //?? fstp[ebp + var_CC]
                           //?? fild[ebp + var_C4]
                           // fstp[ebp + var_210]
                        }
                        v45 = cos(v174);
                       // __asm { fmul[ebp + var_210] }
                        *(_DWORD*)(a1 + 120) = _ftol(v45);
                        __asm
                        {
                           // fild[ebp + var_C4]
                           // fstp[ebp + var_218]
                        }
                        v46 = sin(v174);
                        //__asm { fmul[ebp + var_218] }
                        result = _ftol(v46);
                        *(_DWORD*)(a1 + 124) = result;
                    }
                }
                else
                {
                    if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)195)
                    {
                        *(_DWORD*)(a1 + 60) = sub_464AC9((char*)unk_4B9B10, *(_BYTE**)(a1 + 56), 0, 1);
                        if (*(_DWORD*)(a1 + 60))
                        {
                            *(_BYTE*)(a1 + 71) = 1;
                            *(_BYTE*)(a1 + 194) = 11;
                            *(_BYTE*)(a1 + 70) = 5;
                            *(_DWORD*)(a1 + 120) = 10 * (*(_DWORD*)(a1 + 164) - (*(_DWORD*)(a1 + 164) == 0));
                            if (sub_425D30(*(_DWORD**)(a1 + 56)))
                                *(_DWORD*)(a1 + 128) = 5;
                            else
                                *(_DWORD*)(a1 + 128) = 1;
                            result = a1;
                            *(_DWORD*)(a1 + 152) = 0;
                            return result;
                        }
                        goto LABEL_259;
                    }
                    if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)196)
                    {
                        *(_BYTE*)(a1 + 71) = 1;
                        *(_BYTE*)(a1 + 68) = 1;
                        *(_BYTE*)(a1 + 194) = 2;
                        *(_DWORD*)(a1 + 120) = 2 * a3 + 150;
                        if (*(int*)(a1 + 120) < 200)
                            *(_DWORD*)(a1 + 120) = 200;
                        if ((int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56)) / 2 <= 0)
                            v111 = (int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56))
                            / -2;
                        else
                            v111 = (int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56))
                            / 2;
                        *(_DWORD*)(a1 + 120) += v111;
                        if (*(int*)(a1 + 120) > 500)
                            *(_DWORD*)(a1 + 120) = 500;
                        if (!*(_DWORD*)(a1 + 164))
                            *(_DWORD*)(a1 + 120) = -*(_DWORD*)(a1 + 120);
                        *(_DWORD*)(a1 + 124) = 0;
                        *(_DWORD*)(a1 + 128) = 0;
                        result = a1;
                        *(_DWORD*)(a1 + 152) = 0;
                        *(_DWORD*)(a1 + 144) = 0;
                        *(_DWORD*)(a1 + 148) = 0;
                        if (a6)
                        {
                            if (*(int*)(a1 + 120) <= 0)
                                v110 = -*(_DWORD*)(a1 + 120);
                            else
                                v110 = *(_DWORD*)(a1 + 120);
                            v171 = v110;
                            v47 = sub_426090(a6);
                            v168 = v47 - sub_426470((_DWORD*)a1);
                            v48 = sub_4260B0(a6);
                            v169 = v48 - sub_426530((_DWORD*)a1);
                            __asm
                            {
                                //??fild[ebp + var_E8]
                                //fstp    qword ptr[esp + 280h + var_280]
                                //??fild[ebp + var_E4]
                                //fstp[esp + 288h + var_288]
                            }
                            sub_4A3090(a2, v75, v91);
                            __asm
                            {
                               //?? fstp[ebp + var_E0]
                               //?? fild[ebp + var_D8]
                              //  fstp[ebp + var_228]
                            }
                            v49 = cos(v170);
                            //__asm { fmul[ebp + var_228] }
                            *(_DWORD*)(a1 + 120) = _ftol(v49);
                            __asm
                            {
                               // fild[ebp + var_D8]
                               // fstp[ebp + var_230]
                            }
                            v50 = sin(v170);
                            //__asm { fmul[ebp + var_230] }
                            result = _ftol(v50);
                            *(_DWORD*)(a1 + 124) = result;
                        }
                    }
                    else
                    {
                        if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) != (struct Concurrency::ISchedulerProxy*)197)
                        {
                            if (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)198)
                            {
                                *(_DWORD*)(a1 + 120) = 10 * (*(_DWORD*)(a1 + 164) - (*(_DWORD*)(a1 + 164) == 0));
                                *(_BYTE*)(a1 + 71) = 1;
                                *(_BYTE*)(a1 + 68) = rand() % 3 == 0;
                                v57 = rand() % 14;
                                result = a1;
                                *(_BYTE*)(a1 + 194) = v57;
                                return result;
                            }
                            goto LABEL_259;
                        }
                        *(_BYTE*)(a1 + 71) = 1;
                        *(_BYTE*)(a1 + 194) = 3;
                        *(_BYTE*)(a1 + 70) = 5;
                        *(_DWORD*)(a1 + 120) = 2 * a3 + 320;
                        if (*(int*)(a1 + 120) < 440)
                            *(_DWORD*)(a1 + 120) = 440;
                        if (*(int*)(a1 + 120) > 1000)
                            *(_DWORD*)(a1 + 120) = 1000;
                        if (!*(_DWORD*)(a1 + 164))
                            *(_DWORD*)(a1 + 120) = -*(_DWORD*)(a1 + 120);
                        *(_DWORD*)(a1 + 124) = 0;
                        if (sub_425D30(*(_DWORD**)(a1 + 56)))
                        {
                            if (*(int*)(a1 + 120) <= 0)
                                v107 = -*(_DWORD*)(a1 + 120);
                            else
                                v107 = *(_DWORD*)(a1 + 120);
                            *(_DWORD*)(a1 + 128) = v107 / 2;
                        }
                        else
                        {
                            *(_DWORD*)(a1 + 128) = 0;
                        }
                        *(_DWORD*)(a1 + 152) = 0;
                        *(_DWORD*)(a1 + 144) = 0;
                        *(_DWORD*)(a1 + 148) = 0;
                        if (a6)
                        {
                            if (*(int*)(a1 + 120) <= 0)
                                v106 = -*(_DWORD*)(a1 + 120);
                            else
                                v106 = *(_DWORD*)(a1 + 120);
                            v167 = v106;
                            v51 = sub_426090(a6);
                            v162 = v51 - sub_426470((_DWORD*)a1);
                            v52 = sub_4260B0(a6);
                            v164 = v52 - sub_426530((_DWORD*)a1);
                            v53 = (sub_4260D0(a6) - 1500) / 100;
                            v163 = 100
                                * (v53
                                    - (int)Concurrency::details::UMSFreeVirtualProcessorRoot::GetExecutingProxy((Concurrency::details::UMSFreeVirtualProcessorRoot*)a1)
                                    / 100);
                            __asm
                            {
                                //??fild[ebp + var_100]
                                //fstp    qword ptr[esp + 280h + var_280]
                               //??? fild[ebp + var_F8]
                                //fstp[esp + 288h + var_288]
                            }
                            sub_4A3090(a2, v76, v92);
                            __asm
                            {
                                //??fstp[ebp + var_F4]
                               //?? fild[ebp + var_EC]
                               // fstp[ebp + var_240]
                            }
                            v54 = cos(v165);
                            //__asm { fmul[ebp + var_240] }
                            *(_DWORD*)(a1 + 120) = _ftol(v54);
                            __asm
                            {
                              //  fild[ebp + var_EC]
                               // fstp[ebp + var_248]
                            }
                            v55 = sin(v165);
                           // __asm { fmul[ebp + var_248] }
                            *(_DWORD*)(a1 + 124) = _ftol(v55);
                            __asm
                            {
                                //fild[ebp + var_100]
                                //fstp    qword ptr[esp + 280h + var_280]
                                //fild[ebp + var_FC]???
                                //fstp[esp + 288h + var_288]
                            }
                            sub_4A3090(v55, v77, v93);
                            __asm
                            {
                                //fstp[ebp + var_F4]
                              //  fild[ebp + var_EC]
                               // fstp[ebp + var_250]
                            }
                            v56 = sin(v166);
                            //__asm { fmul[ebp + var_250] }
                            *(_DWORD*)(a1 + 128) = _ftol(v56);
                        }
                        *(_DWORD*)(a1 + 88) = *(_DWORD*)(a1 + 120);
                        result = a1;
                        *(_DWORD*)(a1 + 92) = *(_DWORD*)(a1 + 124);
                    }
                }
                return result;
            }
            *(_BYTE*)(a1 + 71) = 1;
            *(_BYTE*)(a1 + 194) = 3;
            *(_BYTE*)(a1 + 70) = 5;
        }
    LABEL_259:
        if (*(unsigned __int8*)(a1 + 72) < 2u
            || *(unsigned __int8*)(a1 + 72) >= 4u && *(unsigned __int8*)(a1 + 72) <= 7u
            || *(_BYTE*)(a1 + 72) == 11
            || *(_BYTE*)(a1 + 72) == 12)
        {
            *(_DWORD*)(a1 + 120) = 2 * a3 + 320;
            if (*(int*)(a1 + 120) < 440)
                *(_DWORD*)(a1 + 120) = 440;
            if ((int)Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56)) <= 0)
                v102 = -Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56));
            else
                v102 = Concurrency::details::SchedulerBase::Id(*(Concurrency::details::SchedulerBase**)(a1 + 56));
            *(_DWORD*)(a1 + 120) += v102;
            if (*(int*)(a1 + 120) > 1000)
                *(_DWORD*)(a1 + 120) = 1000;
            if (!*(_DWORD*)(a1 + 164))
                *(_DWORD*)(a1 + 120) = -*(_DWORD*)(a1 + 120);
            if (*(_DWORD*)(a1 + 8) == 185)
            {
                *(int*)(a1 + 120) /= 4;
            }
            else if (*(_DWORD*)(a1 + 8) == 193)
            {
                *(int*)(a1 + 120) /= 2;
            }
            *(_DWORD*)(a1 + 124) = 0;
            if (a5)
            {
                if (*(int*)(a1 + 120) <= 0)
                    v101 = -*(_DWORD*)(a1 + 120);
                else
                    v101 = *(_DWORD*)(a1 + 120);
                *(_DWORD*)(a1 + 128) = v101 / 2;
                *(_DWORD*)(a1 + 152) = 0;
            }
            else
            {
                *(_DWORD*)(a1 + 128) = 0;
                *(_DWORD*)(a1 + 152) = 0;
            }
            result = a1;
            *(_DWORD*)(a1 + 144) = 0;
            *(_DWORD*)(a1 + 148) = 0;
            if (a6)
            {
                if (*(int*)(a1 + 120) <= 0)
                    v100 = -*(_DWORD*)(a1 + 120);
                else
                    v100 = *(_DWORD*)(a1 + 120);
                v161 = v100;
                v58 = sub_426090(a6);
                v156 = v58 - sub_426470((_DWORD*)a1);
                v59 = sub_4260B0(a6);
                v158 = v59 - sub_426530((_DWORD*)a1);
                v60 = (sub_4260D0(a6) - 1500) / 100;
                v157 = 100
                    * (v60
                        - (int)Concurrency::details::UMSFreeVirtualProcessorRoot::GetExecutingProxy((Concurrency::details::UMSFreeVirtualProcessorRoot*)a1)
                        / 100);
                __asm
                {
                   // fild[ebp + var_118]
                    //fstp    qword ptr[esp + 280h + var_280]
                   // fild[ebp + var_110]
                   // fstp[esp + 288h + var_288]
                }
                sub_4A3090(a2, v78, v94);
                __asm
                {
                  //  fstp[ebp + var_10C]
                  //  fild[ebp + var_104]
                   // fstp[ebp + var_264]
                }
                v61 = cos(v159);
                //__asm { fmul[ebp + var_264] }
                *(_DWORD*)(a1 + 120) = _ftol(v61);
                //__asm
                //{
                //    fild[ebp + var_104]
                //    fstp[ebp + var_26C]
                //}
                v62 = sin(v159);
                //__asm { fmul[ebp + var_26C] }
                *(_DWORD*)(a1 + 124) = _ftol(v62);
                __asm
                {
                   // fild[ebp + var_118]
                   // fstp    qword ptr[esp + 280h + var_280]
                   // fild[ebp + var_114]
                   // fstp[esp + 288h + var_288]
                }
                sub_4A3090(v62, v79, v95);
                __asm
                {
                  //  fstp[ebp + var_10C]
                  //  fild[ebp + var_104]
                  ///  fstp[ebp + var_274]
                }
                v63 = sin(v160);
                //__asm { fmul[ebp + var_274] }
                result = _ftol(v63);
                *(_DWORD*)(a1 + 128) = result;
            }
        }
        else if (*(_BYTE*)(a1 + 72) == 2)
        {
            *(_DWORD*)(a1 + 120) = 150 * (*(_DWORD*)(a1 + 164) - (*(_DWORD*)(a1 + 164) == 0));
            *(_DWORD*)(a1 + 96) = *(_DWORD*)(a1 + 120) + sub_426090(*(_DWORD**)(a1 + 56));
            *(_DWORD*)(a1 + 124) = 0;
            *(_DWORD*)(a1 + 128) = -860;
            *(_DWORD*)(a1 + 144) = 0;
            result = a1;
            *(_DWORD*)(a1 + 148) = 0;
            *(_DWORD*)(a1 + 152) = 30;
        }
        else if (*(_BYTE*)(a1 + 72) == 3)
        {
            *(_DWORD*)(a1 + 120) = 250;
            if (!*(_DWORD*)(a1 + 164))
                *(_DWORD*)(a1 + 120) = -*(_DWORD*)(a1 + 120);
            *(_DWORD*)(a1 + 124) = 0;
            *(_DWORD*)(a1 + 128) = -300;
            *(_DWORD*)(a1 + 144) = 0;
            result = a1;
            *(_DWORD*)(a1 + 148) = 0;
            *(_DWORD*)(a1 + 152) = 30;
        }
        else if (*(_BYTE*)(a1 + 72) == 8
            || *(_BYTE*)(a1 + 72) == 9
            || *(_BYTE*)(a1 + 72) == 10
            || (result = *(unsigned __int8*)(a1 + 72), result == 13))
        {
            *(_DWORD*)(a1 + 120) = 300;
            if (!*(_DWORD*)(a1 + 164))
                *(_DWORD*)(a1 + 120) = -*(_DWORD*)(a1 + 120);
            *(_DWORD*)(a1 + 124) = 0;
            *(_DWORD*)(a1 + 128) = -180;
            *(_DWORD*)(a1 + 144) = 0;
            result = a1;
            *(_DWORD*)(a1 + 148) = 0;
            *(_DWORD*)(a1 + 152) = 30;
        }
        return result;
    }
    if (!a6)
        a6 = (int*)sub_4682D3((char*)unk_4B9B10, *(_DWORD**)(a1 + 56), 0);
    if (!a6)
        goto LABEL_259;
    *(_BYTE*)(a1 + 70) = 5;
    *(_DWORD*)(a1 + 60) = (int)(int*)a6;
    *(_BYTE*)(a1 + 194) = 3;
    *(_BYTE*)(a1 + 71) = 1;
    v208 = 160;
    sub_44647E((char*)unk_4B9B10);
    v12 = sub_426090(a6);
    v203 = v12 - sub_426470((_DWORD*)a1);
    v13 = sub_4260B0(a6);
    v205 = v13 - sub_426530((_DWORD*)a1);
    v209 = sub_425D70(*(_DWORD**)(a1 + 56));
    if (!v203)
    {
        if (v205 <= 0)
            v149 = -v205;
        else
            v149 = v205;
        v203 = (v209 - (v209 == 0)) * v149;
    }
    v14 = (sub_4260D0(a6) - 1500) / 100;
    v204 = 100
        * (v14
            - (int)Concurrency::details::UMSFreeVirtualProcessorRoot::GetExecutingProxy((Concurrency::details::UMSFreeVirtualProcessorRoot*)a1)
            / 100);
    __asm
    {
       // fild[ebp + var_48]
       // fstp    qword ptr[esp + 280h + var_280]
       // fild[ebp + var_3C]
       // fstp[esp + 288h + var_288]
    }
    sub_4A3090(a2, v65, v81);
    //__asm { fstp[ebp + var_144] }
    v147 = 2 * (rand() % 2) - 1;
    __asm
    {
       // fild[ebp + var_148]
       // fmul    ds : dbl_4AC3C8
       // fadd[ebp + var_144]
      // / fstp[ebp + var_38]
       //// fild[ebp + var_30]
       // fstp[ebp + var_150]
    }
    v15 = cos(v206);
    //__asm { fmul[ebp + var_150] }
    *(_DWORD*)(a1 + 120) = _ftol(v15);
    __asm
    {
        //fild[ebp + var_30]
        //fstp[ebp + var_158]
    }
    v16 = sin(v206);
    //__asm { fmul[ebp + var_158] }
    *(_DWORD*)(a1 + 124) = _ftol(v16);
    if (*(int*)(a1 + 120) <= 0)
        v144 = -*(_DWORD*)(a1 + 120);
    else
        v144 = *(_DWORD*)(a1 + 120);
    if (*(int*)(a1 + 124) <= 0)
        v143 = -*(_DWORD*)(a1 + 124);
    else
        v143 = *(_DWORD*)(a1 + 124);
    if (v144 < v143)
    {
        v202 = *(_DWORD*)(a1 + 120);
        v201 = *(_DWORD*)(a1 + 124);
        if (v201 <= 0)
            v142 = -v201;
        else
            v142 = *(_DWORD*)(a1 + 124);
        if (v202 <= 0)
            v141 = (v202 >= 0) - 1;
        else
            v141 = 1;
        *(_DWORD*)(a1 + 120) = v141 * v142;
        if (v202 <= 0)
            v140 = -v202;
        else
            v140 = v202;
        if (v201 <= 0)
            v139 = (v201 >= 0) - 1;
        else
            v139 = 1;
        *(_DWORD*)(a1 + 124) = v139 * v140;
    }
    if (!v209 && *(int*)(a1 + 120) > 0 || v209 && *(int*)(a1 + 120) < 0)
        *(_DWORD*)(a1 + 120) = -*(_DWORD*)(a1 + 120);
    __asm
    {
        //fild[ebp + var_48]
       // fstp    qword ptr[esp + 280h + var_280]
       // fild[ebp + var_44]
       // fstp[esp + 288h + var_288]
    }
    sub_4A3090(v16, v66, v82);
    __asm
    {
        //fstp[ebp + var_38]
        //fild[ebp + var_30]
        //fstp[ebp + var_178]
    }
    v17 = sin(v207);
   // __asm { fmul[ebp + var_178] }
    *(_DWORD*)(a1 + 128) = _ftol(v17);
    result = a1;
    if (*(int*)(a1 + 128) > 0)
        *(_DWORD*)(a1 + 128) = 0;
    *(_DWORD*)(a1 + 124) = 0;
    return result;
} 
int sub_494209(_DWORD* thisx)
{
    if (!unknown_libname_22(thisx))
        return 0;
    if (thisx[3] == 2 || thisx[3] == 7)
        return thisx[42];
    if (thisx[3] == 8)
        return thisx[42];
    return 0;
}
 
int sub_494257(int thisx, int a2, int a3, int a4)
{
    int result; // eax
    int v5; // [esp+4h] [ebp-Ch]
    int v6; // [esp+8h] [ebp-8h]

    sub_49951D((int*)thisx);
    sub_4995EB((_WORD*)thisx);
    result = thisx;
    if (*(_DWORD*)(thisx + 12) == 8)
    {
        if (a3)
        {
            result = thisx;
            *(_BYTE*)(thisx + *(unsigned __int8*)(a3 + 40) + 181) = 1;
        }
    }
    else if (a2 && !a4)
    {
        *(_DWORD*)(thisx + 56) = *(_DWORD*)(a3 + 32);
        *(_DWORD*)(thisx + 16) = 7;
        *(_DWORD*)(thisx + 12) = 7;
        *(_DWORD*)(thisx + 76) = (unsigned __int8)sub_425EF0(*(_BYTE**)(a3 + 32));
        memset((void*)(thisx + 181), 0, 8u);
        *(_BYTE*)(thisx + *(_DWORD*)(thisx + 76) + 181) = 1;
        *(_DWORD*)(thisx + 156) = 0;
        *(_DWORD*)(thisx + 120) = 10 * *(_DWORD*)a3;
        if (*(int*)(thisx + 120) >= 100)
        {
            if (*(int*)(thisx + 120) > 2000)
                *(_DWORD*)(thisx + 120) = 2000;
        }
        else
        {
            *(_DWORD*)(thisx + 120) = 100;
        }
        if (*(_BYTE*)(a3 + 4) == 5)
        {
            *(_DWORD*)(thisx + 172) = 1;
            *(_DWORD*)(thisx + 128) = 2 * *(_DWORD*)(thisx + 120) / -3;
            *(_DWORD*)(thisx + 152) = 30;
            *(int*)(thisx + 120) /= 5;
            if (*(_BYTE*)(thisx + 72) == 10 || *(_BYTE*)(thisx + 72) == 13)
            {
                *(_DWORD*)(thisx + 128) = 2 * *(_DWORD*)(thisx + 128) / 3;
                *(_DWORD*)(thisx + 120) = 2 * *(_DWORD*)(thisx + 120) / 3;
            }
        }
        if (!*(_DWORD*)(a3 + 12))
            *(_DWORD*)(thisx + 120) = -*(_DWORD*)(thisx + 120);
        *(_DWORD*)(thisx + 124) = 0;
        *(_WORD*)(thisx + 192) = *(unsigned __int16*)(thisx + 190) / 5 + *(_DWORD*)a3;
        *(_BYTE*)(thisx + 194) = 0;
        *(_BYTE*)(thisx + 69) = 1;
        if (*(_BYTE*)(thisx + 72) == 10)
        {
            *(_BYTE*)(thisx + 22) = (*(char*)(thisx + 22) + 1) % 4;
        }
        else if (*(_BYTE*)(thisx + 72) == 13)
        {
            *(int*)(thisx + 120) /= 2;
            if (*(int*)(thisx + 84) > 0)
            {
                *(_DWORD*)(thisx + 84) -= 60;
                if (*(int*)(thisx + 84) < 0)
                    *(_DWORD*)(thisx + 84) = 0;
            }
        }
        result = *(unsigned __int8*)(thisx + 72);
        switch (*(_BYTE*)(thisx + 72))
        {
        case 8:
            result = sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9ABC, -1, 100, 100, 0);
            break;
        case 9:
            result = sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9AC0, -1, 100, 100, 0);
            break;
        case 0xA:
        case 0xD:
            result = sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A14, -1, 100, 100, 0);
            break;
        default:
            return result;
        }
    }
    else
    {
        if (*(_DWORD*)(thisx + 8) == 190 && !*(_DWORD*)(thisx + 88))
        {
            *(_DWORD*)(thisx + 88) = 1;
            *(int*)(thisx + 120) /= 2;
            result = thisx;
            *(_DWORD*)(thisx + 152) = -60;
        }
        if (*(_BYTE*)(thisx + 68) && a4)
        {
            result = thisx;
            if (*(_DWORD*)(thisx + 8) != 190)
            {
                *(_WORD*)(thisx + 192) = *(unsigned __int16*)(thisx + 192) / 2;
                result = thisx;
                if (!*(_WORD*)(thisx + 192))
                    *(_WORD*)(thisx + 192) = 1;
            }
        }
        else if (a4)
        {
            sub_494754(thisx);
            *(int*)(thisx + 120) /= 2;
            result = *(_DWORD*)(thisx + 124) / 2;
            *(_DWORD*)(thisx + 124) = result;
            if (*(_DWORD*)(thisx + 12) == 7)
            {
                if (*(int*)(thisx + 120) <= 0)
                    v6 = -*(_DWORD*)(thisx + 120);
                else
                    v6 = *(_DWORD*)(thisx + 120);
                if (v6 >= 100)
                {
                    if (*(int*)(thisx + 120) <= 0)
                        v5 = (*(_DWORD*)(thisx + 120) >= 0) - 1;
                    else
                        v5 = 1;
                    *(_DWORD*)(thisx + 120) = 100 * v5;
                }
                *(_DWORD*)(thisx + 128) = -300;
                *(_DWORD*)(thisx + 152) = 30;
                *(_DWORD*)(thisx + 172) = 1;
                *(_DWORD*)(thisx + 16) = 2;
                *(_DWORD*)(thisx + 12) = 2;
                result = thisx;
                *(_BYTE*)(thisx + 180) = 0;
            }
        }
        if (!a4)
        {
            result = thisx;
            *(_BYTE*)(thisx + *(unsigned __int8*)(a3 + 40) + 181) = 1;
        }
        if (*(_BYTE*)(thisx + 72) == 11 || (result = thisx, *(_BYTE*)(thisx + 72) == 13))
        {
            if (*(_DWORD*)(thisx + 12) != 8)
            {
                if (*(_DWORD*)(thisx + 56) && (result = sub_41BA53(*(_DWORD*)(thisx + 56), 0x8Au, 0)) != 0)
                {
                    *(_DWORD*)(thisx + 84) = 0;
                }
                else
                {
                    result = thisx;
                    if (*(int*)(thisx + 84) > 0)
                    {
                        result = thisx;
                        *(_DWORD*)(thisx + 84) -= 60;
                        if (*(int*)(thisx + 84) < 0)
                            *(_DWORD*)(thisx + 84) = 0;
                    }
                }
            }
        }
    }
    return result;
}

 
int sub_494754(int thisx)
{
    int result; // eax
    int v2; // [esp+0h] [ebp-1Ch]
    int v3; // [esp+4h] [ebp-18h]
    int v4; // [esp+8h] [ebp-14h]
    int v5; // [esp+Ch] [ebp-10h]
    int v6; // [esp+10h] [ebp-Ch]
    int v7; // [esp+14h] [ebp-8h]

    sub_49951D((int*)thisx);
    sub_4995EB((short*)thisx);
    if (*(_DWORD*)(thisx + 12) == 7)
    {
        result = thisx;
        *(_DWORD*)(thisx + 120) = -*(_DWORD*)(thisx + 120);
    }
    else
    {
        if (*(int*)(thisx + 120) <= 0)
            v7 = -*(_DWORD*)(thisx + 120);
        else
            v7 = *(_DWORD*)(thisx + 120);
        if (v7 > 500)
        {
            if (*(int*)(thisx + 120) <= 0)
                v6 = (*(_DWORD*)(thisx + 120) >= 0) - 1;
            else
                v6 = 1;
            *(_DWORD*)(thisx + 120) = 500 * v6;
        }
        if (*(int*)(thisx + 124) <= 0)
            v5 = -*(_DWORD*)(thisx + 124);
        else
            v5 = *(_DWORD*)(thisx + 124);
        if (v5 > 500)
        {
            if (*(int*)(thisx + 124) <= 0)
                v4 = (*(_DWORD*)(thisx + 124) >= 0) - 1;
            else
                v4 = 1;
            *(_DWORD*)(thisx + 124) = 500 * v4;
        }
        *(_DWORD*)(thisx + 16) = 3;
        *(_DWORD*)(thisx + 8) = 83;
        *(_DWORD*)(thisx + 120) = -*(_DWORD*)(thisx + 120) / 2;
        *(int*)(thisx + 124) /= 2;
        *(int*)(thisx + 128) /= 2;
        *(_DWORD*)(thisx + 144) = 0;
        *(_DWORD*)(thisx + 148) = 0;
        *(_DWORD*)(thisx + 168) = 0;
        *(_BYTE*)(thisx + 180) = 0;
        if (*(_DWORD*)(thisx + 172))
            *(_DWORD*)(thisx + 152) = 30;
        result = *(unsigned __int8*)(thisx + 72);
        if (result == 2)
        {
            v3 = *(_DWORD*)(thisx + 76);
            if (v3)
            {
                if (v3 == 1)
                    *(_DWORD*)(thisx + 76) = 2;
            }
            else
            {
                result = thisx;
                *(_DWORD*)(thisx + 76) = 3;
            }
        }
        else
        {
            result = *(unsigned __int8*)(thisx + 72);
            if (result == 3)
            {
                v2 = *(_DWORD*)(thisx + 76);
                if (v2)
                {
                    if (v2 == 1)
                        *(_DWORD*)(thisx + 76) = 3;
                }
                else
                {
                    result = thisx;
                    *(_DWORD*)(thisx + 76) = 4;
                }
            }
            else
            {
                result = *(unsigned __int8*)(thisx + 72);
                if (result == 12)
                {
                    *(_BYTE*)(thisx + 71) = 0;
                    *(_BYTE*)(thisx + 68) = 0;
                    result = thisx;
                    *(_DWORD*)(thisx + 168) = 0;
                }
            }
        }
    }
    return result;
}
 
int sub_494979(int thisx)
{
    int result; // eax

    result = thisx;
    if (*(_DWORD*)(thisx + 12) != 8)
    {
        *(_DWORD*)(thisx + 16) = 3;
        *(_DWORD*)(thisx + 12) = 3;
        *(_DWORD*)(thisx + 96) = sub_426090(*(_DWORD**)(thisx + 56));
        *(_DWORD*)(thisx + 100) = sub_4260B0(*(_DWORD**)(thisx + 56));
        *(_DWORD*)(thisx + 56) = 0;
        *(_DWORD*)(thisx + 168) = 0;
        *(_DWORD*)(thisx + 172) = 1;
        *(_BYTE*)(thisx + 180) = 0;
        *(_DWORD*)(thisx + 76) = 0;
        if (*(_BYTE*)(thisx + 72) != 11 && *(_BYTE*)(thisx + 72) != 13)
            *(_DWORD*)(thisx + 80) = 0;
        *(_DWORD*)(thisx + 152) = 0;
        *(_DWORD*)(thisx + 148) = 0;
        *(_DWORD*)(thisx + 144) = 0;
        *(_DWORD*)(thisx + 128) = 0;
        *(_DWORD*)(thisx + 124) = 0;
        *(_DWORD*)(thisx + 120) = 0;
        result = thisx;
        *(_DWORD*)(thisx + 152) = 30;
        if (*(_BYTE*)(thisx + 72) == 2)
        {
            result = thisx;
            *(_DWORD*)(thisx + 76) = 3;
        }
        else if (*(_BYTE*)(thisx + 72) == 3)
        {
            result = thisx;
            *(_DWORD*)(thisx + 76) = 4;
        }
    }
    return result;
}
 
BOOL sub_494AA9(char* thisx, int a2)
{
    return sub_4771C5(a2, thisx[72]);
}
 
int sub_494AC9(int thisx)
{
    int result; // eax
    int i; // [esp+4h] [ebp-4h]
    int j; // [esp+4h] [ebp-4h]

    *(_DWORD*)(thisx + 164) = 0;
    *(_DWORD*)(thisx + 172) = 0;
    *(_DWORD*)(thisx + 168) = 0;
    *(_DWORD*)(thisx + 176) = 0;
    *(_DWORD*)(thisx + 4) = 0;
    *(_BYTE*)(thisx + 195) = 5;
    *(_BYTE*)(thisx + 194) = 0;
    *(_BYTE*)(thisx + 180) = 0;
    for (i = 0; i < 8; ++i)
        *(_BYTE*)(i + thisx + 181) = 0;
    *(_BYTE*)(thisx + 69) = 1;
    *(_BYTE*)(thisx + 68) = 0;
    *(_BYTE*)(thisx + 71) = 0;
    *(_BYTE*)(thisx + 72) = 0;
    *(_BYTE*)(thisx + 22) = 0;
    *(_DWORD*)(thisx + 8) = 3;
    *(_BYTE*)(thisx + 70) = -1;
    for (j = 0; j < 2; ++j)
        *(_WORD*)(thisx + 16 * j + 24) = -2;
    *(_DWORD*)(thisx + 156) = 0;
    *(_DWORD*)(thisx + 64) = 0;
    *(_DWORD*)(thisx + 152) = 0;
    *(_DWORD*)(thisx + 144) = 0;
    *(_DWORD*)(thisx + 148) = 0;
    *(_DWORD*)(thisx + 116) = 0;
    *(_DWORD*)(thisx + 108) = 0;
    *(_DWORD*)(thisx + 112) = 0;
    *(_DWORD*)(thisx + 104) = 0;
    *(_DWORD*)(thisx + 96) = 0;
    *(_DWORD*)(thisx + 100) = 0;
    *(_DWORD*)(thisx + 160) = 0;
    *(_DWORD*)(thisx + 88) = 0;
    *(_DWORD*)(thisx + 92) = 0;
    *(_DWORD*)(thisx + 76) = 0;
    *(_DWORD*)(thisx + 80) = 0;
    *(_DWORD*)(thisx + 84) = 0;
    *(_DWORD*)(thisx + 128) = 0;
    *(_DWORD*)(thisx + 120) = 0;
    *(_DWORD*)(thisx + 124) = 0;
    *(_DWORD*)(thisx + 140) = 1;
    *(_DWORD*)(thisx + 136) = 1;
    *(_DWORD*)(thisx + 132) = 1;
    *(_DWORD*)(thisx + 16) = 0;
    *(_DWORD*)(thisx + 12) = 0;
    *(_DWORD*)(thisx + 56) = 0;
    *(_DWORD*)(thisx + 60) = 0;
    *(_WORD*)(thisx + 190) = 0;
    result = thisx;
    *(_WORD*)(thisx + 20) = 0;
    *(_WORD*)(thisx + 192) = 0;
    return result;
}

 
int __fastcall sub_494D01(int a1, int a2, unsigned __int8 a3, _BYTE* a4, int a5)
{
    int result; // eax
    int v7; // [esp+4h] [ebp-Ch]
    int v8; // [esp+8h] [ebp-8h]
    _DWORD* v9; // [esp+Ch] [ebp-4h]

    result = a3;
    if (a3)
    {
        if (a3 == 1)
        {
            result = a1;
            if (*(_DWORD*)(a1 + 12) == 5 && *(_BYTE**)(a1 + 56) == a4)
            {
                v9 = (_DWORD*)sub_464AC9((char*)unk_4B9B10, a4, 0, 0);
                if (v9)
                {
                    v8 = rand() % 10 + 5;
                    *(_DWORD*)(a1 + 120) = (sub_426090(v9) - *(_DWORD*)(a1 + 96)) / v8;
                    *(_DWORD*)(a1 + 124) = (sub_4260B0(v9) - *(_DWORD*)(a1 + 100)) / v8;
                    *(_DWORD*)(a1 + 128) = (sub_4260D0(v9) - *(_DWORD*)(a1 + 104) - 800) / v8;
                    *(_DWORD*)(a1 + 152) = 0;
                    *(_DWORD*)(a1 + 148) = 0;
                    *(_DWORD*)(a1 + 144) = 0;
                    *(_DWORD*)(a1 + 16) = 2;
                    *(_DWORD*)(a1 + 12) = 2;
                    v7 = a5 * *(unsigned __int16*)(a1 + 190) / 100 + 50;
                    if ((unsigned __int8)byte_4B999A >= 4u)
                        v7 /= (int)(unsigned __int8)byte_4B999A >> 2;
                    if (v7 > 0xFFFF)
                        LOWORD(v7) = -1;
                    *(_WORD*)(a1 + 192) = v7;
                    *(_BYTE*)(a1 + 194) = 0;
                    *(_BYTE*)(a1 + 195) = 5;
                    *(_DWORD*)(a1 + 156) = 0;
                    *(_BYTE*)(a1 + 180) = 0;
                    *(_DWORD*)(a1 + 172) = 1;
                    *(_DWORD*)(a1 + 168) = 1;
                    *(_DWORD*)(a1 + 76) = 0;
                    if (*(_BYTE*)(a1 + 72) == 11 || *(_BYTE*)(a1 + 72) == 13)
                    {
                        if (*(int*)(a1 + 84) < 0)
                        {
                            *(_DWORD*)(a1 + 84) = rand() % 300 + 300;
                            *(_DWORD*)(a1 + 80) = *(_DWORD*)(a1 + 84);
                        }
                    }
                    else
                    {
                        *(_DWORD*)(a1 + 80) = 0;
                    }
                    memset((void*)(a1 + 181), 0, 8u);
                    *(_BYTE*)(a1 + (unsigned __int8)sub_425EF0(*(_BYTE**)(a1 + 56)) + 181) = 1;
                    *(_BYTE*)(a1 + 68) = 0;
                    result = a1;
                    *(_BYTE*)(a1 + 71) = 0;
                }
                else
                {
                    return sub_494D01(a1, (_DWORD)a4, 2u, a4, a5);
                }
            }
        }
        else if (a3 == 2 && *(_DWORD*)(a1 + 12) == 5)
        {
            result = a1;
            if (*(_BYTE**)(a1 + 56) == a4)
            {
                *(_DWORD*)(a1 + 16) = 2;
                *(_DWORD*)(a1 + 12) = 2;
                *(_DWORD*)(a1 + 156) = 0;
                *(_DWORD*)(a1 + 76) = 255;
                result = a1;
                *(_DWORD*)(a1 + 152) = 30;
                *(_DWORD*)(a1 + 168) = 0;
                *(_BYTE*)(a1 + 180) = 0;
            }
        }
    }
    else if (!*(_DWORD*)(a1 + 12) && *(int*)(a1 + 96) >= 0)
    {
        result = a1;
        if (*(int*)(a1 + 100) >= 0)
        {
            *(_DWORD*)(a1 + 56) = (_DWORD)a4;
            *(_DWORD*)(a1 + 16) = 5;
            *(_DWORD*)(a1 + 12) = 5;
            *(_DWORD*)(a1 + 156) = 0;
            *(_DWORD*)(a1 + 76) = 0;
            if (*(_BYTE*)(a1 + 72) != 11 && *(_BYTE*)(a1 + 72) != 13)
                *(_DWORD*)(a1 + 80) = 0;
            result = a1;
            *(_DWORD*)(a1 + 128) = 0;
            *(_DWORD*)(a1 + 152) = 0;
        }
    }
    return result;
}

 
__int16 sub_49507B(_DWORD* a1, double a2, double a3, double a4)
{
	a1[4] = 6;
	a1[3] = 6;
	a1[39] = 0;
	return sub_4967E4((int)a1, a3, a2, a4);
}

 
int sub_4950AF(int thisx)
{
    int result; // eax
    int v2; // edx
    int v3; // edx
    int v4; // edx
    int v5; // edx
    int v6; // edx
    int v7; // edx
    int v8; // edx
    int v9; // edx
    int v10; // edx
    int v11; // edx

    result = thisx;
    switch (*(_BYTE*)(thisx + 72))
    {
    case 0:
        v2 = 10 * (rand() % 5) + 175;
        result = thisx;
        *(_WORD*)(thisx + 190) = v2;
        break;
    case 1:
        v3 = 10 * (rand() % 10) + 155;
        result = thisx;
        *(_WORD*)(thisx + 190) = v3;
        break;
    case 2:
    case 0xB:
        v4 = 10 * (rand() % 5) + 195;
        result = thisx;
        *(_WORD*)(thisx + 190) = v4;
        break;
    case 3:
        v5 = 10 * (rand() % 3) + 225;
        result = thisx;
        *(_WORD*)(thisx + 190) = v5;
        break;
    case 4:
        v6 = 10 * (rand() % 5) + 200;
        result = thisx;
        *(_WORD*)(thisx + 190) = v6;
        break;
    case 5:
        v7 = 10 * (rand() % 5) + 185;
        result = thisx;
        *(_WORD*)(thisx + 190) = v7;
        break;
    case 6:
        v8 = 10 * (rand() % 5) + 190;
        result = thisx;
        *(_WORD*)(thisx + 190) = v8;
        break;
    case 7:
        v9 = 5 * (rand() % 5) + 150;
        result = thisx;
        *(_WORD*)(thisx + 190) = v9;
        break;
    case 8:
    case 9:
    case 0xD:
        v11 = 5 * (rand() % 7) + 225;
        result = thisx;
        *(_WORD*)(thisx + 190) = v11;
        break;
    case 0xA:
        result = 10 * (rand() % 4) + 225;
        *(_WORD*)(thisx + 190) = result;
        break;
    case 0xC:
        v10 = 5 * (rand() % 5) + 125;
        result = thisx;
        *(_WORD*)(thisx + 190) = v10;
        break;
    default:
        return result;
    }
    return result;
}

 
_DWORD* sub_49530B(int thisx, _DWORD* a2)
{
    _DWORD* v2; // eax
    int v4[4]; // [esp+4h] [ebp-14h] BYREF
    char* v5; // [esp+14h] [ebp-4h]

    v5 = (char*)(140 * *(unsigned __int16*)(thisx + 20) + dword_4B92E8);
    v2 = sub_47EE60(v5, v4, *(_DWORD*)(thisx + 164), 0);
    *a2 = *v2;
    a2[1] = v2[1];
    a2[2] = v2[2];
    a2[3] = v2[3];
    return a2;
}
 
double sub_495368(int a1, double a2, double result)
{
    char* v3; // eax
    int v4; // [esp+8h] [ebp-E0h]
    int v5; // [esp+Ch] [ebp-DCh]
    int v6; // [esp+14h] [ebp-D4h]
    int v7; // [esp+18h] [ebp-D0h]
    double v8; // [esp+24h] [ebp-C4h]
    double v9; // [esp+30h] [ebp-B8h]
    int v10; // [esp+3Ch] [ebp-ACh]
    int v11; // [esp+44h] [ebp-A4h]
    char v12; // [esp+48h] [ebp-A0h]
    int v13; // [esp+4Ch] [ebp-9Ch]
    int v14; // [esp+50h] [ebp-98h]
    int v15; // [esp+54h] [ebp-94h]
    double v17; // [esp+5Ch] [ebp-8Ch]
    int v18; // [esp+68h] [ebp-80h]
    int v19; // [esp+7Ch] [ebp-6Ch]
    double v20; // [esp+80h] [ebp-68h]
    int v21; // [esp+88h] [ebp-60h]
    int v22; // [esp+8Ch] [ebp-5Ch]
    char v23; // [esp+90h] [ebp-58h]
    char v24; // [esp+90h] [ebp-58h]
    char* v25; // [esp+94h] [ebp-54h]
    int v26; // [esp+98h] [ebp-50h]
    int v27; // [esp+9Ch] [ebp-4Ch]
    int v28; // [esp+A0h] [ebp-48h]
    int v29; // [esp+A4h] [ebp-44h]
    int v30; // [esp+A8h] [ebp-40h]
    int v31; // [esp+ACh] [ebp-3Ch]
    int v32; // [esp+B0h] [ebp-38h]
    int v33; // [esp+B8h] [ebp-30h]
    int v34; // [esp+BCh] [ebp-2Ch]
    int v35; // [esp+C4h] [ebp-24h]
    int v36; // [esp+C8h] [ebp-20h]
    int i; // [esp+CCh] [ebp-1Ch]
    int v38; // [esp+D0h] [ebp-18h]
    int v39; // [esp+D0h] [ebp-18h]
    int v40; // [esp+D0h] [ebp-18h]
    int v41; // [esp+D0h] [ebp-18h]
    int v42; // [esp+D0h] [ebp-18h]
    char v43; // [esp+D8h] [ebp-10h]
    char v44; // [esp+D8h] [ebp-10h]
    char v45; // [esp+D8h] [ebp-10h]
    unsigned __int8 v46; // [esp+D8h] [ebp-10h]
    int v47; // [esp+DCh] [ebp-Ch]
    int v48; // [esp+E0h] [ebp-8h]
    char v49; // [esp+E4h] [ebp-4h]

    v25 = sub_426210((char*)unk_4B9B10);
    v38 = -100 * sub_486633((int*)v25, *(_DWORD*)(a1 + 96) / 100, *(_DWORD*)(a1 + 100) / 100);
    if (*(_DWORD*)(a1 + 12) == 7 && (v38 == -102000 || *(_DWORD*)(a1 + 104) > v38))
    {
        *(_DWORD*)(a1 + 16) = 0;
        *(_DWORD*)(a1 + 172) = 0;
        *(_DWORD*)(a1 + 120) = 0;
        *(_DWORD*)(a1 + 128) = 0;
        *(_DWORD*)(a1 + 152) = 0;
        return result;
    }
    *(_DWORD*)(a1 + 120) += *(_DWORD*)(a1 + 144);
    *(_DWORD*)(a1 + 124) += *(_DWORD*)(a1 + 148);
    v32 = *(_DWORD*)(a1 + 120) / *(_DWORD*)(a1 + 132) + *(_DWORD*)(a1 + 96);
    v26 = *(_DWORD*)(a1 + 124) / *(_DWORD*)(a1 + 136) + *(_DWORD*)(a1 + 100);
    v27 = v26 / 100 - (v26 < 0);
    v35 = v26 / 800 - (v26 < 0);
    v47 = sub_4897D0(v25);
    v28 = 8 * sub_4261D0(v25);
    sub_486633((int*)v25, v32 / 100 - (v32 < 0), v27);
    sub_4868C1(v25, v32 / 800 - (v32 < 0), v35);
    if (*(_DWORD*)(a1 + 96) / 800 - v32 / 800 <= 0)
        v15 = v32 / 800 - *(_DWORD*)(a1 + 96) / 800;
    else
        v15 = *(_DWORD*)(a1 + 96) / 800 - v32 / 800;
    v29 = v15 + 1;
    if (*(int*)(a1 + 96) <= 0)
        v14 = -*(_DWORD*)(a1 + 96);
    else
        v14 = *(_DWORD*)(a1 + 96);
    if (v32 <= 0)
        v13 = -v32;
    else
        v13 = v32;
    if (v14 == v13)
        v29 = 0;
    if (v32 - *(_DWORD*)(a1 + 96) <= 0)
        v12 = (v32 - *(_DWORD*)(a1 + 96) >= 0) - 1;
    else
        v12 = 1;
    v48 = 0;
    v33 = *(_DWORD*)(a1 + 96) / 100;
    v30 = *(_DWORD*)(a1 + 100) / 100;
    v34 = *(_DWORD*)(a1 + 104) / -100;
    v49 = sub_4868C1(v25, v33 / 8, v30 / 8);
    for (i = 0; i < v29; ++i)
    {
        v22 = i * 8 * v12 + v33;
        if (i == v29 - 1)
            v22 = v32 / 100 - (v32 < 0);
        v39 = sub_486633((int*)v25, v22, v30);
        v43 = sub_4868C1(v25, v22 / 8, v30 / 8);
        v23 = v43 | v49;
        if (v39 == 1020
            || (!v23 || *(_DWORD*)(a1 + 172)) && v39 - v34 > 2
            || v23 && !*(_DWORD*)(a1 + 172) && v39 - v34 > 8)
        {
            if (!*(_DWORD*)(a1 + 172) || !v23)
                v48 = 1;
            v21 = -8 * v12;
            if (!v21)
            {
                v34 = v39;
                *(_DWORD*)(a1 + 104) = -100 * v39;
            }
            v36 = 800 * (v22 / 8) - 100;
            if (v36 < 0)
                v36 = 100;
            if (v36 / 100 >= v47)
                v36 = 100 * v47 - 100;
            if (v21 > 0)
                v36 += 900;
            if (v22 >= 0)
            {
                if (v22 > v47)
                    v22 = v47;
            }
            else
            {
                v22 = 0;
            }
            while (1)
            {
                if (v22 < 0 || v22 > v47)
                {
                    *(_DWORD*)(a1 + 96) = -32000;
                    *(_DWORD*)(a1 + 120) = 0;
                    *(_DWORD*)(a1 + 144) = 0;
                    *(_DWORD*)(a1 + 128) = 0;
                    *(_DWORD*)(a1 + 152) = 0;
                    return result;
                }
                v22 += v21;
                v40 = sub_486633((int*)v25, v22, v30);
                if (!v21)
                    break;
                v44 = sub_4868C1(v25, v22 / 8, v30 / 8);
                v24 = v44 | v49;
                if (v40 != 1020
                    && (v24 && !*(_DWORD*)(a1 + 172) || v40 - v34 <= 2)
                    && (!v24 || *(_DWORD*)(a1 + 172) || v40 - v34 <= 8))
                {
                    goto LABEL_65;
                }
                v36 = 800 * (v22 / 8) - 100;
                if (v21 > 0)
                    v36 += 900;
                v49 = v44;
            }
            *(_DWORD*)(a1 + 104) = -100 * v40;
            break;
        }
        v49 = v43;
        if (v23 && !*(_DWORD*)(a1 + 172))
        {
            v34 = v39;
            *(_DWORD*)(a1 + 104) = -100 * v39;
        }
    }
LABEL_65:
    if (v48)
    {
        if (*(int*)(a1 + 120) <= 0)
            v11 = (*(_DWORD*)(a1 + 120) >= 0) - 1;
        else
            v11 = 1;
        v32 = v36 - v11;
        if (!*(_DWORD*)(a1 + 172))
            *(_DWORD*)(a1 + 104) = -100 * sub_486633((int*)v25, v32 / 100, v30);
        sub_494754(a1);
    }
    *(_DWORD*)(a1 + 96) = v32;
    v41 = -100 * sub_486633((int*)v25, *(_DWORD*)(a1 + 96) / 100, v27);
    v45 = sub_4868C1(v25, *(_DWORD*)(a1 + 96) / 800, v35);
    v31 = 0;
    if (v26 >= 0 || *(int*)(a1 + 124) >= 0)
    {
        if (v26 < 100 * v28 || *(int*)(a1 + 124) <= 0)
        {
            if (v41 == -102000 || !v45 && *(_DWORD*)(a1 + 104) - v41 > 200 || v45 && *(_DWORD*)(a1 + 104) - v41 > 800)
            {
                v26 = *(_DWORD*)(a1 + 100);
                v31 = 1;
            }
        }
        else
        {
            v26 = 100 * (v28 - 1);
            v31 = 1;
        }
    }
    else
    {
        v26 = 0;
        v31 = 1;
    }
    if (v31)
    {
        sub_49951D((int*)a1);
        *(int*)(a1 + 120) /= 2;
        *(_DWORD*)(a1 + 124) = -*(_DWORD*)(a1 + 124) / 2;
        *(_DWORD*)(a1 + 144) = 0;
        *(_DWORD*)(a1 + 148) = 0;
        *(_DWORD*)(a1 + 8) = 83;
        *(_BYTE*)(a1 + 71) = 0;
        if (*(_DWORD*)(a1 + 172))
            *(_DWORD*)(a1 + 152) = 30;
    }
    *(_DWORD*)(a1 + 100) = v26;
    *(_DWORD*)(a1 + 128) += *(_DWORD*)(a1 + 152);
    *(_DWORD*)(a1 + 104) += *(_DWORD*)(a1 + 128) / *(_DWORD*)(a1 + 140);
    if (*(int*)(a1 + 104) >= 3200
        || *(int*)(a1 + 96) < 0
        || *(_DWORD*)(a1 + 96) >= 100 * v47
        || *(int*)(a1 + 100) < 0
        || *(_DWORD*)(a1 + 100) >= 100 * v28)
    {
        *(_DWORD*)(a1 + 96) = -32000;
        *(_DWORD*)(a1 + 100) = -24000;
        *(_DWORD*)(a1 + 16) = 0;
        return result;
    }
    v42 = -100 * sub_486633((int*)v25, *(_DWORD*)(a1 + 96) / 100, *(_DWORD*)(a1 + 100) / 100);
    v46 = sub_4868C1(v25, *(_DWORD*)(a1 + 96) / 800, *(_DWORD*)(a1 + 100) / 800);
    if (*(_DWORD*)(a1 + 104) > v42 && *(_DWORD*)(a1 + 172))
    {
        switch (*(_BYTE*)(a1 + 72))
        {
        case 0:
            sub_43FFC3((int*)unk_4BDB28, dword_4B9A78, -1, 100, 100, 0);
            break;
        case 1:
        case 5:
        case 7:
        case 0xB:
            sub_43FFC3((int*)unk_4BDB28, dword_4B9A7C, -1, 100, 100, 0);
            break;
        case 2:
        case 4:
        case 0xD:
            sub_43FFC3((int*)unk_4BDB28, dword_4B9A80, -1, 100, 100, 0);
            break;
        case 3:
            sub_43FFC3((int*)unk_4BDB28, dword_4B9A84, -1, 100, 100, 0);
            break;
        case 6:
            sub_43FFC3((int*)unk_4BDB28, dword_4B9A8C, -1, 100, 100, 0);
            break;
        case 8:
        case 9:
        case 0xA:
            sub_43FFC3((int*)unk_4BDB28, dword_4B9A14, -1, 100, 100, 0);
            break;
        case 0xC:
            sub_43FFC3((int*)unk_4BDB28, dword_4B9ACC, -1, 100, 100, 0);
            break;
        default:
            break;
        }
        *(_DWORD*)(a1 + 8) = 83;
        sub_4995EB((_WORD*)a1);
        sub_49951D((int*)a1);
        if ((*(_BYTE*)(a1 + 72) == 11 || *(_BYTE*)(a1 + 72) == 13) && *(_DWORD*)(a1 + 12) != 8)
        {
            if (*(_DWORD*)(a1 + 56) && sub_41BA53(*(_DWORD*)(a1 + 56), 0x8Au, 0))
            {
                *(_DWORD*)(a1 + 84) = 0;
            }
            else if (*(int*)(a1 + 84) > 0)
            {
                *(_DWORD*)(a1 + 84) -= 20;
                if (*(int*)(a1 + 84) < 0)
                    *(_DWORD*)(a1 + 84) = 0;
            }
        }
        *(_DWORD*)(a1 + 104) = v42;
        *(_DWORD*)(a1 + 144) = 0;
        *(_DWORD*)(a1 + 148) = 0;
        if (*(_BYTE*)(a1 + 72) == 12)
        {
            *(_DWORD*)(a1 + 168) = 0;
            *(_BYTE*)(a1 + 71) = 0;
            v5 = *(_DWORD*)(a1 + 100) / 800;
            v4 = *(_DWORD*)(a1 + 96) / 800;
            v3 = sub_426210((char*)unk_4B9B10);
            sub_4897EE(v3, a2, v4, v5);
            v17 = result;
            if (result == 0.0 && !*(_DWORD*)(a1 + 128))
            {
                if (*(int*)(a1 + 120) <= 0)
                    v10 = -*(_DWORD*)(a1 + 120);
                else
                    v10 = *(_DWORD*)(a1 + 120);
                *(_DWORD*)(a1 + 128) = v10;
            }
            result = (double)*(int*)(a1 + 128);
            sub_4A3090(result, result, (double)*(int*)(a1 + 120));
            v20 = v17 + v17 + a2;
            if (*(_DWORD*)(a1 + 120))
            {
                v9 = (double)(100 * *(_DWORD*)(a1 + 120));
                v18 = (__int64)(v9 / cos(a2));
            }
            else
            {
                v8 = (double)(100 * *(_DWORD*)(a1 + 128));
                v18 = (__int64)(v8 / sin(a2));
            }
            *(_DWORD*)(a1 + 120) = (__int64)(cos(v20) * (double)v18 / 100.0);
            *(_DWORD*)(a1 + 128) = (__int64)(sin(v20) * (double)v18 / 100.0);
            v19 = (__int64)(sin(3.1415926535 - v17 - v20) * (double)v18);
            if (v19 <= 0)
                v7 = -v19;
            else
                v7 = v19;
            if (v7 >= 3000)
            {
                *(_DWORD*)(a1 + 120) = 85 * *(_DWORD*)(a1 + 120) / 100;
                *(_DWORD*)(a1 + 124) = 85 * *(_DWORD*)(a1 + 124) / 100;
                *(_DWORD*)(a1 + 128) = -85 * *(_DWORD*)(a1 + 128) / 100;
                *(_DWORD*)(a1 + 152) = 30;
                *(_DWORD*)(a1 + 172) = 1;
            }
            else
            {
                *(_DWORD*)(a1 + 128) = 0;
                *(_DWORD*)(a1 + 152) = 0;
                *(_DWORD*)(a1 + 172) = 0;
                *(_DWORD*)(a1 + 76) = 1;
            }
        }
        else if (*(unsigned __int8*)(a1 + 180) >= 2u || *(_BYTE*)(a1 + 72) == 10)
        {
            if (*(unsigned __int8*)(a1 + 72) < 2u
                || *(unsigned __int8*)(a1 + 72) >= 4u && *(unsigned __int8*)(a1 + 72) <= 7u
                || *(_BYTE*)(a1 + 72) == 11
                || *(_BYTE*)(a1 + 72) == 12)
            {
                *(_DWORD*)(a1 + 120) = 0;
                *(_DWORD*)(a1 + 128) = 0;
                *(_DWORD*)(a1 + 152) = 0;
                *(_DWORD*)(a1 + 16) = 0;
                return result;
            }
            if (*(unsigned __int8*)(a1 + 72) < 4u || *(_BYTE*)(a1 + 72) == 13)
            {
                if (*(_DWORD*)(a1 + 76) || !*(_DWORD*)(a1 + 120))
                {
                    *(_DWORD*)(a1 + 120) = 0;
                    *(_DWORD*)(a1 + 128) = 0;
                    *(_DWORD*)(a1 + 152) = 0;
                    *(_DWORD*)(a1 + 16) = 0;
                    *(_BYTE*)(a1 + 68) = 0;
                    *(_BYTE*)(a1 + 71) = 0;
                    return result;
                }
                *(_DWORD*)(a1 + 76) = 1;
                *(_DWORD*)(a1 + 172) = 0;
                *(_DWORD*)(a1 + 128) = 0;
                *(_DWORD*)(a1 + 152) = 0;
            }
            else
            {
                *(_DWORD*)(a1 + 128) = 0;
                *(_DWORD*)(a1 + 152) = 0;
                *(_DWORD*)(a1 + 172) = 0;
            }
        }
        else
        {
            ++* (_BYTE*)(a1 + 180);
            if ((*(_BYTE*)(a1 + 72) == 7 || *(_BYTE*)(a1 + 72) == 8 || *(_BYTE*)(a1 + 72) == 9)
                && *(_BYTE*)(a1 + 180) == 1)
            {
                ++* (_BYTE*)(a1 + 180);
            }
            if (*(_BYTE*)(a1 + 72) == 8 || *(_BYTE*)(a1 + 72) == 9)
            {
                *(_DWORD*)(a1 + 120) = 90 * *(_DWORD*)(a1 + 120) / 100;
                *(_DWORD*)(a1 + 124) = 75 * *(_DWORD*)(a1 + 124) / 100;
                *(_DWORD*)(a1 + 128) = -250;
            }
            else
            {
                *(_DWORD*)(a1 + 120) = 75 * *(_DWORD*)(a1 + 120) / 100;
                *(int*)(a1 + 124) /= 2;
                *(_DWORD*)(a1 + 128) = 50 * *(unsigned __int8*)(a1 + 180) - 300;
            }
            *(_DWORD*)(a1 + 152) = 30;
            *(_DWORD*)(a1 + 172) = 1;
            if ((*(unsigned __int8*)(a1 + 72) < 2u
                || *(unsigned __int8*)(a1 + 72) >= 4u && *(unsigned __int8*)(a1 + 72) <= 7u
                || *(_BYTE*)(a1 + 72) == 11
                || *(_BYTE*)(a1 + 72) == 12)
                && *(unsigned __int8*)(a1 + 180) >= 2u)
            {
                *(_DWORD*)(a1 + 168) = 0;
                *(_DWORD*)(a1 + 16) = 3;
                *(_BYTE*)(a1 + 68) = 0;
                *(_BYTE*)(a1 + 71) = 0;
            }
        }
    }
    if (v42 - *(_DWORD*)(a1 + 104) >= 800 && !*(_DWORD*)(a1 + 172))
    {
        *(_DWORD*)(a1 + 172) = 1;
        *(_DWORD*)(a1 + 152) = 30;
        *(_BYTE*)(a1 + 180) = 0;
    }
    if (v42 - *(_DWORD*)(a1 + 104) <= 0)
        v6 = *(_DWORD*)(a1 + 104) - v42;
    else
        v6 = v42 - *(_DWORD*)(a1 + 104);
    if (v6 <= 800 && !*(_DWORD*)(a1 + 172))
    {
        *(_DWORD*)(a1 + 104) = v42;
        if (v46)
        {
            if ((v46 & 1) == 1)
            {
                *(_DWORD*)(a1 + 120) -= 3 * (v46 + 1);
            }
            else if ((v46 & 1) == 0)
            {
                *(_DWORD*)(a1 + 120) += 3 * (v46 - 1);
            }
        }
    }
    return result;
}
 
__int16 sub_4967E4(int a1, double a2, double st5_0, double a4)
{
    int v4; // eax
    int v5; // esi
    int v6; // esi
    int v7; // esi
    double v8; // st7
    int v9; // esi
    int v10; // esi
    int v11; // esi
    double v12; // st7
    double v13; // st7
    double v14; // st7
    int v15; // eax
    int v17; // eax
    int v18; // ecx
    int v19; // kr34_4
    int v20; // eax
    int v21; // et2
    int v23; // edx
    double v25; // [esp+0h] [ebp-F0h]
    double v26; // [esp+0h] [ebp-F0h]
    double v27; // [esp+8h] [ebp-E8h]
    double v28; // [esp+8h] [ebp-E8h]
    int v29; // [esp+14h] [ebp-DCh]
    int v30; // [esp+18h] [ebp-D8h]
    int v31; // [esp+1Ch] [ebp-D4h]
    int v32; // [esp+20h] [ebp-D0h]
    int v33; // [esp+24h] [ebp-CCh]
    int v34; // [esp+28h] [ebp-C8h]
    int v35; // [esp+2Ch] [ebp-C4h]
    int v36; // [esp+30h] [ebp-C0h]
    int v37; // [esp+34h] [ebp-BCh]
    int v38; // [esp+38h] [ebp-B8h]
    int v39; // [esp+3Ch] [ebp-B4h]
    int v40; // [esp+40h] [ebp-B0h]
    int v41; // [esp+44h] [ebp-ACh]
    int v42; // [esp+48h] [ebp-A8h]
    int v43; // [esp+4Ch] [ebp-A4h]
    int v44; // [esp+50h] [ebp-A0h]
    int v45; // [esp+54h] [ebp-9Ch]
    int v46; // [esp+58h] [ebp-98h]
    int v47; // [esp+5Ch] [ebp-94h]
    int v48; // [esp+60h] [ebp-90h]
    int v49; // [esp+64h] [ebp-8Ch]
    int v50; // [esp+68h] [ebp-88h]
    int j; // [esp+88h] [ebp-68h]
    int v56; // [esp+8Ch] [ebp-64h]
    int v57; // [esp+90h] [ebp-60h]
    int v58; // [esp+94h] [ebp-5Ch]
    int v59; // [esp+98h] [ebp-58h]
    int v60; // [esp+A8h] [ebp-48h]
    int v61; // [esp+B0h] [ebp-40h]
    int v62; // [esp+B4h] [ebp-3Ch]
    int v63; // [esp+B8h] [ebp-38h]
    int v64; // [esp+BCh] [ebp-34h]
    int v65; // [esp+C0h] [ebp-30h]
    int i; // [esp+C4h] [ebp-2Ch]
    int v67; // [esp+C8h] [ebp-28h]
    int v68; // [esp+CCh] [ebp-24h]
    int v69; // [esp+D0h] [ebp-20h]
    double X; // [esp+D4h] [ebp-1Ch]
    double Xa; // [esp+D4h] [ebp-1Ch]
    int v72; // [esp+DCh] [ebp-14h]
    char* v73; // [esp+E0h] [ebp-10h]
    unsigned __int8 v74; // [esp+E4h] [ebp-Ch]
    _BYTE* v75; // [esp+E8h] [ebp-8h]
    int v76; // [esp+ECh] [ebp-4h]

    if (*(_BYTE*)(a1 + 72) != 11 && *(_BYTE*)(a1 + 72) != 13)
        goto LABEL_433;
    if (*(int*)(a1 + 84) > 0)
        --* (_DWORD*)(a1 + 84);
    if (*(_DWORD*)(a1 + 84) || (LOWORD(v4) = a1, *(_DWORD*)(a1 + 12) == 8))
    {
    LABEL_433:
        if (*(_DWORD*)(a1 + 12))
        {
            switch (*(_DWORD*)(a1 + 12))
            {
            case 1:
                *(_BYTE*)(a1 + 22) = 0;
                v75 = (_BYTE*)sub_41C915(*(_DWORD*)(a1 + 56));
                *(_DWORD*)(a1 + 164) = sub_425D70(*(_DWORD**)(a1 + 56));
                v5 = sub_426090(*(_DWORD**)(a1 + 56));
                *(_DWORD*)(a1 + 96) = 100 * sub_4758D0(v75, *(_DWORD*)(a1 + 164)) + v5;
                *(_DWORD*)(a1 + 100) = sub_4260B0(*(_DWORD**)(a1 + 56));
                v6 = sub_4260D0(*(_DWORD**)(a1 + 56));
                *(_DWORD*)(a1 + 104) = 100 * sub_4758F0(v75, 0) + v6;
                v4 = (unsigned __int8)sub_425B70(v75);
                if (v4)
                {
                    v7 = 44 * *(unsigned __int8*)(a1 + 72);
                    LOWORD(v4) = *(_WORD*)&dword_4B7180[4 * (unsigned __int8)sub_425B70(v75) + v7];
                    *(_WORD*)(a1 + 20) = v4;
                }
                break;
            case 2:
            case 3:
                v8 = sub_495368(a1, a2, a4);
                v73 = sub_426210((char*)unk_4B9B10);
                v74 = sub_4868C1(v73, *(_DWORD*)(a1 + 96) / 800, *(_DWORD*)(a1 + 100) / 800);
                ++* (_DWORD*)(a1 + 156);
                switch (*(_DWORD*)(a1 + 8))
                {
                case 0xB4:
                    switch (++ * (_DWORD*)(a1 + 160))
                    {
                    case 0x14:
                        *(_DWORD*)(a1 + 88) = *(_DWORD*)(a1 + 120);
                        *(_DWORD*)(a1 + 92) = *(_DWORD*)(a1 + 124);
                        *(_DWORD*)(a1 + 144) = -*(_DWORD*)(a1 + 120) / 12;
                        *(_DWORD*)(a1 + 148) = -*(_DWORD*)(a1 + 124) / 12;
                        break;
                    case 0x1E:
                        *(int*)(a1 + 144) /= 10;
                        *(int*)(a1 + 148) /= 10;
                        *(int*)(a1 + 128) /= 2;
                        *(int*)(a1 + 152) /= 4;
                        break;
                    case 0x32:
                        *(_DWORD*)(a1 + 144) = -*(_DWORD*)(a1 + 88) / 10;
                        *(_DWORD*)(a1 + 148) = -*(_DWORD*)(a1 + 92) / 10;
                        *(_DWORD*)(a1 + 152) *= 4;
                        break;
                    case 0x3D:
                        *(_DWORD*)(a1 + 144) = 0;
                        *(_DWORD*)(a1 + 148) = 0;
                        *(_DWORD*)(a1 + 152) = 0;
                        break;
                    }
                    break;
                case 0xB7:
                    if (++ * (_DWORD*)(a1 + 160) == 60)
                    {
                        *(_DWORD*)(a1 + 120) = 0;
                        *(_DWORD*)(a1 + 124) = 0;
                        *(_DWORD*)(a1 + 128) = 0;
                    }
                    else
                    {
                        LOWORD(v4) = a1;
                        if (*(_DWORD*)(a1 + 160) == 80)
                        {
                            if (*(_DWORD*)(a1 + 60))
                            {
                                v72 = 500;
                                v9 = sub_426090(*(_DWORD**)(a1 + 60));
                                v67 = v9 - sub_426470((_DWORD*)a1);
                                v10 = sub_4260B0(*(_DWORD**)(a1 + 60));
                                v69 = v10 - sub_426530((_DWORD*)a1);
                                v11 = (sub_4260D0(*(_DWORD**)(a1 + 60)) - 1500) / 100;
                                v68 = 100
                                    * (v11
                                        - (int)Concurrency::details::UMSFreeVirtualProcessorRoot::GetExecutingProxy((Concurrency::details::UMSFreeVirtualProcessorRoot*)a1)
                                        / 100);
                                //__asm?????????????????/
                                //{
                                //    fild[ebp + var_28]
                                //    fstp[esp + 0E8h + var_E8]
                                //    fild[ebp + var_20]
                                //    fstp[esp + 0F0h + var_F0]
                                //}
                                //sub_4A3090(v8, a2, v25, v27);
                                //__asm
                                //{
                                //    fstp[ebp + X]
                                //    fild[ebp + var_14]
                                //    fstp[ebp + var_74]
                                //}
                                v12 = cos(X);
                               __asm { fmul[ebp + 74] }
                               //__asm { fmul[ebp + var_74] }
                                *(_DWORD*)(a1 + 120) = _ftol(v12);
                                __asm
                                {
                                    //fild[ebp /+ var_14]
                                   // fstp[ebp + var_7C]
                                }
                                v13 = sin(X);
                               // __asm { fmul[ebp + var_7C] }
                                *(_DWORD*)(a1 + 124) = _ftol(v13);
                                __asm
                                {
                                    //fild[ebp + var_28]
                                   // fstp[esp + 0E8h + var_E8]
                                   // fild[ebp + var_24]
                                   // fstp[esp + 0F0h + var_F0]
                                }
                                sub_4A3090(v13, v26, v28);
 /*                               __asm
                                {
                                    fstp[ebp + X]
                                    fild[ebp + var_14]
                                    fstp[ebp + var_84]
                                }*/
                                v14 = sin(Xa);
                                //__asm { fmul[ebp + var_84] }
                                v4 = _ftol(v14);
                                *(_DWORD*)(a1 + 128) = v4;
                            }
                            else
                            {
                                *(_DWORD*)(a1 + 152) = 30;
                            }
                            return v4;
                        }
                    }
                    break;
                case 0xB9:
                    ++ * (_DWORD*)(a1 + 160);
                    if (*(_DWORD*)(a1 + 56) && !(*(_DWORD*)(a1 + 160) % 2))
                    {
                        *(_DWORD*)(a1 + 120) += (char)sub_485120(*(char**)(a1 + 56));
                        *(_DWORD*)(a1 + 124) += (char)sub_485140(*(char**)(a1 + 56));
                    }
                    break;
                case 0xBD:
                    *(_WORD*)(a1 + 192) += *(_WORD*)(a1 + 88);
                    if (++ * (_DWORD*)(a1 + 160) == 30)
                        *(_DWORD*)(a1 + 128) = 0;
                    break;
                case 0xBE:
                    ++ * (_DWORD*)(a1 + 160);
                    if (*(int*)(a1 + 104) < -24000 && *(_DWORD*)(a1 + 88) == 1)
                    {
                        *(_DWORD*)(a1 + 88) = 2;
                        *(_DWORD*)(a1 + 120) = 0;
                        *(_DWORD*)(a1 + 144) = 0;
                        *(_DWORD*)(a1 + 152) = 0;
                        *(_DWORD*)(a1 + 128) = 0;
                        *(_DWORD*)(a1 + 160) = 0;
                    }
                    if (*(_DWORD*)(a1 + 160) == 40 && *(_DWORD*)(a1 + 88) == 2)
                        *(_DWORD*)(a1 + 128) = 1200;
                    break;
                case 0xBF:
                    if (*(_DWORD*)(a1 + 160) % 6)
                    {
                        if (*(_DWORD*)(a1 + 160) % 6 == 3)
                            *(_DWORD*)(a1 + 128) += 2 * *(_DWORD*)(a1 + 88);
                    }
                    else
                    {
                        *(_DWORD*)(a1 + 128) -= *(_DWORD*)(a1 + 88);
                        *(_DWORD*)(a1 + 88) = 400 * (rand() % 3) + 800;
                        *(_DWORD*)(a1 + 128) -= *(_DWORD*)(a1 + 88);
                    }
                    ++* (_DWORD*)(a1 + 160);
                    break;
                case 0xC0:
                    if (!*(_DWORD*)(a1 + 160))
                        *(_DWORD*)(a1 + 128) = -600;
                    if (*(_DWORD*)(a1 + 160) % 16)
                    {
                        switch (*(_DWORD*)(a1 + 160) % 16)
                        {
                        case 4:
                            if (*(int*)(a1 + 120) <= 0)
                                v50 = (*(_DWORD*)(a1 + 120) >= 0) - 1;
                            else
                                v50 = 1;
                            *(_DWORD*)(a1 + 144) = -10 * v50;
                            break;
                        case 8:
                            *(_DWORD*)(a1 + 152) = -150;
                            break;
                        case 12:
                            if (*(int*)(a1 + 120) <= 0)
                                v49 = (*(_DWORD*)(a1 + 120) >= 0) - 1;
                            else
                                v49 = 1;
                            *(_DWORD*)(a1 + 144) = 10 * v49;
                            break;
                        }
                    }
                    else
                    {
                        *(_DWORD*)(a1 + 152) = 150;
                    }
                    ++* (_DWORD*)(a1 + 160);
                    break;
                case 0xC1:
                    v15 = *(_DWORD*)(a1 + 160) % 16;
                    if (v15 >= 8)
                        v65 = 2 * (16 - v15);
                    else
                        v65 = 2 * v15;
                    for (i = 0; i < 2; ++i)
                    {
                        *(_WORD*)(a1 + 16 * i + 24) = -1;
                        *(_DWORD*)(a1 + 16 * i + 28) = 0;
                        *(_DWORD*)(a1 + 16 * i + 32) = 0;
                        *(_DWORD*)(a1 + 16 * i + 36) = i * v65 - (i == 0) * v65;
                    }
                    ++* (_DWORD*)(a1 + 160);
                    break;
                case 0xC2:
                    if (!*(_DWORD*)(a1 + 160))
                        *(_DWORD*)(a1 + 124) -= 600;
                    if (*(_DWORD*)(a1 + 160) % 16)
                    {
                        switch (*(_DWORD*)(a1 + 160) % 16)
                        {
                        case 4:
                            if (*(int*)(a1 + 120) <= 0)
                                v48 = (*(_DWORD*)(a1 + 120) >= 0) - 1;
                            else
                                v48 = 1;
                            *(_DWORD*)(a1 + 144) = -10 * v48;
                            break;
                        case 8:
                            *(_DWORD*)(a1 + 148) = -150;
                            break;
                        case 12:
                            if (*(int*)(a1 + 120) <= 0)
                                v47 = (*(_DWORD*)(a1 + 120) >= 0) - 1;
                            else
                                v47 = 1;
                            *(_DWORD*)(a1 + 144) = 10 * v47;
                            break;
                        }
                    }
                    else
                    {
                        *(_DWORD*)(a1 + 148) = 150;
                    }
                    ++* (_DWORD*)(a1 + 160);
                    break;
                case 0xC3:
                    if (*(_DWORD*)(a1 + 60))
                    {
                        v62 = sub_426090(*(_DWORD**)(a1 + 60));
                        v61 = sub_4260B0(*(_DWORD**)(a1 + 60));
                        if (v62 - *(_DWORD*)(a1 + 96) <= 0)
                            v46 = *(_DWORD*)(a1 + 96) - v62;
                        else
                            v46 = v62 - *(_DWORD*)(a1 + 96);
                        v63 = v46;
                        if (v61 - *(_DWORD*)(a1 + 100) <= 0)
                            v45 = *(_DWORD*)(a1 + 100) - v61;
                        else
                            v45 = v61 - *(_DWORD*)(a1 + 100);
                        v64 = v45;
                        if (v46 >= 10)
                            v63 = 10;
                        if (v45 >= 10)
                            v64 = 10;
                        if (v62 - *(_DWORD*)(a1 + 96) <= 0)
                            v44 = (v62 - *(_DWORD*)(a1 + 96) >= 0) - 1;
                        else
                            v44 = 1;
                        *(_DWORD*)(a1 + 120) = v63 * v44;
                        if (v61 - *(_DWORD*)(a1 + 100) <= 0)
                            v43 = (v61 - *(_DWORD*)(a1 + 100) >= 0) - 1;
                        else
                            v43 = 1;
                        *(_DWORD*)(a1 + 124) = v64 * v43;
                    }
                    break;
                case 0xC4:
                    if (!*(_DWORD*)(a1 + 160))
                    {
                        *(_DWORD*)(a1 + 88) = *(_DWORD*)(a1 + 120) / 5;
                        *(int*)(a1 + 120) /= 2;
                        *(_DWORD*)(a1 + 144) = *(_DWORD*)(a1 + 88);
                        if (*(int*)(a1 + 88) <= 0)
                            v42 = -*(_DWORD*)(a1 + 88);
                        else
                            v42 = *(_DWORD*)(a1 + 88);
                        *(_DWORD*)(a1 + 124) += 8 * v42;
                        *(_DWORD*)(a1 + 160) = 8;
                    }
                    if (*(_DWORD*)(a1 + 160) % 32)
                    {
                        switch (*(_DWORD*)(a1 + 160) % 32)
                        {
                        case 8:
                            if (*(int*)(a1 + 88) <= 0)
                                v41 = -*(_DWORD*)(a1 + 88);
                            else
                                v41 = *(_DWORD*)(a1 + 88);
                            *(_DWORD*)(a1 + 148) = -v41;
                            break;
                        case 16:
                            *(_DWORD*)(a1 + 144) = -*(_DWORD*)(a1 + 88);
                            break;
                        case 24:
                            if (*(int*)(a1 + 88) <= 0)
                                v40 = -*(_DWORD*)(a1 + 88);
                            else
                                v40 = *(_DWORD*)(a1 + 88);
                            *(_DWORD*)(a1 + 148) = v40;
                            break;
                        }
                    }
                    else
                    {
                        *(_DWORD*)(a1 + 144) = *(_DWORD*)(a1 + 88);
                    }
                    ++* (_DWORD*)(a1 + 160);
                    break;
                case 0xC5:
                    ++ * (_DWORD*)(a1 + 160);
                    if (*(_DWORD*)(a1 + 56))
                    {
                        *(_DWORD*)(a1 + 120) = 30 * (char)sub_485120(*(char**)(a1 + 56)) + *(_DWORD*)(a1 + 88);
                        *(_DWORD*)(a1 + 124) = 30 * (char)sub_485140(*(char**)(a1 + 56)) + *(_DWORD*)(a1 + 92);
                    }
                    break;
                case 0xC6:
                    if (!*(_DWORD*)(a1 + 160))
                    {
                        *(_DWORD*)(a1 + 160) = 4 * (rand() % 6) + 4;
                        *(_DWORD*)(a1 + 120) = 50 * (rand() % 11) - 400;
                        if (*(_DWORD*)(a1 + 164))
                            *(_DWORD*)(a1 + 120) = -*(_DWORD*)(a1 + 120);
                        *(_DWORD*)(a1 + 124) = 25 * (rand() % 11) - 125;
                        *(_DWORD*)(a1 + 128) = 25 * (rand() % 11) - 100;
                        *(_DWORD*)(a1 + 152) = 0;
                        *(_DWORD*)(a1 + 148) = 0;
                        *(_DWORD*)(a1 + 144) = 0;
                        if (!(rand() % 5))
                            *(_DWORD*)(a1 + 144) = 10 * (rand() % 11) - 80;
                        if (!(rand() % 5))
                            *(_DWORD*)(a1 + 148) = rand() % 11 - 5;
                        if (!(rand() % 5))
                            *(_DWORD*)(a1 + 152) = 5 * (rand() % 11) - 20;
                    }
                    --* (_DWORD*)(a1 + 160);
                    break;
                }
                if (*(_BYTE*)(a1 + 72))
                {
                    switch (*(_BYTE*)(a1 + 72))
                    {
                    case 1:
                        LOWORD(v4) = a1;
                        *(_WORD*)(a1 + 20) = 16;
                        break;
                    case 2:
                    case 0xD:
                        if (*(_BYTE*)(a1 + 72) == 2)
                            *(_WORD*)(a1 + 20) = 20;
                        else
                            *(_WORD*)(a1 + 20) = 184;
                        if (!*(_DWORD*)(a1 + 76))
                            *(_DWORD*)(a1 + 156) = 1;
                        if (*(_DWORD*)(a1 + 76) == 1 && *(int*)(a1 + 156) > 160 && !v74)
                        {
                            *(_DWORD*)(a1 + 120) = 95 * *(_DWORD*)(a1 + 120) / 100;
                            *(_DWORD*)(a1 + 124) = 95 * *(_DWORD*)(a1 + 124) / 100;
                        }
                        if (*(_DWORD*)(a1 + 76) == 1
                            && !*(_DWORD*)(a1 + 120)
                            && !*(_DWORD*)(a1 + 124)
                            && !*(_DWORD*)(a1 + 172)
                            && !v74)
                        {
                            *(_DWORD*)(a1 + 76) = 2;
                        }
                        LOWORD(v4) = a1;
                        if (*(_DWORD*)(a1 + 76) == 2)
                        {
                            *(_DWORD*)(a1 + 76) = 3;
                            *(_BYTE*)(a1 + 180) = 0;
                            *(_DWORD*)(a1 + 172) = 1;
                            *(_DWORD*)(a1 + 168) = 0;
                            *(_DWORD*)(a1 + 120) = 0;
                            LOWORD(v4) = a1;
                            *(_DWORD*)(a1 + 128) = -300;
                            *(_DWORD*)(a1 + 152) = 30;
                        }
                        break;
                    case 3:
                        if (*(int*)(a1 + 76) <= 2 || *(int*)(a1 + 76) > 4)
                        {
                            *(_DWORD*)(a1 + 164) = *(_DWORD*)(a1 + 120) > 0;
                            if (*(int*)(a1 + 120) <= 0)
                                v39 = -*(_DWORD*)(a1 + 120);
                            else
                                v39 = *(_DWORD*)(a1 + 120);
                            int _EDX = a1;
                            //__asm
                            //{
                            //    fild    dword ptr[edx + 50h]
                            //    fild[ebp + var_B4]
                            //    fmul    ds : dbl_4AC260
                            //    faddp   st(1), st
                            //}
                            *(_DWORD*)(a1 + 80) = _ftol(v8);
                            if (*(int*)(a1 + 80) >= 4000)
                                *(_DWORD*)(a1 + 80) = 0;
                            *(_WORD*)(a1 + 20) = *(_DWORD*)(a1 + 80) / 1000 + 27;
                        }
                        if (*(_DWORD*)(a1 + 76) == 1 && *(int*)(a1 + 156) > 160 && !v74)
                        {
                            *(_DWORD*)(a1 + 120) = 95 * *(_DWORD*)(a1 + 120) / 100;
                            *(_DWORD*)(a1 + 124) = 95 * *(_DWORD*)(a1 + 124) / 100;
                        }
                        if (*(_DWORD*)(a1 + 76) == 1
                            && !*(_DWORD*)(a1 + 120)
                            && !*(_DWORD*)(a1 + 124)
                            && !*(_DWORD*)(a1 + 172)
                            && !v74)
                        {
                            *(_BYTE*)(a1 + 68) = 0;
                            *(_BYTE*)(a1 + 71) = 0;
                            *(_DWORD*)(a1 + 76) = 2;
                            *(_DWORD*)(a1 + 156) = 160;
                        }
                        if (*(_DWORD*)(a1 + 76) != 2)
                            goto LABEL_223;
                        *(_DWORD*)(a1 + 120) = 0;
                        *(_DWORD*)(a1 + 124) = 0;
                        v60 = 6;
                        if (*(int*)(a1 + 156) < 200)
                        {
                            if (*(int*)(a1 + 156) >= 184)
                                v60 = 4;
                        }
                        else
                        {
                            v60 = 3;
                        }
                        v17 = *(_DWORD*)(a1 + 156) / v60 % 4;
                        *(_WORD*)(a1 + 20) = v17 >= 3 ? 32 : v17 + 31;
                        if (*(int*)(a1 + 156) > 212)
                        {
                            *(_DWORD*)(a1 + 120) = 0;
                            *(_DWORD*)(a1 + 124) = 0;
                            LOWORD(v4) = a1;
                            *(_DWORD*)(a1 + 128) = 0;
                            *(_DWORD*)(a1 + 152) = 0;
                            *(_DWORD*)(a1 + 16) = 0;
                        }
                        else
                        {
                        LABEL_223:
                            LOWORD(v4) = a1;
                            if (*(_DWORD*)(a1 + 76) == 3)
                            {
                                *(_DWORD*)(a1 + 76) = 4;
                                *(_BYTE*)(a1 + 180) = 0;
                                *(_DWORD*)(a1 + 172) = 1;
                                *(_DWORD*)(a1 + 168) = 0;
                                *(_DWORD*)(a1 + 120) = 0;
                                LOWORD(v4) = a1;
                                *(_DWORD*)(a1 + 124) = 0;
                                *(_DWORD*)(a1 + 128) = -300;
                                *(_DWORD*)(a1 + 152) = 30;
                            }
                        }
                        break;
                    case 4:
                        LOWORD(v4) = *(_DWORD*)(a1 + 156) / 2 % 8 + 40;
                        *(_WORD*)(a1 + 20) = v4;
                        if (*(_DWORD*)(a1 + 156) == 40)
                        {
                            LOWORD(v4) = a1;
                            if (*(_DWORD*)(a1 + 8) == 143)
                                *(_DWORD*)(a1 + 152) = 30;
                        }
                        break;
                    case 5:
                        LOWORD(v4) = a1;
                        *(_WORD*)(a1 + 20) = *(_DWORD*)(a1 + 156) / 4 % 3 + 54;
                        break;
                    case 6:
                        *(_WORD*)(a1 + 20) = ((*(_DWORD*)(a1 + 156) - 1) / 4 % 8 + 1) / 2 % 2 + 63;
                        v4 = (*(_DWORD*)(a1 + 156) - 1) % 8;
                        if (!v4)
                        {
                            LOWORD(v4) = a1;
                            *(_DWORD*)(a1 + 164) = *(_DWORD*)(a1 + 164) == 0;
                        }
                        break;
                    case 7:
                        LOWORD(v4) = a1;
                        *(_WORD*)(a1 + 20) = 68;
                        break;
                    case 8:
                        LOWORD(v4) = a1;
                        *(_WORD*)(a1 + 20) = *(_DWORD*)(a1 + 156) / 8 % 6 + 74;
                        if (!*(_DWORD*)(a1 + 172))
                        {
                            *(_DWORD*)(a1 + 120) = 95 * *(_DWORD*)(a1 + 120) / 100;
                            *(_DWORD*)(a1 + 124) = 95 * *(_DWORD*)(a1 + 124) / 100;
                            LOWORD(v4) = a1;
                            if (*(int*)(a1 + 120) <= 0)
                            {
                                LOWORD(v4) = a1;
                                v38 = -*(_DWORD*)(a1 + 120);
                            }
                            else
                            {
                                v38 = *(_DWORD*)(a1 + 120);
                            }
                            if (v38 <= 50)
                            {
                                if (*(int*)(a1 + 124) <= 0)
                                {
                                    v4 = -*(_DWORD*)(a1 + 124);
                                    v37 = v4;
                                }
                                else
                                {
                                    LOWORD(v4) = a1;
                                    v37 = *(_DWORD*)(a1 + 124);
                                }
                                if (v37 <= 50)
                                {
                                    *(_DWORD*)(a1 + 120) = 0;
                                    *(_DWORD*)(a1 + 124) = 0;
                                    LOWORD(v4) = a1;
                                    *(_DWORD*)(a1 + 16) = 0;
                                }
                            }
                        }
                        break;
                    case 9:
                        *(_WORD*)(a1 + 20) = 92;
                        *(_BYTE*)(a1 + 22) = *(_DWORD*)(a1 + 156) / 10 % 4;
                        LOWORD(v4) = a1;
                        if (!*(_DWORD*)(a1 + 172))
                        {
                            *(_DWORD*)(a1 + 120) = 95 * *(_DWORD*)(a1 + 120) / 100;
                            *(_DWORD*)(a1 + 124) = 95 * *(_DWORD*)(a1 + 124) / 100;
                            LOWORD(v4) = a1;
                            if (*(int*)(a1 + 120) <= 0)
                            {
                                LOWORD(v4) = a1;
                                v36 = -*(_DWORD*)(a1 + 120);
                            }
                            else
                            {
                                v36 = *(_DWORD*)(a1 + 120);
                            }
                            if (v36 <= 50)
                            {
                                if (*(int*)(a1 + 124) <= 0)
                                {
                                    v4 = -*(_DWORD*)(a1 + 124);
                                    v35 = v4;
                                }
                                else
                                {
                                    LOWORD(v4) = a1;
                                    v35 = *(_DWORD*)(a1 + 124);
                                }
                                if (v35 <= 50)
                                {
                                    *(_DWORD*)(a1 + 120) = 0;
                                    *(_DWORD*)(a1 + 124) = 0;
                                    LOWORD(v4) = a1;
                                    *(_DWORD*)(a1 + 16) = 0;
                                }
                            }
                        }
                        break;
                    case 0xA:
                        *(_WORD*)(a1 + 20) = 107;
                        *(_BYTE*)(a1 + 22) = *(_DWORD*)(a1 + 156) / 4 % 4;
                        LOWORD(v4) = a1;
                        if (!*(_DWORD*)(a1 + 172))
                        {
                            *(_DWORD*)(a1 + 120) = 90 * *(_DWORD*)(a1 + 120) / 100;
                            *(_DWORD*)(a1 + 124) = 90 * *(_DWORD*)(a1 + 124) / 100;
                            LOWORD(v4) = a1;
                            if (*(int*)(a1 + 120) <= 0)
                            {
                                LOWORD(v4) = a1;
                                v34 = -*(_DWORD*)(a1 + 120);
                            }
                            else
                            {
                                v34 = *(_DWORD*)(a1 + 120);
                            }
                            if (v34 <= 50)
                            {
                                if (*(int*)(a1 + 124) <= 0)
                                {
                                    v4 = -*(_DWORD*)(a1 + 124);
                                    v33 = v4;
                                }
                                else
                                {
                                    LOWORD(v4) = a1;
                                    v33 = *(_DWORD*)(a1 + 124);
                                }
                                if (v33 <= 50)
                                {
                                    *(_DWORD*)(a1 + 120) = 0;
                                    *(_DWORD*)(a1 + 124) = 0;
                                    LOWORD(v4) = a1;
                                    *(_DWORD*)(a1 + 16) = 0;
                                }
                            }
                        }
                        break;
                    case 0xB:
                        LOWORD(v4) = 6 * (*(_DWORD*)(a1 + 156) / 4 % 4) + 129;
                        *(_WORD*)(a1 + 20) = v4;
                        break;
                    default:
                        v4 = *(unsigned __int8*)(a1 + 72);
                        if (v4 == 12)
                        {
                            if (*(_DWORD*)(a1 + 172))
                                *(_DWORD*)(a1 + 76) = 0;
                            *(_DWORD*)(a1 + 164) = *(_DWORD*)(a1 + 120) > 0;
                            LOWORD(v4) = a1;
                            if (!*(_DWORD*)(a1 + 76))
                            {
                                if (*(_DWORD*)(a1 + 8) == 173)
                                {
                                    *(_WORD*)(a1 + 20) = 174;
                                }
                                else
                                {
                                    LOWORD(v4) = a1;
                                    if (*(_DWORD*)(a1 + 8) == 184)
                                    {
                                        if (*(int*)(a1 + 156) >= 2)
                                        {
                                            LOWORD(v4) = a1;
                                            if (*(int*)(a1 + 156) >= 4)
                                                *(_WORD*)(a1 + 20) = 175;
                                            else
                                                *(_WORD*)(a1 + 20) = 177;
                                        }
                                        else
                                        {
                                            *(_WORD*)(a1 + 20) = 176;
                                        }
                                    }
                                    else if (*(_DWORD*)(a1 + 8) == 185)
                                    {
                                        LOWORD(v4) = *(_DWORD*)(a1 + 156) / 5 % 2 + 178;
                                        *(_WORD*)(a1 + 20) = v4;
                                    }
                                    else
                                    {
                                        LOWORD(v4) = a1;
                                        switch (*(_DWORD*)(a1 + 8))
                                        {
                                        case 0xBA:
                                            *(_WORD*)(a1 + 20) = 178;
                                            break;
                                        case 0xC1:
                                            LOWORD(v4) = a1;
                                            v18 = *(_DWORD*)(a1 + 160) % 16;
                                            if (v18 >= 2)
                                            {
                                                if (v18 >= 4)
                                                {
                                                    if (v18 >= 14)
                                                    {
                                                        *(_WORD*)(a1 + 20) = 185;
                                                    }
                                                    else
                                                    {
                                                        LOWORD(v4) = a1;
                                                        *(_WORD*)(a1 + 20) = 175;
                                                    }
                                                }
                                                else
                                                {
                                                    *(_WORD*)(a1 + 20) = 185;
                                                }
                                            }
                                            else
                                            {
                                                LOWORD(v4) = *(_DWORD*)(a1 + 156) / 4 % 8 + 165;
                                                *(_WORD*)(a1 + 20) = v4;
                                            }
                                            break;
                                        case 0xC5:
                                            v19 = *(_DWORD*)(a1 + 156);
                                            v4 = v19 / 4 / 3;
                                            v59 = v19 / 4 % 3;
                                            if (v59)
                                            {
                                                if (v59 == 1)
                                                {
                                                    LOWORD(v4) = a1;
                                                    *(_WORD*)(a1 + 20) = 165;
                                                }
                                                else if (v59 == 2)
                                                {
                                                    *(_WORD*)(a1 + 20) = 177;
                                                }
                                            }
                                            else
                                            {
                                                *(_WORD*)(a1 + 20) = 175;
                                            }
                                            break;
                                        case 0xC6:
                                            v4 = *(_DWORD*)(a1 + 156) / 3;
                                            if (*(_DWORD*)(a1 + 156) % 3 == 2)
                                            {
                                                v20 = rand();
                                                v21 = v20 % 6;
                                                v4 = v20 / 6;
                                                v58 = v21;
                                                if (v21)
                                                {
                                                    switch (v58)
                                                    {
                                                    case 1:
                                                        *(_WORD*)(a1 + 20) = 174;
                                                        break;
                                                    case 2:
                                                        LOWORD(v4) = a1;
                                                        *(_WORD*)(a1 + 20) = 175;
                                                        break;
                                                    case 3:
                                                        LOWORD(v4) = *(_DWORD*)(a1 + 156) / 4 % 2 + 176;
                                                        *(_WORD*)(a1 + 20) = v4;
                                                        break;
                                                    case 4:
                                                        LOWORD(v4) = *(_DWORD*)(a1 + 156) / 4 % 2 + 178;
                                                        *(_WORD*)(a1 + 20) = v4;
                                                        break;
                                                    case 5:
                                                        *(_WORD*)(a1 + 20) = 185;
                                                        break;
                                                    }
                                                }
                                                else
                                                {
                                                    LOWORD(v4) = *(_DWORD*)(a1 + 156) / 4 % 8 + 165;
                                                    *(_WORD*)(a1 + 20) = v4;
                                                }
                                            }
                                            break;
                                        default:
                                            LOWORD(v4) = *(_DWORD*)(a1 + 156) / 4 % 8 + 165;
                                            *(_WORD*)(a1 + 20) = v4;
                                            break;
                                        }
                                    }
                                }
                            }
                            if (*(_DWORD*)(a1 + 76) == 1)
                            {
                                if (*(int*)(a1 + 120) <= 0)
                                    v32 = -*(_DWORD*)(a1 + 120);
                                else
                                    v32 = *(_DWORD*)(a1 + 120);
                                int _EDX = a1;
                                //__asm
                                //{
                                //    fild    dword ptr[edx + 50h]
                                //    fild[ebp + var_D0]
                                //    fmul    ds : dbl_4AC260
                                //    faddp   st(1), st
                                //}
                                *(_DWORD*)(a1 + 80) = _ftol(v8);
                                if (*(int*)(a1 + 80) >= 4000)
                                    *(_DWORD*)(a1 + 80) = 0;
                                *(_WORD*)(a1 + 20) = *(_DWORD*)(a1 + 80) / 500 + 165;
                                LOWORD(v4) = v74;
                                if (!v74)
                                {
                                    *(_DWORD*)(a1 + 120) = 98 * *(_DWORD*)(a1 + 120) / 100;
                                    *(_DWORD*)(a1 + 124) = 98 * *(_DWORD*)(a1 + 124) / 100;
                                    LOWORD(v4) = a1;
                                    if (!*(_DWORD*)(a1 + 120) && !*(_DWORD*)(a1 + 124) && !*(_DWORD*)(a1 + 172))
                                    {
                                        LOWORD(v4) = a1;
                                        *(_DWORD*)(a1 + 16) = 0;
                                    }
                                }
                            }
                        }
                        break;
                    }
                }
                else
                {
                    *(_WORD*)(a1 + 20) = ((*(_DWORD*)(a1 + 156) - 1) / 4 % 8 + 1) / 2 % 2 + 14;
                    v4 = (*(_DWORD*)(a1 + 156) - 1) % 8;
                    if (!v4)
                    {
                        LOWORD(v4) = a1;
                        *(_DWORD*)(a1 + 164) = *(_DWORD*)(a1 + 164) == 0;
                    }
                }
                break;
            case 4:
                ++ * (_DWORD*)(a1 + 156);
                v56 = sub_426090(*(_DWORD**)(a1 + 60)) - *(_DWORD*)(a1 + 96);
                v57 = sub_4260B0(*(_DWORD**)(a1 + 60)) - *(_DWORD*)(a1 + 100);
                if (*(int*)(a1 + 104) <= -20000)
                {
                    *(_DWORD*)(a1 + 120) = v56 / 4;
                    *(_DWORD*)(a1 + 124) = v57 / 4;
                    *(_DWORD*)(a1 + 96) += *(_DWORD*)(a1 + 120);
                    *(_DWORD*)(a1 + 100) += *(_DWORD*)(a1 + 124);
                }
                *(_DWORD*)(a1 + 104) += *(_DWORD*)(a1 + 128);
                if (*(int*)(a1 + 104) < -20000)
                {
                    *(_DWORD*)(a1 + 128) = 0;
                    *(_DWORD*)(a1 + 104) = -20000;
                }
                LOWORD(v4) = a1;
                if (*(_DWORD*)(a1 + 156) >= *(_DWORD*)(a1 + 76))
                {
                    *(_DWORD*)(a1 + 16) = 2;
                    *(_DWORD*)(a1 + 128) = 1500;
                    *(_DWORD*)(a1 + 152) = 30;
                    LOWORD(v4) = a1;
                    *(_DWORD*)(a1 + 76) = 0;
                    *(_DWORD*)(a1 + 156) = 0;
                }
                break;
            case 5:
                if (!*(_DWORD*)(a1 + 156))
                    *(_DWORD*)(a1 + 76) = rand() % 10 + 25;
                *(_DWORD*)(a1 + 128) += *(_DWORD*)(a1 + 152);
                *(_DWORD*)(a1 + 104) += *(_DWORD*)(a1 + 128);
                *(_DWORD*)(a1 + 172) = 1;
                ++* (_DWORD*)(a1 + 156);
                *(_WORD*)(a1 + 20) = dword_4B719C[11 * *(unsigned __int8*)(a1 + 72)];
                if (*(_DWORD*)(a1 + 56)
                    && (Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)94
                        || Concurrency::details::SchedulerBase::GetSchedulerProxy(*(Concurrency::details::SchedulerBase**)(a1 + 56)) == (struct Concurrency::ISchedulerProxy*)176))
                {
                    v4 = *(_DWORD*)(a1 + 156);
                    if (v4 >= *(_DWORD*)(a1 + 76))
                    {
                        LOWORD(v4) = a1;
                        if (*(_DWORD*)(a1 + 156) == *(_DWORD*)(a1 + 76))
                        {
                            *(_DWORD*)(a1 + 128) = -70;
                        }
                        else
                        {
                            *(_DWORD*)(a1 + 152) = 5;
                            v4 = (*(_DWORD*)(a1 + 156) - *(_DWORD*)(a1 + 76)) / 30 % 2;
                            if (v4)
                                *(_DWORD*)(a1 + 152) = -5;
                        }
                    }
                    else
                    {
                        *(_DWORD*)(a1 + 128) = -150;
                    }
                }
                else
                {
                    LOWORD(v4) = sub_494D01(a1, a1, 2u, *(char**)(a1 + 56), 0);
                }
                break;
            default:
                LOWORD(v4) = a1;
                switch (*(_DWORD*)(a1 + 12))
                {
                case 6:
                    *(_DWORD*)(a1 + 176) = (*(_DWORD*)(a1 + 156))++ / 5 % 2;
                    v23 = rand() % 60 + 100;
                    LOWORD(v4) = a1;
                    if (*(_DWORD*)(a1 + 156) >= v23)
                    {
                        *(_DWORD*)(a1 + 56) = 0;
                        sub_4995EB((_WORD*)a1);
                        *(_BYTE*)(a1 + 72) = sub_477148();
                        *(_DWORD*)(a1 + 152) = 30;
                        *(_BYTE*)(a1 + 180) = 0;
                        *(_DWORD*)(a1 + 176) = 0;
                        *(_DWORD*)(a1 + 172) = 1;
                        *(_DWORD*)(a1 + 156) = 0;
                        *(_DWORD*)(a1 + 76) = 255;
                        *(_DWORD*)(a1 + 84) = -1;
                        *(_BYTE*)(a1 + 22) = 0;
                        *(_DWORD*)(a1 + 16) = 2;
                        *(_DWORD*)(a1 + 116) = 0;
                        *(_DWORD*)(a1 + 112) = 0;
                        *(_DWORD*)(a1 + 108) = 0;
                        *(_DWORD*)(a1 + 140) = 1;
                        *(_DWORD*)(a1 + 136) = 1;
                        *(_DWORD*)(a1 + 132) = 1;
                        *(_DWORD*)(a1 + 120) = 0;
                        *(_DWORD*)(a1 + 144) = 0;
                        *(_DWORD*)(a1 + 124) = 0;
                        *(_DWORD*)(a1 + 148) = 0;
                        *(_DWORD*)(a1 + 128) = 0;
                        if (*(_BYTE*)(a1 + 72))
                        {
                            --* (_BYTE*)(a1 + 72);
                            sub_4654DA((char*)unk_4B9B10, (_DWORD*)(a1 + 96), (_DWORD*)(a1 + 100));
                            *(_DWORD*)(a1 + 104) = -24000;
                            LOWORD(v4) = sub_4950AF(a1);
                        }
                        else
                        {
                            *(_DWORD*)(a1 + 96) = -32000;
                            *(_DWORD*)(a1 + 100) = -24000;
                            LOWORD(v4) = a1;
                            *(_DWORD*)(a1 + 104) = 0;
                            *(_DWORD*)(a1 + 16) = 0;
                        }
                    }
                    break;
                case 7:
                    sub_495368(a1, a2, a4);
                    if (++ * (_DWORD*)(a1 + 156) == 12)
                        *(_BYTE*)(a1 + *(_DWORD*)(a1 + 76) + 181) = 0;
                    *(_DWORD*)(a1 + 168) = 1;
                    if (*(_BYTE*)(a1 + 72) != 10 || *(_DWORD*)(a1 + 172))
                    {
                        if (*(int*)(a1 + 156) > 8 && !*(_DWORD*)(a1 + 172))
                        {
                            *(_DWORD*)(a1 + 120) = *(_BYTE*)(a1 + 72) == 13 ? 95 * *(_DWORD*)(a1 + 120) / 100 : 90 * *(_DWORD*)(a1 + 120) / 100;
                            if (*(_BYTE*)(a1 + 72) != 13
                                && (*(int*)(a1 + 120) <= 0 ? (v30 = -*(_DWORD*)(a1 + 120)) : (v30 = *(_DWORD*)(a1 + 120)),
                                    v30 < 50)
                                || *(_BYTE*)(a1 + 72) == 13
                                && (*(int*)(a1 + 120) <= 0 ? (v29 = -*(_DWORD*)(a1 + 120)) : (v29 = *(_DWORD*)(a1 + 120)),
                                    v29 < 10))
                            {
                                *(_DWORD*)(a1 + 120) = 0;
                                *(_DWORD*)(a1 + 16) = 0;
                            }
                        }
                    }
                    else
                    {
                        *(_DWORD*)(a1 + 120) = 85 * *(_DWORD*)(a1 + 120) / 100;
                        if (*(int*)(a1 + 120) <= 0)
                            v31 = -*(_DWORD*)(a1 + 120);
                        else
                            v31 = *(_DWORD*)(a1 + 120);
                        if (v31 < 50)
                        {
                            *(_DWORD*)(a1 + 120) = 0;
                            *(_DWORD*)(a1 + 16) = 0;
                        }
                    }
                    if (*(_DWORD*)(a1 + 172))
                        *(_DWORD*)(a1 + 152) = 30;
                    LOWORD(v4) = a1;
                    if (*(_BYTE*)(a1 + 72) == 8)
                    {
                        *(_WORD*)(a1 + 20) = 73;
                    }
                    else
                    {
                        LOWORD(v4) = a1;
                        if (*(_BYTE*)(a1 + 72) == 9)
                        {
                            *(_WORD*)(a1 + 20) = 88;
                        }
                        else
                        {
                            LOWORD(v4) = a1;
                            if (*(_BYTE*)(a1 + 72) == 10)
                            {
                                *(_WORD*)(a1 + 20) = 103;
                                LOWORD(v4) = a1;
                                if (!(*(_DWORD*)(a1 + 156) % 4))
                                {
                                    v4 = (*(char*)(a1 + 22) + 1) % 4;
                                    *(_BYTE*)(a1 + 22) = v4;
                                }
                            }
                        }
                    }
                    break;
                case 8:
                    if (*(int*)(a1 + 156) >= 12)
                    {
                        *(_WORD*)(a1 + 20) = 0;
                        *(_DWORD*)(a1 + 176) = 1;
                        *(_DWORD*)(a1 + 168) = 0;
                        *(_DWORD*)(a1 + 96) = -32000;
                        *(_DWORD*)(a1 + 100) = -24000;
                        *(_DWORD*)(a1 + 116) = 0;
                        *(_DWORD*)(a1 + 112) = 0;
                        *(_DWORD*)(a1 + 108) = 0;
                        LOWORD(v4) = a1;
                        *(_DWORD*)(a1 + 16) = 0;
                    }
                    else
                    {
                        if (!*(_DWORD*)(a1 + 156))
                        {
                            *(_DWORD*)(a1 + 56) = 0;
                            if (*(int*)(a1 + 80) < 300)
                                *(_DWORD*)(a1 + 80) = 300;
                            *(_WORD*)(a1 + 192) = (*(_DWORD*)(a1 + 80) - 300) / 10 + *(unsigned __int16*)(a1 + 190) / 8;
                            *(_BYTE*)(a1 + 195) = 16;
                            if (*(_BYTE*)(a1 + 72) == 13)
                                *(_BYTE*)(a1 + 195) += 8;
                            *(_BYTE*)(a1 + 194) = 3;
                            *(_DWORD*)(a1 + 168) = 1;
                            memset((void*)(a1 + 181), 0, 8u);
                            if (*(_BYTE*)(a1 + 72) == 11)
                            {
                                sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9AC4, -1, 100, 100, 0);
                            }
                            else if (*(_BYTE*)(a1 + 72) == 13)
                            {
                                sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9A34, -1, 100, 100, 0);
                            }
                        }
                        *(_DWORD*)(a1 + 84) = -1;
                        if (*(int*)(a1 + 156) >= 8)
                        {
                            if (*(int*)(a1 + 156) >= 10)
                                *(_WORD*)(a1 + 20) = 154;
                            else
                                *(_WORD*)(a1 + 20) = 155;
                        }
                        else
                        {
                            *(_WORD*)(a1 + 20) = *(_DWORD*)(a1 + 156) / 2 % 4 + 153;
                        }
                        if (*(_BYTE*)(a1 + 72) == 13)
                        {
                            for (j = 0; j < 2; ++j)
                            {
                                *(_WORD*)(a1 + 16 * j + 24) = *(_DWORD*)(a1 + 156) % 4 + 153;
                                *(_DWORD*)(a1 + 16 * j + 32) = 0;
                                if (*(int*)(a1 + 156) >= 4)
                                {
                                    if (*(int*)(a1 + 156) >= 8)
                                        *(_DWORD*)(a1 + 16 * j + 28) = 24 - 48 * j;
                                    else
                                        *(_DWORD*)(a1 + 16 * j + 28) = 48 * j - 24;
                                    *(_DWORD*)(a1 + 16 * j + 36) = 48 * j - 24;
                                }
                                else
                                {
                                    *(_DWORD*)(a1 + 16 * j + 28) = (j << 6) - 32;
                                    *(_DWORD*)(a1 + 16 * j + 36) = 0;
                                }
                            }
                        }
                        LOWORD(v4) = a1;
                        ++* (_DWORD*)(a1 + 156);
                    }
                    break;
                }
                break;
            }
        }
        else
        {
            *(_DWORD*)(a1 + 128) = 0;
            *(_DWORD*)(a1 + 124) = 0;
            *(_DWORD*)(a1 + 120) = 0;
            *(_DWORD*)(a1 + 152) = 0;
            *(_DWORD*)(a1 + 148) = 0;
            *(_DWORD*)(a1 + 144) = 0;
            *(_DWORD*)(a1 + 168) = 0;
            *(_BYTE*)(a1 + 68) = 0;
            *(_BYTE*)(a1 + 71) = 0;
            LOWORD(v4) = dword_4B719C[11 * *(unsigned __int8*)(a1 + 72)];
            *(_WORD*)(a1 + 20) = v4;
            *(_DWORD*)(a1 + 172) = 0;
            if (*(int*)(a1 + 96) < 0 || (LOWORD(v4) = a1, *(int*)(a1 + 100) < 0))
            {
                ++byte_4B997C;
            }
            else
            {
                v76 = -100 * sub_446497((_DWORD*)unk_4B9B10, *(_DWORD*)(a1 + 96) / 100, *(_DWORD*)(a1 + 100) / 100);
                LOWORD(v4) = v76;
                if (v76 <= *(_DWORD*)(a1 + 104))
                {
                    v4 = sub_4773CC(*(_DWORD*)(a1 + 96) / 800, *(_DWORD*)(a1 + 100) / 800);
                    if (!v4 || (LOWORD(v4) = v76, v76 < *(_DWORD*)(a1 + 104)))
                        ++byte_4B997C;
                }
                else
                {
                    *(_DWORD*)(a1 + 16) = 3;
                    *(_DWORD*)(a1 + 152) = 30;
                }
            }
        }
    }
    else
    {
        if (*(_DWORD*)(a1 + 12) == 1 && *(_DWORD*)(a1 + 56))
            LOWORD(v4) = sub_41F6DE(*(_DWORD**)(a1 + 56));
        *(_DWORD*)(a1 + 16) = 8;
    }
    return v4;
}


 
__int16 __fastcall sub_498F3D(int a1)
{
    int v1; // eax
    int v2; // esi
    int v3; // esi
    int v4; // esi
    _BYTE* v7; // [esp+8h] [ebp-4h]

    LOWORD(v1) = a1;
    if (*(_DWORD*)(a1 + 56))
    {
        *(_BYTE*)(a1 + 22) = 0;
        v7 = (_BYTE*)sub_41C915(*(_DWORD*)(a1 + 56));
        *(_DWORD*)(a1 + 164) = sub_425D70(*(_DWORD**)(a1 + 56));
        v2 = sub_426090(*(_DWORD**)(a1 + 56));
        *(_DWORD*)(a1 + 96) = 100 * sub_4758D0(v7, *(_DWORD*)(a1 + 164)) + v2;
        *(_DWORD*)(a1 + 100) = sub_4260B0(*(_DWORD**)(a1 + 56));
        v3 = sub_4260D0(*(_DWORD**)(a1 + 56));
        *(_DWORD*)(a1 + 104) = 100 * sub_4758F0(v7, 0) + v3;
        sub_499622(a1);
        v1 = (unsigned __int8)sub_425B70(v7);
        if (v1)
        {
            v4 = 44 * *(unsigned __int8*)(a1 + 72);
            LOWORD(v1) = *(_WORD*)&dword_4B7180[4 * (unsigned __int8)sub_425B70(v7) + v4];
            *(_WORD*)(a1 + 20) = v1;
        }
    }
    return v1;
}
 
int* sub_49951D(int* thisx)
{
    int* result; // eax

    thisx[30] /= thisx[33];
    thisx[31] /= thisx[34];
    thisx[32] /= thisx[35];
    thisx[36] /= thisx[33];
    thisx[37] /= thisx[34];
    thisx[38] /= thisx[35];
    result = thisx;
    thisx[35] = 1;
    thisx[34] = 1;
    thisx[33] = 1;
    return result;
}


 
int sub_4995EB(_WORD* thisx)
{
    int result; // eax
    int i; // [esp+4h] [ebp-4h]

    for (i = 0; i < 2; ++i)
    {
        thisx[8 * i + 12] = -2;
        result = i + 1;
    }
    return result;
}

 
void __fastcall sub_499622(int a1)
{
    int v1; // eax
    int v3[2]; // [esp+8h] [ebp-34h] BYREF
    char v4; // [esp+10h] [ebp-2Ch]
    int v5; // [esp+14h] [ebp-28h]
    int v6; // [esp+18h] [ebp-24h]
    int v7[2]; // [esp+1Ch] [ebp-20h] BYREF
    _DWORD* v8; // [esp+24h] [ebp-18h]
    int v9; // [esp+28h] [ebp-14h]
    int v10; // [esp+2Ch] [ebp-10h]
    int v11; // [esp+30h] [ebp-Ch]
    int v12; // [esp+34h] [ebp-8h]
    _BYTE* v13; // [esp+38h] [ebp-4h]

    v11 = *(_DWORD*)(a1 + 64);
    *(_DWORD*)(a1 + 64) = -1000;
    if (*(_DWORD*)(a1 + 12) != 8)
    {
        v10 = *(_DWORD*)(a1 + 96);
        v9 = *(_DWORD*)(a1 + 100);
        if (*(_DWORD*)(a1 + 12) == 1 && *(_DWORD*)(a1 + 56))
        {
            v10 = sub_426090(*(_DWORD**)(a1 + 56));
            v9 = sub_4260B0(*(_DWORD**)(a1 + 56));
        }
        v13 = (_BYTE*)sub_4741F8((int)unk_4B9B10, v10 / 800, v9 / 800);
        v8 = (_DWORD*)sub_426210((char*)unk_4B9B10);
        v12 = -100 * sub_486633(v8, v10 / 100, v9 / 100);
        if (v13 && sub_425C50(v13))
            v12 = -400 * (unsigned __int8)unknown_libname_6(v13);
        if (v13)
        {
            if ((unsigned __int8)sub_425C30(v13))
            {
                *(_DWORD*)(a1 + 64) = (*(_DWORD*)(a1 + 104) - v12) / 100 + (unsigned __int8)sub_425C30(v13);
                if (*(_DWORD*)(a1 + 172))
                {
                    if (v11 <= 0 && *(int*)(a1 + 64) > 0 && unknown_libname_5(v13) == 11)
                    {
                        sub_43FFC3((_DWORD*)unk_4BDB28, dword_4B9AE4, -1, 100, 100, 0);
                        sub_442863(v3);
                        sub_4641FE((_DWORD*)unk_4B9B10, *(_DWORD*)(a1 + 96), *(_DWORD*)(a1 + 100), *(_DWORD*)(a1 + 104), (int)v7);
                        v1 = sub_446465((char*)unk_4B9B10);
                        v3[0] = v1 + v7[0];
                        v3[1] = v7[1];
                        v4 = 20;
                        v5 = 0;
                        v6 = 0;
                        sub_4561A5((char*)unk_4B9B10, (int)v3);
                    }
                }
            }
        }
    }
}

 
void* sub_499810(void* thisx, char a2)
{
    sub_490BC8(thisx);
    if ((a2 & 1) != 0)
        operator delete(thisx);
    return thisx;
}
 
int __cdecl messagebox(LPCSTR lpText)
{
    //return MessageBoxA(0, lpText, (LPCSTR)aError_40, 0);
    printf("%s\n", lpText);
    return 0;
}

 
void sub_499868(void* thisx)
{
    *(_DWORD*)thisx = 0;
    *((_BYTE*)thisx + 4) = 0;
    *((_DWORD*)thisx + 5) = -1;
    *((_BYTE*)thisx + 5) = 0;
    *((_DWORD*)thisx + 4) = 0;
    *((_DWORD*)thisx + 3) = 0;
}

 //Õâ¸öthisÖ»ÊÇ¸ö´óÊý×é unk_4BDC60
//a2 ÊÇ int v4[256]
int sub_4998E0(int thisx, int a2)
{
    int b;
    int v4[31]; // [esp+4h] [ebp-198h] BYREF
    int v5[4]; // [esp+80h] [ebp-11Ch] BYREF
    unsigned int v6; // [esp+90h] [ebp-10Ch]
    char j; // [esp+94h] [ebp-108h]
    int v8[31]; // [esp+98h] [ebp-104h] BYREF
    int i; // [esp+114h] [ebp-88h]
    int* v10; // [esp+118h] [ebp-84h]
    int v11[31]; // [esp+11Ch] [ebp-80h] BYREF
    int v12; // [esp+198h] [ebp-4h]

    *(_DWORD*)(thisx + 50500) = *(_DWORD*)a2;
    *(_WORD*)(thisx + 50448) = *(_WORD*)(a2 + 4);
    *(_WORD*)(thisx + 50450) = *(_WORD*)(a2 + 8);
    *(_WORD*)(thisx + 50446) = *(_WORD*)(a2 + 12);
    *(_BYTE*)(thisx + 50442) = *(_BYTE*)(a2 + 16);
    if (*(_BYTE*)(thisx + 50442))
    {
        *(_BYTE*)(thisx + 50443) = *(_BYTE*)(a2 + 20);
        *(_BYTE*)(thisx + 50444) = *(_BYTE*)(a2 + 21);
    }
    else
    {
        *(_BYTE*)(thisx + 50443) = 1;
        *(_BYTE*)(thisx + 50444) = 0;
    }
    SetRect((LPRECT)(thisx + 50452), 0, 0, *(__int16*)(thisx + 50448), *(__int16*)(thisx + 50450));
    SetRect(&rc, 0, 0, *(__int16*)(thisx + 50448), *(__int16*)(thisx + 50450));
    //µÚ¶þ¸ö²ÎÊýÊÇ(thisx + 50504)£ºÕâ¸ö²ÎÊýÊÇÓÃÀ´½ÓÊÜ³õÊ¼»¯³É¹¦µÄDirectDraw¶ÔÏóµÄµØÖ·
    b = DirectDrawCreate(0, (LPDIRECTDRAW*)(thisx + 50504), 0);//ÕâÀï¶Ôthisx + 50504¸³ÖµÁË
    if (b)
    {
        MessageBoxA(0, aDirectdrawObje, aDdrawerror, 0);
    LABEL_52:
        sub_49A184((_DWORD**)thisx);
        return 0;
    }

    // »ñÈ¡Ã¿Ò»¸öÄ£¿é¼ÓÔØ»ùÖ·
    DWORD pro_base = NULL;
    HMODULE hModule[100] = { 0 };
    DWORD dwRet = 0;
    int num = 0;

    int bRet = EnumProcessModulesEx(GetCurrentProcess(), (HMODULE*)(hModule), sizeof(hModule), (LPDWORD)&dwRet, NULL);
    if (bRet == 0) {
        printf("EnumProcessModules");
    }


    int f = *(int*)(thisx + 50504);//Ò»¼¶Ö¸Õë£¬DirectDraw¶ÔÏóµÄµØÖ·
    f = *(int*)f;//¶þ¼¶
    f = *(int*)f;//Èý¼¶

    int _3 = thisx + 50508;
    int _2 = (int)&unk_4ACA48;
    int _1 = *(int*)(thisx + 50504);
    /*
    __asm
    {
        push _3
        push _2
        push _1
        call f
        mov b,eax
    }
    */
    char d[] = {154, 80, 89, 156,    189, 57,   209, 17,     140, 74, 0, 192, 79, 217, 48, 197};
    IID* d2 = (IID*)d;
    LPDIRECTDRAW* ddp = (LPDIRECTDRAW*)(thisx + 50504);
    HRESULT hresult = (*ddp)->QueryInterface(*d2, (LPVOID*)(thisx + 50508));
    //b = (***(int(__stdcall****)(_DWORD, void*, int))    (thisx + 50504))      (*(_DWORD*)(thisx + 50504), &unk_4ACA48, thisx + 50508);
    if (hresult)
    {
        MessageBoxA(0, aQueryinterface, aDdrawerror_0, 0);
        goto LABEL_52;
    }
    if (*(_BYTE*)(thisx + 50442))
        v12 = 17;
    else
        v12 = 8;
    //´°¿ÚÈ«ÆÁ
    //b = (*(int(__stdcall**)(_DWORD, _DWORD, int))(**(_DWORD**)        (thisx + 50508) + 80))           (*(_DWORD*)(thisx + 50508), *(_DWORD*)(thisx + 50500), v12);
    //(**(_DWORD**)        (thisx + 50508) + 80)) È·ÊµÆ«ÒÆÁË21¸öº¯Êý£¬µ«ÊÇ¶ÔÏóµÄÎ»ÖÃ»¹ÊÇ21¸öº¯ÊýÖ®Ç°µÄÎ»ÖÃÒ²¾ÍÊÇ*(_DWORD*)(thisx + 50508)
    LPDIRECTDRAW* ddd = (LPDIRECTDRAW*)(_DWORD*)(thisx + 50508);//Ö®Ç°ÊÇLPDIRECTDRAW* ddd = (LPDIRECTDRAW*)(_DWORD*)*(thisx + 50508);Ö®Ç°¶àÁË¸ö*
    b = (*ddd)->SetCooperativeLevel(*(HWND*)(thisx + 50500), v12);
    if (b)
    {
        MessageBoxA(*(HWND*)(thisx + 50500), byte_4B749C, aDdrawerror_1, 0);
        goto LABEL_52;
    }
    if (*(_BYTE*)(thisx + 50442))
        //Õý³£À´½²£¬²»»áÖ´ÐÐµ½ÕâÀïÃæ
    {
        if ((*(int(__stdcall**)(_DWORD, int, int, int, _DWORD, _DWORD))(**(_DWORD**)(thisx + 50508) + 84))(
            *(_DWORD*)(thisx + 50508),
            (*(__int16*)(thisx + 50446) * *(__int16*)(thisx + 50448)) >> 8,
            (*(__int16*)(thisx + 50446) * *(__int16*)(thisx + 50450)) >> 8,
            16,
            0,
            0))
        {
            *(_WORD*)(thisx + 50446) *= 2;
            

            if ((*(int(__stdcall**)(_DWORD, int, int, int, _DWORD, _DWORD))(**(_DWORD**)(thisx + 50508) + 84))(
                *(_DWORD*)(thisx + 50508),
                (*(__int16*)(thisx + 50446) * *(__int16*)(thisx + 50448)) >> 8,
                (*(__int16*)(thisx + 50446) * *(__int16*)(thisx + 50450)) >> 8,
                16,
                0,
                0))
            {
                MessageBoxA(*(HWND*)(thisx + 50500), byte_4B74C8, aError03, 0);
                goto LABEL_52;
            }
        }
    }
    memset(v8, 0, sizeof(v8));
    v8[0] = 124;
    v8[1] = 2095598;
    (*(void(__stdcall**)(_DWORD, int*))(**(_DWORD**)(thisx + 50508) + 48))(*(_DWORD*)(thisx + 50508), v8);
    if (!*(_BYTE*)(thisx + 50442) && ((v8[19] & 0x40) == 0 || v8[21] != 16))
    {
        //ÉèÖÃ16Î»¼æÈÝµÄ£¬²»ÓÃÒ²¿ÉÒÔ
        //MessageBoxA(*(HWND*)(thisx + 50500), &byte_4B74F8, aNot16bit, 0);
        //goto LABEL_52;
    }
    v10 = &v8[18];
    word_4CA1F0[0] = v8[22];
    word_4CA1F0[1] = v8[23];//word_4CA1F2 = v8[23];
    word_4CA1F0[2] = v8[24];//word_4CA1F4 = v8[24];
    for (i = 0; i < 3; ++i)
    {
        v6 = (unsigned __int16)word_4CA1F0[i];
        for (j = 0; j < 16; ++j)
        {
            if ((v6 & 1) != 0)
            {
                byte_4CA210[i] = j;
                break;
            }
            v6 >>= 1;
        }
        if ((word_4CA1F0[i] & 0x8000) != 0)
            word_4CA208[i] = 0x8000;
        else
            word_4CA208[i] = ((unsigned __int16)word_4CA1F0[i] + 1) >> 1;
        byte_4CA214[i] = (int)(unsigned __int16)word_4CA1F0[i] >> byte_4CA210[i];
        v6 = (unsigned __int8)byte_4CA214[i];
        byte_4CA218[i] = 0;
        while (v6)
        {
            ++byte_4CA218[i];
            v6 >>= 1;
        }
    }
    word_4CB21C = ~((1 << byte_4CA212) | (1 << byte_4CA211) | (1 << byte_4CA210[0]));
    memset(v11, 0, sizeof(v11));
    v11[0] = 124;
    v11[1] = 1;
    v11[26] = 512;
    v11[5] = 1;
    if (*(_BYTE*)(thisx + 50442) && *(_BYTE*)(thisx + 50444) || !*(_BYTE*)(thisx + 50444) && !*(_BYTE*)(thisx + 50443))
    {
        v11[1] |= 0x20u;
        v11[26] |= 0x18u;
    }
    if ((*(int(__stdcall**)(_DWORD, int*, int, _DWORD))(**(_DWORD**)(thisx + 50508) + 24))(
        *(_DWORD*)(thisx + 50508),
        v11,
        thisx + 50512,
        0))
    {
        MessageBoxA(0, byte_4B7528, aError04, 0);
        goto LABEL_52;
    }
    if (*(_BYTE*)(thisx + 50442) && *(_BYTE*)(thisx + 50444) || !*(_BYTE*)(thisx + 50444) && !*(_BYTE*)(thisx + 50443))
    {
        v5[0] = 4;
        if ((*(int(__stdcall**)(_DWORD, int*, int))(**(_DWORD**)(thisx + 50512) + 48))(
            *(_DWORD*)(thisx + 50512),
            v5,
            thisx + 50516))
        {
            MessageBoxA(0, byte_4B7564, aError05, 0);
            goto LABEL_52;
        }
    }
    if (*(_BYTE*)(thisx + 50443)
        && (memset(v4, 0, sizeof(v4)),
            v4[0] = 124,
            v4[1] = 7,
            v4[26] = 2112,
            v4[3] = *(__int16*)(thisx + 50448),
            v4[2] = *(__int16*)(thisx + 50450),
            (*(int(__stdcall**)(_DWORD, int*, int, _DWORD))(**(_DWORD**)(thisx + 50508) + 24))(
                *(_DWORD*)(thisx + 50508),
                v4,
                thisx + 50520,
                0)))
    {
        MessageBoxA(0, byte_4B75A0, aError_41, 0);
        sub_49A184((_DWORD**)thisx);
        return 0;
    }
    else
    {
        SetRect(
            (LPRECT)(thisx + 50468),
            0,
            0,
            (*(__int16*)(thisx + 50446) * *(__int16*)(thisx + 50448)) >> 8,
            (*(__int16*)(thisx + 50446) * *(__int16*)(thisx + 50450)) >> 8);
        SetRect((LPRECT)(thisx + 50484), 0, 0, *(__int16*)(thisx + 50448), *(__int16*)(thisx + 50450));
        return 1;
    }
}

 
int sub_49A184(_DWORD** thisx)
{
    int result; // eax
    int i; // [esp+4h] [ebp-4h]

    for (i = 0; i < 2048; ++i)
        sub_49B04B((int*) & thisx[6 * i]);
    sub_49B882(thisx);
    if (thisx[12630])
    {
        (*(void(**)(_DWORD*, _DWORD*))(*thisx[12630] + 8))(thisx[12630], thisx[12630]);
        thisx[12630] = 0;
    }
    if (thisx[12628])
    {
        (*(void(__stdcall**)(_DWORD*))(*thisx[12628] + 8))(thisx[12628]);
        thisx[12628] = 0;
    }
    if (thisx[12632])
    {
        (*(void(__stdcall**)(_DWORD*))(*thisx[12632] + 8))(thisx[12632]);
        thisx[12632] = 0;
    }
    result = (int)thisx;
    if (thisx[12627])
    {
        result = (*(int(**)(_DWORD*, _DWORD*))(*thisx[12627] + 8))(thisx[12627], thisx[12627]);
        thisx[12627] = 0;
    }
    if (thisx[12626])
    {
        (*(void(__stdcall**)(_DWORD*))(*thisx[12626] + 8))(thisx[12626]);
        result = (int)thisx;
        thisx[12626] = 0;
    }
    return result;
}

 
void sub_49A2BB(_DWORD** thisx)
{
    sub_49A184(thisx);
    sub_49B98C((_DWORD*)thisx);
    eh_vector_destructor_iterator(thisx, 0x18u, 2048, unknown_libname_28);
}

 
int sub_49A318(int thisx)
{
    int k; // [esp+4h] [ebp-8h]
    int i; // [esp+8h] [ebp-4h]
    int j; // [esp+8h] [ebp-4h]

    eh_vector_constructor_iterator((void *)thisx, 0x18u, 2048, sub_499868, unknown_libname_28);
        * (_DWORD*)(thisx + 50516) = 0;
    *(_DWORD*)(thisx + 50520) = 0;
    *(_DWORD*)(thisx + 50512) = 0;
    *(_DWORD*)(thisx + 50504) = 0;
    *(_DWORD*)(thisx + 50508) = 0;
    *(_DWORD*)(thisx + 50524) = 0;
    *(_DWORD*)(thisx + 50528) = 0;
    *(_DWORD*)(thisx + 49152) = 0;
    *(_DWORD*)(thisx + 50436) = 0;
    *(_DWORD*)(thisx + 50500) = 0;
    *(_BYTE*)(thisx + 50441) = -1;
    *(_BYTE*)(thisx + 50445) = 0;
    memset((void*)(thisx + 49156), 0, 0x400u);
    memset((void*)(thisx + 50180), 0, 0x100u);
    for (i = 0; i < 256; ++i)
    {
        *(_BYTE*)(thisx + 4 * i + 49156) = (-1 - i) * (i % 3 == 0);
        *(_BYTE*)(thisx + 4 * i + 49157) = (-1 - i) * (i % 3 == 1);
        *(_BYTE*)(thisx + 4 * i + 49158) = (-1 - i) * (i % 3 == 2);
        *(_BYTE*)(thisx + 4 * i + 49159) = 1;
    }
    *(_BYTE*)(thisx + 50443) = 1;
    for (j = 0; j < 64; ++j)
    {
        for (k = 0; k < 64; ++k)
            byte_4CA21C[64 * k + j] = k * j / 64;
    }
    return thisx;
}

 
int sub_49A518(int thisx)
{
    int result; // eax
    struct tagRECT rc; // [esp+4h] [ebp-24h] BYREF
    HDC hdc; // [esp+14h] [ebp-14h]
    HDC hdcSrc; // [esp+18h] [ebp-10h] BYREF
    int v6; // [esp+1Ch] [ebp-Ch]
    struct tagPOINT Point; // [esp+20h] [ebp-8h] BYREF

    Point.y = 0;
    Point.x = 0;
    if (!*(_BYTE*)(thisx + 50442) && !ClientToScreen(*(HWND*)(thisx + 50500), &Point))
        MessageBoxA(*(HWND*)(thisx + 50500), aClienttoscreen, byte_4B75D4, 0);
    if (*(_BYTE*)(thisx + 50445))
    {

        //if (        (*(int(__stdcall**)(_DWORD, HDC*))           (**(_DWORD**)(thisx + 50520) + 68))            (*(_DWORD*)(thisx + 50520), &hdcSrc)           )
        IDirectDrawSurface* d = (IDirectDrawSurface*)*(_DWORD*)(thisx + 50520);

        HRESULT res = d->GetDC(&hdcSrc);
        
        if (res)
            //MessageBoxA(*(HWND*)(thisx + 50500), aMPddssysscGetd, byte_4B75FC, 0);
            printf("%s---%s\n", aMPddssysscGetd,byte_4B75FC);
        hdc = GetDC(*(HWND*)(thisx + 50500));
        if (*(_WORD*)(thisx + 50446) == 256)
            BitBlt(hdc, 0, 0, *(_DWORD*)(thisx + 50492), *(_DWORD*)(thisx + 50496), hdcSrc, 0, 0, 0xCC0020u);
        else
            StretchBlt(
                hdc,
                0,
                0,
                *(_DWORD*)(thisx + 50476),
                *(_DWORD*)(thisx + 50480),
                hdcSrc,
                0,
                0,
                *(_DWORD*)(thisx + 50492),
                *(_DWORD*)(thisx + 50496),
                0xCC0020u);
        if (hdcSrc)
            (*(void(**)(_DWORD, _DWORD, HDC))(**(_DWORD**)(thisx + 50520) + 104))(
                *(_DWORD*)(thisx + 50520),
                *(_DWORD*)(thisx + 50520),
                hdcSrc);
        result = ReleaseDC(*(HWND*)(thisx + 50500), hdc);
    }
    else if (*(_BYTE*)(thisx + 50443))
    {
        if (*(_BYTE*)(thisx + 50444))
        {
            if (*(_WORD*)(thisx + 50446) == 256)
                v6 = (*(int(__stdcall**)(_DWORD, LONG, LONG, _DWORD, _DWORD, _DWORD))(**(_DWORD**)(thisx + 50516) + 28))(
                    *(_DWORD*)(thisx + 50516),
                    Point.x,
                    Point.x,
                    *(_DWORD*)(thisx + 50520),
                    0,
                    0);
            else
                v6 = (*(int(__stdcall**)(_DWORD, int, _DWORD, int, _DWORD, _DWORD))(**(_DWORD**)(thisx + 50512) + 20))(
                    *(_DWORD*)(thisx + 50512),
                    thisx + 50468,
                    *(_DWORD*)(thisx + 50520),
                    thisx + 50484,
                    0,
                    0);
            result = (*(int(__stdcall**)(_DWORD, _DWORD, int))(**(_DWORD**)(thisx + 50512) + 44))(
                *(_DWORD*)(thisx + 50512),
                0,
                1);
            v6 = result;
        }
        else
        {
            if (*(_WORD*)(thisx + 50446) == 256)
            {
                result = (*(int(__stdcall**)(_DWORD, LONG, LONG, _DWORD, _DWORD, _DWORD))(**(_DWORD**)(thisx + 50512) + 28))(
                    *(_DWORD*)(thisx + 50512),
                    Point.x,
                    Point.y,
                    *(_DWORD*)(thisx + 50520),
                    0,
                    0);
            }
            else
            {
                SetRect(&rc, Point.x, Point.y, Point.x + *(_DWORD*)(thisx + 50476), Point.y + *(_DWORD*)(thisx + 50480));
                result = (*(int(__stdcall**)(_DWORD, struct tagRECT*, _DWORD, int, _DWORD, _DWORD))(**(_DWORD**)(thisx + 50512)
                    + 20))(
                        *(_DWORD*)(thisx + 50512),
                        &rc,
                        *(_DWORD*)(thisx + 50520),
                        thisx + 50484,
                        0,
                        0);
            }
            v6 = result;
        }
    }
    else
    {
        if (*(_BYTE*)(thisx + 50444))
            result = (*(int(**)(_DWORD, _DWORD, _DWORD, int))(**(_DWORD**)(thisx + 50512) + 44))(
                *(_DWORD*)(thisx + 50512),
                *(_DWORD*)(thisx + 50512),
                0,
                1);
        else
            result = (*(int(__stdcall**)(_DWORD, LONG, LONG, _DWORD, _DWORD, _DWORD))(**(_DWORD**)(thisx + 50512) + 28))(
                *(_DWORD*)(thisx + 50512),
                Point.x,
                Point.y,
                *(_DWORD*)(thisx + 50516),
                0,
                0);
        v6 = result;
    }
    if (v6 == -2005532222)
        return (*(int(__stdcall**)(_DWORD))(**(_DWORD**)(thisx + 50512) + 108))(*(_DWORD*)(thisx + 50512));
    return result;
}

 
unsigned __int16* sub_49AB05(int thisx, int* a2)
{
    unsigned __int16* result; // eax
    struct tagRECT rc; // [esp+4h] [ebp-10h] BYREF

    result = (unsigned __int16*)thisx;
    if (*(_BYTE*)(thisx + 50440) && *a2 < 2048)
    {
        if (a2[8])
        {
            a2[3] = thisx + 50452;
        }
        else
        {
            SetRect(&rc, 0, 0, *(__int16*)(thisx + 50448), *(__int16*)(thisx + 50450));
            a2[3] = (int)&rc;
        }
        a2[4] = 256;
        a2[5] = 256;
        if (*(_BYTE*)(thisx + 50443))
            return sub_49ABE2((unsigned __int16*)(24 * *a2 + thisx), *(_DWORD*)(thisx + 50520), (int)a2);
        else
            return sub_49ABE2((unsigned __int16*)(24 * *a2 + thisx), *(_DWORD*)(thisx + 50516), (int)a2);
    }
    return result;
}
 
unsigned __int16* sub_49ABE2(unsigned __int16* thisx, int a2, int a3)
{
    unsigned __int16* result; // eax
    int v4; // eax
    int v5; // edx
    int v6; // eax
    int v7; // edx
    int v8; // eax
    LONG v10; // [esp+108h] [ebp-A8h]
    LONG v11; // [esp+10Ch] [ebp-A4h]
    LONG v12; // [esp+110h] [ebp-A0h]
    LONG v13; // [esp+114h] [ebp-9Ch]
    int v14; // [esp+11Ch] [ebp-94h]
    int v15[25]; // [esp+120h] [ebp-90h] BYREF
    unsigned __int16* v16; // [esp+184h] [ebp-2Ch]
    struct tagRECT v17; // [esp+188h] [ebp-28h] BYREF
    struct tagRECT rc; // [esp+198h] [ebp-18h] BYREF
    int v19; // [esp+1A8h] [ebp-8h]
    int v20; // [esp+1ACh] [ebp-4h]

    result = (unsigned __int16*)a3;
    if (*(_DWORD*)(a3 + 40) && a2)
    {
        if (*((_DWORD*)thisx + 3))
            return (unsigned __int16*)sub_4A0CA2((int)thisx, a2, a3, 0);
        if (*(_DWORD*)thisx)
        {
            if (*(int*)(a3 + 40) < 64)
                return (unsigned __int16*)sub_49E6A3((_DWORD*)thisx, a2, a3);
            if (*(_BYTE*)(a3 + 44))
                return (unsigned __int16*)sub_49E6A3((_DWORD*)thisx, a2, a3);
            if (*(char*)(a3 + 45) > 0)
                return (unsigned __int16*)sub_49F638((_DWORD*)thisx, a2, a3, 0);
            v14 = (*(_DWORD*)(a3 + 16) * thisx[3]) >> 8;
            v19 = (*(_DWORD*)(a3 + 20) * thisx[4]) >> 8;
            if (*(_DWORD*)(a3 + 16) == 256 && *(_DWORD*)(a3 + 20) == 256)
            {
                v10 = 0;
                v12 = 0;
                v11 = 0;
                v13 = 0;
                if (**(_DWORD**)(a3 + 12) > *(_DWORD*)(a3 + 4))
                    v13 = **(_DWORD**)(a3 + 12) - *(_DWORD*)(a3 + 4);
                if (*(_DWORD*)(*(_DWORD*)(a3 + 12) + 4) > *(_DWORD*)(a3 + 8))
                    v11 = *(_DWORD*)(*(_DWORD*)(a3 + 12) + 4) - *(_DWORD*)(a3 + 8);
                if (*(_DWORD*)(*(_DWORD*)(a3 + 12) + 8) < v14 + *(_DWORD*)(a3 + 4))
                    v12 = v14 + *(_DWORD*)(a3 + 4) - *(_DWORD*)(*(_DWORD*)(a3 + 12) + 8);
                if (*(_DWORD*)(*(_DWORD*)(a3 + 12) + 12) < v19 + *(_DWORD*)(a3 + 8))
                    v10 = v19 + *(_DWORD*)(a3 + 8) - *(_DWORD*)(*(_DWORD*)(a3 + 12) + 12);
                if (*(_DWORD*)(a3 + 24))
                {
                    rc.left = v12;
                    rc.right = thisx[3] - v13;
                }
                else
                {
                    rc.left = v13;
                    rc.right = thisx[3] - v12;
                }
                if (*(_DWORD*)(a3 + 28))
                {
                    rc.top = v10;
                    rc.bottom = thisx[4] - v11;
                }
                else
                {
                    rc.top = v11;
                    rc.bottom = thisx[4] - v10;
                }
                result = (unsigned __int16*)rc.left;
                if (rc.left >= rc.right || rc.top >= rc.bottom)
                    return result;
                v17.left = v13 + *(_DWORD*)(a3 + 4);
                v17.top = v11 + *(_DWORD*)(a3 + 8);
                result = (unsigned __int16*)(v14 + v17.left - v13 - v12);
                v17.right = (LONG)result;
                v17.bottom = v19 + v17.top - v11 - v10;
            }
            else
            {
                SetRect(&rc, 0, 0, thisx[3], thisx[4]);
                result = (unsigned __int16*)SetRect(
                    &v17,
                    *(_DWORD*)(a3 + 4),
                    *(_DWORD*)(a3 + 8),
                    v14 + *(_DWORD*)(a3 + 4),
                    v19 + *(_DWORD*)(a3 + 8));
            }
            if (v17.left < v17.right && v17.top < v17.bottom)
            {
                memset(v15, 0, sizeof(v15));
                v15[0] = 100;
                v15[1] = 0;
                v20 = 0x1000000;
                if (*((_BYTE*)thisx + 5))
                {
                    v4 = v20;
                    BYTE1(v4) = BYTE1(v20) | 0x80;
                    v20 = v4;
                }
                if (*(_DWORD*)(a3 + 24))
                {
                    v5 = v20;
                    BYTE1(v5) = BYTE1(v20) | 8;
                    v20 = v5;
                    v6 = v15[1];
                    LOBYTE(v6) = LOBYTE(v15[1]) | 2;
                    v15[1] = v6;
                }
                if (*(_DWORD*)(a3 + 28))
                {
                    v7 = v20;
                    BYTE1(v7) = BYTE1(v20) | 8;
                    v20 = v7;
                    v8 = v15[1];
                    LOBYTE(v8) = LOBYTE(v15[1]) | 4;
                    v15[1] = v8;
                }
                result = (unsigned __int16*)(*(int(__stdcall**)(int, struct tagRECT*, _DWORD, struct tagRECT*, int, int*))(*(_DWORD*)a2 + 20))(
                    a2,
                    &v17,
                    *(_DWORD*)thisx,
                    &rc,
                    v20,
                    v15);
                v16 = result;
                if (result)
                {
                    if (v16 == (unsigned __int16*)-2005532222)
                        return (unsigned __int16*)MessageBoxA(0, byte_4B76AC, aError_42, 0);
                }
            }
        }
    }
    return result;
} 
int sub_49B04B(_DWORD* thisx)
{
    int result; // eax

    result = (int)thisx;
    if (*thisx)
    {
        result = (*(int(**)(_DWORD, _DWORD))(*(_DWORD*)*thisx + 8))(*thisx, *thisx);
        *thisx = 0;
    }
    if (thisx[3])
    {
        operator delete((void*)thisx[3]);
        result = (int)thisx;
        thisx[3] = 0;
    }
    thisx[4] = 0;
    return result;
}

 
int sub_49B0AB(_BYTE* thisx, int a2)
{
    int v4[2]; // [esp+4h] [ebp-8h] BYREF

    if (!*(_DWORD*)thisx)
        return 0;
    v4[0] = a2;
    v4[1] = a2;
    (*(void(**)(_DWORD, _DWORD, int, int*))(**(_DWORD**)thisx + 116))(
        *(_DWORD*)thisx,
        *(_DWORD*)thisx,
        8,
        v4);
    thisx[5] = 1;
    return 1;
}
 
int sub_49B106(_DWORD* thisx, int a2, int a3, int a4, int a5, int a6)
{
    int j; // [esp+4h] [ebp-94h]
    int v9; // [esp+8h] [ebp-90h]
    int v10[31]; // [esp+Ch] [ebp-8Ch] BYREF
    int v11; // [esp+88h] [ebp-10h]
    int i; // [esp+8Ch] [ebp-Ch]
    int v13; // [esp+90h] [ebp-8h]
    int v14; // [esp+94h] [ebp-4h]

    if (*thisx)
    {
        v10[0] = 124;
        v9 = (*(int(__stdcall**)(_DWORD, _DWORD, int*, _DWORD, _DWORD))(*(_DWORD*)*thisx + 100))(*thisx, 0, v10, 0, 0);
        if (v9 == -2005532222)
        {
            MessageBoxA(0, byte_4B7710, aError_44, 0);
            (*(void(__stdcall**)(_DWORD))(*(_DWORD*)*thisx + 108))(*thisx);
            v9 = (*(int(__stdcall**)(_DWORD, _DWORD, int*, _DWORD, _DWORD))(*(_DWORD*)*thisx + 100))(*thisx, 0, v10, 0, 0);
        }
        if (v9)
        {
            return 0;
        }
        else
        {
            v13 = v10[9];
            v14 = v10[4];
            v11 = a2;
            for (i = 0; i < a4; ++i)
            {
                for (j = 0; j < a3; ++j)
                    *(_BYTE*)(j + v13) = *(_BYTE*)(a5 + *(unsigned __int8*)(j + v11));
                v13 += v14;
                v11 += a3;
            }
            if ((*(int(__stdcall**)(_DWORD, _DWORD))(*(_DWORD*)*thisx + 128))(*thisx, 0))
            {
                MessageBoxA(0, byte_4B7720, aError_45, 0);
                return 0;
            }
            else
            {
                return 1;
            }
        }
    }
    else
    {
        MessageBoxA(0, byte_4B76CC, aError_43, 0);
        return 0;
    }
}
 
int sub_49B2A5(_DWORD* thisx, int a2, int a3, int cy, int a5, int a6)
{
    int k; // [esp+8h] [ebp-450h]
    int j; // [esp+Ch] [ebp-44Ch]
    HDC hdcSrc; // [esp+10h] [ebp-448h]
    HGDIOBJ v11; // [esp+14h] [ebp-444h]
    HBITMAP h; // [esp+1Ch] [ebp-43Ch]
    HDC hdc; // [esp+20h] [ebp-438h] BYREF
    int i; // [esp+24h] [ebp-434h]
    void* ppvBits; // [esp+28h] [ebp-430h] BYREF
    BITMAPINFO pbmi; // [esp+2Ch] [ebp-42Ch] BYREF

    if (*thisx)
    {
        if ((*(int(__stdcall**)(_DWORD, HDC*))(*(_DWORD*)*thisx + 68))(*thisx, &hdc))
        {
            MessageBoxA(0, byte_4B779C, aError_47, 0);
            return 0;
        }
        else
        {
            pbmi.bmiHeader.biSize = 40;
            pbmi.bmiHeader.biWidth = a3;
            pbmi.bmiHeader.biHeight = cy;
            pbmi.bmiHeader.biPlanes = 1;
            pbmi.bmiHeader.biBitCount = 8;
            pbmi.bmiHeader.biCompression = 0;
            pbmi.bmiHeader.biClrUsed = 256;
            pbmi.bmiHeader.biClrImportant = 0;
            for (i = 0; i < 256; ++i)
            {
                pbmi.bmiColors[i].rgbBlue = *(_BYTE*)(a6 + 4 * i + 2);
                pbmi.bmiColors[i].rgbGreen = *(_BYTE*)(a6 + 4 * i + 1);
                pbmi.bmiColors[i].rgbRed = *(_BYTE*)(a6 + 4 * i);
            }
            h = CreateDIBSection(hdc, &pbmi, 0, &ppvBits, 0, 0);
            if (h)
            {
                for (j = 0; j < cy; ++j)
                {
                    for (k = 0; k < a3; ++k)
                        *((_BYTE*)ppvBits + k + ((a3 + 3) & 0xFFFFFFFC) * (cy - j - 1)) = *(_BYTE*)(a5
                            + *(unsigned __int8*)(a2 + k + a3 * j));
                }
                hdcSrc = CreateCompatibleDC(hdc);
                v11 = SelectObject(hdcSrc, h);
                BitBlt(hdc, 0, 0, a3, cy, hdcSrc, 0, 0, 0xCC0020u);
                SelectObject(hdcSrc, v11);
                DeleteObject(h);
                DeleteDC(hdcSrc);
                (*(void(**)(_DWORD, _DWORD, HDC))(*(_DWORD*)*thisx + 104))(*thisx, *thisx, hdc);
                return 1;
            }
            else
            {
                MessageBoxA(0, byte_4B77C0, aError_48, 0);
                return 0;
            }
        }
    }
    else
    {
        MessageBoxA(0, byte_4B7758, aError_46, 0);
        return 0;
    }
}
 
int sub_49B578(_DWORD* thisx, int a2, int a3, int a4, char a5)
{
    int v6; // edx
    int v8[31]; // [esp+4h] [ebp-7Ch] BYREF

    if (a2)
    {
        memset(v8, 0, sizeof(v8));
        v8[0] = 124;
        v8[1] = 7;
        v8[26] = 64;
        if (a5)
        {
            v6 = v8[26];
            BYTE1(v6) = BYTE1(v8[26]) | 8;
            v8[26] = v6;
        }
        v8[3] = a3;
        *((_WORD*)thisx + 3) = a3;
        v8[2] = a4;
        *((_WORD*)thisx + 4) = a4;
        if (*thisx)
        {
            (*(void(**)(_DWORD, _DWORD))(*(_DWORD*)*thisx + 8))(*thisx, *thisx);
            *thisx = 0;
        }
        if ((*(int(__stdcall**)(int, int*, _DWORD*, _DWORD))(*(_DWORD*)a2 + 24))(a2, v8, thisx, 0))
        {
            MessageBoxA(0, byte_4B7818, aError_50, 0);
            return 0;
        }
        else
        {
            IDirectDrawSurface* ddp = (IDirectDrawSurface*)*thisx;
            (*ddp).Restore();
            //(*(void(**)(_DWORD, _DWORD))        (*(int*)*thisx + 108))       (*thisx, *thisx);
            return 1;
        }
    }
    else
    {
        MessageBoxA(0, byte_4B77E8, aError_49, 0);
        return 0;
    }
}
 
int sub_49B882(_DWORD** thisx)
{
    if (thisx[12631])
    {
        (*(void(**)(_DWORD*, _DWORD*))(*thisx[12631] + 8))(thisx[12631], thisx[12631]);
        thisx[12631] = 0;
    }
    return 1;
}
 
_DWORD* sub_49B98C(_DWORD* thisx)
{
    _DWORD* result; // eax

    result = thisx;
    if (thisx[12609])
    {
        result = (_DWORD*)thisx[12609];
        if (result)
            result = (_DWORD*)sub_4A1390((void*)thisx[12609], 1);
        thisx[12609] = 0;
    }
    return result;
}

 
int sub_49B9E0(_DWORD* thisx, LPCSTR lpFileName)
{
    _DWORD* v3; // [esp+0h] [ebp-1Ch]
    _DWORD* Block; // [esp+8h] [ebp-14h]

    sub_49B98C(thisx);
    Block = (_DWORD*)operator new(0x54Cu);
    if (Block)
        v3 = sub_4A1450(Block);
    else
        v3 = 0;
    thisx[12609] = (_DWORD)v3;
    if (thisx[12609])
    {
        if (sub_4A14C0((_WORD*)thisx[12609], lpFileName))
        {
            return 1;
        }
        else
        {
            sub_49B98C(thisx);
            return 0;
        }
    }
    else
    {
        MessageBoxA(0, byte_4B7988, aError_51, 0);
        return 0;
    }
}
 
int sub_49BAAB(_DWORD* thisx, LPCSTR lpFileName)
{
    _DWORD* v3; // [esp+0h] [ebp-1Ch]
    _DWORD* Block; // [esp+8h] [ebp-14h]

    sub_49B98C(thisx);
    Block = (_DWORD*)operator new(0x54Cu);
    if (Block)
        v3 = sub_4A1450(Block);
    else
        v3 = 0;
    thisx[12609] = (_DWORD)v3;
    if (thisx[12609])
    {
        if (sub_4A1ACA(thisx[12609], lpFileName))
        {
            return 1;
        }
        else
        {
            MessageBoxA(0, aImg, aError_53, 0);
            sub_49B98C(thisx);
            return 0;
        }
    }
    else
    {
        MessageBoxA(0, byte_4B79A8, aError_52, 0);
        return 0;
    }
} 
int sub_49BB8A(int thisx, int* a2)
{
    int v3; // edx
    int v5; // [esp+Ch] [ebp-13Ch]
    int v6; // [esp+10h] [ebp-138h]
    int v7; // [esp+14h] [ebp-134h]
    int v8; // [esp+18h] [ebp-130h]
    int Size; // [esp+1Ch] [ebp-12Ch]
    int v10; // [esp+20h] [ebp-128h]
    int v11; // [esp+24h] [ebp-124h]
    int v12; // [esp+28h] [ebp-120h]
    int i; // [esp+2Ch] [ebp-11Ch]
    int v14; // [esp+30h] [ebp-118h]
    _DWORD* v15; // [esp+34h] [ebp-114h]
    char v16; // [esp+38h] [ebp-110h]
    char v17[256]; // [esp+3Ch] [ebp-10Ch] BYREF
    int v18; // [esp+13Ch] [ebp-Ch]
    int v19; // [esp+140h] [ebp-8h]
    int cy; // [esp+144h] [ebp-4h]

    if (*(_DWORD*)(thisx + 50436))
    {
        if (*a2 == -1 || *a2 <= 2048)
        {
            v14 = *a2;
            v12 = 0;
            if (*a2 == -1)
                v14 = *(_DWORD*)(thisx + 49152);
            v16 = sub_4A13C0(*(_BYTE**)(thisx + 50436));
            v11 = unknown_libname_13(*(_DWORD**)(thisx + 50436));
            v19 = unknown_libname_21(*(_DWORD**)(thisx + 50436));
            if (a2[3] + a2[1] <= v11 && a2[4] + a2[2] <= v19 || v16)
            {
                if (a2[3] == -1)
                    Size = v11;
                else
                    Size = a2[3];
                if (a2[4] == -1)
                    cy = v19;
                else
                    cy = a2[4];
                if (v16 == 1)
                {
                    Size = a2[1];
                    cy = a2[2];
                }
                v10 = 0;
                v18 = 0;
                v15 = (_DWORD*)operator new(cy * Size);
                sub_4A17BF(*(_BYTE**)(thisx + 50436), thisx + 49156, thisx + 50180, (char*)a2[6], (int)v17, 0);
                *a2 = v14;
                for (i = v14; i < a2[5] + v14; ++i)
                {
                    if (i >= 2048)
                    {
                        MessageBoxA(*(HWND*)(thisx + 50500), aI, aEntrypat_1, 0);
                        break;
                    }
                    if (!v16 && v11 <= a2[3] * v10 + a2[1])
                    {
                        v10 = 0;
                        ++v18;
                    }
                    if (!v16 && v19 <= a2[4] * v18 + a2[2])
                    {
                        MessageBoxA(*(HWND*)(thisx + 50500), aBitmap, aEntrypat_2, 0);
                        break;
                    }
                    v8 = a2[3] * v10 + a2[1];
                    v7 = a2[4] * v18 + a2[2];
                    *(_DWORD*)(thisx + 24 * i + 20) = i;
                    if (!sub_49B578((_DWORD*)(24 * i + thisx), *(_DWORD*)(thisx + 50508), Size, cy, *(_BYTE*)(thisx + 50443)))
                    {
                        MessageBoxA(*(HWND*)(thisx + 50500), byte_4B7AEC, aEntrypat_3, 0);
                        break;
                    }
                    if (!v16)
                        v5 = sub_4A1694(*(_DWORD*)(thisx + 50436), v15, v8, v7, Size, cy);
                    if (v16 == 1)
                        v5 = sub_4A1C28(*(_DWORD**)(thisx + 50436), v15, Size, cy, 1);
                    if (!v5)
                    {
                        MessageBoxA(*(HWND*)(thisx + 50500), aCutbit, aEntrypat_4, 0);
                        break;
                    }
                    v3 = thisx;
                    if (*(_BYTE*)(thisx + 50441))
                    {
                        LOBYTE(v3) = *(_BYTE*)(thisx + 50441);
                        if (!sub_49B106((_DWORD*)(thisx + 24 * i), (int)v15, Size, cy, (int)v17, v3))
                        {
                            MessageBoxA(*(HWND*)(thisx + 50500), aEntrybit, aEntrypat_5, 0);
                            break;
                        }
                    }
                    else if (!sub_49B2A5((_DWORD*)(thisx + 24 * i), (int)v15, Size, cy, (int)v17, thisx + 49156))
                    {
                        MessageBoxA(*(HWND*)(thisx + 50500), aEntrybit2, aEntrypat_6, 0);
                        break;
                    }
                    v6 = a2[9];
                    if (v6 != -1)
                        v6 = v17[a2[9]];
                    sub_49B0AB((_BYTE*)(24 * i + thisx), v6);
                    ++v10;
                    ++v12;
                    ++* (_DWORD*)(thisx + 49152);
                }
                operator delete(v15);
                return v12;
            }
            else
            {
                MessageBoxA(*(HWND*)(thisx + 50500), byte_4B7A58, aEntrypat_0, 0);
                return 0;
            }
        }
        else
        {
            MessageBoxA(*(HWND*)(thisx + 50500), byte_4B7A28, aError_55, 0);
            return 0;
        }
    }
    else
    {
        MessageBoxA(0, byte_4B79F8, aError_54, 0);
        return 0;
    }
} 
int sub_49C15E(int thisx)
{
    *(_DWORD*)(thisx + 24) = 0;
    *(_DWORD*)(thisx + 28) = 0;
    *(_DWORD*)(thisx + 4) = 0;
    *(_DWORD*)(thisx + 8) = 0;
    *(_DWORD*)(thisx + 36) = -1;
    *(_DWORD*)(thisx + 12) = 0;
    *(_DWORD*)(thisx + 20) = 256;
    *(_DWORD*)(thisx + 16) = 256;
    *(_DWORD*)(thisx + 40) = 64;
    *(_BYTE*)(thisx + 44) = 0;
    *(_DWORD*)(thisx + 32) = 1;
    *(_BYTE*)(thisx + 45) = 0;
    *(_WORD*)(thisx + 50) = 0;
    *(_WORD*)(thisx + 48) = 0;
    *(_WORD*)(thisx + 46) = 0;
    *(_DWORD*)(thisx + 52) = 0;
    return thisx;
}
 
BOOL sub_49C3F9(_DWORD* thisx, _DWORD* a2)
{
    int v4; // [esp+4h] [ebp-4h]

    if (*thisx)
    {
        *a2 = 108;
        v4 = (*(int(__stdcall**)(_DWORD, _DWORD, _DWORD*, _DWORD, _DWORD))(*(_DWORD*)*thisx + 100))(*thisx, 0, a2, 0, 0);
        if (v4 == -2005532222)
        {
            MessageBoxA(0, byte_4B7C60, aError_59, 0);
            (*(void(__stdcall**)(_DWORD))(*(_DWORD*)*thisx + 108))(*thisx);
            v4 = (*(int(**)(_DWORD, _DWORD, _DWORD, _DWORD*, _DWORD, _DWORD))(*(_DWORD*)*thisx + 100))(
                *thisx,
                *thisx,
                0,
                a2,
                0,
                0);
        }
        return v4 == 0;
    }
    else
    {
        MessageBoxA(0, byte_4B7C38, aError_58, 0);
        return 0;
    }
}

 
int sub_49C500(_DWORD* thisx)
{
    if (!(*(int(__stdcall**)(_DWORD, _DWORD))(*(_DWORD*)*thisx + 128))(*thisx, 0))
        return 1;
    MessageBoxA(0, byte_4B7C8C, aError_61, 0);
    return 0;
}

 
int sub_49C541(_DWORD* thisx, int a2, int a3, struct tagRECT* a4)
{
    int result; // eax
    int v5; // ecx
    int v6; // ecx
    int v7; // eax
    int v8; // eax
    CHAR Text[256]; // [esp+4h] [ebp-19Ch] BYREF
    int v11[25]; // [esp+104h] [ebp-9Ch] BYREF
    int v12; // [esp+168h] [ebp-38h]
    int v13; // [esp+16Ch] [ebp-34h]
    int v14; // [esp+170h] [ebp-30h]
    int v15; // [esp+174h] [ebp-2Ch] BYREF
    int v16; // [esp+178h] [ebp-28h]
    int v17; // [esp+17Ch] [ebp-24h]
    int v18; // [esp+180h] [ebp-20h]
    int v19; // [esp+184h] [ebp-1Ch]
    int v20; // [esp+188h] [ebp-18h]
    int v21; // [esp+18Ch] [ebp-14h] BYREF
    int v22; // [esp+190h] [ebp-10h]
    int v23; // [esp+194h] [ebp-Ch]
    int v24; // [esp+198h] [ebp-8h]
    int v25; // [esp+19Ch] [ebp-4h]

    if (!a2)
        return messagebox(aLpddsNull);
    if (thisx[3])
        return sub_4A0CA2((int)thisx, a2, a3, a4);
    if (!*thisx)
        return messagebox(aMPddsbufNull);
    if (*(char*)(a3 + 45) > 0)
        return sub_49F638(thisx, a2, a3, (_DWORD*)&a4->left);
    v13 = 0;
    v19 = 0;
    v14 = 0;
    v20 = 0;
    if (**(_DWORD**)(a3 + 12) > *(_DWORD*)(a3 + 4))
        v20 = **(_DWORD**)(a3 + 12) - *(_DWORD*)(a3 + 4);
    if (*(_DWORD*)(*(_DWORD*)(a3 + 12) + 4) > *(_DWORD*)(a3 + 8))
        v14 = *(_DWORD*)(*(_DWORD*)(a3 + 12) + 4) - *(_DWORD*)(a3 + 8);
    if (*(_DWORD*)(*(_DWORD*)(a3 + 12) + 8) < a4->right + *(_DWORD*)(a3 + 4))
        v19 = a4->right + *(_DWORD*)(a3 + 4) - *(_DWORD*)(*(_DWORD*)(a3 + 12) + 8);
    if (*(_DWORD*)(*(_DWORD*)(a3 + 12) + 12) < a4->bottom + *(_DWORD*)(a3 + 8))
        v13 = a4->bottom + *(_DWORD*)(a3 + 8) - *(_DWORD*)(*(_DWORD*)(a3 + 12) + 12);
    if (*(_DWORD*)(a3 + 24))
    {
        v21 = v19 + a4->left;
        v22 = v14 + a4->top;
        v23 = a4->right + v21 - v20 - v19;
        v5 = a4->bottom + v22 - v14;
    }
    else
    {
        v21 = a4->left + v20;
        v22 = a4->top + v14;
        v23 = a4->right + a4->left - v19;
        v5 = a4->bottom + a4->top;
    }
    v24 = v5 - v13;
    result = v21;
    if (v21 < v23 && v22 < v24)
    {
        v15 = (*(_DWORD*)(a3 + 16) * (v20 + *(_DWORD*)(a3 + 4))) >> 8;
        v16 = (*(_DWORD*)(a3 + 20) * (v14 + *(_DWORD*)(a3 + 8))) >> 8;
        v17 = (*(_DWORD*)(a3 + 16) * (a4->right + v15 - v20 - v19)) >> 8;
        result = (*(_DWORD*)(a3 + 20) * (a4->bottom + v16 - v14 - v13)) >> 8;
        v18 = result;
        if (v15 < v17)
        {
            result = v16;
            if (v16 < v18)
            {
                memset(v11, 0, sizeof(v11));
                v11[0] = 100;
                v11[1] = 0;
                v25 = 0x1000000;
                if (*((_BYTE*)thisx + 5))
                {
                    v6 = v25;
                    BYTE1(v6) = BYTE1(v25) | 0x80;
                    v25 = v6;
                }
                if (*(_DWORD*)(a3 + 24))
                {
                    v7 = v25;
                    BYTE1(v7) = BYTE1(v25) | 8;
                    v25 = v7;
                    v11[1] |= 2u;
                }
                if (*(_DWORD*)(a3 + 28))
                {
                    v8 = v25;
                    BYTE1(v8) = BYTE1(v25) | 8;
                    v25 = v8;
                    v11[1] |= 4u;
                }
                result = (*(int(__stdcall**)(int, int*, _DWORD, int*, int, int*))(*(_DWORD*)a2 + 20))(
                    a2,
                    &v15,
                    *thisx,
                    &v21,
                    v25,
                    v11);
                v12 = result;
                if (result)
                {
                    if (v12 == -2005532222)
                    {
                        return messagebox(byte_4B7CE0);
                    }
                    else if (v12 != -2005532522)
                    {
                        wsprintfA(Text, "%X", v12);
                        return messagebox(Text);
                    }
                }
            }
        }
    }
    return result;
} 
int sub_49C8A6(int thisx, int* a2, _DWORD* a3)
{
    int result; // eax

    result = thisx;
    if (*(_BYTE*)(thisx + 50440) && *a2 < 2048)
    {
        a2[3] = thisx + 50452;
        if (*(_BYTE*)(thisx + 50443))
            return sub_49C541((_DWORD*)(24 * *a2 + thisx), *(_DWORD*)(thisx + 50520), (int)a2, (tagRECT*)a3);
        else
            return sub_49C541((_DWORD*)(24 * *a2 + thisx), *(_DWORD*)(thisx + 50516), (int)a2, (tagRECT*)a3);
    }
    return result;
}
 
int sub_49CA4B(_DWORD* thisx, int a2, LPCSTR name, char a4)
{
    int v6; // [esp+4h] [ebp-8h] BYREF
    __int16 v7; // [esp+8h] [ebp-4h]

    if (*thisx)
    {
        (*(void(**)(_DWORD, _DWORD))(*(_DWORD*)*thisx + 8))(*thisx, *thisx);
        *thisx = 0;
    }
    *thisx = sub_4A25CE(a2, name, 0, 0, a4, (int)&v6);
    if (!*thisx)
        return 0;
    *((_WORD*)thisx + 3) = v6;
    *((_WORD*)thisx + 4) = v7;
    *((_BYTE*)thisx + 4) = 1;
    return 1;
}

 
int  sub_49CB92(int thisx, int a2, int a3, int a4, int a5, COLORREF color)
{
    int v7; // eax
    char v9[4] = {}; // [esp+4h] [ebp-8h] BYREF
    int v10; // [esp+8h] [ebp-4h]
    int* a = (int*)v9;
    if (a2 >= 2048 || a2 < -1)
        return -1;
    if (a2 == -1)
        a2 = *(_DWORD*)(thisx + 49152);
    if (!sub_49B578((_DWORD*)(24 * a2 + thisx), *(_DWORD*)(thisx + 50508), a3, a4, *(_BYTE*)(thisx + 50443)))
        return -1;
    if (a5)
    {
        v9[0] = 1;
        v7 = unknown_libname_30((_DWORD*)(void*)(thisx + 24 * a2));
        v10 = sub_4A246A(v7, color);
    }
    else
    {
        v9[0] = 0;
    }
    sub_49CDF4((_DWORD*)(thisx + 24 * a2), (int)v9);
    ++* (_DWORD*)(thisx + 49152);
    return a2;
}
 
void  sub_49CC5B(_WORD* thisx, int a2, int* a3)
{
    int v3; // eax
    int v5[2]; // [esp+4h] [ebp-10h] BYREF
    int v6; // [esp+Ch] [ebp-8h]
    int v7; // [esp+10h] [ebp-4h]

    if (a2 >= 0)
    {
        if (*a3 < 2048 && a2 < 2048)
        {
            v5[1] = 0;
            v5[0] = 0;
            LOWORD(v6) = sub_4260F0(&thisx[12 * a2]);
            v6 = (unsigned __int16)v6;
            LOWORD(v7) = sub_48E130(&thisx[12 * a2]);
            v7 = (unsigned __int16)v7;
            a3[3] = (int)v5;
            v3 = unknown_libname_30((_DWORD*)&thisx[12 * a2]);
            sub_49ABE2((unsigned short*)&thisx[12 * *a3], v3, (int)a3);
        }
    }
    else
    {
        sub_49AB05((int)thisx, a3);
    }
}
 
int  sub_49CD45(_DWORD* thisx, int a2)
{
    if (!(*(int(__stdcall**)(_DWORD, int))(*(_DWORD*)*thisx + 68))(*thisx, a2))
        return 1;
    messagebox(aGetdcFailed);
    return 0;
}
 
int  sub_49CD87(_DWORD* thisx, _DWORD* a2)
{
    int result; // eax

    result = (*(int(__stdcall**)(_DWORD, _DWORD))(*(_DWORD*)*thisx + 104))(*thisx, *a2);
    if (result)
        return messagebox(aReleasedcFaile);
    return result;
}
 
int  sub_49CDF4(_DWORD* thisx, int a2)
{
    int v4[2]; // [esp+4h] [ebp-8h] BYREF

    if (thisx[3] && thisx[4])
    {
        *((_BYTE*)thisx + 5) = *(_BYTE*)a2;
        return 1;
    }
    else if (*thisx)
    {
        if (*(_BYTE*)a2)
        {
            v4[0] = *(_DWORD*)(a2 + 4);
            v4[1] = *(_DWORD*)(a2 + 4);
            (*(void(__stdcall**)(_DWORD, int, int*))(*(_DWORD*)*thisx + 116))(*thisx, 8, v4);
            *((_BYTE*)thisx + 5) = 1;
        }
        else
        {
            *((_BYTE*)thisx + 5) = 0;
        }
        return 1;
    }
    else
    {
        return 0;
    }
}
 
char*  sub_49CE7F(char** thisx)
{
    if (thisx[12609])
        return unknown_libname_31(thisx[12609]);
    else
        return 0;
}
 
int  sub_49D0B7(_DWORD* thisx, int a2, int a3, int cy, void* Src)
{
    int j; // [esp+8h] [ebp-44Ch]
    int i; // [esp+Ch] [ebp-448h]
    HDC hdcSrc; // [esp+10h] [ebp-444h]
    HGDIOBJ v10; // [esp+14h] [ebp-440h]
    HBITMAP h; // [esp+1Ch] [ebp-438h]
    HDC hdc; // [esp+20h] [ebp-434h] BYREF
    void* ppvBits; // [esp+24h] [ebp-430h] BYREF
    char pbmi[1064]; // [esp+28h] [ebp-42Ch] BYREF

    if (*thisx || thisx[3])
    {
        if ((*(int(__stdcall**)(_DWORD, HDC*))(*(_DWORD*)*thisx + 68))(*thisx, &hdc))
        {
            messagebox(byte_4B7DA4);
            return 0;
        }
        else
        {
            *(_DWORD*)pbmi = 40;
            *(_DWORD*)&pbmi[4] = a3;
            *(_DWORD*)&pbmi[8] = cy;
            *(_WORD*)&pbmi[12] = 1;
            *(_WORD*)&pbmi[14] = 8;
            *(_DWORD*)&pbmi[16] = 0;
            *(_DWORD*)&pbmi[32] = 256;
            *(_DWORD*)&pbmi[36] = 0;
            memcpy(&pbmi[40], Src, 0x400u);
            h = CreateDIBSection(hdc, (const BITMAPINFO*)pbmi, 0, &ppvBits, 0, 0);
            if (h)
            {
                for (i = 0; i < cy; ++i)
                {
                    for (j = 0; j < a3; ++j)
                        *((_BYTE*)ppvBits + j + ((a3 + 3) & 0xFFFFFFFC) * (cy - i - 1)) = *(_BYTE*)(a2 + j + a3 * i);
                }
                hdcSrc = CreateCompatibleDC(hdc);
                v10 = SelectObject(hdcSrc, h);
                BitBlt(hdc, 0, 0, a3, cy, hdcSrc, 0, 0, 0xCC0020u);
                SelectObject(hdcSrc, v10);
                DeleteObject(h);
                DeleteDC(hdcSrc);

                IDirectDrawSurface* d = (IDirectDrawSurface*)*thisx;
                d->ReleaseDC(hdc);
                //(*(void(**)(_DWORD, _DWORD, HDC))(*(_DWORD*)*thisx + 104))(*thisx, *thisx, hdc);
                return 1;
            }
            else
            {
                messagebox(byte_4B7DC0);
                return 0;
            }
        }
    }
    else
    {
        messagebox(byte_4B7D68);
        return 0;
    }
}
 
int sub_49D318(int thisx, int a2)
{
    int v3; // eax
    int v4; // [esp-4h] [ebp-55Ch]
    signed int j; // [esp+Ch] [ebp-54Ch]
    int v7; // [esp+10h] [ebp-548h]
    int v8; // [esp+14h] [ebp-544h]
    int v9; // [esp+18h] [ebp-540h]
    size_t v10; // [esp+1Ch] [ebp-53Ch]
    char v11[4]; // [esp+20h] [ebp-538h] BYREF
    int v12; // [esp+24h] [ebp-534h]
    CHAR Text[256]; // [esp+28h] [ebp-530h] BYREF
    size_t Size; // [esp+128h] [ebp-430h]
    int v15; // [esp+12Ch] [ebp-42Ch]
    int v16; // [esp+130h] [ebp-428h]
    int v17; // [esp+134h] [ebp-424h]
    char Src[1024]; // [esp+138h] [ebp-420h] BYREF
    int i; // [esp+538h] [ebp-20h]
    int v20; // [esp+53Ch] [ebp-1Ch]
    void* v21; // [esp+540h] [ebp-18h]
    char v22; // [esp+544h] [ebp-14h]
    char v23; // [esp+548h] [ebp-10h]
    int v24; // [esp+54Ch] [ebp-Ch]
    int v25; // [esp+550h] [ebp-8h]
    int cy; // [esp+554h] [ebp-4h]

    if (*(_DWORD*)(thisx + 50436) || *(_DWORD*)(a2 + 52))
    {
        if (!*(_DWORD*)(a2 + 52))
            *(_DWORD*)(a2 + 52) = *(_DWORD*)(thisx + 50436);
        if (*(_DWORD*)a2 == -1 || *(int*)a2 <= 2048)
        {
            v20 = *(_DWORD*)a2;
            v17 = 0;
            if (*(_DWORD*)a2 == -1)
                v20 = *(_DWORD*)(thisx + 49152);
            v23 = sub_4A13C0(*(_BYTE**)(a2 + 52));
            v16 = unknown_libname_13(*(_DWORD**)(a2 + 52));
            v25 = unknown_libname_21(*(_DWORD**)(a2 + 52));
            if (*(_DWORD*)(a2 + 12) + *(_DWORD*)(a2 + 4) <= v16 && *(_DWORD*)(a2 + 16) + *(_DWORD*)(a2 + 8) <= v25 || v23)
            {
                if (*(_DWORD*)(a2 + 12) == -1)
                    Size = v16;
                else
                    Size = *(_DWORD*)(a2 + 12);
                if (*(_DWORD*)(a2 + 16) == -1)
                    cy = v25;
                else
                    cy = *(_DWORD*)(a2 + 16);
                if (v23 == 1)
                {
                    Size = *(_DWORD*)(a2 + 4);
                    cy = *(_DWORD*)(a2 + 8);
                }
                v15 = 0;
                v24 = 0;
                v21 = operator new(cy * Size);
                if (*(_DWORD*)(a2 + 44))
                    memcpy(Src, *(const void**)(a2 + 44), sizeof(Src));
                else
                    sub_4A1AA5(*(_DWORD*)(a2 + 52), Src);
                *(_DWORD*)a2 = v20;
                if (*(_DWORD*)(a2 + 20) == -1)
                    *(_DWORD*)(a2 + 20) = v25 / cy * (v16 / (int)Size);
                if (*(_BYTE*)(a2 + 48))
                {
                    if (*(_BYTE*)(a2 + 48) != 1 && *(_BYTE*)(thisx + 50442))
                    {
                        if (*(_BYTE*)(a2 + 48) == 2 && *(_BYTE*)(thisx + 50442))
                            v22 = 0;
                    }
                    else
                    {
                        v22 = 1;
                    }
                }
                else
                {
                    v22 = *(_BYTE*)(thisx + 50443);
                }
                for (i = v20; i < *(_DWORD*)(a2 + 20) + v20; ++i)
                {
                    if (i >= 2048)
                    {
                        MessageBoxA(*(HWND*)(thisx + 50500), aI_0, aEntrypat_8, 0);
                        break;
                    }
                    if (!v23 && v16 <= (int)(Size * v15 + *(_DWORD*)(a2 + 4)))
                    {
                        v15 = 0;
                        ++v24;
                    }
                    if (!v23 && v25 <= cy * v24 + *(_DWORD*)(a2 + 8))
                    {
                        MessageBoxA(*(HWND*)(thisx + 50500), aBitmap_0, aEntrypat_9, 0);
                        break;
                    }
                    v10 = Size * v15 + *(_DWORD*)(a2 + 4);
                    v9 = cy * v24 + *(_DWORD*)(a2 + 8);
                    *(_DWORD*)(thisx + 24 * i + 20) = i;
                    if (*(_DWORD*)(a2 + 56))
                    {
                        sub_4A1216(24 * i + thisx, Size, cy, *(_DWORD*)(a2 + 56));
                    }
                    else if (!sub_49B578((_DWORD*)(24 * i + thisx), *(_DWORD*)(thisx + 50508), Size, cy, v22))
                    {
                        MessageBoxA(*(HWND*)(thisx + 50500), byte_4B7F04, aEntrypat_10, 0);
                        break;
                    }
                    if (v23)
                    {
                        if (v23 == 1)
                            v7 = sub_4A1C28(*(_DWORD**)(a2 + 52), v21, Size, cy, 1);
                    }
                    else
                    {
                        v7 = sub_4A1694(*(_DWORD*)(a2 + 52), v21, v10, v9, Size, cy);
                    }
                    if (!v7)
                    {
                        MessageBoxA(*(HWND*)(thisx + 50500), aCutbit_0, aEntrypat_11, 0);
                        break;
                    }
                    if (*(_DWORD*)(a2 + 56))
                    {
                        sub_4A1299(24 * i + thisx, (int)v21, Size, cy);
                    }
                    else if (!sub_49D0B7((_DWORD*)(24 * i + thisx), (int)v21, Size, cy, Src))
                    {
                        MessageBoxA(*(HWND*)(thisx + 50500), aEntrybit3, aEntrypat_12, 0);
                        break;
                    }
                    v8 = *(_DWORD*)(a2 + 36);
                    if (v8 == -1)
                    {
                        v11[0] = 0;
                    }
                    else
                    {
                        v11[0] = 0;
                        if (v8 > 255)
                            v8 = (unsigned __int8)v8;
                        for (j = 0; j < (int)(cy * Size); ++j)
                        {
                            if (*((unsigned __int8*)v21 + j) == v8)
                            {
                                v11[0] = 1;
                                break;
                            }
                        }
                        if (*(_DWORD*)(a2 + 56))
                        {
                            v12 = v8;
                        }
                        else
                        {
                            v4 = ((unsigned __int8)Src[4 * v8] << 16) | ((unsigned __int8)Src[4 * v8 + 1] << 8) | (unsigned __int8)Src[4 * v8 + 2];
                            v3 = unknown_libname_30((_DWORD*)(void*)(24 * i + thisx));
                            v12 = sub_4A246A(v3, v4);
                        }
                    }
                    sub_49CDF4((_DWORD*)(24 * i + thisx), (int)v11);
                    ++v15;
                    ++v17;
                    if ((unsigned int)i >= *(_DWORD*)(thisx + 49152))
                        ++* (_DWORD*)(thisx + 49152);
                }
                operator delete(v21);
                if (*(_DWORD*)(a2 + 52) == *(_DWORD*)(thisx + 50436))
                    *(_DWORD*)(a2 + 52) = 0;
                return v17;
            }
            else
            {
                wsprintfA(
                    Text,
                    "type=%d, x=%d, y=%d, w=%d, h=%d, bw=%d, bh=%d",
                    0,
                    *(_DWORD*)(a2 + 4),
                    *(_DWORD*)(a2 + 8),
                    *(_DWORD*)(a2 + 12),
                    *(_DWORD*)(a2 + 16),
                    v16,
                    v25);
                MessageBoxA(*(HWND*)(thisx + 50500), byte_4B7E70, aEntrypat_7, 0);
                messagebox(Text);
                return 0;
            }
        }
        else
        {
            MessageBoxA(*(HWND*)(thisx + 50500), byte_4B7E10, aError_64, 0);
            return 0;
        }
    }
    else
    {
        messagebox(byte_4B7DE0);
        return 0;
    }
}
 
int  sub_49DA45(_DWORD* thisx, LPCSTR lpFileName, int a3)
{
    int v5; // [esp+4h] [ebp-4h]

    sub_49B9E0(thisx, lpFileName);
    if (!thisx[12609])
        return 0;
    v5 = sub_49D318((int)thisx, a3);
    sub_49B98C(thisx);
    return v5;
}
 
_DWORD*  sub_49DA8A(_DWORD* thisx, int a2)
{
    _DWORD* result; // eax
    int i; // [esp+4h] [ebp-4h]

    result = thisx;
    if (thisx[12288] && thisx[12288] >= (unsigned int)a2)
    {
        for (i = thisx[12288] - 1; ; --i)
        {
            result = (_DWORD*)i;
            if (i < a2)
                break;
            sub_49B04B(&thisx[6 * i]);
            --thisx[12288];
        }
    }
    return result;
}
 
int  sub_49DB00(_DWORD* thisx, int a2)
{
    int result; // eax
    int v3[25]; // [esp+4h] [ebp-64h] BYREF

    result = (int)thisx;
    if (*thisx)
    {
        v3[0] = 100;
        v3[20] = a2;
        return (*(int(__stdcall**)(_DWORD, _DWORD, _DWORD, _DWORD, int, int*))(*(_DWORD*)*thisx + 20))(
            *thisx,
            0,
            0,
            0,
            16778240,
            v3);
    }
    return result;
}
 
_DWORD*  sub_49DB43(_DWORD* thisx)
{
    thisx[4] = 0;
    thisx[2] = 320;
    *thisx = 0;
    thisx[1] = 240;
    thisx[3] = 256;
    *((_BYTE*)thisx + 20) = 1;
    *((_BYTE*)thisx + 21) = 0;
    return thisx;
}
 
_DWORD*  sub_49DB90(_DWORD* thisx)
{
    thisx[1] = 0;
    thisx[2] = 0;
    thisx[3] = -1;
    thisx[4] = -1;
    *thisx = -1;
    thisx[5] = -1;
    thisx[6] = 0;
    thisx[9] = 0;
    thisx[10] = 0;
    thisx[11] = 0;
    *((_BYTE*)thisx + 48) = 0;
    thisx[13] = 0;
    thisx[14] = 0;
    return thisx;
}
 
int  sub_49DDFD(unsigned __int16* thisx, int a2, int a3)
{
    int result; // eax
    CHAR Text[256]; // [esp+4h] [ebp-27Ch] BYREF
    int v6; // [esp+104h] [ebp-17Ch]
    int v7; // [esp+108h] [ebp-178h]
    int v8; // [esp+10Ch] [ebp-174h]
    __int16 v9; // [esp+110h] [ebp-170h]
    int v10; // [esp+114h] [ebp-16Ch]
    int v11; // [esp+118h] [ebp-168h]
    int v12[4]; // [esp+11Ch] [ebp-164h] BYREF
    int v13; // [esp+12Ch] [ebp-154h]
    int v14; // [esp+140h] [ebp-140h]
    __int16 v15; // [esp+15Ch] [ebp-124h]
    int v16; // [esp+198h] [ebp-E8h]
    int v17; // [esp+19Ch] [ebp-E4h]
    int v18; // [esp+1A0h] [ebp-E0h]
    int v19; // [esp+1A4h] [ebp-DCh]
    int v20; // [esp+1A8h] [ebp-D8h] BYREF
    int v21; // [esp+1ACh] [ebp-D4h]
    int v22; // [esp+1B0h] [ebp-D0h]
    int v23; // [esp+1B4h] [ebp-CCh]
    int v24; // [esp+1B8h] [ebp-C8h]
    int v25[4]; // [esp+1BCh] [ebp-C4h] BYREF
    int v26; // [esp+1CCh] [ebp-B4h]
    int v27; // [esp+1E0h] [ebp-A0h]
    int v28[7]; // [esp+238h] [ebp-48h] BYREF
    __int16 v29; // [esp+254h] [ebp-2Ch]
    int v30; // [esp+258h] [ebp-28h]
    int v31; // [esp+25Ch] [ebp-24h]
    int v32; // [esp+260h] [ebp-20h]
    int v33; // [esp+264h] [ebp-1Ch] BYREF
    int v34; // [esp+268h] [ebp-18h]
    int v35; // [esp+26Ch] [ebp-14h]
    int v36; // [esp+270h] [ebp-10h]
    int v37; // [esp+274h] [ebp-Ch]
    int v38; // [esp+278h] [ebp-8h]
    int v39; // [esp+27Ch] [ebp-4h]

    v17 = 0;
    v31 = 0;
    v19 = 0;
    v32 = 0;
    v37 = 0;
    v8 = 0;
    v6 = thisx[3];
    v38 = thisx[4];
    if (**(_DWORD**)(a3 + 12) > *(_DWORD*)(a3 + 4))
        v32 = **(_DWORD**)(a3 + 12) - *(_DWORD*)(a3 + 4);
    if (*(_DWORD*)(*(_DWORD*)(a3 + 12) + 4) > *(_DWORD*)(a3 + 8))
        v19 = *(_DWORD*)(*(_DWORD*)(a3 + 12) + 4) - *(_DWORD*)(a3 + 8);
    if (*(_DWORD*)(*(_DWORD*)(a3 + 12) + 8) < v6 + *(_DWORD*)(a3 + 4))
        v31 = v6 + *(_DWORD*)(a3 + 4) - *(_DWORD*)(*(_DWORD*)(a3 + 12) + 8);
    if (*(_DWORD*)(*(_DWORD*)(a3 + 12) + 12) < v38 + *(_DWORD*)(a3 + 8))
        v17 = v38 + *(_DWORD*)(a3 + 8) - *(_DWORD*)(*(_DWORD*)(a3 + 12) + 12);
    if (*(_DWORD*)(a3 + 24))
    {
        v33 = v31;
        v35 = thisx[3] - v32;
    }
    else
    {
        v33 = v32;
        v35 = thisx[3] - v31;
    }
    if (*(_DWORD*)(a3 + 28))
    {
        v34 = v17;
        result = (int)thisx;
        v36 = thisx[4] - v19;
    }
    else
    {
        v34 = v19;
        result = thisx[4] - v17;
        v36 = result;
    }
    if (v33 < v35 && v34 < v36)
    {
        v20 = v32 + *(_DWORD*)(a3 + 4);
        v21 = v19 + *(_DWORD*)(a3 + 8);
        v22 = v6 + v20 - v32 - v31;
        v23 = v38 + v21 - v19 - v17;
        v12[0] = 124;
        v25[0] = 124;
        result = (*(int(__stdcall**)(_DWORD, int*, int*, int, _DWORD))(**(_DWORD**)thisx + 100))(
            *(_DWORD*)thisx,
            &v33,
            v12,
            1,
            0);
        v39 = result;
        if (result)
        {
            if (v39 == -2147024809)
            {
                wsprintfA(Text, "LockError ( %d, %d )-( %d, %d )", v33, v34, v35, v36);
                return messagebox(Text);
            }
        }
        else
        {
            v39 = (*(int(__stdcall**)(int, int*, int*, int, _DWORD))(*(_DWORD*)a2 + 100))(a2, &v20, v25, 1, 0);
            if (v39)
            {
                (*(void(__stdcall**)(_DWORD, int*))(**(_DWORD**)thisx + 128))(*(_DWORD*)thisx, &v33);
                return messagebox(aLockerror2);
            }
            else
            {
                v10 = v14;
                if (*(_DWORD*)(a3 + 24))
                    v10 = v10 + 2 * (v35 - v33) - 2;
                if (*(_DWORD*)(a3 + 28))
                    v10 += 2 * (v13 * (v36 - v34 - 1) / 2);
                v16 = (*(_DWORD*)(a3 + 24) == 0) - *(_DWORD*)(a3 + 24);
                v11 = v13 * ((*(_DWORD*)(a3 + 28) == 0) - *(_DWORD*)(a3 + 28)) / 2;
                v7 = v27;
                v18 = v26 / 2;
                v9 = v15;
                LOWORD(v24) = *(_WORD*)(a3 + 40);
                v28[0] = (int)&v33;
                v28[1] = (int)&v20;
                v28[2] = v10;
                v28[3] = v27;
                v28[4] = v16;
                v28[5] = v11;
                v28[6] = v26 / 2;
                v29 = v15;
                v30 = (unsigned __int16)v24;
                if ((unsigned __int16)v24 == 32)
                    sub_49E561((char*)thisx, (int)v28);
                else
                    sub_49E288((char*)thisx, (short*)v28);
                (*(void(__stdcall**)(_DWORD, int*))(**(_DWORD**)thisx + 128))(*(_DWORD*)thisx, &v33);
                return (*(int(__stdcall**)(int, int*))(*(_DWORD*)a2 + 128))(a2, &v20);
            }
        }
    }
    return result;
}

 
int sub_49E288(_BYTE* thisx, _WORD* a2)
{
    int result; // eax
    _WORD* v3; // [esp+8h] [ebp-74h]
    int j; // [esp+Ch] [ebp-70h]
    _WORD* v5; // [esp+10h] [ebp-6Ch]
    _WORD* v6; // [esp+18h] [ebp-64h]
    int v7; // [esp+24h] [ebp-58h]
    __int16 v8; // [esp+28h] [ebp-54h]
    char v9; // [esp+2Ch] [ebp-50h]
    int v10; // [esp+30h] [ebp-4Ch]
    int v11; // [esp+34h] [ebp-48h]
    _WORD* v12; // [esp+3Ch] [ebp-40h]
    int v13; // [esp+40h] [ebp-3Ch]
    __int16 v14; // [esp+4Ch] [ebp-30h]
    unsigned __int16 v15; // [esp+54h] [ebp-28h]
    int v16; // [esp+60h] [ebp-1Ch]
    int i; // [esp+64h] [ebp-18h]
    __int16 v18; // [esp+6Ch] [ebp-10h]
    int v19; // [esp+70h] [ebp-Ch]
    __int16 v20; // [esp+74h] [ebp-8h]
    char v21; // [esp+78h] [ebp-4h]

    v15 = 64 - a2[16];
    v20 = word_4CA1F0[0];
    v18 = word_4CA1F2;
    v14 = word_4CA1F4;
    v21 = byte_4CA210[0];
    v9 = byte_4CA211;
    v7 = *(_DWORD*)(*(_DWORD*)a2 + 12) - *(_DWORD*)(*(_DWORD*)a2 + 4);
    v19 = *(_DWORD*)(*(_DWORD*)a2 + 8) - **(_DWORD**)a2;
    v12 = (_WORD*)*((_DWORD*)a2 + 2);
    v6 = (_WORD*)*((_DWORD*)a2 + 3);
    v8 = a2[14];
    v10 = *((_DWORD*)a2 + 8);
    v13 = *((_DWORD*)a2 + 4);
    v11 = *((_DWORD*)a2 + 5);
    v16 = *((_DWORD*)a2 + 6);
    for (i = 0; ; ++i)
    {
        result = i;
        if (i >= v7)
            break;
        v3 = v12;
        v5 = v6;
        for (j = 0; j < v19; ++j)
        {
            if (!thisx[5] || *v12 != v8)
                *v6 = ((unsigned __int8)byte_4CA21C[64 * v10 + (unsigned __int16)(v14 & *v12)]
                    + (unsigned __int8)byte_4CA21C[64 * v15 + (unsigned __int16)(v14 & *v6)]) | (((unsigned __int8)byte_4CA21C[64 * v10 + (unsigned __int16)((int)(unsigned __int16)(v18 & *v12) >> v9)]
                        + (unsigned __int16)(unsigned __int8)byte_4CA21C[64 * v15 + (unsigned __int16)((int)(unsigned __int16)(v18 & *v6) >> v9)]) << v9) | (((unsigned __int8)byte_4CA21C[64 * v10 + (unsigned __int16)((int)(unsigned __int16)(v20 & *v12) >> v21)] + (unsigned __int16)(unsigned __int8)byte_4CA21C[64 * v15 + (unsigned __int16)((int)(unsigned __int16)(v20 & *v6) >> v21)]) << v21);
            v12 += v13;
            ++v6;
        }
        v12 = &v3[v11];
        v6 = &v5[v16];
    }
    return result;
}

 
int sub_49E561(_BYTE* thisx, int a2)
{
    int result; // eax
    _WORD* v3; // [esp+4h] [ebp-30h]
    int j; // [esp+8h] [ebp-2Ch]
    _WORD* v5; // [esp+Ch] [ebp-28h]
    _WORD* v6; // [esp+10h] [ebp-24h]
    int v7; // [esp+14h] [ebp-20h]
    __int16 v8; // [esp+18h] [ebp-1Ch]
    int v9; // [esp+1Ch] [ebp-18h]
    _WORD* v10; // [esp+20h] [ebp-14h]
    int v11; // [esp+24h] [ebp-10h]
    int v12; // [esp+28h] [ebp-Ch]
    int i; // [esp+2Ch] [ebp-8h]
    int v14; // [esp+30h] [ebp-4h]

    v7 = *(_DWORD*)(*(_DWORD*)a2 + 12) - *(_DWORD*)(*(_DWORD*)a2 + 4);
    v14 = *(_DWORD*)(*(_DWORD*)a2 + 8) - **(_DWORD**)a2;
    v10 = *(_WORD**)(a2 + 8);
    v6 = *(_WORD**)(a2 + 12);
    v8 = *(_WORD*)(a2 + 28);
    v11 = *(_DWORD*)(a2 + 16);
    v9 = *(_DWORD*)(a2 + 20);
    result = *(_DWORD*)(a2 + 24);
    v12 = result;
    for (i = 0; i < v7; ++i)
    {
        v3 = v10;
        v5 = v6;
        for (j = 0; j < v14; ++j)
        {
            if (!thisx[5] || *v10 != v8)
                *v6 = ((unsigned __int16)(word_4CB21C & *v6) + (unsigned __int16)(word_4CB21C & *v10)) >> 1;
            v10 += v11;
            ++v6;
        }
        v10 = &v3[v9];
        result = v12;
        v6 = &v5[v12];
    }
    return result;
}

 
int sub_49E6A3(_DWORD* thisx, int a2, int a3)
{
    int result; // eax
    _WORD* v5; // [esp+4h] [ebp-2A8h]
    int j; // [esp+8h] [ebp-2A4h]
    _WORD* v7; // [esp+Ch] [ebp-2A0h]
    CHAR Text[256]; // [esp+10h] [ebp-29Ch] BYREF
    int v9; // [esp+110h] [ebp-19Ch]
    _WORD* v10; // [esp+114h] [ebp-198h]
    int v11; // [esp+118h] [ebp-194h]
    unsigned int v12; // [esp+11Ch] [ebp-190h]
    unsigned int v13; // [esp+120h] [ebp-18Ch]
    int v14; // [esp+124h] [ebp-188h]
    int v15; // [esp+128h] [ebp-184h]
    int v16; // [esp+12Ch] [ebp-180h]
    int v17; // [esp+130h] [ebp-17Ch]
    char v18; // [esp+134h] [ebp-178h]
    _WORD* v19; // [esp+138h] [ebp-174h]
    int v20; // [esp+13Ch] [ebp-170h]
    int v21; // [esp+140h] [ebp-16Ch]
    int v22; // [esp+144h] [ebp-168h]
    int v23; // [esp+148h] [ebp-164h]
    int v24; // [esp+14Ch] [ebp-160h]
    int v25[4]; // [esp+150h] [ebp-15Ch] BYREF
    int v26; // [esp+160h] [ebp-14Ch]
    _WORD* v27; // [esp+174h] [ebp-138h]
    __int16 v28; // [esp+190h] [ebp-11Ch]
    char v29; // [esp+1CCh] [ebp-E0h]
    int v30; // [esp+1D0h] [ebp-DCh]
    int v31; // [esp+1D4h] [ebp-D8h]
    int v32; // [esp+1D8h] [ebp-D4h] BYREF
    int v33; // [esp+1DCh] [ebp-D0h]
    int v34; // [esp+1E0h] [ebp-CCh]
    int v35; // [esp+1E4h] [ebp-C8h]
    int v36; // [esp+1E8h] [ebp-C4h]
    int v37; // [esp+1ECh] [ebp-C0h]
    int v38; // [esp+1F0h] [ebp-BCh]
    int v39[31]; // [esp+1F4h] [ebp-B8h] BYREF
    int i; // [esp+270h] [ebp-3Ch]
    int v41; // [esp+274h] [ebp-38h]
    unsigned int v42; // [esp+278h] [ebp-34h]
    int v43; // [esp+27Ch] [ebp-30h]
    int v44; // [esp+280h] [ebp-2Ch]
    int v45; // [esp+284h] [ebp-28h]
    int v46; // [esp+288h] [ebp-24h] BYREF
    int v47; // [esp+28Ch] [ebp-20h]
    int v48; // [esp+290h] [ebp-1Ch]
    int v49; // [esp+294h] [ebp-18h]
    int v50; // [esp+298h] [ebp-14h]
    int v51; // [esp+29Ch] [ebp-10h]
    int v52; // [esp+2A0h] [ebp-Ch]
    int v53; // [esp+2A4h] [ebp-8h]
    char v54; // [esp+2A8h] [ebp-4h]

    v30 = 0;
    v41 = 0;
    v31 = 0;
    v45 = 0;
    v50 = 0;
    v15 = 0;
    v9 = *((unsigned __int16*)thisx + 3);
    v51 = *((unsigned __int16*)thisx + 4);
    if (**(_DWORD**)(a3 + 12) > *(_DWORD*)(a3 + 4))
        v45 = **(_DWORD**)(a3 + 12) - *(_DWORD*)(a3 + 4);
    if (*(_DWORD*)(*(_DWORD*)(a3 + 12) + 4) > *(_DWORD*)(a3 + 8))
        v31 = *(_DWORD*)(*(_DWORD*)(a3 + 12) + 4) - *(_DWORD*)(a3 + 8);
    if (*(_DWORD*)(*(_DWORD*)(a3 + 12) + 8) < v9 + *(_DWORD*)(a3 + 4))
        v41 = v9 + *(_DWORD*)(a3 + 4) - *(_DWORD*)(*(_DWORD*)(a3 + 12) + 8);
    if (*(_DWORD*)(*(_DWORD*)(a3 + 12) + 12) < v51 + *(_DWORD*)(a3 + 8))
        v30 = v51 + *(_DWORD*)(a3 + 8) - *(_DWORD*)(*(_DWORD*)(a3 + 12) + 12);
    if (*(_DWORD*)(a3 + 24))
    {
        v46 = v41;
        v48 = *((unsigned __int16*)thisx + 3) - v45;
    }
    else
    {
        v46 = v45;
        v48 = *((unsigned __int16*)thisx + 3) - v41;
    }
    if (*(_DWORD*)(a3 + 28))
    {
        v47 = v30;
        result = (int)thisx;
        v49 = *((unsigned __int16*)thisx + 4) - v31;
    }
    else
    {
        v47 = v31;
        result = *((unsigned __int16*)thisx + 4) - v30;
        v49 = result;
    }
    if (v46 < v48 && v47 < v49)
    {
        v32 = v45 + *(_DWORD*)(a3 + 4);
        v33 = v31 + *(_DWORD*)(a3 + 8);
        v34 = v9 + v32 - v45 - v41;
        v35 = v51 + v33 - v31 - v30;
        v25[0] = 124;
        v39[0] = 124;
        result = (*(int(__stdcall**)(_DWORD, int*, int*, int, _DWORD))(*(_DWORD*)*thisx + 100))(*thisx, &v46, v25, 1, 0);
        v52 = result;
        if (result)
        {
            if (v52 == -2147024809)
            {
                wsprintfA(Text, "LockError ( %d, %d )-( %d, %d )", v46, v47, v48, v49);
                return messagebox(Text);
            }
        }
        else
        {
            v52 = (*(int(__stdcall**)(int, int*, int*, int, _DWORD))(*(_DWORD*)a2 + 100))(a2, &v32, v39, 1, 0);
            if (v52)
            {
                (*(void(__stdcall**)(_DWORD, int*))(*(_DWORD*)*thisx + 128))(*thisx, &v46);
                return messagebox(aLockerror2_0);
            }
            else
            {
                v19 = v27;
                if (*(_DWORD*)(a3 + 24))
                    v19 = &v19[v48 - v46 - 1];
                if (*(_DWORD*)(a3 + 28))
                    v19 += v26 * (v49 - v47 - 1) / 2;
                v20 = (*(_DWORD*)(a3 + 24) == 0) - *(_DWORD*)(a3 + 24);
                v17 = v26 * ((*(_DWORD*)(a3 + 28) == 0) - *(_DWORD*)(a3 + 28)) / 2;
                v10 = (_WORD*)v39[9];
                v38 = v39[4] / 2;
                LOWORD(v16) = v28;
                v43 = v48 - v46;
                v14 = v49 - v47;
                LOWORD(v53) = word_4CA1F0[0];
                LOWORD(v44) = word_4CA1F2;
                LOWORD(v24) = word_4CA1F4;
                v54 = byte_4CA210[0];
                v18 = byte_4CA211;
                v29 = byte_4CA212;
                for (i = 0; i < v14; ++i)
                {
                    v5 = v19;
                    v7 = v10;
                    for (j = 0; j < v43; ++j)
                    {
                        if (!*((_BYTE*)thisx + 5) || (unsigned __int16)*v19 != (unsigned __int16)v16)
                        {
                            LOWORD(v22) = v53 & *v19;
                            LOWORD(v11) = v44 & *v19;
                            LOWORD(v23) = v24 & *v19;
                            LOWORD(v36) = v53 & *v10;
                            LOWORD(v21) = v44 & *v10;
                            LOWORD(v37) = v24 & *v10;
                            v12 = (unsigned __int16)v36 + (unsigned __int16)v22;
                            v42 = (unsigned __int16)v21 + (unsigned __int16)v11;
                            v13 = (unsigned __int16)v37 + (unsigned __int16)v23;
                            if (v12 > (unsigned __int16)v53)
                                v12 = (unsigned __int16)v53;
                            if (v42 > (unsigned __int16)v44)
                                v42 = (unsigned __int16)v44;
                            if (v13 > (unsigned __int16)v24)
                                v13 = (unsigned __int16)v24;
                            *v10 = v13 | v42 | v12;
                        }
                        v19 += v20;
                        ++v10;
                    }
                    v19 = &v5[v17];
                    v10 = &v7[v38];
                }
                (*(void(__stdcall**)(_DWORD, int*))(*(_DWORD*)*thisx + 128))(*thisx, &v46);
                return (*(int(__stdcall**)(int, int*))(*(_DWORD*)a2 + 128))(a2, &v32);
            }
        }
    }
    return result;
}

 
_DWORD* sub_49EDC1(int a1, int a2, _DWORD* a3, int a4)
{
    _DWORD* result; // eax
    int v6[25]; // [esp+4h] [ebp-1C8h] BYREF
    CHAR Text[256]; // [esp+68h] [ebp-164h] BYREF
    int v8[25]; // [esp+168h] [ebp-64h] BYREF

    result = (_DWORD*)a1;
    if (*(_BYTE*)(a1 + 50440))
    {
        if (!a3)
            a3 = (_DWORD*)(a1 + 50452);
        result = a3;
        if (*a3 < a3[2])
        {
            result = a3;
            if (a3[1] < a3[3])
            {
                result = (_DWORD*)a1;
                if (*(_BYTE*)(a1 + 50443))
                {
                    if (*(_DWORD*)(a1 + 50520))
                    {
                        memset(v8, 0, sizeof(v8));
                        v8[0] = 100;
                        v8[20] = a4;
                        result = (_DWORD*)(*(int(__thiscall**)(_DWORD, _DWORD, _DWORD*, _DWORD, _DWORD, int, int*))(**(_DWORD**)(a1 + 50520) + 20))(
                            *(_DWORD*)(a1 + 50520),
                            *(_DWORD*)(a1 + 50520),
                            a3,
                            0,
                            0,
                            16778240,
                            v8);
                        if (result)
                        {
                            wsprintfA(Text, aFillrect, *a3, a3[1], a3[2], a3[3]);
                            return (_DWORD*)messagebox(Text);
                        }
                    }
                }
                else if (*(_DWORD*)(a1 + 50516))
                {
                    memset(v6, 0, sizeof(v6));
                    v6[0] = 100;
                    v6[20] = a4;
                    result = (_DWORD*)(*(int(__thiscall**)(_DWORD, _DWORD, _DWORD*, _DWORD, _DWORD, int, int*))(**(_DWORD**)(a1 + 50516) + 20))(
                        *(_DWORD*)(a1 + 50516),
                        *(_DWORD*)(a1 + 50516),
                        a3,
                        0,
                        0,
                        16778240,
                        v6);
                    if (result)
                        return (_DWORD*)messagebox(byte_4B809C);
                }
                else
                {
                    return (_DWORD*)messagebox(aMPddsbackNull);
                }
            }
        }
    }
    return result;
}
int sub_49EF70(
    int thisx,
    _DWORD* a2,
    unsigned __int8 a3,
    unsigned __int8 a4,
    unsigned __int8 a5,
    unsigned __int8 a6)
{
    int result; // eax
    unsigned int* v7; // [esp+8h] [ebp-110h]
    int i; // [esp+Ch] [ebp-10Ch]
    int j; // [esp+10h] [ebp-108h]
    unsigned int* v10; // [esp+14h] [ebp-104h]
    int v11; // [esp+18h] [ebp-100h]
    int m; // [esp+34h] [ebp-E4h]
    _WORD* v13; // [esp+38h] [ebp-E0h]
    int k; // [esp+3Ch] [ebp-DCh]
    unsigned __int16 v15; // [esp+40h] [ebp-D8h]
    _WORD* v16; // [esp+44h] [ebp-D4h]
    int v17; // [esp+48h] [ebp-D0h]
    int v18; // [esp+50h] [ebp-C8h]
    char v19; // [esp+54h] [ebp-C4h]
    int v20; // [esp+5Ch] [ebp-BCh]
    unsigned __int16 v21; // [esp+60h] [ebp-B8h]
    unsigned __int16 v22; // [esp+64h] [ebp-B4h]
    __int16 v23; // [esp+68h] [ebp-B0h]
    unsigned __int16 v24; // [esp+70h] [ebp-A8h]
    unsigned __int16 v25; // [esp+78h] [ebp-A0h]
    int v26; // [esp+7Ch] [ebp-9Ch]
    int v27; // [esp+7Ch] [ebp-9Ch]
    int v28[9]; // [esp+80h] [ebp-98h] BYREF
    _WORD* v29; // [esp+A4h] [ebp-74h]
    int v30; // [esp+FCh] [ebp-1Ch]
    int v31; // [esp+100h] [ebp-18h]
    int v32; // [esp+104h] [ebp-14h]
    int v33; // [esp+108h] [ebp-10h]
    int v34; // [esp+10Ch] [ebp-Ch]
    int v35; // [esp+110h] [ebp-8h]
    char v36; // [esp+114h] [ebp-4h]

    result = thisx;
    if (*(_BYTE*)(thisx + 50440))
    {
        if (*(_BYTE*)(thisx + 50443))
            v20 = *(_DWORD*)(thisx + 50520);
        else
            v20 = *(_DWORD*)(thisx + 50516);
        if (*a2 < *(_DWORD*)(thisx + 50452))
            *a2 = *(_DWORD*)(thisx + 50452);
        if (a2[1] < *(_DWORD*)(thisx + 50456))
            a2[1] = *(_DWORD*)(thisx + 50456);
        if (a2[2] > *(_DWORD*)(thisx + 50460))
            a2[2] = *(_DWORD*)(thisx + 50460);
        if (a2[3] > *(_DWORD*)(thisx + 50464))
            a2[3] = *(_DWORD*)(thisx + 50464);
        v28[0] = 124;
        result = (*(int(__stdcall**)(int, _DWORD*, int*, int, _DWORD))(*(_DWORD*)v20 + 100))(v20, a2, v28, 1, 0);
        v33 = result;
        if (!result)
        {
            v21 = (int)a3 >> (8 - byte_4CA218[0]);
            //v15 = (int)a4 >> (8 - byte_4CA219);
            v15 = (int)a4 >> (8 - byte_4CA214[2]);
            v22 = (int)a5 >> (8 - byte_4CA21A);
            v34 = v22 | (v15 << byte_4CA211) | (v21 << byte_4CA210[0]);
            v24 = 64 - a6;
            LOWORD(v35) = word_4CA1F0[0];
            LOWORD(v31) = word_4CA1F2;
            v23 = word_4CA1F4;
            v36 = byte_4CA210[0];
            v19 = byte_4CA211;
            v18 = a2[3] - a2[1];
            v32 = a2[2] - *a2;
            v16 = v29;
            v26 = v28[4] / 2;
            if (a6 == 32 && !v34)
            {
                v7 = (unsigned int*)v29;
                v11 = (unsigned __int16)word_4CB21C | ((unsigned __int16)word_4CB21C << 16);
                v32 /= 2;
                v27 = v26 / 2;
                for (i = 0; i < v18; ++i)
                {
                    v10 = v7;
                    for (j = 0; j < v32; ++j)
                    {
                        *v7 = (v11 & *v7) >> 1;
                        ++v7;
                    }
                    v7 = &v10[v27];
                }
            }
            else
            {
                for (k = 0; k < v18; ++k)
                {
                    v13 = v16;
                    for (m = 0; m < v32; ++m)
                    {
                        v25 = v23 & *v16;
                        v17 = ((unsigned __int8)byte_4CA21C[64 * a6 + v21]
                            + (unsigned __int8)byte_4CA21C[64 * v24
                            + (unsigned __int16)((int)(unsigned __int16)(v35 & *v16) >> v36)]) << v36;
                        v30 = ((unsigned __int8)byte_4CA21C[64 * a6 + v15]
                            + (unsigned __int8)byte_4CA21C[64 * v24
                            + (unsigned __int16)((int)(unsigned __int16)(v31 & *v16) >> v19)]) << v19;
                        *v16++ = ((unsigned __int8)byte_4CA21C[64 * a6 + v22] + (unsigned __int8)byte_4CA21C[64 * v24 + v25]) | v30 | v17;
                    }
                    v16 = &v13[v26];
                }
            }
            return (*(int(__stdcall**)(int, _DWORD*))(*(_DWORD*)v20 + 128))(v20, a2);
        }
    }
    return result;
} 
int sub_49F638(_DWORD* thisx, int a2, int a3, int* a4)
{
    int result; // eax
    _WORD* v6; // [esp+4h] [ebp-3D4h]
    _WORD* v7; // [esp+8h] [ebp-3D0h]
    CHAR v8[256]; // [esp+Ch] [ebp-3CCh] BYREF
    CHAR Text[256]; // [esp+10Ch] [ebp-2CCh] BYREF
    int v10; // [esp+20Ch] [ebp-1CCh]
    int v11; // [esp+210h] [ebp-1C8h]
    int v12; // [esp+214h] [ebp-1C4h]
    _WORD* v13; // [esp+218h] [ebp-1C0h]
    int v14; // [esp+21Ch] [ebp-1BCh]
    int v15; // [esp+220h] [ebp-1B8h]
    int v16; // [esp+224h] [ebp-1B4h]
    int v17; // [esp+228h] [ebp-1B0h]
    int v18; // [esp+22Ch] [ebp-1ACh]
    int v19; // [esp+230h] [ebp-1A8h]
    int v20; // [esp+234h] [ebp-1A4h]
    int v21; // [esp+238h] [ebp-1A0h]
    char v22; // [esp+23Ch] [ebp-19Ch]
    __int16 v23; // [esp+240h] [ebp-198h]
    __int16 v24; // [esp+244h] [ebp-194h]
    _WORD* v25; // [esp+248h] [ebp-190h]
    int v26; // [esp+24Ch] [ebp-18Ch]
    int v27; // [esp+254h] [ebp-184h]
    int v28; // [esp+258h] [ebp-180h]
    int v29; // [esp+25Ch] [ebp-17Ch]
    int v30[4]; // [esp+260h] [ebp-178h] BYREF
    int v31; // [esp+270h] [ebp-168h]
    _WORD* v32; // [esp+284h] [ebp-154h]
    __int16 v33; // [esp+2A0h] [ebp-138h]
    char v34; // [esp+2DCh] [ebp-FCh]
    int v35; // [esp+2E0h] [ebp-F8h]
    int v36; // [esp+2E4h] [ebp-F4h]
    char v37; // [esp+2E8h] [ebp-F0h]
    int v38; // [esp+2ECh] [ebp-ECh]
    int v39; // [esp+2F0h] [ebp-E8h] BYREF
    int v40; // [esp+2F4h] [ebp-E4h]
    int v41; // [esp+2F8h] [ebp-E0h]
    int v42; // [esp+2FCh] [ebp-DCh]
    int v43; // [esp+308h] [ebp-D0h]
    __int16 v44; // [esp+30Ch] [ebp-CCh]
    int v45[31]; // [esp+310h] [ebp-C8h] BYREF
    int i; // [esp+38Ch] [ebp-4Ch]
    int v47; // [esp+390h] [ebp-48h]
    int v48; // [esp+394h] [ebp-44h]
    int v49; // [esp+398h] [ebp-40h]
    int v50; // [esp+39Ch] [ebp-3Ch]
    int j; // [esp+3A0h] [ebp-38h]
    int v52; // [esp+3A4h] [ebp-34h]
    int v53; // [esp+3A8h] [ebp-30h] BYREF
    int v54; // [esp+3ACh] [ebp-2Ch]
    int v55; // [esp+3B0h] [ebp-28h]
    int v56; // [esp+3B4h] [ebp-24h]
    int v57; // [esp+3B8h] [ebp-20h]
    int v58; // [esp+3BCh] [ebp-1Ch]
    int v59; // [esp+3C0h] [ebp-18h]
    int v60; // [esp+3C4h] [ebp-14h]
    int v61; // [esp+3C8h] [ebp-10h]
    char v62; // [esp+3CCh] [ebp-Ch]
    int v63; // [esp+3D0h] [ebp-8h]
    __int16 v64; // [esp+3D4h] [ebp-4h]

    v36 = 0;
    v47 = 0;
    v38 = 0;
    v52 = 0;
    v58 = 0;
    v19 = 0;
    v10 = *((unsigned __int16*)thisx + 3);
    v59 = *((unsigned __int16*)thisx + 4);
    if (a4)
    {
        v10 = a4[2];
        v59 = a4[3];
    }
    if (a4)
    {
        v53 = *a4;
        v54 = a4[1];
        v55 = a4[2] + v53;
        v56 = a4[3] + v54;
    }
    else
    {
        v53 = 0;
        v54 = 0;
        v55 = *((unsigned __int16*)thisx + 3);
        v56 = *((unsigned __int16*)thisx + 4);
    }
    if (**(_DWORD**)(a3 + 12) > *(_DWORD*)(a3 + 4))
        v52 = **(_DWORD**)(a3 + 12) - *(_DWORD*)(a3 + 4);
    if (*(_DWORD*)(*(_DWORD*)(a3 + 12) + 4) > *(_DWORD*)(a3 + 8))
        v38 = *(_DWORD*)(*(_DWORD*)(a3 + 12) + 4) - *(_DWORD*)(a3 + 8);
    if (*(_DWORD*)(*(_DWORD*)(a3 + 12) + 8) < v10 + *(_DWORD*)(a3 + 4))
        v47 = v10 + *(_DWORD*)(a3 + 4) - *(_DWORD*)(*(_DWORD*)(a3 + 12) + 8);
    if (*(_DWORD*)(*(_DWORD*)(a3 + 12) + 12) < v59 + *(_DWORD*)(a3 + 8))
        v36 = v59 + *(_DWORD*)(a3 + 8) - *(_DWORD*)(*(_DWORD*)(a3 + 12) + 12);
    if (*(_DWORD*)(a3 + 24))
        v53 += v47;
    else
        v53 += v52;
    v55 = v10 + v53 - v52 - v47;
    if (*(_DWORD*)(a3 + 28))
        v54 += v36;
    else
        v54 += v38;
    v56 = v59 + v54 - v38 - v36;
    result = v53;
    if (v53 < v55 && v54 < v56)
    {
        v39 = v52 + *(_DWORD*)(a3 + 4);
        v40 = v38 + *(_DWORD*)(a3 + 8);
        v41 = v10 + v39 - v52 - v47;
        v42 = v59 + v40 - v38 - v36;
        v30[0] = 124;
        v45[0] = 124;
        result = (*(int(**)(_DWORD, _DWORD, int*, int*, int, _DWORD))(*(_DWORD*)*thisx + 100))(
            *thisx,
            *thisx,
            &v53,
            v30,
            1,
            0);
        v60 = result;
        if (result)
        {
            if (v60 == -2147024809)
            {
                wsprintfA(Text, "LockError ( %d, %d )-( %d, %d )", v53, v54, v55, v56);
                return messagebox(Text);
            }
        }
        else
        {
            v60 = (*(int(__stdcall**)(int, int*, int*, int, _DWORD))(*(_DWORD*)a2 + 100))(a2, &v39, v45, 1, 0);
            if (v60)
            {
                (*(void(**)(_DWORD, _DWORD, int*))(*(_DWORD*)*thisx + 128))(*thisx, *thisx, &v53);
                wsprintfA(v8, "LockError! 2 (%d,%d)-(%d,%d)", v39, v40, v41, v42);
                return messagebox(v8);
            }
            else
            {
                v25 = v32;
                if (*(_DWORD*)(a3 + 24))
                    v25 = &v25[v55 - v53 - 1];
                if (*(_DWORD*)(a3 + 28))
                    v25 += v31 * (v56 - v54 - 1) / 2;
                v26 = (*(_DWORD*)(a3 + 24) == 0) - *(_DWORD*)(a3 + 24);
                v21 = v31 * ((*(_DWORD*)(a3 + 28) == 0) - *(_DWORD*)(a3 + 28)) / 2;
                v13 = (_WORD*)v45[9];
                v43 = v45[4] / 2;
                LOWORD(v20) = v33;
                v49 = v55 - v53;
                v18 = v56 - v54;
                LOWORD(v61) = word_4CA1F0[0];
                LOWORD(v50) = word_4CA1F2;
                LOWORD(v29) = word_4CA1F4;
                v62 = byte_4CA210[0];
                v22 = byte_4CA211;
                v34 = byte_4CA212;
                LOWORD(v11) = (int)(unsigned __int16)word_4CA1F0[0] >> byte_4CA210[0];
                LOWORD(v35) = (int)(unsigned __int16)word_4CA1F2 >> byte_4CA211;
                LOWORD(v15) = (int)(unsigned __int16)word_4CA1F4 >> byte_4CA212;
                v37 = *(_BYTE*)(a3 + 45);
                v23 = *(_WORD*)(a3 + 46);
                v64 = *(_WORD*)(a3 + 48);
                v24 = *(_WORD*)(a3 + 50);
                if ((v37 == 1 || v37 == 3 || v37 == 4) && byte_4CA210[0] == 11)
                    v64 = 2 * v64 + 1;
                v44 = (v24 << v34) | (v64 << v22) | (v23 << v62);
                for (i = 0; i < v18; ++i)
                {
                    v6 = v25;
                    v7 = v13;
                    for (j = 0; j < v49; ++j)
                    {
                        if (!*((_BYTE*)thisx + 5) || (unsigned __int16)*v25 != (unsigned __int16)v20)
                        {
                            if (v37 == 4)
                            {
                                *v13 = v44;
                            }
                            else
                            {
                                LOWORD(v27) = v61 & *v25;
                                LOWORD(v14) = v50 & *v25;
                                LOWORD(v28) = v29 & *v25;
                                if (v37 == 1 || v37 == 3)
                                {
                                    LOWORD(v27) = (unsigned __int16)v27 >> v62;
                                    LOWORD(v14) = (unsigned __int16)v14 >> v22;
                                    LOWORD(v28) = (unsigned __int16)v28 >> v34;
                                    v12 = v23 + (unsigned __int16)v27;
                                    v63 = v64 + (unsigned __int16)v14;
                                    v57 = v24 + (unsigned __int16)v28;
                                    if (v37 == 3)
                                    {
                                        v12 /= 2;
                                        v63 /= 2;
                                        v57 /= 2;
                                    }
                                    if (v12 <= (unsigned __int16)v11)
                                    {
                                        if (v12 >= 0)
                                            v16 = v12;
                                        else
                                            v16 = 0;
                                    }
                                    else
                                    {
                                        v16 = (unsigned __int16)v11;
                                    }
                                    if (v63 <= (unsigned __int16)v35)
                                    {
                                        if (v63 >= 0)
                                            v48 = v63;
                                        else
                                            v48 = 0;
                                    }
                                    else
                                    {
                                        v48 = (unsigned __int16)v35;
                                    }
                                    if (v57 <= (unsigned __int16)v15)
                                    {
                                        if (v57 >= 0)
                                            v17 = v57;
                                        else
                                            v17 = 0;
                                    }
                                    else
                                    {
                                        v17 = (unsigned __int16)v15;
                                    }
                                    v16 <<= v62;
                                    v48 <<= v22;
                                    v17 <<= v34;
                                }
                                else if (v37 == 2)
                                {
                                    v16 = (unsigned __int16)v61 & (v23 * (unsigned __int16)v27 / 100);
                                    v48 = (unsigned __int16)v50 & (v64 * (unsigned __int16)v14 / 100);
                                    v17 = (unsigned __int16)v29 & (v24 * (unsigned __int16)v28 / 100);
                                }
                                *v13 = v17 | v48 | v16;
                            }
                        }
                        v25 += v26;
                        ++v13;
                    }
                    v25 = &v6[v21];
                    v13 = &v7[v43];
                }
                (*(void(**)(_DWORD, _DWORD, int*))(*(_DWORD*)*thisx + 128))(*thisx, *thisx, &v53);
                return (*(int(__stdcall**)(int, int*))(*(_DWORD*)a2 + 128))(a2, &v39);
            }
        }
    }
    return result;
}
 
unsigned int __stdcall sub_49FFEC(unsigned __int8 a1, unsigned __int8 a2, unsigned __int8 a3)
{
    int j; // [esp+4h] [ebp-28h]
    int v5; // [esp+8h] [ebp-24h]
    int i; // [esp+14h] [ebp-18h]
    int v7[3]; // [esp+20h] [ebp-Ch]

    for (i = 0; i < 3; ++i)
    {
        v5 = 8 - byte_4CA218[i];
        v7[i] = 1;
        for (j = 0; j < v5; ++j)
            v7[i] *= 2;
    }
    return (((unsigned int)a3 / v7[2]) << byte_4CA212) | (((unsigned int)a2 / v7[1]) << byte_4CA211) | (((unsigned int)a1 / v7[0]) << byte_4CA210[0]);
}

 
int sub_4A00C6(int thisx, int* a2, int a3, _DWORD* a4)
{
    int result; // eax
    unsigned __int16 v5; // ax
    int v6; // eax
    int v7; // [esp-4h] [ebp-38h]
    int v9; // [esp+Ch] [ebp-28h]
    struct tagRECT rc; // [esp+10h] [ebp-24h] BYREF
    struct tagRECT v11; // [esp+20h] [ebp-14h] BYREF
    int v12; // [esp+30h] [ebp-4h]

    result = thisx;
    if (*(_BYTE*)(thisx + 50440) || a2[9] >= 0)
    {
        result = (int)a2;
        if (*a2 >= 0 && *a2 < 2048)
        {
            if (a2[9] >= 0)
            {
                if (a2[9] >= 2048)
                    return result;
                v7 = (unsigned __int16)sub_48E130((_WORD*)(thisx + 24 * a2[9]));
                v5 = sub_4260F0((short*)thisx + 24 * a2[9]);
                SetRect(&rc, 0, 0, v5, v7);
                a2[3] = (int)&rc;
            }
            else
            {
                a2[3] = thisx + 50452;
            }
            LOWORD(v12) = sub_4260F0((short*)thisx + 24 * *a2);
            v12 = (unsigned __int16)v12;
            v9 = (unsigned __int16)sub_48E130((_WORD*)(thisx + 24 * *a2));
            result = a3;
            if (a3 < v9 * (v12 / 8) / 8)
            {
                SetRect(&v11, 8 * (a3 % (v12 / 8)), 8 * (a3 / (v12 / 8)), 8, 8);
                if (a4)
                {
                    v11.top += a4[1];
                    v11.left += *a4;
                    v11.bottom = a4[3];
                    v11.right = a4[2];
                }
                if (a2[9] >= 0)
                {
                    v6 = unknown_libname_30((_DWORD*)(void*)(24 * a2[9] + thisx));
                    return sub_49C541((_DWORD*)(24 * *a2 + thisx), v6, (int)a2, (tagRECT*)(_DWORD*)&v11);
                }
                else if (*(_BYTE*)(thisx + 50443))
                {
                    return sub_49C541((_DWORD*)(thisx + 24 * *a2), *(_DWORD*)(thisx + 50520), (int)a2, (tagRECT*)(_DWORD*)&v11);
                }
                else
                {
                    return sub_49C541((_DWORD*)(24 * *a2 + thisx), *(_DWORD*)(thisx + 50516), (int)a2, (tagRECT*)(_DWORD*)&v11);
                }
            }
        }
    }
    return result;
}

 
_DWORD* __fastcall sub_4A02E9(_DWORD* thisx, int edx0, int a1, int a2, int a3)
{
    _DWORD* result; // eax

    if (a3 == -1)
        return sub_49EDC1((int)thisx, edx0, (_DWORD*)a1, a2);
    if (a3 >= 0 && a3 < 2048)
        return sub_4A0337(&thisx[6 * a3], (_DWORD*)a1, a2);
    return result;
}
 
_DWORD* sub_4A0337(_DWORD* thisx, _DWORD* a2, int a3)
{
    _DWORD* result; // eax
    int v5[25]; // [esp+4h] [ebp-64h] BYREF

    if (!a2 || (result = a2, *a2 < a2[2]) && (result = a2, a2[1] < a2[3]))
    {
        result = thisx;
        if (*thisx)
        {
            memset(v5, 0, sizeof(v5));
            v5[0] = 100;
            v5[20] = a3;
            return (_DWORD*)(*(int(__stdcall**)(_DWORD, _DWORD*, _DWORD, _DWORD, int, int*))(*(_DWORD*)*thisx + 20))(
                *thisx,
                a2,
                0,
                0,
                16778240,
                v5);
        }
    }
    return result;
} 
void sub_4A03B3(_WORD* thisx, int a2, int* a3, _DWORD* a4)
{
    int v4; // eax
    int v6[2]; // [esp+4h] [ebp-10h] BYREF
    int v7; // [esp+Ch] [ebp-8h]
    int v8; // [esp+10h] [ebp-4h]

    if (a2 >= 0)
    {
        if (*a3 < 2048 && a2 < 2048)
        {
            v6[1] = 0;
            v6[0] = 0;
            LOWORD(v7) = sub_4260F0(&thisx[12 * a2]);
            v7 = (unsigned __int16)v7;
            LOWORD(v8) = sub_48E130(&thisx[12 * a2]);
            v8 = (unsigned __int16)v8;
            a3[3] = (int)v6;
            v4 = unknown_libname_30((_DWORD*)&thisx[12 * a2]);
            sub_49C541((_DWORD*)&thisx[12 * *a3], v4, (int)a3, (tagRECT*)a4);
        }
    }
    else
    {
        sub_49C8A6((int)thisx, a3, a4);
    }
}

void sub_4A0A0D(void* thisx)
{
    *(_DWORD*)thisx = 0;
    *((_WORD*)thisx + 2) = 0;
}



 
void  sub_4A0A2D(void* thisx)
{
	sub_4A0A40((int)thisx);
}
 
int sub_4A0A40(int thisx)
{
    int result; // eax

    result = thisx;
    if (*(_DWORD*)thisx)
        operator delete(*(void**)thisx);
    *(_DWORD*)thisx = 0;
    *(_WORD*)(thisx + 4) = 0;
    return result;
}

 
int sub_4A0A7B(int thisx, unsigned __int16 a2)
{
    sub_4A0A40(thisx);
    *(_DWORD*)thisx = (_DWORD)operator new(2 * a2);
    if (!*(_DWORD*)thisx)
        return 0;
    *(_WORD*)(thisx + 4) = a2;
    memset(*(void**)thisx, 0, 2 * a2);
    return 1;
}
 
int sub_4A0AE7(void* thisx, int a1, __int16 a2)
{
    if (!sub_4A0A7B((int)thisx, a2))
        return 0;
    sub_4A0C45((unsigned __int16*)thisx, a1, a2);
    return 1;
}

unsigned __int16* sub_4A0B26(
    unsigned __int16* thisx,
    unsigned __int8 a2,
    unsigned __int8 a3,
    unsigned __int8 a4,
    unsigned __int8 a5)
{
    unsigned __int16* result; // eax
    int j; // [esp+4h] [ebp-28h]
    int v7; // [esp+8h] [ebp-24h]
    int i; // [esp+14h] [ebp-18h]
    int v9[3]; // [esp+20h] [ebp-Ch]

    result = thisx;
    if (thisx[2] > (int)a2)
    {
        for (i = 0; i < 3; ++i)
        {
            v7 = 8 - byte_4CA218[i];
            v9[i] = 1;
            for (j = 0; j < v7; ++j)
                v9[i] *= 2;
        }
        result = *(unsigned __int16**)thisx;
        *(_WORD*)(*(_DWORD*)thisx + 2 * a2) = (((unsigned int)a5 / v9[2]) << byte_4CA212) | (((unsigned int)a4 / v9[1]) << byte_4CA211) | (((unsigned int)a3 / v9[0]) << (int)byte_4CA210);
    }
    return result;
} 
int sub_4A0C45(unsigned __int16* thisx, int a1, unsigned __int16 a2)
{
    int result; // eax
    int i; // [esp+4h] [ebp-4h]

    for (i = 0; i < a2; ++i)
    {
        sub_4A0B26(thisx, i, *(_BYTE*)(a1 + 4 * i + 2), *(_BYTE*)(a1 + 4 * i + 1), *(_BYTE*)(a1 + 4 * i));
        result = i + 1;
    }
    return result;
}
 
int sub_4A0CA2(int thisx, int a2, int a3, struct tagRECT* p_rc)
{
    int result; // eax
    unsigned __int8 v6; // [esp+8h] [ebp-108h]
    unsigned __int8* v7; // [esp+Ch] [ebp-104h]
    LONG j; // [esp+10h] [ebp-100h]
    _WORD* v9; // [esp+14h] [ebp-FCh]
    int v10; // [esp+18h] [ebp-F8h]
    int v11; // [esp+1Ch] [ebp-F4h]
    int v12; // [esp+20h] [ebp-F0h]
    int v13; // [esp+24h] [ebp-ECh]
    int v14; // [esp+28h] [ebp-E8h]
    int v15; // [esp+2Ch] [ebp-E4h]
    int bottom; // [esp+30h] [ebp-E0h]
    int v17; // [esp+34h] [ebp-DCh]
    int v18; // [esp+38h] [ebp-D8h]
    int v19; // [esp+3Ch] [ebp-D4h]
    LONG right; // [esp+40h] [ebp-D0h]
    LONG left; // [esp+44h] [ebp-CCh]
    LONG top; // [esp+48h] [ebp-C8h]
    int v23; // [esp+5Ch] [ebp-B4h]
    int v24; // [esp+60h] [ebp-B0h]
    int v25; // [esp+64h] [ebp-ACh]
    int v26[4]; // [esp+68h] [ebp-A8h] BYREF
    __int16 v27; // [esp+78h] [ebp-98h]
    int v28[31]; // [esp+7Ch] [ebp-94h] BYREF
    int i; // [esp+F8h] [ebp-18h]
    struct tagRECT rc; // [esp+FCh] [ebp-14h] BYREF
    int v31; // [esp+10Ch] [ebp-4h]

    result = thisx;
    if (*(_DWORD*)(thisx + 16) && *(_DWORD*)(thisx + 12))
    {
        if (!p_rc)
        {
            SetRect(&rc, 0, 0, *(unsigned __int16*)(thisx + 6), *(unsigned __int16*)(thisx + 8));
            p_rc = &rc;
        }
        left = p_rc->left;
        top = p_rc->top;
        v15 = *(_DWORD*)(a3 + 4);
        v14 = *(_DWORD*)(a3 + 8);
        right = p_rc->right;
        bottom = p_rc->bottom;
        if (**(_DWORD**)(a3 + 12) > v15)
        {
            v13 = **(_DWORD**)(a3 + 12) - v15;
            v15 = **(_DWORD**)(a3 + 12);
            right -= v13;
            if (!*(_DWORD*)(a3 + 24))
                left += v13;
        }
        if (*(_DWORD*)(*(_DWORD*)(a3 + 12) + 4) > v14)
        {
            v12 = *(_DWORD*)(*(_DWORD*)(a3 + 12) + 4) - v14;
            v14 = *(_DWORD*)(*(_DWORD*)(a3 + 12) + 4);
            bottom -= v12;
            if (!*(_DWORD*)(a3 + 28))
                top += v12;
        }
        if (*(_DWORD*)(*(_DWORD*)(a3 + 12) + 8) < v15 + right)
        {
            v11 = v15 + right - *(_DWORD*)(*(_DWORD*)(a3 + 12) + 8);
            right = *(_DWORD*)(*(_DWORD*)(a3 + 12) + 8) - v15;
            if (*(_DWORD*)(a3 + 24))
                left += v11;
        }
        if (*(_DWORD*)(*(_DWORD*)(a3 + 12) + 12) < v14 + bottom)
        {
            v10 = v14 + bottom - *(_DWORD*)(*(_DWORD*)(a3 + 12) + 12);
            bottom = *(_DWORD*)(*(_DWORD*)(a3 + 12) + 12) - v14;
            if (*(_DWORD*)(a3 + 28))
                top += v10;
        }
        v26[0] = v15;
        v26[1] = v14;
        v26[2] = right + v15;
        v26[3] = bottom + v14;
        v28[0] = 124;
        result = (*(int(__stdcall**)(int, int*, int*, int, _DWORD))(*(_DWORD*)a2 + 100))(a2, v26, v28, 1, 0);
        v31 = result;
        if (!result)
        {
            v17 = v28[9];
            v25 = v28[4] / 2;
            v27 = *(_WORD*)(a3 + 40);
            v18 = *(unsigned __int16*)(thisx + 6) * ((bottom - 1) * *(_DWORD*)(a3 + 28) + top)
                + (right - 1) * *(_DWORD*)(a3 + 24)
                + left
                + *(_DWORD*)(thisx + 12);
            v24 = 1 - 2 * *(_DWORD*)(a3 + 24);
            v23 = *(unsigned __int16*)(thisx + 6) * (1 - 2 * *(_DWORD*)(a3 + 28));
            v19 = unknown_libname_30((_DWORD*)*(_DWORD*)(thisx + 16));
            if (*(_DWORD*)(a3 + 52))
                v19 = unknown_libname_30((_DWORD*)*(_DWORD*)(a3 + 52));
            for (i = 0; i < bottom; ++i)
            {
                v7 = (unsigned __int8*)v18;
                v9 = (_WORD*)v17;
                for (j = 0; j < right; ++j)
                {
                    v6 = *v7;
                    if (!*(_BYTE*)(thisx + 5) || v6)
                        *v9 = *(_WORD*)(v19 + 2 * v6);
                    v7 += v24;
                    ++v9;
                }
                v18 += v23;
                v17 += 2 * v25;
            }
            return (*(int(__stdcall**)(int, int*))(*(_DWORD*)a2 + 128))(a2, v26);
        }
    }
    return result;
}
 
int sub_4A1216(int thisx, int a2, int a3, int a4)
{
    if (a2 <= 0 || a3 <= 0 || !a4)
        return 0;
    if (*(_DWORD*)(thisx + 12))
        operator delete(*(void**)(thisx + 12));
    *(_DWORD*)(thisx + 12) = (_DWORD)operator new(a3 * a2);
    *(_DWORD*)(thisx + 16) = a4;
    *(_WORD*)(thisx + 6) = a2;
    *(_WORD*)(thisx + 8) = a3;
    return 1;
}

 
int sub_4A1299(int thisx, int a2, size_t Size, int a4)
{
    int i; // [esp+4h] [ebp-4h]

    if (!*(_DWORD*)(thisx + 12))
        return 0;
    for (i = 0; i < a4; ++i)
        memcpy((void*)(*(unsigned __int16*)(thisx + 6) * i + *(_DWORD*)(thisx + 12)), (const void*)(Size * i + a2), Size);
    return 1;
}

 
void sub_4A1307(int thisx, HardwareAffinity* a2)
{
    int v2; // esi
    unsigned __int16 Group; // ax
    const void* v4; // eax
    size_t v5; // [esp-4h] [ebp-Ch]

    if (a2)
    {
        v2 = *(unsigned __int16*)(thisx + 4);
        if (v2 != GetGroup(a2))
        {
            sub_4A0A40(thisx);
            Group = GetGroup(a2);
            sub_4A0A7B(thisx, Group);
        }
        v5 = 2 * *(unsigned __int16*)(thisx + 4);
        v4 = (const void*)unknown_libname_30((_DWORD*)a2);
        memcpy(*(void**)thisx, v4, v5);
    }
}

 
_BYTE* sub_4A1376(_BYTE* thisx, char a2)
{
    _BYTE* result; // eax

    result = thisx;
    thisx[50445] = a2;
    return result;
}

 
void* sub_4A1390(void* thisx, char a2)
{
    sub_4A148B((void**)thisx);
    if ((a2 & 1) != 0)
        operator delete(thisx);
    return thisx;
}
 
char sub_4A13C0(_BYTE* thisx)
{
    return thisx[1344];
}

 
int sub_4A1430(_DWORD* thisx)
{
    return thisx[338];
}
 
_DWORD* sub_4A1450(_DWORD* thisx)
{
    memset(thisx + 16, 0, 0x400u);
    thisx[15] = 0;
    thisx[337] = 0;
    return thisx;
}
 
void sub_4A148B(void** thisx)
{
    if (thisx[15])
    {
        operator delete(thisx[15]);
        thisx[15] = 0;
    }
}
 
int sub_4A14C0(_WORD* thisx, LPCSTR lpFileName)
{
    int v4; // [esp+Ch] [ebp-10h]
    HANDLE hFile; // [esp+10h] [ebp-Ch]
    int v6; // [esp+14h] [ebp-8h]
    DWORD NumberOfBytesRead; // [esp+18h] [ebp-4h] BYREF

    hFile = CreateFileA(lpFileName, 0x80000000, 0, 0, 3u, 0x80u, 0);
    if (hFile == (HANDLE)-1)
        return 0;
    ReadFile(hFile, thisx, 0xEu, (LPDWORD)&NumberOfBytesRead, 0);
    if (NumberOfBytesRead != 14 || *thisx != 19778)
        return 0;
    ReadFile(hFile, thisx + 8, 0x28u, (LPDWORD)&NumberOfBytesRead, 0);
    if (NumberOfBytesRead != 40)
        return 0;
    if (thisx[15] != 8)
        return 0;
    if (*((_DWORD*)thisx + 8))
        return 0;
    v6 = *((_DWORD*)thisx + 12);
    if (!v6)
    {
        *((_DWORD*)thisx + 12) = 256;
        v6 = 256;
    }
    *((_DWORD*)thisx + 14) = (*((_DWORD*)thisx + 5) + 3) & 0xFFFFFFFC;
    if (!*((_DWORD*)thisx + 9))
    {
        v4 = *((_DWORD*)thisx + 6);
        if (v4 < 0)
            v4 = -v4;
        *((_DWORD*)thisx + 9) = v4 * *((_DWORD*)thisx + 14);
    }
    memset(thisx + 32, 0, 0x400u);
    ReadFile(hFile, thisx + 32, 4 * v6, (LPDWORD)&NumberOfBytesRead, 0);
    if (*((_DWORD*)thisx + 15))
        operator delete(*((void**)thisx + 15));
    *((_DWORD*)thisx + 15) = (_DWORD)operator new(*((_DWORD*)thisx + 9));
    SetFilePointer(hFile, *(_DWORD*)(thisx + 5), 0, 0);
    ReadFile(hFile, *((LPVOID*)thisx + 15), *((_DWORD*)thisx + 9), (LPDWORD)&NumberOfBytesRead, 0);
    *((_BYTE*)thisx + 1344) = 0;
    CloseHandle(hFile);
    return 1;
}
 
int sub_4A1694(int thisx, void* a2, int a3, int a4, size_t Size, int a6)
{
    int i; // [esp+4h] [ebp-10h]
    int v9; // [esp+8h] [ebp-Ch]
    int v10; // [esp+Ch] [ebp-8h]

    if (*(_BYTE*)(thisx + 1344))
        return sub_4A1C28((_DWORD*)thisx, a2, Size, a6, 1);
    v10 = *(_DWORD*)(thisx + 24);
    if (*(_DWORD*)(thisx + 20) < (signed int)(Size + a3) || v10 < a6 + a4)
        return 0;
    v9 = *(_DWORD*)(thisx + 56) * (v10 - a4 - 1) + a3;
    for (i = 0; i < a6; ++i)
        memcpy((char*)a2 + Size * i, (const void*)(v9 - *(_DWORD*)(thisx + 56) * i + *(_DWORD*)(thisx + 60)), Size);
    return 1;
}
 
char* sub_4A17BF(_BYTE* thisx, int a2, int a3, char* a4, int a5, int a6)
{
    char* result; // eax
    int j; // [esp+8h] [ebp-10h]
    int v8; // [esp+Ch] [ebp-Ch]
    int i; // [esp+10h] [ebp-8h]
    char* v10; // [esp+14h] [ebp-4h]

    result = a4;
    v10 = a4;
    v8 = 0;
    if (a4 == (char*)-1)
        v10 = 0;
    for (i = 0; i < 256 && (int)&v10[i] <= 255; ++i)
    {
        result = &thisx[i];
        if (thisx[i + 1088])
        {
            if (a4 == (char*)-1)
            {
                for (j = v8; j < 256; ++j)
                {
                    result = (char*)(j + a3);
                    if (!*(_BYTE*)(j + a3))
                    {
                        *(_BYTE*)(j + a3) = 1;
                        *(_BYTE*)(a2 + 4 * j) = thisx[4 * i + 66];
                        *(_BYTE*)(a2 + 4 * j + 1) = thisx[4 * i + 65];
                        *(_BYTE*)(a2 + 4 * j + 2) = thisx[4 * i + 64];
                        result = (char*)(i + a5);
                        *(_BYTE*)(i + a5) = j;
                        break;
                    }
                }
                v8 = j;
            }
            else
            {
                *(_BYTE*)(a2 + 4 * (_DWORD)&a4[i]) = thisx[4 * i + 66];
                *(_BYTE*)(a2 + 4 * (_DWORD)&a4[i] + 1) = thisx[4 * i + 65];
                *(_BYTE*)(a2 + 4 * (_DWORD)&a4[i] + 2) = thisx[4 * i + 64];
                result = (char*)(i + a5);
                *(_BYTE*)(i + a5) = i + (_BYTE)a4;
            }
        }
    }
    return result;
}
 
void* sub_4A1A15(int thisx)
{
    if (*(_DWORD*)(thisx + 60))
    {
        operator delete(*(void**)(thisx + 60));
        *(_DWORD*)(thisx + 60) = 0;
    }
    memset((void*)thisx, 0, 0xEu);
    memset((void*)(thisx + 16), 0, 0x28u);
    *(_DWORD*)(thisx + 56) = 0;
    memset((void*)(thisx + 64), 0, 0x400u);
    return memset((void*)(thisx + 1088), 0, 0x100u);
}
 
void* sub_4A1AA5(int thisx, void* a2)
{
    return memcpy(a2, (const void*)(thisx + 64), 0x400u);
}
 
int sub_4A1ACA(int thisx, LPCSTR lpFileName)
{
    HANDLE hFile; // [esp+Ch] [ebp-108h]
    DWORD NumberOfBytesRead; // [esp+10h] [ebp-104h] BYREF
    CHAR Buffer[256]; // [esp+14h] [ebp-100h] BYREF

    hFile = CreateFileA(lpFileName, 0x80000000, 0, 0, 3u, 0x80u, 0);
    if (hFile == (HANDLE)-1)
        return 0;
    ReadFile(hFile, Buffer, 0x10u, (LPDWORD)&NumberOfBytesRead, 0);
    if (lstrcmpiA(Buffer, (LPCSTR)aImagefile))// if (lstrcmpiA(Buffer, aImagefile))
    {
        CloseHandle(hFile);
        return 0;
    }
    else
    {
        if (*(_DWORD*)(thisx + 60))
            operator delete(*(void**)(thisx + 60));
        *(_DWORD*)(thisx + 1352) = GetFileSize(hFile, 0) - 16;
        *(_DWORD*)(thisx + 60) = (int)operator new(*(_DWORD*)(thisx + 1352));//¸Ä*(_DWORD*)(thisx + 60) = operator new(*(_DWORD*)(thisx + 1352));
        ReadFile(hFile, *(LPVOID*)(thisx + 60), *(_DWORD*)(thisx + 1352), (LPDWORD)&NumberOfBytesRead, 0);
        *(_BYTE*)(thisx + 1344) = 1;
        *(_DWORD*)(thisx + 1348) = 0;
        CloseHandle(hFile);
        return 1;
    }
}
 
int sub_4A1C28(_DWORD* thisx, void* a2, int a3, int a4, int a5)
{
    if ((unsigned int)(a4 * a3 + thisx[337]) > thisx[338])
        return 0;
    memcpy(a2, (const void*)(thisx[337] + thisx[15]), a4 * a3);
    if (a5)
        thisx[337] += a4 * a3;
    return 1;
}
 
void* sub_4A1CA0(int thisx, void* Src)
{
    return memcpy((void*)(thisx + 64), Src, 0x400u);
}
 
int __cdecl sub_4A202A(int a1, HGDIOBJ h, int xSrc, int ySrc, int wSrc, int hSrc)
{
    int v7; // [esp+0h] [ebp-A8h]
    int v8; // [esp+4h] [ebp-A4h]
    HDC hdcDest; // [esp+8h] [ebp-A0h] BYREF
    char pv[4]; // [esp+Ch] [ebp-9Ch] BYREF
    int v11; // [esp+10h] [ebp-98h]
    int v12; // [esp+14h] [ebp-94h]
    int v13; // [esp+24h] [ebp-84h]
    HDC hdc; // [esp+28h] [ebp-80h]
    int v15[31]; // [esp+2Ch] [ebp-7Ch] BYREF

    if (!h || !a1)
        return -2147467259;
    (*(void(__stdcall**)(int))(*(_DWORD*)a1 + 108))(a1);
    hdc = CreateCompatibleDC(0);
    if (!hdc)
        OutputDebugStringA(OutputString);
    SelectObject(hdc, h);
    GetObjectA(h, 24, pv);
    if (wSrc)
        v8 = wSrc;
    else
        v8 = v11;
    if (hSrc)
        v7 = hSrc;
    else
        v7 = v12;
    v15[0] = 124;
    v15[1] = 6;
    (*(void(__stdcall**)(int, int*))(*(_DWORD*)a1 + 88))(a1, v15);
    v13 = (*(int(__stdcall**)(int, HDC*))(*(_DWORD*)a1 + 68))(a1, &hdcDest);
    if (!v13)
    {
        StretchBlt(hdcDest, 0, 0, v15[3], v15[2], hdc, xSrc, ySrc, v8, v7, 0xCC0020u);
        (*(void(__stdcall**)(int, HDC))(*(_DWORD*)a1 + 104))(a1, hdcDest);
    }
    DeleteDC(hdc);
    return v13;
}
 
int __cdecl sub_4A246A(int a1, COLORREF color)
{
    COLORREF Pixel; // [esp+0h] [ebp-8Ch]
    int v4; // [esp+4h] [ebp-88h]
    HDC hdc; // [esp+8h] [ebp-84h] BYREF
    int v6; // [esp+Ch] [ebp-80h]
    //int v7[21]; // [esp+10h] [ebp-7Ch] BYREF
    _DDSURFACEDESC v7;
    unsigned int v8; // [esp+64h] [ebp-28h]

    IDirectDrawSurface* d = (IDirectDrawSurface*)a1;

    v4 = -1;
    //if (color != -1 && !(*(int(__stdcall**)(int, HDC*))(*(_DWORD*)a1 + 68))(a1, &hdc))
    if (color != -1 && ! d->GetDC(&hdc))
    {
        Pixel = GetPixel(hdc, 0, 0);
        SetPixel(hdc, 0, 0, color);
        d->ReleaseDC(hdc);
        //(*(void(__stdcall**)(int, HDC))(*(_DWORD*)a1 + 104))(a1, hdc);
    }
    v7.dwSize = 124;
    //v7[0] = 124;
    do
        v6 = d->Lock(0, (LPDDSURFACEDESC)&v7, 0, 0);
        //v6 = (*(int(__stdcall**)(int, _DWORD, int*, _DWORD, _DWORD))(*(_DWORD*)a1 + 100))(a1, 0, v7, 0, 0);
    while (v6 == -2005532132);
    if (!v6)
    {
        //v4 = *(_DWORD*)v7[9];
        v4 = v7.dwZBufferBitDepth;
        if (v8 < 32)
            v4 &= (1 << v8) - 1;

        d->Unlock(0);
        //(*(void(__stdcall**)(int, _DWORD))(*(_DWORD*)a1 + 128))(a1, 0);
    }
    //if (color != -1 && !(*(int(__stdcall**)(int, HDC*))(*(_DWORD*)a1 + 68))(a1, &hdc))
    if (color != -1 && !d->GetDC(&hdc))
    {
        SetPixel(hdc, 0, 0, Pixel);

        d->ReleaseDC(hdc);
        //(*(void(__stdcall**)(int, HDC))(*(_DWORD*)a1 + 104))(a1, hdc);
    }
    return v4;
}
 
int __cdecl sub_4A25CE(int a1, LPCSTR name, int a3, int cy, char a5, int a6)
{
    HMODULE ModuleHandleA; // eax
    int v8; // ecx
    int v9; // [esp+0h] [ebp-9Ch] BYREF
    HANDLE h; // [esp+4h] [ebp-98h]
    char pv[4]; // [esp+8h] [ebp-94h] BYREF
    int v12; // [esp+Ch] [ebp-90h]
    int v13; // [esp+10h] [ebp-8Ch]
    int v14[31]; // [esp+20h] [ebp-7Ch] BYREF

    ModuleHandleA = GetModuleHandleA(0);
    h = LoadImageA(ModuleHandleA, name, 0, a3, cy, 0x2000u);
    if (!h)
        h = LoadImageA(0, name, 0, a3, cy, 0x2010u);
    if (!h)
        return 0;
    GetObjectA(h, 24, pv);
    memset(v14, 0, sizeof(v14));
    v14[0] = 124;
    v14[1] = 7;
    v14[26] = 64;
    if (a5)
    {
        v8 = v14[26];
        BYTE1(v8) = BYTE1(v14[26]) | 8;
        v14[26] = v8;
    }
    *(_DWORD*)a6 = v12;
    v14[3] = v12;
    *(_DWORD*)(a6 + 4) = v13;
    v14[2] = v13;
    if ((*(int(__stdcall**)(int, int*, int*, _DWORD))(*(_DWORD*)a1 + 24))(a1, v14, &v9, 0))
        return 0;
    sub_4A202A(v9, h, 0, 0, 0, 0);
    DeleteObject(h);
    return v9;
}
 
int __cdecl sub_4A2738(int a1, int a2)
{
    __int32 v3; // [esp-8h] [ebp-8h]
    void* retaddr; // [esp+0h] [ebp+0h] BYREF

    //return ((int (*)(void))_InterlockedExchange((volatile __int32*)&retaddr, v3))();????????
    return {};
}
 
// ?_CallMemberFunction0@@YGXPAX0@Z
// doubtful name
// positive sp value has been detected, the output may be wrong!
int __cdecl sub_4A273F(int a1, int a2)
{
	__int32 v3; // [esp-8h] [ebp-8h]
	void* retaddr; // [esp+0h] [ebp+0h] BYREF

	//return ((int (*)(void))_InterlockedExchange((unsigned volatile)&retaddr, (unsigned)v3))();??????
	return {};
}


int __cdecl sub_4A2B56(int a1)//±£´æÊ±¼ä
{
	int result; // eax

	result = a1;
	dword_4B82A0 = a1;
	return result;
} 
void sub_4A3090(double a1, double a2, double a3)
{
	_ctrandisp2(a1, a2, a3);
}
 
void  sub_4A3FCC()
{
    if (dword_4CB244)
        //dword_4CB244();???
    abort();
}

 
void   sub_4A4022(EXCEPTION_POINTERS* a1, int a2, int a3, int a4)
{
    int v4; // [esp-Ch] [ebp-24h] BYREF
    int v5; // [esp-8h] [ebp-20h]
    int v6; // [esp-4h] [ebp-1Ch]
    CPPEH_RECORD ms_exc; // [esp+0h] [ebp-18h]

    ms_exc.registration.ScopeTable = (PSCOPETABLE_ENTRY)stru_4AC480;
    ms_exc.registration.ExceptionHandler = _except_handler3;
    //ms_exc.registration.Next = (struct _EH3_EXCEPTION_REGISTRATION*)NtCurrentTeb()->NtTib.ExceptionList;???????
    ms_exc.exc_ptr = a1;
    v6 = a2;
    v5 = a4;
    v4 = a3;
    ms_exc.old_esp = (DWORD)&v4;
    ms_exc.registration.TryLevel = 0;
    if (off_4B8314)
        //off_4B8314(???????
        //    v4,
        //    v5,
        //    v6,
        //    ms_exc.old_esp,
        //    ms_exc.exc_ptr,
        //    ms_exc.registration.Next,
        //    ms_exc.registration.ExceptionHandler,
        //    ms_exc.registration.ScopeTable,
        //    1);
    ms_exc.registration.TryLevel = -1;
    sub_4A3FCC();
}
 
LONG(__stdcall* sub_4A655B())(struct _EXCEPTION_POINTERS* ExceptionInfo)
{
    LONG(__stdcall * result)(struct _EXCEPTION_POINTERS*); // eax

    result = SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)__CxxUnhandledExceptionFilter);
    lpfn = result;
    return result;
}

 
LPTOP_LEVEL_EXCEPTION_FILTER sub_4A656C()
{
    return SetUnhandledExceptionFilter(lpfn);
}
 
int __cdecl sub_4A7A9D(unsigned __int16* a1, _DWORD* a2)
{
    return _ld12cvt(a1, a2, (_DWORD*)dword_4B8768);
}
 
int __cdecl sub_4A7AB3(unsigned __int16* a1, _DWORD* a2)
{
    return _ld12cvt(a1, a2, (int*)dword_4B8780);
}
 
int __cdecl sub_4A7AC9(_DWORD* a1, int a2)
{
    unsigned __int16 v3[6]; // [esp+0h] [ebp-Ch] BYREF

    __strgtold12((_DWORD)v3, (char**)&a2, (char*)a2, 0, 0, 0, 0);
    return sub_4A7A9D(v3, a1);
}
 
int __cdecl sub_4A7AF6(_DWORD* a1, int a2)
{
    unsigned __int16 v3[6]; // [esp+0h] [ebp-Ch] BYREF

    __strgtold12((_DWORD)v3, (char**)&a2, (char*)a2, 0, 0, 0, 0);
    return sub_4A7AB3(v3, a1);
}
 
int sub_4AAA24()
{
    return 0;
}
 
//int sub_4AAF2F()//Ã»ÓÃ
//{
//    return flsall(1);
//}

//???
//int __cdecl tolower(int C)
//{
//  int result; // eax
//  int v2; // ebx
//  int v3; // eax
//  int v4; // eax
//  int v5; // eax
//  unsigned __int16 DestStr; // [esp+Ch] [ebp-4h] BYREF
//
//  if ( dword_4CB440 )
//  {
//    v2 = C;
//    if ( (C >= 256 || (cbMultiByte <= 1 ? (v3 = *((_BYTE *)off_4B8414 + 2 * C) & 1) : (v3 = _isctype(C, 1)), v3))
//      && (*((char *)off_4B8414 + 2 * BYTE1(v2) + 1) >= 0 ? (LOWORD(C) = (unsigned __int8)v2, v4 = 1) : (LOBYTE(C) = BYTE1(v2), *(_WORD *)((char *)&C + 1) = (unsigned __int8)v2, v4 = 2),
//          (v5 = __crtLCMapStringA(dword_4CB440, 0x100u, (LPCSTR)&C, v4, (LPSTR)&DestStr, 3, 0, 1)) != 0) )
//    {
//      if ( v5 == 1 )
//        return (unsigned __int8)DestStr;
//      else
//        return DestStr;
//    }
//    else
//    {
//      return v2;
//    }
//  }
//  else
//  {
//    result = C;
//    if ( C >= 65 && C <= 90 )
//      return C + 32;
//  }
//  return result;
//}
int  TranslatorGuardHandler(
    struct _EXCEPTION_REGISTRATION_RECORD** a1,
    EXCEPTION_POINTERS* a2,
    PEXCEPTION_RECORD ExceptionRecord,
    PVOID TargetFrame,
    struct _CONTEXT* a5)
{
    if ((ExceptionRecord->ExceptionFlags & 0x66) != 0)
    {
        *((_DWORD*)TargetFrame + 9) = 1;
        return 1;
    }
    else
    {
        __InternalCxxFrameHandler(
            a2,
            (int)a1,
            ExceptionRecord,
            *((struct EHRegistrationNode**)TargetFrame + 3),
            a5,
            0,
            *((struct _s_FuncInfo**)TargetFrame + 2),
            *((_DWORD*)TargetFrame + 4),
            *((PVOID*)TargetFrame + 5),
            1);
        if (!*((_DWORD*)TargetFrame + 9))
            _UnwindNestedFrames(a1, TargetFrame, ExceptionRecord);
        return (*((int (**)(void))TargetFrame + 6))();
    }
}
BOOL __cdecl TypeMatch(
        const struct _s_HandlerType *a1,
        const struct _s_CatchableType *a2,
        const struct _s_ThrowInfo *a3)
{
  TypeDescriptor *pType; // eax
  TypeDescriptor *v4; // ecx
  BOOL result; // eax

  pType = a1->pType;
  result = 1;
  if ( pType && pType->name[0] )
  {
    v4 = (TypeDescriptor*)a2->pType;
    if ( pType != v4 )
    {
      if ( strcmp(pType->name, v4->name) )
        return 0;
    }
    if ( (a2->properties & 2) != 0 && (a1->adjectives & 8) == 0
      || (a3->attributes & 1) != 0 && (a1->adjectives & 1) == 0
      || (a3->attributes & 2) != 0 && (a1->adjectives & 2) == 0 )
    {
      return 0;
    }
  }
  return result;
}
void streambuf::unbuffered(streambuf* thisx, int a2)
{
  *((_DWORD *)thisx + 2) = a2;
}
// Microsoft VisualC 2-14/net runtime
char * unknown_libname_1(char *thisx)
{
  return thisx + 4;
}
// Microsoft VisualC 2-14/net runtime
int  unknown_libname_10(_DWORD *thisx)
{
  return thisx[8];
}
// Microsoft VisualC 2-14/net runtime
int  unknown_libname_11(_DWORD *thisx)
{
  return thisx[7];
}
// Microsoft VisualC 2-14/net runtime
int  unknown_libname_12(_DWORD *thisx)
{
  return thisx[3];
}
// Microsoft VisualC 2-14/net runtime
int  unknown_libname_13(_DWORD *thisx)
{
  return thisx[5];
}
// Microsoft VisualC 2-14/net runtime
int  unknown_libname_14(_DWORD *thisx)
{
  return thisx[2];
}
// Microsoft VisualC 2-14/net runtime
int  unknown_libname_15(_DWORD *thisx)
{
  return thisx[19];
}
// Microsoft VisualC 2-14/net runtime
int  unknown_libname_16(_DWORD *thisx)
{
  return thisx[28];
}
// Microsoft VisualC 2-14/net runtime
int  unknown_libname_17(_DWORD *thisx)
{
  return thisx[2];
}
// Microsoft VisualC 2-14/net runtime
char * unknown_libname_18(char *thisx)
{
  return thisx + 4;
}
// Microsoft VisualC 2-14/net runtime
int  unknown_libname_19(_DWORD *thisx)
{
  return thisx[28];
}
// Microsoft VisualC 2-14/net runtime
int  unknown_libname_2(_DWORD *thisx)
{
  return thisx[1];
}
// Microsoft VisualC 2-14/net runtime
char * unknown_libname_20(char *thisx)
{
  return thisx + 4;
}
// Microsoft VisualC 2-14/net runtime
int  unknown_libname_21(_DWORD *thisx)
{
  return thisx[6];
}
// Microsoft VisualC 2-14/net runtime
int  unknown_libname_22(_DWORD *thisx)
{
  return thisx[1];
}
// Microsoft VisualC 2-14/net runtime
int  unknown_libname_23(_DWORD *thisx)
{
  return thisx[8];
}
// Microsoft VisualC 2-14/net runtime
int  unknown_libname_24(_DWORD *thisx)
{
  return thisx[1];
}
// Microsoft VisualC 2-14/net runtime
char  unknown_libname_25(_BYTE *thisx)
{
  return thisx[12];
}
// Microsoft VisualC 2-14/net runtime
int  unknown_libname_26(_DWORD *thisx)
{
  return thisx[2];
}
// Microsoft VisualC 2-14/net runtime
_DWORD * unknown_libname_27(_DWORD *thisx, int a2)
{
  _DWORD *result; // eax

  result = thisx;
  thisx[4] = a2;
  return result;
}
// Microsoft VisualC 2-14/net runtime
void  unknown_libname_28(void *thisx)
{
  ;
}
// Microsoft VisualC 2-14/net runtime
void __stdcall unknown_libname_29(int a1, int a2)
{
  ;
}
// Microsoft VisualC 2-14/net runtime
char  unknown_libname_3(void *thisx)
{
  return *(_BYTE *)thisx;
}
// Microsoft VisualC 2-14/net runtime
int  unknown_libname_30(_DWORD* thisx)
{
  return *(_DWORD *)thisx;
}
// Microsoft VisualC 2-14/net runtime
char * unknown_libname_31(char *thisx)
{
  return thisx + 64;
}
// Microsoft VisualC 2-14/net runtime
int  unknown_libname_32(_DWORD *thisx)
{
  return thisx[15];
}
// Microsoft VisualC 2-14/net runtime
int __cdecl unknown_libname_33(_DWORD** a1)
{
    if (**a1 == -529697949)
        sub_4A3FCC();
    return 0;
}
// Microsoft VisualC 2-14/net runtime
int __cdecl unknown_libname_34(int a1)
{
  int result; // eax
  int v2; // ecx

  result = a1;
  if ( a1 )
  {
    v2 = *(_DWORD *)(*(_DWORD *)(a1 + 28) + 4);
    if ( v2 )
      return sub_4A2738(*(_DWORD *)(a1 + 24), v2);
  }
  return result;
}
// Microsoft VisualC 2-14/net runtime
double __cdecl unknown_libname_35(_TBYTE a1, _TBYTE a2)
{
  double v2; // st7
  double v3; // st6
  unsigned int v4; // eax

  v2 = *(double *)&a2;
  v3 = *(double *)&a1;
  while ( !__CFADD__(DWORD1(a1), DWORD1(a1)) )
  {
    if ( !*(_QWORD *)&a1 || (HIWORD(a1) & 0x7FFF) != 0 )
      return v2 / v3;
    if ( (HIWORD(a2) & 0x7FFF) != 0 )
    {
      if ( (HIWORD(a2) & 0x7FFF) == 0x7FFF || !__CFADD__(DWORD1(a2), DWORD1(a2)) )
        return v2 / v3;
    }
    else if ( __CFADD__(DWORD1(a2), DWORD1(a2)) )
    {
      return v2 / v3;
    }
    *(double *)&a1 = v3 * flt_4B87B8;
    v2 = *(double *)&a2;
  }
  v4 = (2 * DWORD1(a1)) ^ 0xE000000;
  if ( (v4 & 0xE000000) != 0 )
    return v2 / v3;
  if ( !byte_4B87A0[v4 >> 28] )
    return v2 / v3;
  if ( (HIWORD(a1) & 0x7FFF) == 0 || (HIWORD(a1) & 0x7FFF) == 0x7FFF )
    return v2 / v3;
  if ( (HIWORD(a2) & 0x7FFF) == 1 )
    return v2 * flt_4B87B4 / (v3 * flt_4B87B4);
  else
    return v2 * flt_4B87B0 / (v3 * flt_4B87B0);
}
//Ì«³¤ÁË
// Microsoft VisualC 2-14/net runtime
void  unknown_libname_37(double a1, double a2)
{
  _TBYTE v2; // [esp+0h] [ebp-2Ch]
  _TBYTE v3; // [esp+Ch] [ebp-20h]

  *(double *)&v2 = a1;
  *(double *)&v3 = a2;
  unknown_libname_35(v2, v3);
}
// Microsoft VisualC 2-14/net runtime
void  unknown_libname_38(double a1, double a2)
{
  _TBYTE v2; // [esp+0h] [ebp-2Ch]
  _TBYTE v3; // [esp+Ch] [ebp-20h]

  *(double *)&v3 = a1;
  *(double *)&v2 = a2;
  unknown_libname_35(v2, v3);
}
// Microsoft VisualC 2-14/net runtime
void unknown_libname_4()
{
  ;
}
// Microsoft VisualC 2-14/net runtime
void   unknown_libname_48(double a1, double a2)
{
  _TBYTE v2; // [esp+0h] [ebp-30h]
  _TBYTE v3; // [esp+Ch] [ebp-24h]

  *(double *)&v3 = a1;
  *(double *)&v2 = a2;
  unknown_libname_35(v2, v3);
}
// Microsoft VisualC 2-14/net runtime
unsigned int  unknown_libname_49(char a1, __int128 a2, int a3, int a4, __int128 a5)
{
  unsigned int result; // eax
  int v6; // ecx
  double v7; // st7
  __int16 v8; // fps
  double v9; // st6
  bool v10; // c0
  char v11; // c2
  bool v12; // c3
  __int16 v13; // fps

  result = *(_DWORD *)((char *)&a2 + 6) ^ 0x700;
  if ( ((*(_DWORD *)((char *)&a2 + 6) ^ 0x700) & 0x700) == 0 )
  {
    result = (result >> 11) & 0xF;
    if ( byte_4B87BC[result] )
    {
      result = *(_DWORD *)((_BYTE *)&a2 + 6) & 0x7FFF0000;
      if ( (*(_DWORD *)((_BYTE *)&a2 + 6) & 0x7FFF0000) != 2147418112 )
      {
        result = *(_DWORD *)((_BYTE *)&a5 + 6) & 0x7FFF0000;
        if ( (*(_DWORD *)((_BYTE *)&a5 + 6) & 0x7FFF0000) != 0 && result != 2147418112 )
        {
          result = 2 * DWORD1(a5);
          if ( !(2 * DWORD1(a5)) )
          {
            result = 2 * DWORD1(a2);
            if ( !(2 * DWORD1(a2)) )
            {
              if ( (WORD4(a5) & 0x7FFFu) > (WORD4(a2) & 0x7FFFu) + 63 )
              {
                v6 = ((BYTE8(a5) - BYTE8(a2)) & 0x3F | 0x20) + 1;
                v7 = fabs(*(long double *)&a2);
                v9 = fabs(*(long double *)&a5);
                do
                {
                  v10 = v9 < v7;
                  v11 = 0;
                  v12 = v9 == v7;
                  result = v8 & 0x100;
                  if ( (v8 & 0x100) == 0 )
                    v9 = v9 - v7;
                  v7 = v7 * *(double*)dbl_4B87EC;
                  --v6;
                }
                while ( v6 );
              }
              else
              {
                while ( 1 )
                {
                  result = (WORD4(a2) & 0x7FFF) + 10;
                  if ( (int)((WORD4(a5) & 0x7FFF) - result) < 0 )
                    break;
                  //*(double *)&a5 = __FPREM__(*(long double *)&a5, *(long double *)&a2);/?????
                }
              }
            }
          }
        }
      }
    }
  }
  if ( (a1 & 3) != 0 )
  {
    result = v13 & 0x4300;
    __asm
    {
      //fnstenv [esp+28h+var_28]£¿£¿£¿£¿£¿
      //fldenv  [esp+28h+var_28]£¿£¿£¿£¿
    }
  }
  return result;
}
// Microsoft VisualC 2-14/net runtime
char  unknown_libname_5(_BYTE *thisx)
{
  return thisx[4];
}
// Microsoft VisualC 2-14/net runtime
int   unknown_libname_50(double a1, double a2)
{
  int result; // eax
  char v3; // dl
  _BYTE v4[20]; // [esp+0h] [ebp-34h]
  int v5; // [esp+14h] [ebp-20h]
  __int128 v6; // [esp+18h] [ebp-1Ch]

  *(double *)&v6 = a1;
  *(double *)v4 = a2;
  if ( (*(_DWORD *)&v4[6] & 0x7FFF0000) != 0 )
    return unknown_libname_49(0, *(__int128 *)v4, *(int *)&v4[16], v5, v6);
  result = *(_DWORD *)&v4[4] | *(_DWORD *)v4;
  if ( a2 != 0.0 )
  {
    *(double *)&v4[12] = a2;
    v3 = 2;
    if ( (WORD4(v6) & 0x7FFFu) <= 0x7FBE )
    {
      v3 = 3;
      *(double *)&v6 = a1 * *(double*)dbl_4B87D4;
    }
    *(double *)v4 = a2 * *(double*)dbl_4B87D4;
    return unknown_libname_49(v3, *(__int128 *)v4, HIDWORD(*(unsigned __int64 *)&a2), v5, v6);
  }
  return result;
}
// Microsoft VisualC 2-14/net runtime
unsigned int  unknown_libname_51(char a1, __int128 a2, int a3, int a4, __int128 a5)
{
  unsigned int result; // eax
  unsigned int v6; // eax
  int v7; // ecx
  double v8; // st7
  __int16 v9; // fps
  double v10; // st6
  bool v11; // c0
  char v12; // c2
  bool v13; // c3
  __int16 v14; // fps

  result = *(_DWORD *)((char *)&a2 + 6) ^ 0x700;
  if ( ((*(_DWORD *)((char *)&a2 + 6) ^ 0x700) & 0x700) == 0 )
  {
    result = (result >> 11) & 0xF;
    if ( byte_4B87BC[result] )
    {
      result = *(_DWORD *)((_BYTE *)&a2 + 6) & 0x7FFF0000;
      if ( (*(_DWORD *)((_BYTE *)&a2 + 6) & 0x7FFF0000) != 2147418112 )
      {
        result = *(_DWORD *)((_BYTE *)&a5 + 6) & 0x7FFF0000;
        if ( (*(_DWORD *)((_BYTE *)&a5 + 6) & 0x7FFF0000) != 0 && result != 2147418112 )
        {
          result = 2 * DWORD1(a5);
          if ( !(2 * DWORD1(a5)) )
          {
            result = 2 * DWORD1(a2);
            if ( !(2 * DWORD1(a2)) )
            {
              v6 = (WORD4(a2) & 0x7FFF) + 63;
              if ( (WORD4(a5) & 0x7FFFu) > v6 )
              {
                v7 = ((BYTE8(a5) - BYTE8(a2)) & 0x3F | 0x20) + 1;
                v8 = fabs(*(long double *)&a2);
                v10 = fabs(*(long double *)&a5);
                do
                {
                  v11 = v10 < v8;
                  v12 = 0;
                  v13 = v10 == v8;
                  result = v9 & 0x100;
                  if ( (v9 & 0x100) == 0 )
                    v10 = v10 - v8;
                  v8 = v8 * *(double*)dbl_4B87EC;
                  --v7;
                }
                while ( v7 );
              }
              else
              {
                while ( 1 )
                {
                  result = (WORD4(a2) & 0x7FFF) + 10;
                  if ( (int)((WORD4(a5) & 0x7FFF) - result) < 0 )
                    break;
                  //*(double *)&a5 = __FPREM__(*(long double *)&a5, *(long double *)&a2);?????
                }
              }
            }
          }
        }
      }
    }
  }
  if ( (a1 & 3) != 0 )
  {
    result = v14 & 0x4300;
    __asm
    {
      //fnstenv [esp+28h+var_28]????
     // fldenv  [esp+28h+var_28]?????
    }
  }
  return result;
}
// Microsoft VisualC 2-14/net runtime
int   unknown_libname_52(double a1, double a2)
{
  int result; // eax
  char v3; // dl
  _BYTE v4[20]; // [esp+0h] [ebp-34h]
  int v5; // [esp+14h] [ebp-20h]
  __int128 v6; // [esp+18h] [ebp-1Ch]

  *(double *)&v6 = a1;
  *(double *)v4 = a2;
  if ( (*(_DWORD *)&v4[6] & 0x7FFF0000) != 0 )
    return unknown_libname_51(0, *(__int128 *)v4, *(int *)&v4[16], v5, v6);
  result = *(_DWORD *)&v4[4] | *(_DWORD *)v4;
  if ( a2 != 0.0 )
  {
    *(double *)&v4[12] = a2;
    v3 = 2;
    if ( (WORD4(v6) & 0x7FFFu) <= 0x7FBE )
    {
      v3 = 3;
      *(double *)&v6 = a1 * *(double*)dbl_4B87D4;
    }
    *(double *)v4 = a2 * *(double*)dbl_4B87D4;
    return unknown_libname_51(v3, *(__int128 *)v4, HIDWORD(*(unsigned __int64 *)&a2), v5, v6);
  }
  return result;
}
// Microsoft VisualC 2-14/net runtime
char  unknown_libname_6(_BYTE *thisx)
{
  return thisx[8];
}
// Microsoft VisualC 2-14/net runtime
int  unknown_libname_7(_DWORD *thisx)
{
  return thisx[40];
}
// Microsoft VisualC 2-14/net runtime
int  unknown_libname_8(_DWORD *thisx)
{
  return thisx[14];
}
// Microsoft VisualC 2-14/net runtime
void unknown_libname_9()
{
  ;
}
void Concurrency::details::InternalContextBase::UNSAFE_SetVirtualProcessor(
    Concurrency::details::InternalContextBase* thisxx,
    struct Concurrency::details::VirtualProcessor* a2)
{
    *((_DWORD*)thisxx + 40) = (int)a2;
}
type_info * vector_deleting_destructor(type_info *thisx, unsigned int a2)
{
  if ( (a2 & 2) != 0 )
  {
    eh_vector_destructor_iterator(thisx, 0xCu, *((_DWORD *)thisx - 1), sub_48E1C7);
    if ( (a2 & 1) != 0 )
      operator delete((char *)thisx - 4);
    return (type_info *)((char *)thisx - 4);
  }
  else
  {
    sub_48E1C7(thisx);
    if ( (a2 & 1) != 0 )
      operator delete(thisx);
    return thisx;
  }
}
type_info * vector_deleting_destructor2(type_info *thisx, unsigned int a2)
{
  if ( (a2 & 2) != 0 )
  {
    eh_vector_destructor_iterator(thisx, 0xCu, *((_DWORD *)thisx - 1), sub_48F666);
    if ( (a2 & 1) != 0 )
      operator delete((char *)thisx - 4);
    return (type_info *)((char *)thisx - 4);
  }
  else
  {
    sub_48F666(thisx);
    if ( (a2 & 1) != 0 )
      operator delete(thisx);
    return thisx;
  }
}//???
//wchar_t *__cdecl wcscpy(wchar_t *Destination, const wchar_t *Source)
//{
//  const wchar_t *v2; // ecx
//  wchar_t *result; // eax
//  wchar_t v4; // dx
//  wchar_t *v5; // esi
//
//  v2 = Source;
//  result = Destination;
//  v4 = *Source;
//  v5 = Destination + 1;
//  *Destination = *Source;
//  while ( 1 )
//  {
//    ++v2;
//    if ( !v4 )
//      break;
//    v4 = *v2;
//    *v5++ = *v2;
//  }
//  return result;
//}//???
//int __cdecl wctomb(char *MbCh, wchar_t WCh)
//{
//  int result; // eax
//
//  result = (int)MbCh;
//  if ( MbCh )
//  {
//    if ( !dword_4CB440 )
//    {
//      if ( WCh <= 0xFFu )
//      {
//        *MbCh = WCh;
//        return 1;
//      }
//      goto LABEL_7;
//    }
//    MbCh = 0;
//    result = WideCharToMultiByte(CodePage, 0x220u, &WCh, 1, (LPSTR)result, cbMultiByte, 0, (LPBOOL)&MbCh);
//    if ( !result || MbCh )
//    {
//LABEL_7:
//      dword_4CB26C = 42;
//      return -1;
//    }
//  }
//  return result;
//}
//int __stdcall sub_47DF27(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
    double v4; // st5
    double v5; // st6
    double v6; // st7
    int v8; // eax
    int v9; // eax
    unsigned int Id; // [esp-4h] [ebp-23Ch]
    int v11; // [esp+0h] [ebp-238h]
    struct tagMSG Msg; // [esp+4h] [ebp-234h] BYREF
    int v13; // [esp+20h] [ebp-218h]
    signed int i; // [esp+24h] [ebp-214h]
    DWORD v15; // [esp+28h] [ebp-210h]
    unsigned int v16; // [esp+2Ch] [ebp-20Ch]
    CHAR String[256]; // [esp+30h] [ebp-208h] BYREF
    int Time; // [esp+130h] [ebp-108h]
    CHAR FileName[260]; // [esp+134h] [ebp-104h] BYREF

    dword_4B93A4 = 0;
    Src = 0;
    dword_4B9394 = 0;
    for (i = 0; i < 4; ++i)
    {
        //*(&dword_4B9380 + i) = 0;
        //dword_4B9370[i] = 0;????
        //¸üºÃµÄ´úÂë
        dword_4B9370[i] = 0;
        dword_4B9370[i] = 0;
    }
    dword_4B92E0 = 0;
    dword_4B92DC = 0;
    Size = 0;
    dword_4B92D4 = 0;
    dword_4B92D8 = 0;
    for (i = 0; i < 6; ++i)
    {
        dword_4B9348[i] = 0;
        dword_4B9324[i] = 0;
    }
    for (i = 0; i < 2; ++i)
    {
        dword_4B9308[i] = 0;
        dword_4B92FC[i] = 0;
        //*(dword_4B9310 + i) = 0;????
        //¸üºÃµÄ´úÂë
        dword_4B9310[i] = 0;
    }
    for (i = 0; i < 14; ++i)
    {
        word_4B99AC[i] = 10;
    }
    
    dword_4B92F0 = 0;
    dword_4B92E8 = 0;
    dword_4B9368 = 0;
    dword_4B9364 = 0;
    dword_4B9360 = 0;
    dword_4B93B0 = 0;
    dword_4B93AC = 0;
    Time = timeGetTime();
    v11 = Time;
    v16 = 0;
    v13 = 0;
    sub_4A2B56(Time);//°ÑÊ±¼ä±£´æµ½Ò»¸öÆæ¹ÖµÄ±äÁ¿ÄÚ
    GetCurrentDirectoryA(260, Buffer);//»ñÈ¡³ÌÐòµ±Ç°Ä¿±ê
    if (!hPrevInstance && !ÉèÖÃ_WNDCLASSA(hInstance))//¶Ô³ÌÐòwin¾ä±úÊµÀý×öÒ»Ð©ÅäÖÃ£¬²»ÓÃ¹Ü
        return 0;

    for (i = 0; i < 8; ++i)//¸Ã²»»áÊÇÄÇ8¸øplayer°É£¬µ«Ó¦¸Ã²»ÊÇÕ½¶·ÖÐµÄÄÚ´æ
    {
        //ÆäÊµÖ»ÊÇÅäÖÃÊÖ±úÏà¹ØµÄ
        sub_47652C((int*)&player_list[108 * i], i);//×öÁËºÜ¶à³õÊ¼»¯£¬×ÐÏ¸¿´¿´ÄÚ´æÎ»ÖÃ¶Ô·ñ//sub_47652C
    }

    //Õâ¸ö¹·ÅäÖÃÓÖÊÇÊ²Ã´ÒâË¼£¬µ«ÊÇ¿ÉÒÔÈ·Êµ£¬¿ÉÄÜ¶¼ÊÇÒ»Ð©Âß¼­Öµ
    dword_4B99F8 = 1;
    dword_4B99F4 = 0;
    dword_4B99F0 = 1;
    byte_4B99C9 = 0;
    byte_4B99CA = 1;
    byte_4B99E9 = 1;
    byte_4B99E8 = 0;
    byte_4B99E6 = 0;
    byte_4B99E7 = 1;
    dword_4B9978 = 0;
    dword_4B9974 = 0;

    sub_479090();//²¢¶ÁÈ¡

    if (!sub_47E5AC(hInstance, nShowCmd))//ÏÔÊ¾´°¿Ú
    {
        return 0;
    }

    v8 = sub_47C5F0();//¶ÁÈ¡Í¼ÐÎÎÄ¼þ

    if (!v8)
    {
        return 0;
    }

    ho = (HGDIOBJ)CreateFontA(14, 0, 0, 0, 100, 0, 0, 0, 0x80u, 0, 0, 0, 1u, pszFaceName);//ÉèÖÃ×ÖÌå

    sub_456F35((int*)unk_4B9B10);//»¹ÊÇ¶ÁÈ¡Ä³Ð©ÅäÖÃ

    dword_4B99EC = 1;
    timeBeginPeriod(1u);//Ê²Ã´¿ªÆôÊ±¼ä¶Î¿ªÆô

    while (1)
    {
        while (1)
        {
            v15 = timeGetTime();//»ñÈ¡µ±Ç°Ê±¼ä
            if (PeekMessageA(&Msg, 0, 0, 0, 0))//²é¿´ÏûÏ¢
                break;
            if (dword_4B99F8 || byte_4B99E6)
            {
                if (byte_4B91D0 || v15 - Time >= 17)
                {
                    if (!byte_4B91D0)
                    {
                        if (dword_4B99EC)
                        {
                            v16 = 0;
                            dword_4B99EC = 0;
                        }
                        else
                        {
                            v16 = v16 + v15 - Time - 17;
                        }
                        while (v16 >= 17)
                        {
                            sub_443059((int*)unk_4B9B10, v4, v5, v6, 0);
                            v16 -= 17;
                        }
                    }
                    Time = v15;
                    ++v13;
                    ++dword_4B93B0;
                    if (v15 - v11 > 1000)
                    {
                        v11 = Time;
                        dword_4CA1CC = v13;
                        v13 = 0;
                    }
                    sub_440B04((int*)unk_4BDB28);
                    sub_443059((int*)unk_4B9B10, v4, v5, v6, 1);
                    if (dword_4B99F4)
                    {
                        wsprintfA(String, "%d", dword_4CA1CC);
                        sub_47BC5A(0, 0, String, 0, -1);
                    }
                    if (byte_4B91D9)
                    {
                        Id = Concurrency::details::VirtualProcessor::GetId((Concurrency::details::VirtualProcessor*)unk_4BDB28);
                        v9 = sub_47EF40((int*)unk_4BDC60);
                        wsprintfA(String, "%d,%d", v9, Id);
                        sub_47B7ED(0, 232, String, 0, -1);
                    }
                    sub_49A518((int)unk_4BDC60);
                }
                else if (v15 - Time < 16)
                {
                    Sleep(16 - (v15 - Time));
                }
            }
            else
            {
                sub_49A518((int)unk_4BDC60);
                Sleep(16);//ËäÈ»Ö®Ç°ºóÃæÓÐ¸öu
            }
        }

        if (!GetMessageA(&Msg, 0, 0, 0))//»ñÈ¡ÏûÏ¢
            break;
        TranslateMessage(&Msg);//·­ÒëÏûÏ¢
        DispatchMessageA(&Msg);//µ÷¶ÈÏûÏ¢A
    }






    sub_43F951((int*)unk_4BDB28);//¹Ø±ÕÊ²Ã´¾ä±ú
    timeEndPeriod(1u);//Ê±¼äÏß½áÊø¶Î
    wsprintfA(FileName, "%s\\%s", Buffer, aKdIni_0);//»ñÈ¡ÅäÖÃÎÄ¼þÂ·¾¶
    sub_47907D(FileName);//±£´æÅäÖÃÎÄ¼þ
    sub_47B2C4();

    //¹Ø±ÕÊ²Ã´ÏµÍ³¾ä±ú
    if (ho)
    {
        DeleteObject((HGDIOBJ)ho);
    }
        
    return Msg.wParam;//ºóÃæÃ»ÓÐ³ÌÐòÂß¼­²»ÓÃ¹ÜÁË
}
int __cdecl write_char(int a1, myFILE *File, int a3)
{
  int v4; // eax
  bool v5; // zf
  int result; // eax

  if ( --File->_cnt < 0 )
  {
    v4 = _flsbuf(a1, File);
  }
  else
  {
    *File->_ptr++ = a1;
    v4 = (unsigned __int8)a1;
  }
  v5 = v4 == -1;
  result = a3;
  if ( v5 )
    *(_DWORD *)a3 = -1;
  else
    ++*(_DWORD *)a3;
  return result;
}
int __cdecl write_multi_char(int a1, int a2, myFILE *File, int a4)
{
  int result; // eax
  int i; // edi

  result = a2;
  for ( i = a2 - 1; result > 0; result = i-- )
  {
    result = write_char(a1, File, a4);
    if ( *(_DWORD *)a4 == -1 )
      break;
  }
  return result;
}
int __cdecl write_string(int a1, int a2, myFILE *File, int a4)
{
  int result; // eax
  int i; // ebx
  int v7; // eax

  result = a2;
  for ( i = a2 - 1; result > 0; result = i-- )
  {
    v7 = *(char *)a1++;
    result = write_char(v7, File, a4);
    if ( *(_DWORD *)a4 == -1 )
      break;
  }
  return result;
}
int *__cdecl xcptlookup(int a1)
{
  int *result; // eax

  result = &dword_4B8638;
  if ( dword_4B8638 != a1 )
  {
    do
      result += 3;
    while ( (unsigned int)result < 12 * (_DWORD)dword_4B86B8 + 4949560 && *result != a1 );
  }
  if ( (unsigned int)result >= 12 * (_DWORD)dword_4B86B8 + 4949560 || *result != a1 )
    return 0;
  return result;
}
int __cdecl x_ismbbtype(unsigned __int8 a1, int a2, unsigned __int8 a3)
{
  int result; // eax

  if ( (a3 & (unsigned __int8)byte_4CB581[a1]) != 0 )
    return 1;
  result = a2 ? (unsigned __int16)(a2 & __ctype[a1 + 1]) : 0;
  if ( result )
    return 1;
  return result;
}
void zerotoxdone()
{
  ;
}
int __cdecl _87except(int a1, int a2, unsigned __int16* a3)
{
    __int16 v3; // cx
    bool v4; // zf
    int v5; // eax
    int v6; // eax
    int v7; // eax
    int v8; // eax
    int v9; // eax
    int v10; // eax
    DWORD v11; // ebx
    int result; // eax
    int v13; // [esp-4h] [ebp-68h]
    int Arguments[10]; // [esp+Ch] [ebp-58h] BYREF
    double v15; // [esp+34h] [ebp-30h]
    unsigned int v16; // [esp+44h] [ebp-20h]

    v3 = *a3;
    v5 = *(_DWORD*)a2 - 1;
    v4 = *(_DWORD*)a2 == 1;
    a3 = (unsigned __int16*)*a3;
    if (v4)
        goto LABEL_13;
    v6 = v5 - 1;
    if (!v6)
    {
        v13 = 4;
        goto LABEL_14;
    }
    v7 = v6 - 1;
    if (!v7)
    {
        v13 = 17;
        goto LABEL_14;
    }
    v8 = v7 - 1;
    if (!v8)
    {
        v13 = 18;
        goto LABEL_14;
    }
    v9 = v8 - 1;
    if (!v9)
    {
    LABEL_13:
        v13 = 8;
    LABEL_14:
        v11 = v13;
        if (!_handle_exc(v13, (double*)(a2 + 24), v3))
        {
            if (a1 == 16 || a1 == 22 || a1 == 29)
            {
                v15 = *(double*)(a2 + 16);
                v16 = v16 & 0xFFFFFFE0 | 3;
            }
            else
            {
                v16 &= ~1u;
            }
            _raise_exc((ULONG_PTR)Arguments, (int)&a3, v11, a1, a2 + 8, a2 + 24);
        }
        goto LABEL_21;
    }
    v10 = v9 - 2;
    if (!v10)
    {
        *(_DWORD*)a2 = 1;
        goto LABEL_21;
    }
    if (v10 == 1)
    {
        v13 = 16;
        goto LABEL_14;
    }
LABEL_21:
    _ctrlfp(v3);
    if (*(_DWORD*)a2 == 8)
        return _set_errno(*(_DWORD*)a2);
    if (dword_4B8D58)
        return _set_errno(*(_DWORD*)a2);
    result = sub_4AAA24();
    if (!result)
        return _set_errno(*(_DWORD*)a2);
    return result;
}
//int __cdecl _abnormal_termination() ????
//{
//  int result; // eax
//  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // ecx
//
//  result = 0;
//  //ExceptionList = NtCurrentTeb()->NtTib.ExceptionList; £¿£¿£¿£¿
//  if ( (int (__cdecl *)(int, int, int, int))ExceptionList->Handler == (int(__cdecl*)(int, int, int, int))_unwind_handler
//    && ExceptionList[1].Next == (struct _EXCEPTION_REGISTRATION_RECORD *)*((_DWORD *)ExceptionList[1].Handler + 3) )
//  {
//    return 1;
//  }
//  return result;
//}
char __cdecl _abstract_cw(char a1)
{
  char result; // al

  result = 0;
  if ( (a1 & 1) != 0 )
    result = 16;
  if ( (a1 & 4) != 0 )
    result |= 8u;
  if ( (a1 & 8) != 0 )
    result |= 4u;
  if ( (a1 & 0x10) != 0 )
    result |= 2u;
  if ( (a1 & 0x20) != 0 )
    return result | 1;
  return result;
}
void _alloca_probe(unsigned int a1, char a2)
{
  char *i; // ecx

  for ( i = &a2; a1 >= 0x1000; a1 -= 4096 )
    i -= 4096;
  //__asm { retn }??±¨´í
}
void* alloca(int a)
{
   _alloca_probe(a,a);//???
   return &a;
}


unsigned int __stdcall _aulldiv(unsigned __int64 a1, __int64 a2)
{
  unsigned __int64 v3; // rtt
  unsigned int v4; // ecx
  unsigned int v5; // ebx
  unsigned __int64 v6; // rax
  char v7; // cf
  unsigned int v8; // esi
  unsigned __int64 v9; // rax

  if ( HIDWORD(a2) )
  {
    v4 = HIDWORD(a2);
    v5 = a2;
    v6 = a1;
    do
    {
      v7 = v4 & 1;
      v4 >>= 1;
      v5 = (v5 >> 1) | (v7 << 31);
      v6 >>= 1;
    }
    while ( v4 );
    v8 = v6 / v5;
    v9 = v8 * (unsigned __int64)(unsigned int)a2;
    if ( __CFADD__(HIDWORD(a2) * v8, HIDWORD(v9)) || (HIDWORD(v9) = (a2 * (unsigned __int64)v8) >> 32, v9 > a1) )
      --v8;
    return v8;
  }
  else
  {
    LODWORD(v3) = a1;
    HIDWORD(v3) = HIDWORD(a1) % (unsigned int)a2;
    return v3 / (unsigned int)a2;
  }
}
unsigned __int64 __stdcall _aullrem(unsigned __int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rtt
  unsigned int v4; // ecx
  unsigned int v5; // ebx
  unsigned __int64 v6; // rax
  bool v7; // cf
  int v8; // ecx
  unsigned __int64 v9; // rax

  if ( HIDWORD(a2) )
  {
    v4 = HIDWORD(a2);
    v5 = a2;
    v6 = a1;
    do
    {
      v7 = v4 & 1;
      v4 >>= 1;
      v5 = (v5 >> 1) | (v7 << 31);
      v6 >>= 1;
    }
    while ( v4 );
    v8 = HIDWORD(a2) * (v6 / v5);
    v9 = (unsigned int)a2 * (unsigned __int64)(unsigned int)(v6 / v5);
    v7 = __CFADD__(v8, HIDWORD(v9));
    HIDWORD(v9) += v8;
    if ( v7 || v9 > a1 )
      v9 -= a2;
    return a1 - v9;
  }
  else
  {
    LODWORD(v2) = a1;
    HIDWORD(v2) = HIDWORD(a1) % (unsigned int)a2;
    return v2 % (unsigned int)a2;
  }
}
void __cdecl _CallCatchBlock2(
    struct EHRegistrationNode* a1,
    const struct _s_FuncInfo* a2,
    void* a3,
    int a4,
    unsigned int a5)
{
    _CallSettingFrame((int)a3, (int)a1, a5);
}//???
//int __cdecl _callnewh(size_t Size)
//{
//  return dword_4CB3D0 && dword_4CB3D0(Size);///???
//}
int __cdecl _CallSETranslator(
        struct EHExceptionRecord *a1,
        struct EHRegistrationNode *a2,
        void *a3,
        void *a4,
        const struct _s_FuncInfo *a5,
        int a6,
        struct EHRegistrationNode *a7)
{
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // ebx
  int v9; // [esp+0h] [ebp-40h] BYREF
  int v10; // [esp+Ch] [ebp-34h]
  int v11[11]; // [esp+10h] [ebp-30h] BYREF
  int v12; // [esp+3Ch] [ebp-4h]
  int savedregs; // [esp+40h] [ebp+0h] BYREF

  v11[3] = (int)TranslatorGuardHandler;
  v11[4] = (int)a5;
  v11[5] = (int)a2;
  v11[6] = a6;
  v11[7] = (int)a7;
  v12 = 0;
  //v11[8] = (int)&_ExceptionContinuation_16667;???
  v11[9] = (int)&v9;
  v11[10] = (int)&savedregs;
  //v11[2] = (int)NtCurrentTeb()->NtTib.ExceptionList;???
  v10 = 1;
  v11[0] = (int)a1;
  v11[1] = (int)a3;
  //dword_4CB240(a1->ExceptionCode, v11);???
  v10 = 0;
  if ( v12 )
  {
    //ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;???
    ExceptionList->Next = ExceptionList->Next;
  }
  return v10;
}
void __stdcall _CallSettingFrame(int a1, int a2, int a3)
{
  void (*v3)(void); // eax
  int v4; // ecx

  _NLG_Notify1(a3);
  v3();
  v4 = a3;
  if ( a3 == 256 )
    v4 = 2;
  _NLG_Notify1(v4);
}
char* __cdecl _cfltcvt(int a1, char* Str, int a3, size_t Size, int a5)
{
    if (a3 == 101 || a3 == 69)
        return _cftoe((double*)a1, Str, Size, a5);
    if (a3 == 102)
        return _cftof(a1, Str, Size);
    return _cftog(a1, Str, Size, a5);
}
char* (__cdecl* _cfltcvt_init())(int a1, char* Str, int a3, size_t Size, int a5)
{
	char* (__cdecl * result)(int, char*, int, size_t, int); // eax

	result = _cfltcvt;
	off_4B831C = (int)(void (*)())_cropzeros;
	off_4B8318 = (int)(int(__cdecl*)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))_cfltcvt;
	off_4B8320 = (int)(void (*)())_fassign;
	off_4B8324 = (int)(void (*)())_forcdecpt;
	off_4B8328 = (int)(void (*)())_positive;
	off_4B832C = (int)(void (*)())_cfltcvt;
	return result;
}
_BYTE *__cdecl _cftoe(double *a1, _BYTE *a2, int a3, int a4)
{
  int v4; // ebx
  int v5; // esi
  _BYTE *v6; // eax
  char *v7; // eax
  int v8; // ebx
  double v10; // [esp+0h] [ebp-10h]

  if ( byte_4CB24C )
  {
    v4 = a3;
    v5 = dword_4CB248;
    _shift(&a2[*(_DWORD *)dword_4CB248 == 45], a3 > 0);
  }
  else
  {
    v10 = *a1;
    v4 = a3;
    v5 = (_DWORD)_fltout(SLOBYTE(v10));
    _fptostr(&a2[(*(_DWORD *)v5 == 45) + (a3 > 0)], a3 + 1, v5);
  }
  v6 = a2;
  if ( *(_DWORD *)v5 == 45 )
  {
    *a2 = 45;
    v6 = a2 + 1;
  }
  if ( v4 > 0 )
  {
    *v6 = v6[1];
    *++v6 = *(char*)byte_4B8624;
  }
  v7 = strcpy(&v6[(byte_4CB24C == 0) + v4], "e+000");
  if ( a4 )
    *v7 = 69;
  if ( **(_BYTE **)(v5 + 12) != 48 )
  {
    v8 = *(_DWORD *)(v5 + 4) - 1;
    if ( v8 < 0 )
    {
      v8 = 1 - *(_DWORD *)(v5 + 4);
      v7[1] = 45;
    }
    if ( v8 >= 100 )
    {
      v7[2] += v8 / 100;
      v8 %= 100;
    }
    if ( v8 >= 10 )
    {
      v7[3] += v8 / 10;
      v8 %= 10;
    }
    v7[4] += v8;
  }
  return a2;
}
_BYTE *__cdecl _cftoe_g(double *a1, _BYTE *a2, int a3, int a4)
{
  _BYTE *result; // eax

  byte_4CB24C = 1;
  result = _cftoe(a1, a2, a3, a4);
  byte_4CB24C = 0;
  return result;
}
char *__cdecl _cftof(int a1, char *Str, size_t Size)
{
  int v3; // ebx
  _DWORD *v4; // esi
  char *v5; // eax
  char *v6; // edi
  int v7; // eax
  char *v8; // edi
  int v9; // esi
  char *v10; // edi
  int v11; // esi
  double v13; // [esp+0h] [ebp-18h]

  if ( byte_4CB24C )
  {
    v3 = Size;
    v4 = (_DWORD *)dword_4CB248;
    if ( dword_4CB250 == Size )
    {
      v5 = &Str[dword_4CB250 + (*(_DWORD *)dword_4CB248 == 45)];
      *v5 = 48;
      v5[1] = 0;
    }
  }
  else
  {
    v13 = *(double *)a1;
    v3 = Size;
    v4 = (_DWORD *)_fltout(SLOBYTE(v13));
    _fptostr(&Str[*v4 == 45], Size + v4[1], (int)v4);
  }
  v6 = Str;
  if ( *v4 == 45 )
  {
    *Str = 45;
    v6 = Str + 1;
  }
  v7 = v4[1];
  if ( v7 > 0 )
  {
    v8 = &v6[v7];
  }
  else
  {
    _shift(v6, 1);
    *v6 = 48;
    v8 = v6 + 1;
  }
  if ( v3 > 0 )
  {
    _shift(v8, 1);
    *v8 = *(char*)byte_4B8624;
    v9 = v4[1];
    v10 = v8 + 1;
    if ( v9 < 0 )
    {
      if ( byte_4CB24C )
      {
        v11 = -v9;
      }
      else
      {
        v11 = -v9;
        if ( v3 < v11 )
        {
LABEL_16:
          _shift(v10, v3);
          memset(v10, 48, v3);
          return Str;
        }
      }
      v3 = v11;
      goto LABEL_16;
    }
  }
  return Str;
}
char *__cdecl _cftof_g(int a1, char *Str, size_t Size)
{
  char *result; // eax

  byte_4CB24C = 1;
  result = _cftof(a1, Str, Size);
  byte_4CB24C = 0;
  return result;
}
char *__cdecl _cftog(int a1, char *Str, size_t Size, int a4)
{
  char *v4; // esi
  bool v5; // cl
  double v7; // [esp+0h] [ebp-14h]

  v7 = *(double *)a1;
  dword_4CB248 = (_DWORD)_fltout(SLOBYTE(v7));
  dword_4CB250 = *(_DWORD *)(dword_4CB248 + 4) - 1;
  v4 = &Str[*(_DWORD *)dword_4CB248 == 45];
  _fptostr(v4, Size, dword_4CB248);
  v5 = dword_4CB250 < *(_DWORD *)(dword_4CB248 + 4) - 1;
  byte_4CB254 = v5;
  dword_4CB250 = *(_DWORD *)(dword_4CB248 + 4) - 1;
  if ( dword_4CB250 < -4 || dword_4CB250 >= (int)Size )
    return _cftoe_g((double *)a1, Str, Size, a4);
  if ( v5 )
    v4[strlen(v4) - 1] = 0;
  return _cftof_g(a1, Str, Size);
}
int __cdecl _checkTOS_withFB(int a1, int a2)
{
  int result; // eax

  result = a2 & 0x7FF00000;
  if ( (a2 & 0x7FF00000) == 2146435072 )
    return a2;
  return result;
}
/*
double  _CIcos(double x)
{
  _checkTOS_withFB(LODWORD(x), HIDWORD(*(unsigned __int64 *)&x));
  return ((double (*)(void))loc_4A2FFD)();
}
*/
//double  _CIlog10(double x)
//{
//  _checkTOS_withFB(LODWORD(x), HIDWORD(*(unsigned __int64 *)&x));
//  return ((double (*)(void))loc_4A323D)();
//}

void __cdecl _initterm(_PVFV* First, _PVFV* Last)
{
    while (First < Last)
    {
        if (*First)
            void (*First)();
        ++First;
    }
}

void _cinit()
{
    if (off_4B82B8)
        _fpmath();//off_4B82B8();
    //_initterm((_PVFV*)First, (_PVFV*)Last);//ÏÈ×¢ÊÍ
    ___onexitinit();
    __initstdio();
    __initmbctable();
    sub_4A655B();
    //_initterm((_PVFV*)&dword_4B0000, (_PVFV*)&dword_4B001C);
    sub_476B00();
    sub_476B3F();
    sub_476B7E();
    sub_476BBD();
    sub_476BDF();
    sub_476C35();
}

void _cintrindisp1(double a1, int a2, __int16 a3, __int16 a4)
{
	int savedregs; // [esp+2A4h] [ebp+0h] BYREF

	_trandisp1(a2, a3, (int)&savedregs, a4, a1);
	byte_4CB268 = 1;
	cintrinexit(&savedregs, a1);
}
void _cintrindisp2(double a1, double a2, int a3, __int16 a4)
{
	int savedregs; // [esp+2A4h] [ebp+0h] BYREF

	_trandisp2(a3, (int)&savedregs, a4, a1, a2);
	byte_4CB268 = 1;
	cintrinexit(&savedregs, a2);
}
//double  _CIsin(double x)
//{
//  _checkTOS_withFB(LODWORD(x), HIDWORD(*(unsigned __int64 *)&x));
//  return ((double (*)(void))loc_4A2F4D)();
//}

//int __cdecl _close(int FileHandle)
//{
//  int v1; // esi
//  intptr_t osfhandle; // ebp
//  void *v3; // eax
//  DWORD LastError; // ebp
//
//  if ( FileHandle < uNumber
//    && (v1 = 8 * (FileHandle & 0x1F), (*(_BYTE *)(dword_4CC6C0[FileHandle >> 5] + v1 + 4) & 1) != 0) )
//  {
//    if ( _get_osfhandle(FileHandle) == -1
//      || (FileHandle == 1 || FileHandle == 2) && (osfhandle = _get_osfhandle(2), _get_osfhandle(1) == osfhandle)
//      || (v3 = (void *)_get_osfhandle(FileHandle), CloseHandle(v3)) )
//    {
//      LastError = 0;
//    }
//    else
//    {
//      LastError = GetLastError();
//    }
//    _free_osfhnd(FileHandle);
//    *(_BYTE *)(dword_4CC6C0[FileHandle >> 5] + v1 + 4) = 0;
//    if ( !LastError )
//      return 0;
//    _dosmaperr(LastError);
//  }
//  else
//  {
//    dword_4CB270 = 0;
//    dword_4CB26C = 9;
//  }
//  return -1;
//}


int  _clrfp(__int16 a1)
{
  __asm { fnclex }
  return a1;
}

//int __cdecl _commit(int FileHandle)//Ã»ÓÐ±»µ÷ÓÃ
//{
//  void *osfhandle; // eax
//  int result; // eax
//
//  if ( FileHandle >= uNumber || (*(_BYTE *)(dword_4CC6C0[FileHandle >> 5] + 8 * (FileHandle & 0x1F) + 4) & 1) == 0 )
//    goto LABEL_8;
//  osfhandle = (void *)_get_osfhandle(FileHandle);
//  if ( FlushFileBuffers(osfhandle) )
//    result = 0;
//  else
//    result = GetLastError();
//  if ( result )
//  {
//    dword_4CB270 = result;
//LABEL_8:
//    dword_4CB26C = 9;
//    return -1;
//  }
//  return result;
//}



//???
//unsigned int __cdecl _control87(unsigned int NewValue, unsigned int Mask)
//{
//  int v2; // eax
//  unsigned int v3; // esi
//  char v5; // [esp+4h] [ebp-4h]
//
//  LOBYTE(v2) = _abstract_cw(v5);
//  v3 = Mask & NewValue | ~Mask & v2;
//  _hw_cw(v3);
//  return v3;
//}//
//unsigned int __cdecl _controlfp(unsigned int NewValue, unsigned int Mask)
//{
//  return _control87(NewValue, Mask & 0xFFF7FFFF);
//}????
double  _convertTOStoQNaN(int a1, double result)
{
  if ( (a1 & 0x80000) == 0 )
    return result + 1.0;
  return result;
}
_DWORD *__cdecl _CopyMan(int a1, _DWORD *a2)
{
  _DWORD *result; // eax
  int v3; // edx

  result = a2;
  v3 = 3;
  do
  {
    *(_DWORD *)((char *)result + a1 - (_DWORD)a2) = *result;
    ++result;
    --v3;
  }
  while ( v3 );
  return result;
}


char *__cdecl _cropzeros(char *a1)
{
  char *v1; // eax
  char i; // cl
  char v3; // cl
  char *result; // eax
  char v5; // cl
  char *v6; // ecx
  char v7; // dl

  v1 = a1;
  for ( i = *a1; i; i = *++v1 )
  {
    if ( i == *(byte*)byte_4B8624 )
      break;
  }
  v3 = *v1;
  result = v1 + 1;
  if ( v3 )
  {
    while ( 1 )
    {
      v5 = *result;
      if ( !*result || v5 == 101 || v5 == 69 )
        break;
      ++result;
    }
    v6 = result;
    do
      --result;
    while ( *result == 48 );
    if ( *result == *(byte*)byte_4B8624 )
      --result;
    do
    {
      v7 = *v6;
      ++result;
      ++v6;
      *result = v7;
    }
    while ( v7 );
  }
  return result;
}


void _ctrandisp1(double a1, double a2)
{
	int v2; // edx
	__int16 v3; // cx
	__int16 v4; // fps
	int savedregs; // [esp+2A4h] [ebp+0h] BYREF

	_fload(a2);
	_trandisp1(v2, v3, (int)&savedregs, v4, a1);
	ctranexit(&savedregs, a1);
}
void _ctrandisp2(double a1, double a2, double a3)
{
	double v4; // st6
	int v5; // edx
	__int16 v6; // fps
	int savedregs; // [esp+2A4h] [ebp+0h] BYREF

	_fload(a2);
	v4 = _fload(a3);
	_trandisp2(v5, (int)&savedregs, v6, v4, a1);
	ctranexit(&savedregs, a1);
}
int __fastcall _ctrlfp(__int16 a1)
{
  return a1;
}
// local variable allocation has failed, the output may be wrong!
double __cdecl _decomp(double a1, int a2)
{
  int v2; // esi
  BOOL v3; // eax
  double result; // st7
  double v5; // [esp+10h] [ebp-8h]

  if ( a1 == 0.0 )
  {
    v2 = 0;
    v5 = 0.0;
  }
  else if ( (HIWORD(a1) & 0x7FF0) == 0 && ((HIDWORD(a1) & 0xFFFFF) != 0 || LODWORD(a1)) )
  {
    v2 = -1021;
    v3 = a1 < 0.0;
    while ( (BYTE6(a1) & 0x10) == 0 )
    {
      HIDWORD(a1) *= 2;
      if ( (SBYTE3(a1) & 0x80u) != 0 )
        HIDWORD(a1) |= 1u;
      LODWORD(a1) *= 2;
      --v2;
    }
    HIWORD(a1) &= ~0x10u;
    if ( v3 )
      HIBYTE(a1) |= 0x80u;
    _set_exp(a1, 0);
    v5 = a1;
  }
  else
  {
    _set_exp(a1, 0);
    v5 = a1;
    v2 = ((*(_DWORD *)((char *)&a1 + 6) >> 4) & 0x7FF) - 1022;
  }
  result = v5;
  *(_DWORD *)a2 = v2;
  return result;
}
_DWORD *__cdecl _dosmaperr(unsigned int a1)
{
  int v1; // edx
  _DWORD *result; // eax

  v1 = 0;
  dword_4CB270 = a1;
  result = (_DWORD*)&unk_4B8DA0;
  do
  {
    if ( a1 == *result )
    {
      result = (_DWORD *)dword_4B8DA4[2 * v1];
      dword_4CB26C = (int)result;
      return result;
    }
    result += 2;
    ++v1;
  }
  while ( (int)result < (int)&unk_4B8F08 );
  if ( a1 < 0x13 || a1 > 0x24 )
  {
    if ( a1 < 0xBC || (dword_4CB26C = 8, a1 > 0xCA) )
      dword_4CB26C = 22;
  }
  else
  {
    dword_4CB26C = 13;
  }
  return result;
}
int __cdecl _d_inttype(double X)
{
  if ( (_fpclass(X) & 0x90) != 0 )
    return 0;
  _frnd(X);
  _frnd(X / 2.0);
  return 2;
}
int __cdecl _except_handler3(int a1, PVOID TargetFrame, int a3)
{
    int* v3; // ebp
    _DWORD* v4; // ebx
    int v5; // esi
    int v6; // edi
    int v7; // eax
    int v8; // edi
    int v9; // ecx
    int v11[2]; // [esp+10h] [ebp-8h] BYREF
    int savedregs; // [esp+18h] [ebp+0h] BYREF

    v3 = &savedregs;
    v4 = (int*)TargetFrame;
    if ((*(_DWORD*)(a1 + 4) & 6) != 0)
    {
        _local_unwind2((int)TargetFrame + 16, (int)TargetFrame, -1);
        return 1;
    }
    else
    {
        v11[0] = a1;
        v11[1] = a3;
        *((_DWORD*)TargetFrame - 1) = (int)v11;
        v5 = *((_DWORD*)TargetFrame + 3);
        v6 = *((_DWORD*)TargetFrame + 2);
        while (v5 != -1)
        {
            if (*(_DWORD*)(v6 + 12 * v5 + 4))
            {
                v7 = (*(int (**)(void))(v6 + 12 * v5 + 4))();
                v4 = (_DWORD*)v3[3];
                if (v7)
                {
                    if (v7 < 0)
                        return 0;
                    v8 = v4[2];
                    _global_unwind2((PVOID)v3[3]);
                    v3 = v4 + 4;
                    _local_unwind2((int)(v4 + 4), (int)v4, v5);
                    _NLG_Notify(*(_DWORD*)(v8 + 12 * v5 + 8), (int)(v4 + 4), 1);
                    v4[3] = *(_DWORD*)(v8 + 4 * v9);
                    (*(void (**)(void))(v8 + 4 * v9 + 8))();
                }
            }
            v6 = v4[2];
            v5 = *(_DWORD*)(v6 + 12 * v5);
        }
        return 1;
    }
}//???
//void _exit(int Code)
//{
//  doexit(Code, 1, 0);
//}
_DWORD *__cdecl _fassign(int a1, _DWORD *a2, int a3)
{
  _DWORD *result; // eax
  int v4[2]; // [esp+0h] [ebp-8h] BYREF

  if ( a1 )
  {
    sub_4A7AC9(v4, a3);
    result = a2;
    *a2 = v4[0];
    a2[1] = v4[1];
  }
  else
  {
    sub_4A7AF6(&a3, a3);
    result = a2;
    *a2 = a3;
  }
  return result;
}

//int __cdecl _fcloseall()//Ã»ÓÃ
//{
//  int v0; // edi
//  int i; // esi
//  int v2; // eax
//
//  v0 = 0;
//  for ( i = 3; i < (int)Count; ++i )
//  {
//    v2 = *(_DWORD *)(dword_4CB688 + 4 * i);
//    if ( v2 )
//    {
//      if ( (*(_BYTE *)(v2 + 12) & 0x83) != 0 && fclose(*(myFILE **)(dword_4CB688 + 4 * i)) != -1 )
//        ++v0;
//      if ( i >= 20 )
//      {
//        free(*(void **)(dword_4CB688 + 4 * i));
//        *(_DWORD *)(dword_4CB688 + 4 * i) = 0;
//      }
//    }
//  }
//  return v0;
//}

// positive sp value has been detected, the output may be wrong!
// positive sp value has been detected, the output may be wrong!
void _ffexpm1(char a1, int _EBP)
{
    __asm
    {
        fld     st
        fabs
        fld     tbyte_4B83CE
        fcompp
        fstsw   word ptr[ebp - 0A0h]
    }
    if ((*(_BYTE*)(_EBP - 159) & 0x41) != 0)
    {
        __asm
        {
            ftst
            fstsw   word ptr[ebp - 0A0h]
        }
        if ((*(_BYTE*)(_EBP - 159) & 1) != 0)
        {
            *(_BYTE*)(_EBP - 144) = 4;
            __asm
            {
                fstp    st
                fldz
            }
        }
        else
        {
            __asm
            {
                fstp    st
                //??fld     tbyte ptr byte_4B83B0
            }
            if (a1)
                __asm { fchs }
            expbigret();
        }
    }
    else
    {
        __asm
        {
            fld     st
            frndint
            ftst
            fstsw   word ptr[ebp - 0A0h]
            fxch    st(1)
            fsub    st, st(1)
            ftst
            fstsw   word ptr[ebp - 0A0h]
            fabs
            f2xm1
        }
    }
}
int* _FF_MSGBANNER()
{
  int* result; // eax

  result = (_DWORD*)dword_4CB234;
  if ( dword_4CB234 == 1 || !dword_4CB234 && *(int*)dword_4B8304 == 1 )
  {
    _NMSG_WRITE(0xFCu);
    if ( dword_4CB3C4 )
      //dword_4CB3C4();£¿£¿£¿
    return _NMSG_WRITE(0xFFu);
  }
  return result;
}
int __cdecl _FillZeroMan(_DWORD *a1)
{
  int result; // eax

  result = 0;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return result;
}
double __cdecl _fload(double a1)
{
  double v2; // [esp+6h] [ebp-Ah]

  if ( (HIWORD(a1) & 0x7FF0) != 32752 )
    return a1;
  HIDWORD(v2) = *(_QWORD *)&a1 >> 21;
  LODWORD(v2) = LODWORD(a1);
  return v2;
}
double __fastcall _fload_withFB(int a1, _DWORD *a2)
{
  double result; // st7

  if ( (a2[1] & 0x7FF00000) != 2146435072 )
    return *(double *)a2;
  *(_QWORD *)&result = *(_QWORD *)a2 << 11;
  return result;
}
int __cdecl _flsbuf(int Ch, myFILE *File)
{
  myFILE *v2; // esi
  int flag; // eax
  int v4; // ebx
  int v5; // eax
  char *base; // eax
  signed int v7; // edi
  _BYTE *v8; // eax

  v2 = File;
  flag = File->_flag;
  v4 = File->_file;
  if ( (flag & 0x82) == 0 || (flag & 0x40) != 0 )
    goto LABEL_24;
  if ( (flag & 1) == 0 )
    goto LABEL_6;
  File->_cnt = 0;
  if ( (flag & 0x10) == 0 )
  {
LABEL_24:
    LOBYTE(flag) = flag | 0x20;
    v2->_flag = flag;
    return -1;
  }
  LOBYTE(flag) = flag & 0xFE;
  v2->_ptr = (int*)v2->_base;
  v2->_flag = flag;
LABEL_6:
  v5 = v2->_flag;
  v2->_cnt = 0;
  File = 0;
  LOBYTE(v5) = v5 & 0xED | 2;
  v2->_flag = v5;
  if ( (v5 & 0x10C) == 0 && (v2 != (myFILE *)&unk_4B8920 && v2 != (myFILE *)&unk_4B8940 || !_isatty(v4)) )
    _getbuf((_DWORD*)v2);
  if ( (v2->_flag & 0x108) != 0 )
  {
    base = (char*)v2->_base;
    v7 = (unsigned int)(v2->_ptr - (int)base);
    v2->_ptr = (_DWORD*)base + 1;
    v2->_cnt = v2->_bufsiz - 1;
    if ( v7 <= 0 )
    {
      if ( v4 == -1 )
        v8 = unk_4B86C0;
      else
        v8 = (_BYTE *)(dword_4CC6C0[v4 >> 5] + 8 * (v4 & 0x1F));
      if ( (v8[4] & 0x20) != 0 )
        _lseek(v4, 0, 2);
    }
    else
    {
      File = (myFILE *)_write(v4, base, v7);
    }
    *(int*)v2->_base = Ch;
  }
  else
  {
    v7 = 1;
    File = (myFILE *)_write(v4, &Ch, 1u);
  }
  if ( File == (myFILE *)v7 )
    return (unsigned __int8)Ch;
  v2->_flag |= 0x20u;
  return -1;
}
int *__cdecl _fltout(int a1)
{
  int v2; // [esp-10h] [ebp-24h]
  __int64 v3; // [esp+8h] [ebp-Ch] BYREF
  __int16 v4; // [esp+10h] [ebp-4h]

  __dtold((unsigned int)&v3, (int)&v3, &a1);
  LOWORD(v2) = v4;
  dword_4CB400 = _I10_OUTPUT(v3, v2, 17, 0, (int)&word_4CB3D8);
  dword_4CB3F8 = byte_4CB3DA;
  dword_4CB3FC = word_4CB3D8;
  dword_4CB404 = (int)&unk_4CB3DC;
  return &dword_4CB3F8;
}
int __cdecl _flush(_DWORD *a1)
{
  int v1; // ebx
  const void *v2; // eax
  unsigned int v3; // edi
  int v4; // eax
  int v5; // eax

  v1 = 0;
  if ( (a1[3] & 3) == 2 && (a1[3] & 0x108) != 0 )
  {
    v2 = (const void *)a1[2];
    if ( *a1 - (int)v2 > 0 )
    {
      v3 = *a1 - (_DWORD)v2;
      if ( _write(a1[4], v2, v3) == v3 )
      {
        v4 = a1[3];
        if ( (v4 & 0x80u) != 0 )
        {
          LOBYTE(v4) = v4 & 0xFD;
          a1[3] = v4;
        }
      }
      else
      {
        a1[3] |= 0x20u;
        v1 = -1;
      }
    }
  }
  v5 = a1[2];
  a1[1] = 0;
  *a1 = v5;
  return v1;
}
char __cdecl _forcdecpt(char *a1)
{
  char *v1; // esi
  int v2; // eax
  char result; // al
  char *v4; // esi
  char v5; // cl

  v1 = a1;
  if ( tolower(*a1) != 101 )
  {
    do
    {
      ++v1;
      if ( cbMultiByte <= 1 )
        v2 = *((_BYTE *)off_4B8414 + 2 * *v1) & 4;
      else
        v2 = _isctype(*v1, 4);
    }
    while ( v2 );
  }
  result = *v1;
  *v1 = *(byte*)byte_4B8624;
  v4 = v1 + 1;
  do
  {
    v5 = *v4;
    *v4 = result;
    result = v5;
  }
  while ( *v4++ );
  return result;
}//???
//int __cdecl _fpclass(double X)
//{
//  int v1; // eax
//  int v2; // eax
//  int v4; // eax
//  int v5; // eax
//
//  if ( (HIWORD(X) & 0x7FF0) == 32752 )
//  {
//    v1 = _sptype(LODWORD(X), HIDWORD(X)) - 1;
//    if ( v1 )
//    {
//      v2 = v1 - 1;
//      if ( !v2 )
//        return 4;
//      if ( v2 == 1 )
//        return 2;
//      return 1;
//    }
//    else
//    {
//      return 512;
//    }
//  }
//  else if ( (HIWORD(X) & 0x7FF0) == 0 && ((HIDWORD(X) & 0xFFFFF) != 0 || LODWORD(X)) )
//  {
//    v4 = -((HIWORD(X) & 0x8000) != 0);
//    LOBYTE(v4) = v4 & 0x90;
//    return v4 + 128;
//  }
//  else
//  {
//    v5 = -((HIWORD(X) & 0x8000) != 0);
//    LOBYTE(v5) = 0;
//    if ( X == 0.0 )
//      return v5 + 64;
//    else
//      return v5 + 256;
//  }
//}
unsigned int _fpmath()
{
	unsigned int result; // eax

	_cfltcvt_init();
	dword_4CB228 = _ms_p5_mp_test_fdiv();
	result = _setdefaultprecision();
	__asm { fnclex }
	return result;
}
char *__cdecl _fptostr(void *a1, int a2, int a3)
{
  int v3; // edx
  int v4; // ebx
  char *v6; // ecx
  const char *v7; // edi
  char *result; // eax
  char v9; // dl
  size_t v10; // eax
  char *v11; // [esp+14h] [ebp+8h]

  v3 = a3;
  v4 = a2;
  v6 = *(char **)(a3 + 12);
  v7 = (char *)a1 + 1;
  *(_BYTE *)a1 = 48;
  result = (char *)a1 + 1;
  if ( a2 > 0 )
  {
    v11 = (char *)a2;
    v4 = 0;
    do
    {
      v9 = *v6;
      if ( *v6 )
        ++v6;
      else
        v9 = 48;
      *result++ = v9;
      --v11;
    }
    while ( v11 );
    v3 = a3;
  }
  *result = 0;
  if ( v4 >= 0 && *v6 >= 53 )
  {
    while ( *--result == 57 )
      *result = 48;
    ++*result;
  }
  if ( *(_BYTE *)a1 == 49 )
  {
    ++*(_DWORD *)(v3 + 4);
  }
  else
  {
    v10 = strlen(v7);
    return (char *)memcpy_0(a1, v7, v10 + 1);
  }
  return result;
}
void  _fptrap()
{
  _amsg_exit(2u);
}
int __cdecl _freebuf(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 12);
  if ( (result & 0x83) != 0 && (result & 8) != 0 )
  {
    free(*(void **)(a1 + 8));
    *(_WORD *)(a1 + 12) &= 0xFBF7u;
    result = 0;
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 4) = 0;
  }
  return result;
}




//int __cdecl _free_osfhnd(int a1)//Ã»ÓÃ
//{
//  int v1; // eax
//
//  if ( a1 >= uNumber
//    || (v1 = 8 * (a1 & 0x1F) + dword_4CC6C0[a1 >> 5], (*(_BYTE *)(v1 + 4) & 1) == 0)
//    || *(_DWORD *)v1 == -1 )
//  {
//    dword_4CB270 = 0;
//    dword_4CB26C = 9;
//    return -1;
//  }
//  else
//  {
//    if ( *(int*)dword_4B8304 == 1 )
//    {
//      if ( a1 )
//      {
//        if ( a1 == 1 )
//        {
//          SetStdHandle(0xFFFFFFF5, 0);
//        }
//        else if ( a1 == 2 )
//        {
//          SetStdHandle(0xFFFFFFF4, 0);
//        }
//      }
//      else
//      {
//        SetStdHandle(0xFFFFFFF6, 0);
//      }
//    }
//    *(_DWORD *)(dword_4CC6C0[a1 >> 5] + 8 * (a1 & 0x1F)) = -1;
//    return 0;
//  }
//}


double __cdecl _frnd(double a1)
{
  double result; // st7

  //_ST7 = a1; £¿£¿£¿£¿£¿
  __asm { frndint }
  return result;
}
__int64  _ftol(double a1)
{
  return (__int64)a1;
}
int __cdecl _getbuf(_DWORD *a1)
{
  void *v1; // eax
  int result; // eax

  ++dword_4CB40C;
  v1 = malloc(0x1000u);
  a1[2] = (int)v1;
  if ( v1 )
  {
    a1[3] |= 8u;
    a1[6] = 4096;
  }
  else
  {
    a1[3] |= 4u;
    a1[2] = (int)a1 + 5;
    a1[6] = 2;
  }
  result = a1[2];
  a1[1] = 0;
  *a1 = result;
  return result;
}
TryBlockMapEntry *__cdecl _GetRangeOfTrysToCheck(
        const struct _s_FuncInfo *a1,
        int a2,
        int a3,
        unsigned int *a4,
        unsigned int *a5)
{
  EXCEPTION_POINTERS *v5; // ecx
  unsigned int nTryBlocks; // esi
  TryBlockMapEntry *pTryBlockMap; // ebx
  unsigned int v9; // eax
  unsigned int v10; // esi
  unsigned int v12; // [esp+Ch] [ebp-4h]
  const struct _s_FuncInfo *v13; // [esp+18h] [ebp+8h]

  nTryBlocks = a1->nTryBlocks;
  pTryBlockMap = (TryBlockMapEntry*)a1->pTryBlockMap;
  v9 = nTryBlocks;
  v13 = (const struct _s_FuncInfo *)nTryBlocks;
  v12 = nTryBlocks;
  if ( a2 >= 0 )
  {
    do
    {
      if ( nTryBlocks == -1 )
        sub_4A4022(v5, (int)pTryBlockMap, (int)a1, -1);
      v5 = (EXCEPTION_POINTERS *)a3;
      if ( pTryBlockMap[--nTryBlocks].tryHigh < a3 && a3 <= pTryBlockMap[nTryBlocks].catchHigh || nTryBlocks == -1 )
      {
        --a2;
        v12 = (unsigned int)v13;
        v13 = (const struct _s_FuncInfo *)nTryBlocks;
      }
    }
    while ( a2 >= 0 );
    v9 = v12;
  }
  v10 = nTryBlocks + 1;
  *a4 = v10;
  *a5 = v9;
  if ( v9 > a1->nTryBlocks || v10 > v9 )
    sub_4A4022((EXCEPTION_POINTERS *)a5, (int)pTryBlockMap, (int)a1, v10);
  return &pTryBlockMap[v10];
}
bool Concurrency::details::_UnrealizedChore::_GetRuntimeOwnsLifetime(
    Concurrency::details::_UnrealizedChore* thisxx)
{
    return *((_BYTE*)thisxx + 16);
}
struct Concurrency::details::_CancellationTokenState*  Concurrency::details::_CancellationTokenRegistration::_GetToken(
    Concurrency::details::_CancellationTokenRegistration* thisxx)
{
    return (struct Concurrency::details::_CancellationTokenState*)*((_DWORD*)thisxx + 4);
}

intptr_t __cdecl _get_osfhandle(int FileHandle)
{
  int v1; // eax

  if ( FileHandle < uNumber )
  {
    v1 = dword_4CC6C0[FileHandle >> 5] + 8 * (FileHandle & 0x1F);
    if ( (*(_BYTE *)(v1 + 4) & 1) != 0 )
      return *(_DWORD *)v1;
  }
  dword_4CB270 = 0;
  dword_4CB26C = 9;
  return -1;
}


void __cdecl _global_unwind2(PVOID TargetFrame)
{
  //RtlUnwind(TargetFrame, &gu_return, 0, 0);
  RtlUnwind(TargetFrame, 0, 0, 0);
}


BOOL __cdecl _handle_exc(char a1, double *a2, __int16 a3)
{
  int v3; // edi
  int v4; // ecx
  double *v5; // ecx
  double v7; // st7
  char v8; // c0
  char v9; // c3
  char v11; // c0
  char v12; // c3
  BOOL v13; // esi
  int v14; // ecx
  BOOL v15; // edx
  __int16 v16; // ax
  int v17; // eax
  double v19; // [esp+18h] [ebp-Ch]
  double v20; // [esp+18h] [ebp-Ch]
  int v21; // [esp+20h] [ebp-4h] BYREF

  v3 = a1 & 0x1F;
  if ( (a1 & 8) != 0 && (a3 & 1) != 0 )
  {
    _set_statfp();
    v3 = a1 & 0x17;
    goto LABEL_46;
  }
  if ( (a1 & 4) != 0 && (a3 & 4) != 0 )
  {
    _set_statfp();
    v3 = a1 & 0x1B;
    goto LABEL_46;
  }
  if ( (a1 & 1) != 0 && (a3 & 8) != 0 )
  {
    _set_statfp();
    v4 = a3 & 0xC00;
    if ( (a3 & 0xC00) != 0 )
    {
      switch ( v4 )
      {
        case 1024:
          v5 = a2;
          if ( *a2 <= 0.0 )
            v7 = -*(double*)dbl_4B8D78;
          else
            v7 = *(double*)dbl_4B8D88;
          break;
        case 2048:
          v5 = a2;
          if ( *a2 <= 0.0 )
            v7 = -*(double*)dbl_4B8D88;
          else
            v7 = *(double*)dbl_4B8D78;
          break;
        case 3072:
          v5 = a2;
          v7 = *(double*)dbl_4B8D88;
          if ( v8 != 0 || v9 != 0 )
            v7 = -*(double*)dbl_4B8D88;
          break;
        default:
LABEL_25:
          v3 = a1 & 0x1E;
          goto LABEL_46;
      }
    }
    else
    {
      v5 = a2;
      v7 = *(double*)dbl_4B8D78;
      if ( v11 != 0 || v12 != 0 )
        v7 = -*(double*)dbl_4B8D78;
    }
    *v5 = v7;
    goto LABEL_25;
  }
  if ( (a1 & 2) != 0 && (a3 & 0x10) != 0 )
  {
    v13 = (a1 & 0x10) != 0;
    v19 = *a2;
    if ( v19 == 0.0 )
    {
      v13 = 1;
    }
    else
    {
      v20 = _decomp(v19, (int)&v21);
      v14 = v21 - 1536;
      if ( v21 - 1536 >= -1074 )
      {
        v15 = v20 < 0.0;
        v16 = BYTE6(v20) & 0xF;
        LOBYTE(v16) = v16 | 0x10;
        HIWORD(v20) = v16;
        if ( v14 < -1021 )
        {
          v17 = -1021 - v14;
          do
          {
            if ( (LOBYTE(v20) & 1) != 0 && !v13 )
              v13 = 1;
            LODWORD(v20) >>= 1;
            if ( (BYTE4(v20) & 1) != 0 )
              BYTE3(v20) |= 0x80u;
            HIDWORD(v20) >>= 1;
            --v17;
          }
          while ( v17 );
        }
        if ( v15 )
          v20 = -v20;
      }
      else
      {
        v13 = 1;
        v20 = 0.0;
      }
      *a2 = v20;
    }
    if ( v13 )
      _set_statfp();
    v3 = a1 & 0x1D;
  }
LABEL_46:
  if ( (a1 & 0x10) != 0 && (a3 & 0x20) != 0 )
  {
    _set_statfp();
    v3 &= ~0x10u;
  }
  return v3 == 0;
}
_DWORD *__cdecl _heap_alloc(unsigned int a1)
{
  int v1; // esi
  _DWORD *result; // eax

  v1 = a1;
  if ( a1 > *(int*)dword_4B8760 || (result = __sbh_alloc_block(a1)) == 0 )
  {
    if ( !a1 )
      v1 = 1;
    return (_DWORD*)HeapAlloc(hHeap, 0, (v1 + 15) & 0xFFFFFFF0);
  }
  return result;
}
int __cdecl _heap_init(int a1)
{
  hHeap = HeapCreate(a1 == 0, 0x1000u, 0);
  if ( !hHeap )
    return 0;
  if ( !__sbh_heap_init() )
  {
    HeapDestroy(hHeap);
    return 0;
  }
  return 1;
}
char __cdecl _hw_cw(int a1)
{
  char result; // al

  result = (a1 & 0x10) != 0;
  if ( (a1 & 8) != 0 )
    result |= 4u;
  if ( (a1 & 4) != 0 )
    result |= 8u;
  if ( (a1 & 2) != 0 )
    result |= 0x10u;
  if ( (a1 & 1) != 0 )
    result |= 0x20u;
  if ( (a1 & 0x80000) != 0 )
    return result | 2;
  return result;
}
int __cdecl _I10_OUTPUT(__int64 a1, int a2, int a3, char a4, int a5)
{
  int v5; // ebx
  __int16 v6; // cx
  unsigned __int16 v7; // dx
  int v8; // edi
  int v9; // esi
  bool v10; // zf
  int v11; // edi
  int v12; // esi
  int i; // esi
  int v14; // eax
  char v15; // al
  _BYTE *v16; // ecx
  char v17; // cl
  _BYTE *v18; // eax
  bool v19; // cc
  _BYTE *v20; // ecx
  char v21; // al
  char v23[12]; // [esp+Ch] [ebp-1Ch] BYREF
  _BYTE v24[12]; // [esp+18h] [ebp-10h] BYREF
  int v25; // [esp+24h] [ebp-4h]

  v5 = a5;
  v6 = a2 & 0x8000;
  memset(v23, 204, 10);
  v23[10] = -5;
  v23[11] = 63;
  v25 = 1;
  v7 = a2 & 0x7FFF;
  if ( (a2 & 0x8000u) == 0 )
    *(_BYTE *)(a5 + 2) = 32;
  else
    *(_BYTE *)(a5 + 2) = 45;
  v8 = HIDWORD(a1);
  if ( !v7 && !a1 )
    goto LABEL_6;
  if ( v7 == 0x7FFF )
  {
    *(_WORD *)v5 = 1;
    if ( (v8 != 0x80000000 || (_DWORD)a1) && (v8 & 0x40000000) == 0 )
    {
      strcpy((char *)(v5 + 4), "1#SNAN");
LABEL_22:
      *(_BYTE *)(v5 + 3) = 6;
      return 0;
    }
    if ( v6 && v8 == -1073741824 )
    {
      if ( !(_DWORD)a1 )
      {
        strcpy((char *)(v5 + 4), "1#IND");
LABEL_19:
        *(_BYTE *)(v5 + 3) = 5;
        return 0;
      }
    }
    else if ( v8 == 0x80000000 && !(_DWORD)a1 )
    {
      strcpy((char *)(v5 + 4), "1#INF");
      goto LABEL_19;
    }
    strcpy((char *)(v5 + 4), "1#QNAN");
    goto LABEL_22;
  }
  *(_WORD *)v24 = 0;
  *(_WORD *)&v24[10] = v7;
  v9 = (77 * (HIBYTE(v7) + 2 * HIBYTE(HIDWORD(a1))) + 19728 * v7 - 323162868) >> 16;
  *(_QWORD *)&v24[2] = a1;
  __multtenpow12((short*)v24, -(__int16)v9, 1);
  if ( *(_WORD *)&v24[10] >= 0x3FFFu )
  {
    LOWORD(v9) = v9 + 1;
    __ld12mul((_DWORD)v24, (_DWORD)v23);
  }
  v10 = (a4 & 1) == 0;
  *(_WORD *)v5 = v9;
  if ( v10 )
  {
    v11 = a3;
    goto LABEL_29;
  }
  v11 = (__int16)v9 + a3;
  if ( v11 > 0 )
  {
LABEL_29:
    if ( v11 > 21 )
      v11 = 21;
    v12 = *(unsigned __int16 *)&v24[10] - 16382;
    *(_WORD *)&v24[10] = 0;
    a5 = 8;
    do
    {
      __shl_12((_DWORD*)v24);
      --a5;
    }
    while ( a5 );
    if ( v12 < 0 )
    {
      for ( i = (unsigned __int8)-(char)v12; i; --i )
        __shr_12((_DWORD*)v24);
    }
    v14 = v5 + 4;
    a5 = v5 + 4;
    if ( v11 + 1 > 0 )
    {
      a3 = v11 + 1;
      do
      {
        a1 = *(_QWORD *)v24;
        a2 = *(_DWORD *)&v24[8];
        __shl_12((_DWORD*)v24);
        __shl_12((_DWORD*)v24);
        __add_12((_DWORD*)v24, (_DWORD*)&a1);
        __shl_12((_DWORD*)v24);
        v15 = v24[11];
        v16 = (_BYTE *)a5;
        v24[11] = 0;
        ++a5;
        v10 = a3-- == 1;
        *v16 = v15 + 48;
      }
      while ( !v10 );
      v14 = a5;
    }
    v17 = *(_BYTE *)(v14 - 1);
    v18 = (_BYTE *)(v14 - 2);
    v19 = v17 < 53;
    v20 = (_BYTE *)(v5 + 4);
    if ( v19 )
    {
      while ( v18 >= v20 )
      {
        if ( *v18 != 48 )
        {
          if ( v18 >= v20 )
            goto LABEL_47;
          break;
        }
        --v18;
      }
      *(_WORD *)v5 = 0;
      *(_BYTE *)(v5 + 2) = 32;
      *(_BYTE *)(v5 + 3) = 1;
      *v20 = 48;
      goto LABEL_54;
    }
    while ( v18 >= v20 )
    {
      if ( *v18 != 57 )
      {
        if ( v18 >= v20 )
          goto LABEL_46;
        break;
      }
      *v18-- = 48;
    }
    ++v18;
    ++*(_WORD *)v5;
LABEL_46:
    ++*v18;
LABEL_47:
    v21 = (_BYTE)v18 - v5 - 3;
    *(_BYTE *)(v5 + 3) = v21;
    *(_BYTE *)(v21 + v5 + 4) = 0;
    return v25;
  }
LABEL_6:
  *(_WORD *)v5 = 0;
  *(_BYTE *)(v5 + 2) = 32;
  *(_BYTE *)(v5 + 3) = 1;
  *(_BYTE *)(v5 + 4) = 48;
LABEL_54:
  *(_BYTE *)(v5 + 5) = 0;
  return 1;
}
int __cdecl _IncMan(int a1, int a2)
{
  int result; // eax
  int v3; // esi
  _DWORD *v4; // edi

  result = __addl(*(_DWORD *)(a1 + 4 * (a2 / 32)), 1 << (31 - a2 % 32), (unsigned int*)a1 + 4 * (a2 / 32));
  v3 = a2 / 32 - 1;
  if ( v3 >= 0 )
  {
    v4 = (_DWORD *)(a1 + 4 * v3);
    do
    {
      if ( !result )
        break;
      result = __addl(*v4, 1, (unsigned int*)v4);
      --v3;
      --v4;
    }
    while ( v3 >= 0 );
  }
  return result;
}

UINT _ioinit()
{
  char *v0; // eax
  char *v1; // esi
  unsigned int i; // eax
  signed int v3; // esi
  LPBYTE v4; // ebp
  HANDLE *v5; // ebx
  _DWORD *v6; // edi
  char *v7; // eax
  unsigned int j; // ecx
  int k; // edi
  int v10; // eax
  int m; // ebx
  int v12; // esi
  DWORD v13; // eax
  HANDLE StdHandle; // eax
  HANDLE v15; // edi
  DWORD FileType; // eax
  struct _STARTUPINFOA StartupInfo; // [esp+10h] [ebp-44h] BYREF

  v0 = (char *)malloc(0x100u);
  v1 = v0;
  if ( !v0 )
    _amsg_exit(0x1Bu);
  dword_4CC6C0[0] = (int)v0;
  uNumber = 32;
  for ( i = (unsigned int)(v0 + 256); (unsigned int)v1 < i; i = dword_4CC6C0[0] + 256 )
  {
    v1[4] = 0;
    *(_DWORD *)v1 = -1;
    v1[5] = 10;
    v1 += 8;
  }
  GetStartupInfoA(&StartupInfo);
  if ( StartupInfo.cbReserved2 && StartupInfo.lpReserved2 )
  {
    v3 = *(_DWORD *)StartupInfo.lpReserved2;
    v4 = StartupInfo.lpReserved2 + 4;
    v5 = (HANDLE *)&StartupInfo.lpReserved2[*(_DWORD *)StartupInfo.lpReserved2 + 4];
    if ( *(int *)StartupInfo.lpReserved2 >= 2048 )
      v3 = 2048;
    if ( (int)uNumber < v3 )
    {
      v6 = (_DWORD*)&unk_4CC6C4;
      while ( 1 )
      {
        v7 = (char *)malloc(0x100u);
        if ( !v7 )
          break;
        uNumber += 32;
        *v6 = (_DWORD)v7;
        for ( j = (unsigned int)(v7 + 256); (unsigned int)v7 < j; j = *v6 + 256 )
        {
          v7[4] = 0;
          *(_DWORD *)v7 = -1;
          v7[5] = 10;
          v7 += 8;
        }
        ++v6;
        if ( (int)uNumber >= v3 )
          goto LABEL_19;
      }
      v3 = uNumber;
    }
LABEL_19:
    for ( k = 0; k < v3; ++v5 )
    {
      if ( *v5 != (HANDLE)-1 && (*v4 & 1) != 0 && ((*v4 & 8) != 0 || GetFileType(*v5)) )
      {
        v10 = dword_4CC6C0[k >> 5] + 8 * (k & 0x1F);
        *(_DWORD *)v10 = (_DWORD)*v5;
        *(_BYTE *)(v10 + 4) = *v4;
      }
      ++k;
      ++v4;
    }
  }
  for ( m = 0; m < 3; ++m )
  {
    v12 = dword_4CC6C0[0] + 8 * m;
    if ( *(_DWORD *)v12 == -1 )
    {
      *(_BYTE *)(v12 + 4) = -127;
      if ( m )
        v13 = -(m != 1) - 11;
      else
        v13 = -10;
      StdHandle = GetStdHandle(v13);
      v15 = StdHandle;
      if ( StdHandle == (HANDLE)-1
        || (FileType = GetFileType(StdHandle)) == 0
        || (*(_DWORD *)v12 = (_DWORD)v15, (unsigned __int8)FileType == 2) )
      {
        *(_BYTE *)(v12 + 4) |= 0x40u;
      }
      else if ( (unsigned __int8)FileType == 3 )
      {
        *(_BYTE *)(v12 + 4) |= 8u;
      }
    }
    else
    {
      *(_BYTE *)(v12 + 4) |= 0x80u;
    }
  }
  return SetHandleCount(uNumber);
}
int __cdecl _isatty(int FileHandle)
{
  if ( FileHandle < uNumber )
    return *(_BYTE *)(dword_4CC6C0[FileHandle >> 5] + 8 * (FileHandle & 0x1F) + 4) & 0x40;
  else
    return 0;
}//???
//int __cdecl _isctype(int C, int Type)
//{
//  int v2; // ecx
//  int v3; // eax
//  int result; // eax
//  int SrcStr; // [esp+0h] [ebp-4h] BYREF
//
//  SrcStr = v2;
//  if ( (unsigned int)(C + 1) <= 0x100 )
//  {
//    v3 = *((unsigned __int16 *)off_4B8414 + C);
//    return Type & v3;
//  }
//  if ( *((char *)off_4B8414 + 2 * BYTE1(C) + 1) >= 0 )
//  {
//    LOWORD(SrcStr) = (unsigned __int8)C;
//    result = __crtGetStringTypeA(1u, (LPCSTR)&SrcStr, 1, (LPWORD)&C + 1, 0, 0, 1);
//  }
//  else
//  {
//    LOBYTE(SrcStr) = BYTE1(C);
//    *(_WORD *)((char *)&SrcStr + 1) = (unsigned __int8)C;
//    result = __crtGetStringTypeA(1u, (LPCSTR)&SrcStr, 2, (LPWORD)&C + 1, 0, 0, 1);
//  }
//  if ( result )
//  {
//    v3 = HIWORD(C);
//    return Type & v3;
//  }
//  return result;
//}
int __cdecl _ismbblead(unsigned int Ch)
{
  return x_ismbbtype(Ch, 0, 4);
}
int __cdecl _IsZeroMan(_DWORD *a1)
{
  int v2; // ecx

  v2 = 0;
  while ( !*a1 )
  {
    ++v2;
    ++a1;
    if ( v2 >= 3 )
      return 1;
  }
  return 0;
}
void __stdcall _JumpToContinuation(void *a1, struct EHRegistrationNode *a2)
{
  ((void (__stdcall *)(void *, struct EHRegistrationNode *))a1)(a1, a2);
}
int __cdecl _ld12cvt(unsigned __int16 *a1, _DWORD *a2, int *a3)
{
  unsigned __int16 v4; // bx
  int v5; // ecx
  int v6; // eax
  int v7; // ebx
  int v8; // esi
  int result; // eax
  int v10; // eax
  int v11; // esi
  int v12; // esi
  int v13; // edi
  unsigned int v14; // esi
  int v15; // edx
  int v16; // [esp-8h] [ebp-2Ch]
  int v17; // [esp-4h] [ebp-28h]
  int v18; // [esp-4h] [ebp-28h]
  _DWORD v19[3]; // [esp+Ch] [ebp-18h] BYREF
  int v20; // [esp+18h] [ebp-Ch] BYREF
  int v21; // [esp+1Ch] [ebp-8h]
  int v22; // [esp+20h] [ebp-4h]
  int v23; // [esp+2Ch] [ebp+8h]

  v4 = a1[5];
  v23 = v4 & 0x8000;
  v20 = *(_DWORD *)(a1 + 3);
  v5 = *(_DWORD *)(a1 + 1);
  v6 = *a1;
  v7 = (v4 & 0x7FFF) - 0x3FFF;
  v21 = v5;
  v22 = v6 << 16;
  if ( v7 != -16383 )
  {
    _CopyMan((int)v19, &v20);
    if ( _RoundMan((int)&v20, a3[2]) )
      ++v7;
    v10 = a3[1];
    if ( v7 >= v10 - a3[2] )
    {
      if ( v7 > v10 )
      {
        if ( v7 >= *a3 )
        {
          _FillZeroMan(&v20);
          v16 = a3[3];
          HIBYTE(v20) |= 0x80u;
          _ShrMan(&v20, v16);
          v8 = *a3 + a3[5];
          v17 = 1;
          goto LABEL_5;
        }
        v18 = a3[3];
        v12 = a3[5];
        HIBYTE(v20) &= ~0x80u;
        v8 = v7 + v12;
        _ShrMan(&v20, v18);
        goto LABEL_16;
      }
      v11 = v10 - v7;
      _CopyMan((int)&v20, v19);
      _ShrMan(&v20, v11);
      _RoundMan((int)&v20, a3[2]);
      _ShrMan(&v20, a3[3] + 1);
    }
    else
    {
      _FillZeroMan(&v20);
    }
    v8 = 0;
    goto LABEL_4;
  }
  v8 = 0;
  if ( !_IsZeroMan(&v20) )
  {
    _FillZeroMan(&v20);
LABEL_4:
    v17 = 2;
LABEL_5:
    result = v17;
    goto LABEL_17;
  }
LABEL_16:
  result = 0;
LABEL_17:
  v13 = a3[4];
  v14 = v20 | (v23 != 0 ? 0x80000000 : 0) | (v8 << (31 - *((_BYTE *)a3 + 12)));
  if ( v13 == 64 )
  {
    v15 = v21;
    a2[1] = v14;
    *a2 = v15;
  }
  else if ( v13 == 32 )
  {
    *a2 = v14;
  }
  return result;
}
int  _local_unwind2(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // ebx
  int v5; // esi
  int v6; // esi
  struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; // [esp-8h] [ebp-1Ch]
  int (__cdecl *v8)(int, int, int, int); // [esp-4h] [ebp-18h]

  v8 = (int( *)(int, int, int, int))_unwind_handler;
  //ExceptionList = NtCurrentTeb()->NtTib.ExceptionList;£¿£¿£¿
  while ( 1 )
  {
    result = a2;
    v4 = *(_DWORD *)(a2 + 8);
    v5 = *(_DWORD *)(a2 + 12);
    if ( v5 == -1 || v5 == a3 )
      break;
    v6 = 3 * v5;
    *(_DWORD *)(a2 + 12) = *(_DWORD *)(v4 + 4 * v6);
    if ( !*(_DWORD *)(v4 + 4 * v6 + 4) )
    {
      _NLG_Notify(*(_DWORD *)(v4 + 4 * v6 + 8), a1, 257);
      (*(void (__cdecl **)(struct _EXCEPTION_REGISTRATION_RECORD *, int (__cdecl *)(int, int, int, int)))(v4 + 4 * v6 + 8))(
        ExceptionList,
        v8);
    }
  }
  return result;
}
int __cdecl _lseek(int FileHandle, int Offset, int Origin)
{
  int v3; // esi
  void *osfhandle; // eax
  int v5; // ebx
  unsigned int LastError; // eax

  if ( FileHandle < uNumber
    && (v3 = 8 * (FileHandle & 0x1F), (*(_BYTE *)(dword_4CC6C0[FileHandle >> 5] + v3 + 4) & 1) != 0) )
  {
    osfhandle = (void *)_get_osfhandle(FileHandle);
    if ( osfhandle == (void *)-1 )
    {
      dword_4CB26C = 9;
    }
    else
    {
      v5 = SetFilePointer(osfhandle, Offset, 0, Origin);
      if ( v5 == -1 )
        LastError = GetLastError();
      else
        LastError = 0;
      if ( !LastError )
      {
        *(_BYTE *)(dword_4CC6C0[FileHandle >> 5] + v3 + 4) &= ~2u;
        return v5;
      }
      _dosmaperr(LastError);
    }
  }
  else
  {
    dword_4CB270 = 0;
    dword_4CB26C = 9;
  }
  return -1;
}//???
//size_t __cdecl _msize(void *Block)
//{
//  if ( __sbh_find_block((int)Block) )
//    return *((_DWORD *)Block - 1) - 9;
//  else
//    return HeapSize(hHeap, 0, Block);
//}
int _ms_p5_mp_test_fdiv()
{
  HMODULE ModuleHandleA; // eax
  BOOL (__stdcall *IsProcessorFeaturePresent)(DWORD); // eax

  ModuleHandleA = GetModuleHandleA("KERNEL32");
  if ( ModuleHandleA
    && (IsProcessorFeaturePresent = (BOOL (__stdcall *)(DWORD))GetProcAddress(
                                                                 ModuleHandleA,
                                                                 "IsProcessorFeaturePresent")) != 0 )
  {
    return IsProcessorFeaturePresent(0);
  }
  else
  {
    return _ms_p5_test_fdiv();
  }
}
BOOL _ms_p5_test_fdiv()
{
  return 4195835.0 - 4195835.0 / 3145727.0 * 3145727.0 > 1.0;
}
_DWORD *__cdecl _nh_malloc(size_t Size, int a2)
{
  _DWORD *result; // eax

  if ( Size > 0xFFFFFFE0 )
    return 0;
  while ( 1 )
  {
    result = (_DWORD*)_heap_alloc(Size);
    if ( result || !a2 )
      break;
    if ( !_callnewh(Size) )
      return 0;
  }
  return result;
}
int  _NLG_Notify(int result, int a2, int a3)
{
  ((int*)dword_4B8284)[2] = *(_DWORD *)(a2 + 8);
  ((int*)dword_4B8284)[1] = result;
  ((int*)dword_4B8284)[3] = a2;
  return result;
}
void __stdcall _NLG_Notify1(int a1)
{
  ////£¿£¿£¿JUMPOUT(0x4A2AC8);£¿£¿
}
int *__cdecl _NMSG_WRITE(DWORD NumberOfBytesWritten)
{
  int v1; // ecx
  int *result; // eax
  int v3; // esi
  char *v4; // edi
  const char **v5; // esi
  HANDLE StdHandle; // eax
  const char *v7; // [esp-14h] [ebp-1B8h]
  DWORD v8; // [esp-10h] [ebp-1B4h]
  DWORD *p_NumberOfBytesWritten; // [esp-Ch] [ebp-1B0h]
  int v10; // [esp-8h] [ebp-1ACh]
  CHAR Filename[260]; // [esp+0h] [ebp-1A4h] BYREF
  char Destination[160]; // [esp+104h] [ebp-A0h] BYREF
  int savedregs; // [esp+1A4h] [ebp+0h] BYREF

  v1 = 0;
  result = (_DWORD*)dword_4B86D0;
  do
  {
    if ( NumberOfBytesWritten == *result )
      break;
    result += 2;
    ++v1;
  }
  while ( (int)result < (int)&dword_4B8760 );
  v3 = 2 * v1;
  if ( NumberOfBytesWritten == dword_4B86D0[2 * v1] )//???,¸ã²»¶®
  {
    result = (int *)dword_4CB234;
    if ( dword_4CB234 == 1 || !dword_4CB234 && *(int*)dword_4B8304 == 1 )
    {
      v5 = (const char **)off_4B86D4[v3];
      v10 = 0;
      p_NumberOfBytesWritten = &NumberOfBytesWritten;
      v8 = strlen(*v5);
      v7 = *v5;
      StdHandle = GetStdHandle(0xFFFFFFF4);
      return (int *)WriteFile(StdHandle, v7, v8, (LPDWORD)&NumberOfBytesWritten, 0);
    }
    else if ( NumberOfBytesWritten != 252 )
    {
      if ( !GetModuleFileNameA(0, Filename, 0x104u) )
        strcpy(Filename, "<program name unknown>");
      v4 = Filename;
      if ( strlen(Filename) + 1 > 0x3C )
      {
        v4 = (char *)&savedregs + strlen(Filename) - 479;
        strncpy(v4, "...", 3u);
      }
      strcpy(Destination, "Runtime Error!\n\nProgram: ");
      strcat(Destination, v4);
      strcat(Destination, "\n\n");
      strcat(Destination, ((const char*)     off_4B86D4[v3]          )             );
      return (int *)__crtMessageBoxA(Destination, "Microsoft Visual C++ Runtime Library", 73744);
    }
  }
  return result;
}

//???
//_onexit_t __cdecl _onexit(_onexit_t Func)
//{
//  size_t v1; // eax
//  _onexit_t *v2; // ecx
//  size_t v3; // eax
//  _onexit_t result; // eax
//  int v5; // ecx
//
//  v1 = _msize((void*)dword_4CC7D0);
//  v2 = (_onexit_t *)dword_4CC7CC;
//  if ( v1 < dword_4CC7CC - (int)dword_4CC7D0 + 4 )
//  {
//    v3 = _msize((void*)dword_4CC7D0);
//    result = (_onexit_t)realloc((void*)dword_4CC7D0, v3 + 16);
//    if ( !result )
//      return result;
//    v5 = dword_4CC7CC - (_DWORD)dword_4CC7D0;
//    dword_4CC7D0 = (_DWORD)result;
//    v2 = (_onexit_t *)((char *)result + 4 * (v5 >> 2));
//    dword_4CC7CC = (int)v2;
//  }
//  result = Func;
//  *v2 = Func;
//  dword_4CC7CC += 4;
//  return result;
//}
int __cdecl _output(myFILE *File, int a2, int a3)
{
  int v3; // esi
  char v4; // bl
  char *v5; // edi
  bool v6; // zf
  int v7; // ecx
  int v8; // eax
  int int_arg; // eax
  int v10; // eax
  int v11; // esi
  int v12; // eax
  char *v13; // ecx
  char *i; // eax
  int v15; // edx
  wchar_t short_arg; // ax
  __int16 *v17; // eax
  int v18; // ecx
  int v19; // eax
  int v20; // eax
  char *j; // eax
  int v22; // edx
  _WORD *v23; // eax
  __int64 v24; // rax
  unsigned __int64 v25; // rdi
  int v26; // eax
  int v27; // ebx
  unsigned __int64 v28; // kr08_8
  _BYTE *v29; // eax
  char *v30; // eax
  char v31; // bl
  int v32; // esi
  wchar_t *v33; // ebx
  int v34; // edi
  wchar_t v35; // ax
  int v36; // eax
  char Str; // [esp+Ch] [ebp-248h] BYREF
  char v40; // [esp+20Bh] [ebp-49h] BYREF
  int v41[2]; // [esp+20Ch] [ebp-48h] BYREF
  __int64 v42; // [esp+214h] [ebp-40h]
  char MbCh[4]; // [esp+21Ch] [ebp-38h] BYREF
  int v44; // [esp+220h] [ebp-34h]
  int v45; // [esp+224h] [ebp-30h]
  int v46; // [esp+228h] [ebp-2Ch]
  int v47; // [esp+22Ch] [ebp-28h]
  int v48; // [esp+230h] [ebp-24h]
  int v49; // [esp+234h] [ebp-20h]
  int v50; // [esp+238h] [ebp-1Ch]
  _WORD v51[3]; // [esp+23Eh] [ebp-16h] BYREF
  int v52; // [esp+244h] [ebp-10h]
  int v53; // [esp+248h] [ebp-Ch]
  int p_Str; // [esp+24Ch] [ebp-8h]
  int v55; // [esp+250h] [ebp-4h]
  char *v56; // [esp+260h] [ebp+Ch]

  v3 = 0;
  v4 = *(_BYTE *)a2;
  v5 = (char *)(a2 + 1);
  v6 = *(_BYTE *)a2 == 0;
  v53 = 0;
  *(_DWORD *)&v51[1] = 0;
  v56 = (char *)(a2 + 1);
  if ( !v6 )
  {
    v7 = v52;
    while ( 1 )
    {
      if ( *(int *)&v51[1] < 0 )
        return *(_DWORD *)&v51[1];
      if ( v4 < 32 || v4 > 120 )
        v8 = 0;
      else
        v8 = *((_BYTE *)&dbl_4AC540 + v4) & 0xF;
      v45 = byte_4AC560[8 * v8 + v3] >> 4;
      switch ( v45 )
      {
        case 0:
          goto $NORMAL_STATE$1535;
        case 1:
          v52 = -1;
          v44 = 0;
          v47 = 0;
          v49 = 0;
          v50 = 0;
          v55 = 0;
          v48 = 0;
          goto LABEL_171;
        case 2:
          switch ( v4 )
          {
            case ' ':
              v55 |= 2u;
              break;
            case '#':
              LOBYTE(v55) = v55 | 0x80;
              break;
            case '+':
              v55 |= 1u;
              break;
            case '-':
              v55 |= 4u;
              break;
            case '0':
              v55 |= 8u;
              break;
          }
          goto LABEL_171;
        case 3:
          if ( v4 == 42 )
          {
            int_arg = get_int_arg(&a3);
            v49 = int_arg;
            if ( int_arg >= 0 )
              goto LABEL_171;
            v55 |= 4u;
            v10 = -int_arg;
          }
          else
          {
            v10 = v4 + 10 * v49 - 48;
          }
          v49 = v10;
          goto LABEL_171;
        case 4:
          v52 = 0;
          goto LABEL_171;
        case 5:
          if ( v4 == 42 )
          {
            v52 = get_int_arg(&a3);
            if ( v52 < 0 )
              v52 = -1;
          }
          else
          {
            v52 = v4 + 10 * v7 - 48;
          }
          goto LABEL_171;
        case 6:
          switch ( v4 )
          {
            case 'I':
              if ( *v5 == 54 && v5[1] == 52 )
              {
                BYTE1(v55) |= 0x80u;
                v56 = v5 + 2;
              }
              else
              {
                v45 = 0;
$NORMAL_STATE$1535:
                v48 = 0;
                if ( *((char *)off_4B8414 + 2 * (unsigned __int8)v4 + 1) < 0 )
                {
                  write_char(v4, File, (int)&v51[1]);
                  v4 = *v5;
                  v56 = v5 + 1;
                }
                write_char(v4, File, (int)&v51[1]);
              }
              break;
            case 'h':
              v55 |= 0x20u;
              break;
            case 'l':
              v55 |= 0x10u;
              break;
            case 'w':
              BYTE1(v55) |= 8u;
              break;
          }
          goto LABEL_171;
        case 7:
          if ( v4 > 103 )
          {
            switch ( v4 )
            {
              case 'i':
                goto LABEL_114;
              case 'n':
                v23 = (_WORD *)get_int_arg(&a3);
                if ( (v55 & 0x20) != 0 )
                  *v23 = v51[1];
                else
                  *(_DWORD *)v23 = *(_DWORD *)&v51[1];
                v47 = 1;
                goto LABEL_171;
              case 'o':
                v53 = 8;
                if ( (v55 & 0x80u) != 0 )
                  BYTE1(v55) |= 2u;
                break;
              default:
                switch ( v4 )
                {
                  case 'p':
                    v52 = 8;
LABEL_105:
                    v46 = 7;
                    break;
                  case 's':
                    goto LABEL_55;
                  case 'u':
                    goto LABEL_115;
                  case 'x':
                    v46 = 39;
                    break;
                  default:
                    goto LABEL_148;
                }
                v53 = 16;
                if ( (v55 & 0x80u) != 0 )
                {
                  LOBYTE(v51[0]) = 48;
                  v50 = 2;
                  HIBYTE(v51[0]) = v46 + 81;
                }
                break;
            }
LABEL_116:
            if ( (v55 & 0x8000) == 0 )
            {
              if ( (v55 & 0x20) != 0 )
              {
                if ( (v55 & 0x40) != 0 )
                  LODWORD(v24) = (__int16)get_int_arg(&a3);
                else
                  LODWORD(v24) = (unsigned __int16)get_int_arg(&a3);
              }
              else
              {
                if ( (v55 & 0x40) == 0 )
                {
                  v24 = (unsigned int)get_int_arg(&a3);
                  goto LABEL_126;
                }
                LODWORD(v24) = get_int_arg(&a3);
              }
              v24 = (int)v24;
            }
            else
            {
              LODWORD(v24) = get_int64_arg(&a3);
            }
LABEL_126:
            if ( (v55 & 0x40) != 0 && v24 < 0 )
            {
              HIDWORD(v25) = -(int)v24;
              BYTE1(v55) |= 1u;
              LODWORD(v25) = (unsigned __int64)-v24 >> 32;
            }
            else
            {
              v25 = __PAIR64__(v24, HIDWORD(v24));
            }
            if ( (v55 & 0x8000) == 0 )
              LODWORD(v25) = 0;
            if ( v52 >= 0 )
              v55 &= ~8u;
            else
              v52 = 1;
            if ( !v25 )
              v50 = 0;
            p_Str = (int)&v40;
            while ( 1 )
            {
              v26 = v52--;
              if ( v26 <= 0 && !v25 )
                break;
              v42 = v53;
              v27 = __PAIR64__(v25, HIDWORD(v25)) % v53 + 48;
              v28 = __PAIR64__(v25, HIDWORD(v25)) / v53;
              v25 = __PAIR64__(v28, HIDWORD(v28));
              if ( v27 > 57 )
                LOBYTE(v27) = v46 + v27;
              v29 = (_BYTE *)p_Str--;
              *v29 = v27;
            }
            v30 = &v40 - p_Str++;
            v53 = (int)v30;
            if ( (v55 & 0x200) != 0 && (*(_BYTE *)p_Str != 48 || !v30) )
            {
              --p_Str;
              v20 = (int)(v30 + 1);
              *(_BYTE *)p_Str = 48;
              goto LABEL_147;
            }
            goto LABEL_148;
          }
          if ( v4 >= 101 )
            goto LABEL_65;
          if ( v4 > 88 )
          {
            if ( v4 == 90 )
            {
              v17 = (__int16 *)get_int_arg(&a3);
              if ( v17 && (v18 = *((_DWORD *)v17 + 1)) != 0 )
              {
                if ( (v55 & 0x800) != 0 )
                {
                  v19 = (unsigned int)*v17 >> 1;
                  p_Str = v18;
                  v53 = v19;
                  v48 = 1;
                  goto LABEL_148;
                }
                v48 = 0;
                p_Str = v18;
                v20 = *v17;
              }
              else
              {
                p_Str = (int)Str;
                v20 = strlen((char*)Str);
              }
              goto LABEL_147;
            }
            if ( v4 == 99 )
              goto LABEL_69;
            if ( v4 != 100 )
              goto LABEL_148;
LABEL_114:
            v55 |= 0x40u;
LABEL_115:
            v53 = 10;
            goto LABEL_116;
          }
          switch ( v4 )
          {
            case 'X':
              goto LABEL_105;
            case 'C':
              if ( (v55 & 0x830) == 0 )
                BYTE1(v55) |= 8u;
LABEL_69:
              if ( (v55 & 0x810) != 0 )
              {
                short_arg = get_short_arg(&a3);
                v53 = wctomb(&Str, short_arg);
                if ( v53 < 0 )
                  v47 = 1;
              }
              else
              {
                Str = get_int_arg(&a3);
                v53 = 1;
              }
              p_Str = (int)&Str;
              goto LABEL_148;
            case 'E':
            case 'G':
              v44 = 1;
              v4 += 32;
LABEL_65:
              v55 |= 0x40u;
              p_Str = (int)&Str;
              if ( v7 >= 0 )
              {
                if ( !v7 && v4 == 103 )
                  v52 = 1;
              }
              else
              {
                v52 = 6;
              }
              a3 += 8;
              v41[0] = *(_DWORD *)(a3 - 8);
              v41[1] = *(_DWORD *)(a3 - 4);
              ((void(__stdcall*)(int,int,int,int,int) ) off_4B8318)           ((_DWORD)v41, (_DWORD)&Str, v4, v52, v44);
              break;
          }
          if ( v4 == 83 )
          {
            if ( (v55 & 0x830) == 0 )
              BYTE1(v55) |= 8u;
LABEL_55:
            v11 = v52;
            if ( v52 == -1 )
              v11 = 0x7FFFFFFF;
            v12 = get_int_arg(&a3);
            v13 = (char *)v12;
            p_Str = v12;
            if ( (v55 & 0x810) != 0 )
            {
              if ( !v12 )
              {
                v13 = (char *)off_4B8634;
                p_Str = (int)off_4B8634;
              }
              v48 = 1;
              for ( i = v13; ; i += 2 )
              {
                v15 = v11--;
                if ( !v15 || !*(_WORD *)i )
                  break;
              }
              v20 = (i - v13) >> 1;
            }
            else
            {
              if ( !v12 )
              {
                v13 = ( char*)Str;
                p_Str = (int)::Str;
              }
              for ( j = v13; ; ++j )
              {
                v22 = v11--;
                if ( !v22 || !*j )
                  break;
              }
              v20 = j - v13;
            }
LABEL_147:
            v53 = v20;
          }
LABEL_148:
          if ( v47 )
            goto LABEL_171;
          v31 = v55;
          if ( (v55 & 0x40) == 0 )
            goto LABEL_157;
          if ( (v55 & 0x100) != 0 )
          {
            LOBYTE(v51[0]) = 45;
LABEL_156:
            v50 = 1;
            goto LABEL_157;
          }
          if ( (v55 & 1) != 0 )
          {
            LOBYTE(v51[0]) = 43;
            goto LABEL_156;
          }
          if ( (v55 & 2) != 0 )
          {
            LOBYTE(v51[0]) = 32;
            goto LABEL_156;
          }
LABEL_157:
          v32 = v49 - v50 - v53;
          if ( (v55 & 0xC) == 0 )
            write_multi_char(32, v49 - v50 - v53, File, (int)&v51[1]);
          write_string((int)v51, v50, File, (int)&v51[1]);
          if ( (v31 & 8) != 0 && (v31 & 4) == 0 )
            write_multi_char(48, v32, File, (int)&v51[1]);
          if ( v48 && v53 > 0 )
          {
            v33 = (wchar_t *)p_Str;
            v34 = v53 - 1;
            do
            {
              v35 = *v33++;
              v36 = wctomb(MbCh, v35);
              if ( v36 <= 0 )
                break;
              write_string((int)MbCh, v36, File, (int)&v51[1]);
            }
            while ( v34-- );
          }
          else
          {
            write_string(p_Str, v53, File, (int)&v51[1]);
          }
          if ( (v55 & 4) != 0 )
            write_multi_char(32, v32, File, (int)&v51[1]);
LABEL_171:
          v4 = *v56;
          v5 = v56 + 1;
          v6 = *v56++ == 0;
          if ( v6 )
            return *(_DWORD *)&v51[1];
          v7 = v52;
          v3 = v45;
          break;
        default:
          goto LABEL_171;
      }
    }
  }
  return *(_DWORD *)&v51[1];
}
BOOL __cdecl _positive(double *a1)
{
  return *a1 >= 0.0;
}
int __cdecl _powhlp(double a1, double a2, int a3)
{
  double v4; // st7
  int v5; // esi
  char v6; // c0
  double v7; // st7
  int v8; // ecx

  v4 = a1;
  v5 = 0;
  if ( v6 )
    v4 = -a1;
  if ( HIDWORD(a2) != 2146435072 )
  {
    if ( a2 == -INFINITY )
    {
      if ( v4 > 1.0 )
        goto LABEL_17;
      if ( v4 >= 1.0 )
        goto LABEL_7;
LABEL_15:
      v7 = *(double*)dbl_4B8D78;
LABEL_28:
      *(double *)a3 = v7;
      return v5;
    }
LABEL_12:
    if ( HIDWORD(a1) == 2146435072 )
    {
      if ( LODWORD(a1) )
        return v5;
      if ( a2 > 0.0 )
        goto LABEL_15;
      if ( a2 < 0.0 )
        goto LABEL_17;
    }
    else
    {
      if ( a1 != -INFINITY )
        return v5;
      v8 = _d_inttype(a2);
      if ( a2 > 0.0 )
      {
        v7 = *(double*)dbl_4B8D78;
        if ( v8 == 1 )
          v7 = -*(double*)dbl_4B8D78;
        goto LABEL_28;
      }
      if ( a2 < 0.0 )
      {
        if ( v8 == 1 )
          v7 = *(double*)dbl_4B8D98;
        else
          v7 = 0.0;
        goto LABEL_28;
      }
    }
    v7 = 1.0;
    goto LABEL_28;
  }
  if ( LODWORD(a2) )
    goto LABEL_12;
  if ( v4 > 1.0 )
    goto LABEL_15;
  if ( v4 < 1.0 )
  {
LABEL_17:
    v7 = 0.0;
    goto LABEL_28;
  }
LABEL_7:
  v5 = 1;
  *(double *)a3 = *(double*)dbl_4B8D80;
  return v5;
}
ULONG_PTR __cdecl _raise_exc(ULONG_PTR Arguments, int a2, DWORD dwExceptionCode, int a4, int a5, int a6)
{
  char v6; // cl
  int v7; // esi
  char v8; // al
  int v9; // eax
  _DWORD *v10; // eax
  unsigned int v11; // ecx
  int v12; // eax
  _DWORD *v13; // eax
  unsigned int v14; // ecx
  double *v15; // edi
  __int16 v16; // fps
  ULONG_PTR result; // eax
  int v18; // ecx
  int v19; // ecx
  int v20; // ecx
  int v21; // ecx
  int v22; // ecx
  int v23; // ecx
  unsigned int v24; // ecx

  *(_DWORD *)(Arguments + 4) = 0;
  *(_DWORD *)(Arguments + 8) = 0;
  *(_DWORD *)(Arguments + 12) = 0;
  v6 = dwExceptionCode;
  if ( (dwExceptionCode & 0x10) != 0 )
  {
    dwExceptionCode = -1073741681;
    *(_DWORD *)(Arguments + 4) |= 1u;
  }
  if ( (v6 & 2) != 0 )
  {
    dwExceptionCode = -1073741677;
    *(_DWORD *)(Arguments + 4) |= 2u;
  }
  if ( (v6 & 1) != 0 )
  {
    dwExceptionCode = -1073741679;
    *(_DWORD *)(Arguments + 4) |= 4u;
  }
  if ( (v6 & 4) != 0 )
  {
    dwExceptionCode = -1073741682;
    *(_DWORD *)(Arguments + 4) |= 8u;
  }
  if ( (v6 & 8) != 0 )
  {
    dwExceptionCode = -1073741680;
    *(_DWORD *)(Arguments + 4) |= 0x10u;
  }
  v7 = a2;
  *(_DWORD *)(Arguments + 8) = *(_DWORD *)(Arguments + 8) & 0xFFFFFFEF | (16 * ((*(_DWORD *)a2 & 1) == 0));
  *(_DWORD *)(Arguments + 8) = *(_DWORD *)(Arguments + 8) & 0xFFFFFFF7 | (2 * (~(unsigned __int8)*(_DWORD *)v7 & 4));
  *(_DWORD *)(Arguments + 8) = *(_DWORD *)(Arguments + 8) & 0xFFFFFFFB | ((unsigned int)~*(_DWORD *)v7 >> 1) & 4;
  *(_DWORD *)(Arguments + 8) = *(_DWORD *)(Arguments + 8) & 0xFFFFFFFD | ((unsigned int)~*(_DWORD *)v7 >> 3) & 2;
  *(_DWORD *)(Arguments + 8) = *(_DWORD *)(Arguments + 8) & 0xFFFFFFFE | ((unsigned int)~*(_DWORD *)v7 >> 5) & 1;
  v8 = _statfp((__int16)a1);
  if ( (v8 & 1) != 0 )
    *(_DWORD *)(Arguments + 12) |= 0x10u;
  if ( (v8 & 4) != 0 )
    *(_DWORD *)(Arguments + 12) |= 8u;
  if ( (v8 & 8) != 0 )
    *(_DWORD *)(Arguments + 12) |= 4u;
  if ( (v8 & 0x10) != 0 )
    *(_DWORD *)(Arguments + 12) |= 2u;
  if ( (v8 & 0x20) != 0 )
    *(_DWORD *)(Arguments + 12) |= 1u;
  v9 = *(_DWORD *)v7 & 0xC00;
  switch ( v9 )
  {
    case 0:
      *(_DWORD *)Arguments &= 0xFFFFFFFC;
      break;
    case 1024:
      v10 = (_DWORD *)Arguments;
      v11 = *(_DWORD *)Arguments & 0xFFFFFFFC | 1;
      goto LABEL_28;
    case 2048:
      v10 = (_DWORD *)Arguments;
      v11 = *(_DWORD *)Arguments & 0xFFFFFFFC | 2;
LABEL_28:
      *v10 = v11;
      break;
    case 3072:
      *(_DWORD *)Arguments |= 3u;
      break;
  }
  v12 = *(_DWORD *)v7 & 0x300;
  switch ( v12 )
  {
    case 0:
      v13 = (_DWORD *)Arguments;
      v14 = *(_DWORD *)Arguments & 0xFFFFFFE3 | 8;
      goto LABEL_36;
    case 512:
      v13 = (_DWORD *)Arguments;
      v14 = *(_DWORD *)Arguments & 0xFFFFFFE3 | 4;
LABEL_36:
      *v13 = v14;
      break;
    case 768:
      *(_DWORD *)Arguments &= 0xFFFFFFE3;
      break;
  }
  *(_DWORD *)Arguments = *(_DWORD *)Arguments & 0xFFFE001F | (32 * (a4 & 0xFFF));
  *(_DWORD *)(Arguments + 32) |= 1u;
  *(_DWORD *)(Arguments + 32) = *(_DWORD *)(Arguments + 32) & 0xFFFFFFE1 | 2;
  *(double *)(Arguments + 16) = *(double *)a5;
  *(_DWORD *)(Arguments + 80) |= 1u;
  v15 = (double *)a6;
  *(_DWORD *)(Arguments + 80) = *(_DWORD *)(Arguments + 80) & 0xFFFFFFE1 | 2;
  *(double *)(Arguments + 64) = *v15;
  _clrfp(v16);
  RaiseException(dwExceptionCode, 0, 1u, &Arguments);
  result = Arguments;
  if ( (*(_BYTE *)(Arguments + 8) & 0x10) != 0 )
    *(_DWORD *)v7 &= ~1u;
  if ( (*(_BYTE *)(result + 8) & 8) != 0 )
    *(_DWORD *)v7 &= ~4u;
  if ( (*(_BYTE *)(result + 8) & 4) != 0 )
    *(_DWORD *)v7 &= ~8u;
  if ( (*(_BYTE *)(result + 8) & 2) != 0 )
    *(_DWORD *)v7 &= ~0x10u;
  if ( (*(_BYTE *)(result + 8) & 1) != 0 )
    *(_DWORD *)v7 &= ~0x20u;
  v18 = *(_DWORD *)result & 3;
  if ( !v18 )
  {
    *(_DWORD *)v7 &= 0xFFFFF3FF;
    goto LABEL_56;
  }
  v19 = v18 - 1;
  if ( !v19 )
  {
    v21 = *(_DWORD *)v7;
    BYTE1(v21) = BYTE1(*(_DWORD *)v7) & 0xF3 | 4;
    goto LABEL_54;
  }
  v20 = v19 - 1;
  if ( !v20 )
  {
    v21 = *(_DWORD *)v7;
    BYTE1(v21) = BYTE1(*(_DWORD *)v7) & 0xF3 | 8;
LABEL_54:
    *(_DWORD *)v7 = v21;
    goto LABEL_56;
  }
  if ( v20 == 1 )
    *(_BYTE *)(v7 + 1) |= 0xCu;
LABEL_56:
  v22 = (*(_DWORD *)result >> 2) & 7;
  if ( !v22 )
  {
    v24 = *(_DWORD *)v7 & 0xFFFFF3FF;
    BYTE1(v24) |= 3u;
    goto LABEL_62;
  }
  v23 = v22 - 1;
  if ( !v23 )
  {
    v24 = *(_DWORD *)v7 & 0xFFFFF3FF;
    BYTE1(v24) |= 2u;
LABEL_62:
    *(_DWORD *)v7 = v24;
    goto LABEL_63;
  }
  if ( v23 == 1 )
    *(_DWORD *)v7 &= 0xFFFFF3FF;
LABEL_63:
  *v15 = *(double *)(result + 64);
  return result;
}
int __cdecl _RoundMan(int a1, int a2)
{
  int v2; // edi
  int v4; // edx
  _DWORD *v5; // eax
  char v6; // si
  int v8; // [esp+Ch] [ebp-8h]
  int v9; // [esp+10h] [ebp-4h]
  _DWORD *v10; // [esp+20h] [ebp+Ch]

  v2 = a2 - 1;
  v9 = 0;
  v4 = a2 % 32;
  v8 = a2 / 32;
  v5 = (_DWORD *)(a1 + 4 * (a2 / 32));
  v10 = v5;
  v6 = 31 - v4;
  if ( ((1 << (31 - v4)) & *v5) != 0 )
  {
    if ( !_ZeroTail(a1, a2 + 1) )
      v9 = _IncMan(a1, v2);
    v5 = v10;
  }
  *v5 &= -1 << v6;
  if ( v8 + 1 < 3 )
    memset((void *)(a1 + 4 * (v8 + 1)), 0, 4 * (3 - (v8 + 1)));
  return v9;
}
double _rtpiby2()
{
  return *(double *)&tbyte_4B833A;
}
void _rttosnpop()
{
  ;
}
void  _rttosnpopde(int a1)
{
  *(_BYTE *)(a1 - 144) = 1;
}
int __stdcall _seh_longjmp_unwind(int *a1)
{
  return _local_unwind2(*a1, a1[6], a1[7]);
}
int _setargv()
{
  CHAR *v0; // edi
  char *v1; // esi
  int result; // eax
  int v3; // [esp+Ch] [ebp-8h] BYREF
  int v4; // [esp+10h] [ebp-4h] BYREF

  if ( !dword_4CC7C8 )
    __initmbctable();
  GetModuleFileNameA(0, (LPSTR)Filename, 0x104u);
  dword_4CB2A4 = (int)Filename;
  v0 = (char*)Filename;
  if ( *(_BYTE *)dword_4CC7D4 )
    v0 = (CHAR *)dword_4CC7D4;
  parse_cmdline((unsigned char*)v0, 0, 0, &v4, &v3);
  v1 = (char *)malloc(v3 + 4 * v4);
  if ( !v1 )
    _amsg_exit(8u);
  parse_cmdline((unsigned char*)v0, (unsigned char**)v1, (unsigned char*)&v1[4 * v4], &v4, &v3);
  result = v4 - 1;
  dword_4CB28C = (int)v1;
  dword_4CB288 = v4 - 1;
  return result;
}
unsigned int _setdefaultprecision()
{
  return _controlfp(0x10000u, 0x30000u);
}
void _SetDetached(
    Concurrency::details::_UnrealizedChore* thisxx,
    bool a2)
{
    *((_BYTE*)thisxx + 17) = a2;
}
void _setenvp()
{
  char *v0; // esi
  int v1; // edi
  char **v2; // esi
  const char *i; // edi
  size_t v4; // eax
  size_t v5; // ebp
  char *v6; // eax

  if ( !dword_4CC7C8 )
    __initmbctable();
  v0 = (char*)Block;
  v1 = 0;
  while ( *v0 )
  {
    if ( *v0 != 61 )
      ++v1;
    v0 += strlen(v0) + 1;
  }
  v2 = (char **)malloc(4 * v1 + 4);
  dword_4CB294 = (int)v2;
  if ( !v2 )
    _amsg_exit(9u);
  for ( i = (char*)Block; *i; i += v5 )
  {
    v4 = strlen(i);
    v5 = v4 + 1;
    if ( *i != 61 )
    {
      v6 = (char *)malloc(v4 + 1);
      *v2 = v6;
      if ( !v6 )
        _amsg_exit(9u);
      strcpy(*v2++, i);
    }
  }
  free(Block);
  Block = 0;
  *v2 = 0;
  dword_4CC7C4 = 1;
}
int __cdecl _setmbcp(int CodePage)
{
  UINT SystemCP; // eax
  UINT v2; // esi
  int v3; // edx
  _DWORD *v4; // eax
  bool v5; // cc
  BYTE *v6; // ecx
  BYTE v7; // dl
  unsigned int i; // eax
  int v9; // esi
  char *v10; // ebx
  unsigned __int8 *v11; // ecx
  unsigned __int8 v12; // dl
  unsigned int v13; // eax
  unsigned int v14; // edi
  char v15; // dl
  int v16; // eax
  _DWORD *v17; // esi
  unsigned int j; // eax
  struct _cpinfo CPInfo; // [esp+Ch] [ebp-18h] BYREF
  unsigned int v21; // [esp+20h] [ebp-4h]
  UINT CodePagea; // [esp+2Ch] [ebp+8h]

  SystemCP = getSystemCP(CodePage);
  v2 = SystemCP;
  CodePagea = SystemCP;
  if ( SystemCP == dword_4CB458 )
    return 0;
  if ( !SystemCP )
  {
LABEL_30:
    setSBCS();
LABEL_31:
    setSBUpLow();
    return 0;
  }
  v3 = 0;
  v4 = (_DWORD*)&unk_4B8B88;
  do
  {
    if ( *v4 == v2 )
    {
      memset(&unk_4CB580, 0, 0x100u);
      v21 = 0;
      v9 = 48 * v3;
      *((_BYTE *)&unk_4CB580 + 256) = 0;
      v10 = (char *)&unk_4B8B98 + 48 * v3;
      do
      {
        v11 = (unsigned __int8 *)v10;
        if ( *v10 )
        {
          do
          {
            v12 = v11[1];
            if ( !v12 )
              break;
            v13 = *v11;
            v14 = v12;
            if ( v13 <= v12 )
            {
              v15 = byte_4B8B80[v21];
              do
                byte_4CB581[v13++] |= v15;
              while ( v13 <= v14 );
            }
            v11 += 2;
          }
          while ( *v11 );
        }
        ++v21;
        v10 += 8;
      }
      while ( v21 < 4 );
      dword_4CB46C = 1;
      dword_4CB458 = CodePagea;
      v16 = CPtoLCID(CodePagea);
      v17 = (_DWORD *)((char *)&unk_4B8B8C + v9);
      dword_4CB460[0] = *v17++;
      dword_4CB460[1] = *v17;
      Locale = v16;
      dword_4CB460[2] = v17[1];
      goto LABEL_31;
    }
    v4 += 12;
    ++v3;
  }
  while ( (int)v4 < (int)&unk_4B8C78 );
  if ( GetCPInfo(v2, &CPInfo) )
  {
    v5 = CPInfo.MaxCharSize <= 1;
    dword_4CB458 = v2;
    //memset(&unk_4CB580, 0, 0x100u);
    memset(&byte_4CB581, 0, 0x100u);
    //*((_BYTE *)&unk_4CB580 + 256) = 0;
    *((_BYTE *)&byte_4CB581 + 256) = 0;
    Locale = 0;
    if ( v5 )
    {
      dword_4CB46C = 0;
    }
    else
    {
      if ( CPInfo.LeadByte[0] )
      {
        v6 = &CPInfo.LeadByte[1];
        do
        {
          v7 = *v6;
          if ( !*v6 )
            break;
          for ( i = *(v6 - 1); i <= v7; ++i )
            byte_4CB581[i] |= 4u;
          v6 += 2;
        }
        while ( *(v6 - 1) );
      }
      for ( j = 1; j < 0xFF; ++j )
        byte_4CB581[j] |= 8u;
      Locale = CPtoLCID(v2);
      dword_4CB46C = 1;
    }
    dword_4CB460[0] = 0;
    dword_4CB460[1] = 0;
    dword_4CB460[2] = 0;
    goto LABEL_31;
  }
  if ( dword_4CB410 )
    goto LABEL_30;
  return -1;
}
void _SetRuntimeOwnsLifetime(
    Concurrency::details::_UnrealizedChore* thisxx,
    bool a2)
{
    *((_BYTE*)thisxx + 16) = a2;
}//???
//errno_t __cdecl _set_errno(int Value)
//{
//  errno_t result; // eax
//
//  result = Value;
//  if ( Value == 1 )
//  {
//    dword_4CB26C = 33;
//  }
//  else if ( Value > 1 && Value <= 3 )
//  {
//    dword_4CB26C = 34;
//  }
//  return result;
//}
double __cdecl _set_exp(double a1, int a2)
{
  double v3; // [esp+0h] [ebp-8h]

  v3 = a1;
  HIWORD(v3) = HIWORD(a1) & 0x800F | (16 * (a2 + 1022));
  return v3;
}
void _set_statfp()
{
  ;
}
void __cdecl _shift(char *Str, int a2)
{
  size_t v2; // eax

  if ( a2 )
  {
    v2 = strlen(Str);
    memcpy_0(&Str[a2], Str, v2 + 1);
  }
}
int *__cdecl _ShrMan(int *a1, int a2)
{
  int *v2; // edi
  int v3; // edx
  bool v4; // zf
  int v5; // ebx
  int i; // ecx
  int *result; // eax
  int v8; // [esp+Ch] [ebp-Ch]
  int v9; // [esp+10h] [ebp-8h]
  int v10; // [esp+14h] [ebp-4h]
  int v11; // [esp+24h] [ebp+Ch]

  v2 = a1;
  v10 = 3;
  v8 = a2 / 32;
  v3 = a2 % 32;
  v11 = 0;
  do
  {
    v9 = ~(-1 << v3) & *v2;
    *v2 = v11 | ((unsigned int)*v2 >> v3);
    ++v2;
    v4 = v10-- == 1;
    v11 = v9 << (32 - v3);
  }
  while ( !v4 );
  v5 = 2;
  for ( i = 2; i >= 0; --i )
  {
    if ( v5 < v8 )
    {
      result = a1;
      a1[i] = 0;
    }
    else
    {
      result = *(int **)((char *)a1 + i * 4 - 4 * v8);
      a1[i] = (int)result;
    }
    --v5;
  }
  return result;
}
int __cdecl _sptype(int a1, int a2)
{
  if ( a2 == 2146435072 )
  {
    if ( !a1 )
      return 1;
  }
  else if ( a2 == -1048576 && !a1 )
  {
    return 2;
  }
  if ( (HIWORD(a2) & 0x7FF8) == 32760 )
    return 3;
  if ( (HIWORD(a2) & 0x7FF8) == 32752 && ((a2 & 0x7FFFF) != 0 || a1) )
    return 4;
  return 0;
}
double  _startOneArgErrorHandling(
        int a1,
        int a2,
        int a3,
        double a4,
        __int16 a5,
        int a6,
        int a7,
        int a8)
{
  int v9[6]; // [esp+0h] [ebp-20h] BYREF
  double v10; // [esp+18h] [ebp-8h]

  v9[0] = a1;
  v10 = a4;
  v9[1] = a3;
  v9[2] = a7;
  v9[3] = a8;
  _87except(a2, (int)v9, (unsigned __int16 *)&a5);
  return v10;
}
void _startTwoArgErrorHandling()
{
  //£¿£¿£¿JUMPOUT(0x4A4950);
}
int  _statfp(__int16 a1)
{
  return a1;
}
int  _trandisp1(int a1, __int16 a2, int a3, __int16 a4, double _ST7)
{
  __int16 v5; // bx

  if ( *(_BYTE *)(a1 + 14) == 5 )
  {
    HIBYTE(v5) = HIBYTE(*(_WORD *)(a3 - 164)) & 0xFC | 2;
    LOBYTE(v5) = 63;
  }
  else
  {
    v5 = 4927;
  }
  *(_WORD *)(a3 - 162) = v5;
  int _EBX = (char)&unk_4B834D;//??
  __asm { fxam }
  *(_DWORD *)(a3 - 148) = a1;
  *(_WORD *)(a3 - 160) = a4;
  *(_BYTE *)(a3 - 144) = 0;
  LOBYTE(a2) = __ROL1__((char)(2 * *(_BYTE *)(a3 - 159)) >> 1, 1);
  int _AL = a2 & 0xF;//??
  __asm { xlat }
  return (*(int ( **)(int))(_AL + a1 + 16))(a2 & 0x404);
}

int  _trandisp2(int a1, int a2, __int16 a3, double _ST6, double a5)
{
  __int16 v5; // bx
  __int16 v7; // fps
  char v9; // cl
  __int16 v10; // cx
  char v13; // ah

  if ( *(_BYTE *)(a1 + 14) == 5 )
  {
    HIBYTE(v5) = HIBYTE(*(_WORD *)(a2 - 164)) & 0xFC | 2;
    LOBYTE(v5) = 63;
  }
  else
  {
    v5 = 4927;
  }
  *(_WORD *)(a2 - 162) = v5;
  int _EBX = (char)&unk_4B834D;
  __asm { fxam }
  *(_DWORD *)(a2 - 148) = a1;
  *(_WORD *)(a2 - 160) = a3;
  *(_BYTE *)(a2 - 144) = 0;
  _ST6 = a5;
  v9 = *(_BYTE *)(a2 - 159);
  __asm { fxam }
  *(_WORD *)(a2 - 160) = v7;
  HIBYTE(v10) = __ROL1__((char)(2 * *(_BYTE *)(a2 - 159)) >> 1, 1);
  int _AL = HIBYTE(v10) & 0xF;
  __asm { xlat }
  v13 = _AL;
  LOBYTE(v10) = __ROL1__((char)(2 * v9) >> 1, 1);
  _AL = v10 & 0xF;
  __asm { xlat }
  return (*(int ( **)(int))((char)((4 * v13) | _AL) + a1 + 16))(v10 & 0x404);
}
double  _twoToTOS(double a1)
{
  _ST6 = a1;
  __asm { frndint }
  //return __FSCALE__(__F2XM1__(-(_ST6 - a1)) + 1.0, _ST6);
  return 0;//?????
}


void  _UnwindNestedFrames(
        struct _EXCEPTION_REGISTRATION_RECORD **a1,
        PVOID TargetFrame,
        PEXCEPTION_RECORD ExceptionRecord)
{
  DWORD ExceptionFlags; // eax

  //RtlUnwind(TargetFrame, &_ReturnPoint_16567, ExceptionRecord, 0);
  RtlUnwind(TargetFrame, 0, ExceptionRecord, 0);
  ExceptionFlags = ExceptionRecord->ExceptionFlags;
  LOBYTE(ExceptionFlags) = ExceptionFlags & 0xFD;
  ExceptionRecord->ExceptionFlags = ExceptionFlags;
  //???*a1 = NtCurrentTeb()->NtTib.ExceptionList;
}



int __cdecl _unwind_handler(int a1, int a2, int a3, _DWORD *a4)
{
  int result; // eax

  result = 1;
  if ( (*(_DWORD *)(a1 + 4) & 6) != 0 )
  {
    *a4 = a2;
    return 3;
  }
  return result;
}
BOOL __cdecl _ValidateExecute(FARPROC lpfn)
{
  return !IsBadCodePtr(lpfn);
}
BOOL __cdecl _ValidateRead(const void *lp, UINT_PTR ucb)
{
  return !IsBadReadPtr(lp, ucb);
}
BOOL __cdecl _ValidateWrite(void *lp, UINT_PTR ucb)
{
  return !IsBadWritePtr(lp, ucb);
}
void  Concurrency::details::VirtualProcessorRoot::_VirtualProcessorRoot(
    Concurrency::details::VirtualProcessorRoot* thisxx)
{
    *(_DWORD*)thisxx = (int)&off_4AC250;
    sub_418130((void**)thisxx + 2);
}


_BYTE *_wincmdln()
{
  _BYTE *v0; // esi
  unsigned __int8 v1; // al

  if ( !dword_4CC7C8 )
    __initmbctable();
  v0 = (_BYTE *)dword_4CC7D4;
  if ( *(_BYTE *)dword_4CC7D4 != 34 )
  {
    if ( *(_BYTE *)dword_4CC7D4 > 0x20u )
    {
      do
        ++v0;
      while ( *v0 > 0x20u );
    }
    goto LABEL_12;
  }
  while ( 1 )
  {
    v1 = *++v0;
    if ( v1 == 34 || !v1 )
      break;
    if ( _ismbblead(v1) )
      ++v0;
  }
  if ( *v0 != 34 )
    goto LABEL_12;
  do
  {
    ++v0;
LABEL_12:
    ;
  }
  while ( *v0 && *v0 <= 0x20u );
  return v0;
}
int __cdecl _write(int FileHandle, const void *Buf, unsigned int MaxCharCount)
{
  _DWORD *v3; // ebx
  int v4; // esi
  char v5; // al
  int v7; // eax
  char *v8; // eax
  char *v9; // ecx
  char v10; // cl
  signed int v11; // edi
  char Buffer[1028]; // [esp+Ch] [ebp-414h] BYREF
  int v13; // [esp+410h] [ebp-10h]
  DWORD NumberOfBytesWritten; // [esp+414h] [ebp-Ch] BYREF
  DWORD v15; // [esp+418h] [ebp-8h]
  char *v16; // [esp+41Ch] [ebp-4h]
  int FileHandlea; // [esp+428h] [ebp+8h]

  if ( FileHandle < uNumber
    && (v3 = (_DWORD *)(4 * (FileHandle >> 5) + 5031616),
        v4 = 8 * (FileHandle & 0x1F),
        v5 = *(_BYTE *)(dword_4CC6C0[FileHandle >> 5] + v4 + 4),
        (v5 & 1) != 0) )
  {
    v15 = 0;
    v13 = 0;
    if ( !MaxCharCount )
      return 0;
    if ( (v5 & 0x20) != 0 )
      _lseek(FileHandle, 0, 2);
    v7 = v4 + dword_4CC6C0[FileHandle >> 5];
    if ( *(char *)(v7 + 4) >= 0 )
    {
      if ( WriteFile(*(HANDLE *)v7, Buf, MaxCharCount, (LPDWORD)&NumberOfBytesWritten, 0) )
      {
        FileHandlea = 0;
        v15 = NumberOfBytesWritten;
      }
      else
      {
        FileHandlea = GetLastError();
      }
    }
    else
    {
      v16 = (char *)Buf;
      FileHandlea = 0;
      while ( 1 )
      {
        v8 = Buffer;
        do
        {
          if ( v16 - (_BYTE *)Buf >= MaxCharCount )
            break;
          v9 = v16++;
          v10 = *v9;
          if ( v10 == 10 )
          {
            ++v13;
            *v8++ = 13;
          }
          *v8++ = v10;
        }
        while ( v8 - Buffer < 1024 );
        v11 = v8 - Buffer;
      if ( WriteFile(*(HANDLE *)v7, Buf, MaxCharCount, (LPDWORD)&NumberOfBytesWritten, 0) )
        if ( !WriteFile(*(HANDLE *)(*v3 + v4), Buffer, v8 - Buffer, (LPDWORD)&NumberOfBytesWritten, 0) )
          break;
        v15 += NumberOfBytesWritten;
        if ( (int)NumberOfBytesWritten < v11 || v16 - (_BYTE *)Buf >= MaxCharCount )
          goto LABEL_17;
      }
      FileHandlea = GetLastError();
    }
LABEL_17:
    if ( v15 )
      return v15 - v13;
    if ( FileHandlea )
    {
      if ( FileHandlea == 5 )
      {
        dword_4CB26C = 9;
        dword_4CB270 = 5;
      }
      else
      {
        _dosmaperr(FileHandlea);
      }
    }
    else
    {
      if ( (*(_BYTE *)(*v3 + v4 + 4) & 0x40) != 0 && *(_BYTE *)Buf == 26 )
        return 0;
      dword_4CB26C = 28;
      dword_4CB270 = 0;
    }
  }
  else
  {
    dword_4CB270 = 0;
    dword_4CB26C = 9;
  }
  return -1;
}

LONG __cdecl _XcptFilter(int a1, struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  int *v2; // eax
  void (__cdecl *v3)(int); // ebx
  int v5; // ecx
  int v6; // edx
  _DWORD *v7; // esi
  int v8; // eax
  int v9; // esi
  int v10; // [esp+Ch] [ebp+8h]

  v2 = (int *)xcptlookup(a1);
  if ( !v2 )
    return UnhandledExceptionFilter(ExceptionInfo);
  v3 = (void (__cdecl *)(int))v2[2];
  if ( !v3 )
    return UnhandledExceptionFilter(ExceptionInfo);
  if ( v3 == (void (__cdecl *)(int))5 )
  {
    v2[2] = 0;
    return 1;
  }
  else
  {
    if ( v3 != (void (__cdecl *)(int))1 )
    {
      v10 = dword_4CB2B8;
      dword_4CB2B8 = (int)ExceptionInfo;
      v5 = v2[1];
      if ( v5 == 8 )
      {
        if ( dword_4B86B0 < dword_4B86B0 + dword_4B86B4 )
        {
          v6 = dword_4B86B4;
          v7 = (_DWORD *)(12 * dword_4B86B0 + 4949568);
          do
          {
            *v7 = 0;
            v7 += 3;
            --v6;
          }
          while ( v6 );
        }
        v8 = *v2;
        v9 = (int)dword_4B86BC;
        switch ( v8 )
        {
          case -1073741682:
            dword_4B86BC = 131;
            break;
          case -1073741680:
            dword_4B86BC = 129;
            break;
          case -1073741679:
            dword_4B86BC = 132;
            break;
          case -1073741677:
            dword_4B86BC = 133;
            break;
          case -1073741683:
            dword_4B86BC = 130;
            break;
          case -1073741681:
            dword_4B86BC = 134;
            break;
          case -1073741678:
            dword_4B86BC = 138;
            break;
        }
        v3(8);
        dword_4B86BC = v9;
      }
      else
      {
        v2[2] = 0;
        v3(v5);
      }
      dword_4CB2B8 = v10;
    }
    return -1;
  }
}
int __cdecl _ZeroTail(int a1, int a2)
{
  int v2; // esi
  _DWORD *i; // eax

  if ( (~(-1 << (31 - a2 % 32)) & *(_DWORD *)(a1 + 4 * (a2 / 32))) == 0 )
  {
    v2 = a2 / 32 + 1;
    if ( v2 >= 3 )
      return 1;
    for ( i = (_DWORD *)(a1 + 4 * v2); !*i; ++i )
    {
      if ( ++v2 >= 3 )
        return 1;
    }
  }
  return 0;
}
int __cdecl __addl(unsigned int a1, unsigned int a2, unsigned int *a3)
{
  int result; // eax
  unsigned int v4; // ecx

  result = 0;
  v4 = a1 + a2;
  if ( a1 + a2 < a1 || v4 < a2 )
    result = 1;
  *a3 = v4;
  return result;
}
int __cdecl __add_12(_DWORD* a1, _DWORD* a2)
{
    if (__addl(*a1, *a2, (unsigned int*)a1) && __addl(a1[1], 1u, (unsigned int*)a1 + 1))
        ++a1[2];
    if (__addl(a1[1], a2[1], (unsigned int*)a1 + 1))
        ++a1[2];
    return __addl(a1[2], a2[2], (unsigned int*)a1 + 2);
}
void __stdcall __ArrayUnwind(void *a1, unsigned int a2, int a3, void ( *a4)(void *))
{
  while ( --a3 >= 0 )
  {
    a1 = (char *)a1 - a2;
    ((void (*)(void))a4)();
  }
}
//__check_overflow_exitÎÞ·¨·´±àÒë

//__crt»ñÈ¡»·¾³×Ö·û´®A
CHAR *__crtGetEnvironmentStringsA()
{
  CHAR *v0; // ebx
  WCHAR *EnvironmentStringsW; // esi
  LPCH EnvironmentStrings; // edi
  WCHAR *i; // eax
  int v4; // eax
  int v5; // ebp
  CHAR *v6; // eax
  LPCH j; // eax
  size_t v9; // ebp
  void *v10; // eax
  void *v11; // esi
  CHAR *Block; // [esp+10h] [ebp-8h]
  int cchWideChar; // [esp+14h] [ebp-4h]

  v0 = 0;
  EnvironmentStringsW = 0;
  EnvironmentStrings = 0;
  if ( dword_4CB3C0 )
  {
    if ( dword_4CB3C0 == 1 )
      goto LABEL_7;
    if ( dword_4CB3C0 != 2 )
      return 0;
  }
  else
  {
    EnvironmentStringsW = GetEnvironmentStringsW();
    if ( EnvironmentStringsW )
    {
      dword_4CB3C0 = 1;
LABEL_7:
      if ( EnvironmentStringsW || (EnvironmentStringsW = GetEnvironmentStringsW()) != 0 )
      {
        for ( i = EnvironmentStringsW; *i; ++i )
        {
          do
            ++i;
          while ( *i );
        }
        cchWideChar = i - EnvironmentStringsW + 1;
        v4 = WideCharToMultiByte(0, 0, EnvironmentStringsW, cchWideChar, 0, 0, 0, 0);
        v5 = v4;
        if ( v4 )
        {
          v6 = (CHAR *)malloc(v4);
          Block = v6;
          if ( v6 )
          {
            if ( !WideCharToMultiByte(0, 0, EnvironmentStringsW, cchWideChar, v6, v5, 0, 0) )
            {
              free(Block);
              Block = 0;
            }
            v0 = Block;
          }
        }
        FreeEnvironmentStringsW(EnvironmentStringsW);
        return v0;
      }
      return 0;
    }
    EnvironmentStrings = (LPCH)GetEnvironmentStrings();
    if ( !EnvironmentStrings )
      return 0;
    dword_4CB3C0 = 2;
  }
  if ( !EnvironmentStrings )
  {
    EnvironmentStrings = (LPCH)GetEnvironmentStrings();
    if ( !EnvironmentStrings )
      return 0;
  }
  for ( j = EnvironmentStrings; *j; ++j )
  {
    do
      ++j;
    while ( *j );
  }
  v9 = j - EnvironmentStrings + 1;
  v10 = malloc(v9);
  v11 = v10;
  if ( v10 )
    memcpy(v10, EnvironmentStrings, v9);
  else
    v11 = 0;
  FreeEnvironmentStringsA(EnvironmentStrings);
  return (CHAR *)v11;
}
BOOL __cdecl __crtGetStringTypeA(
        DWORD dwInfoType,
        LPCSTR lpSrcStr,
        int cchSrc,
        LPWORD lpCharType,
        UINT CodePage,
        LCID Locale,
        int a7)
{
  int v7; // eax
  LCID v8; // eax
  int v10; // eax
  size_t v11; // edi
  int v12; // eax
  void *v13; // esp
  int v14; // eax
  //WCHAR v15[8]; // [esp+0h] [ebp-34h] BYREF
  WCHAR v15[512]; // [esp+0h] [ebp-34h] BYREF
  WCHAR *v16; // [esp+10h] [ebp-24h]
  int cchWideChar; // [esp+14h] [ebp-20h]
  WORD CharType; // [esp+18h] [ebp-1Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+1Ch] [ebp-18h]

  v7 = (int)dword_4CB408;
  if ( !dword_4CB408 )
  {
    if ( GetStringTypeW(1u, (LPCWCH) & SrcStr, 1, (LPWORD) & CharType))
    {
      v7 = 1;
    }
    else
    {
      if ( !GetStringTypeA(0, 1u, (LPCSTR)byte_4AC8C4, 1, (LPWORD)&CharType) )
        return 0;
      v7 = 2;
    }
    dword_4CB408 = v7;
  }
  if ( v7 != 2 )
  {
    if ( v7 == 1 )
    {
      if ( !CodePage )
        CodePage = ::CodePage;
      v10 = MultiByteToWideChar(CodePage, a7 != 0 ? 9 : 1, lpSrcStr, cchSrc, 0, 0);
      cchWideChar = v10;
      if ( v10 )
      {
        v11 = 2 * v10;
        v12 = 2 * v10 + 3;
        LOBYTE(v12) = v12 & 0xFC;
        v13 = alloca(v12);
        ms_exc.old_esp = (DWORD)v15;
        v16 = v15;
        memset(v15, 0, v11);
        ms_exc.registration.TryLevel = -1;
        if ( v15 )
        {
          v14 = MultiByteToWideChar(CodePage, 1u, lpSrcStr, cchSrc, v15, cchWideChar);
          if ( v14 )
            return GetStringTypeW(dwInfoType, v15, v14, lpCharType);
        }
      }
    }
    return 0;
  }
  v8 = Locale;
  if ( !Locale )
    v8 = dword_4CB440;
  return GetStringTypeA(v8, dwInfoType, lpSrcStr, cchSrc, lpCharType);
}
int __cdecl __crtLCMapStringA(
        LCID Locale,
        DWORD dwMapFlags,
        LPCSTR lpSrcStr,
        int cchSrc,
        LPSTR lpDestStr,
        int cchDest,
        UINT CodePage,
        int a8)
{
  int v9; // eax
  int v10; // ebx
  int v11; // eax
  void *v12; // esp
  int v13; // eax
  int v14; // esi
  int v15; // eax
  void *v16; // esp
  int v17; // eax
  //WCHAR v18[8]; // [esp+0h] [ebp-38h] BYREF
  WCHAR v18[256]; // [esp+0h] [ebp-38h] BYREF
  int v19; // [esp+10h] [ebp-28h]
  LPWSTR lpWideCharStr; // [esp+14h] [ebp-24h]
  WCHAR *v21; // [esp+18h] [ebp-20h]
  int v22; // [esp+1Ch] [ebp-1Ch]
  CPPEH_RECORD ms_exc; // [esp+20h] [ebp-18h]

  if ( !dword_4CB434 )
  {
    if ( LCMapStringW(0, 0x100u, (LPCWSTR)&SrcStr, 1, 0, 0) )
    {
      dword_4CB434 = 1;
    }
    else
    {
      if ( !LCMapStringA(0, 0x100u, (LPCSTR)byte_4AC8C4, 1, 0, 0) )
        return 0;
      dword_4CB434 = 2;
    }
  }
  if ( cchSrc > 0 )
    cchSrc = (int)strncnt((char*)lpSrcStr, cchSrc);
  if ( dword_4CB434 == 2 )
    return LCMapStringA(Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
  if ( dword_4CB434 != 1 )
    return 0;
  if ( !CodePage )
    CodePage = ::CodePage;
  v9 = MultiByteToWideChar(CodePage, a8 != 0 ? 9 : 1, lpSrcStr, cchSrc, 0, 0);
  v10 = v9;
  v22 = v9;
  if ( !v9 )
    return 0;
  v11 = 2 * v9 + 3;
  LOBYTE(v11) = v11 & 0xFC;
  v12 = alloca(v11);
  ms_exc.old_esp = (DWORD)v18;
  lpWideCharStr = v18;
  ms_exc.registration.TryLevel = -1;
  if ( !v18 )
    return 0;
  if ( !MultiByteToWideChar(CodePage, 1u, lpSrcStr, cchSrc, lpWideCharStr, v10) )
    return 0;
  v13 = LCMapStringW(Locale, dwMapFlags, lpWideCharStr, v10, 0, 0);
  v14 = v13;
  v19 = v13;
  if ( !v13 )
    return 0;
  if ( (dwMapFlags & 0x400) != 0 )
  {
    if ( cchDest && (v13 > cchDest || !LCMapStringW(Locale, dwMapFlags, lpWideCharStr, v10, (LPWSTR)lpDestStr, cchDest)) )
      return 0;
  }
  else
  {
    v15 = 2 * v13 + 3;
    LOBYTE(v15) = v15 & 0xFC;
    v16 = alloca(v15);
    ms_exc.old_esp = (DWORD)v18;
    v21 = v18;
    ms_exc.registration.TryLevel = -1;
    if ( !v18 || !LCMapStringW(Locale, dwMapFlags, lpWideCharStr, v22, v18, v14) )
      return 0;
    v17 = cchDest ? WideCharToMultiByte(CodePage, 0x220u, v18, v14, lpDestStr, cchDest, 0, 0) : WideCharToMultiByte(
                                                                                                  CodePage,
                                                                                                  0x220u,
                                                                                                  v18,
                                                                                                  v14,
                                                                                                  0,
                                                                                                  0,
                                                                                                  0,
                                                                                                  0);
    v14 = v17;
    if ( !v17 )
      return 0;
  }
  return v14;
}

int __cdecl __crtMessageBoxA(const CHAR *a1, const CHAR *a2, UINT a3)
{
  HWND ActiveWindow; // ebx
  HMODULE LibraryA; // eax
  HMODULE v5; // edi

  ActiveWindow = 0;
  if ( !MessageBoxA_0 )
  {
    LibraryA = LoadLibraryA("user32.dll");
    v5 = LibraryA;
    if ( !LibraryA )
      return 0;
    MessageBoxA_0 = (int (__stdcall *)(HWND, LPCSTR, LPCSTR, UINT))GetProcAddress(LibraryA, "MessageBoxA");
    if ( !MessageBoxA_0 )
      return 0;
    //GetActiveWindow = (HWND (__stdcall *)())GetProcAddress(v5, "GetActiveWindow");
    //GetLastActivePopup = (HWND (__stdcall *)(HWND))GetProcAddress(v5, "GetLastActivePopup");
  }
  if ( GetActiveWindow )
  {
    ActiveWindow = GetActiveWindow();
    if ( ActiveWindow )
    {
      if ( GetLastActivePopup )
        ActiveWindow = GetLastActivePopup(ActiveWindow);
    }
  }
  return ((int(__stdcall*)(HWND,const char*,const char*,int)) MessageBoxA_0)  (ActiveWindow, a1, a2, a3);
}


int __CxxFrameHandler(
    struct _s_FuncInfo* a1,
    EXCEPTION_POINTERS* a2,
    int a3,
    PEXCEPTION_RECORD ExceptionRecord,
    struct EHRegistrationNode* a5,
    struct _CONTEXT* a6,
    void* a7)
{
    return __InternalCxxFrameHandler(a2, a3, ExceptionRecord, a5, a6, a7, a1, 0, 0, 0);
}
LONG __stdcall __CxxUnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo, int a2, int a3)
{
  PEXCEPTION_RECORD ExceptionRecord; // eax

  ExceptionRecord = ExceptionInfo->ExceptionRecord;
  if ( ExceptionInfo->ExceptionRecord->ExceptionCode == -529697949
    && ExceptionRecord->NumberParameters == 3
    && ExceptionRecord->ExceptionInformation[0] == 429065504 )
  {
      sub_4A3FCC();
  }
  if ( lpfn && _ValidateExecute((FARPROC)lpfn) )
    return lpfn(ExceptionInfo);
  else
    return 0;
}
int __dtold(unsigned int a1, int a2, int *a3)
{
  int v4; // ecx
  int v5; // eax
  unsigned int v6; // edx
  int v7; // eax
  __int16 v8; // di
  int result; // eax
  int v10; // ecx
  int v11; // ecx
  unsigned __int64 v12; // rcx
  unsigned int v13; // [esp+Ch] [ebp-4h]
  __int16 v14; // [esp+1Ch] [ebp+Ch]

  LOWORD(a1) = *((_WORD *)a3 + 3);
  v4 = (a1 >> 4) & 0x7FF;
  v14 = a1 & 0x8000;
  v5 = a3[1];
  v6 = *a3;
  v7 = v5 & 0xFFFFF;
  v13 = 0x80000000;
  if ( (_WORD)v4 )
  {
    if ( (unsigned __int16)v4 == 2047 )
      v8 = 0x7FFF;
    else
      v8 = v4 + 15360;
  }
  else
  {
    if ( !v7 && !v6 )
    {
      result = a2;
      *(_DWORD *)(a2 + 4) = 0;
      *(_DWORD *)a2 = 0;
      *(_WORD *)(a2 + 8) = 0;
      return result;
    }
    v8 = v4 + 15361;
    v13 = 0;
  }
  v10 = (v7 << 11) | (v6 >> 21);
  result = a2;
  v11 = v13 | v10;
  *(_DWORD *)(a2 + 4) = v11;
  *(_DWORD *)a2 = v6 << 11;
  while ( (v11 & 0x80000000) == 0 )
  {
    v12 = 2 * __PAIR64__(v11, *(_DWORD *)a2);
    *(_QWORD *)a2 = v12;
    --v8;
    v11 = HIDWORD(v12);
  }
  *(_WORD *)(a2 + 8) = v8 | v14;
  return result;
}

//int __endstdio()//¸ù±¾Ã»ÓÐ±»µ÷ÓÃ//Ã»ÓÃ
//{
//  int result; // eax
//
//  result = sub_4AAF2F();
//  if ( byte_4CB2AC )
//    return _fcloseall();
//  return result;
//}


void __cdecl __FrameUnwindToState(int a1, int a2, int a3, int a4)
{
  EXCEPTION_POINTERS *v4; // ecx
  int i; // esi
  int v6; // eax

  for ( i = *(_DWORD *)(a1 + 8); i != a4; i = *(_DWORD *)(*(_DWORD *)(a3 + 8) + 8 * i) )
  {
    if ( i <= -1 || i >= *(_DWORD *)(a3 + 4) )
      sub_4A4022(v4, a1, a3, i);
    v6 = *(_DWORD *)(*(_DWORD *)(a3 + 8) + 8 * i + 4);
    if ( v6 )
      _CallSettingFrame(v6, a1, 259);
  }
  *(_DWORD *)(a1 + 8) = i;
}
int __initmbctable()
{
  int result = 0; // eax
  //int result; // eax//Ô­À´

  if ( !dword_4CC7C8 )
  {
    result = _setmbcp(-3);
    dword_4CC7C8 = 1;
  }
  return result;
}
int __initstdio()
{
  size_t v0; // eax
  int v1; // ecx
  void **v2; // eax
  int v3; // edx
  _DWORD *v4; // ecx
  int result; // eax

  v0 = Count;
  if ( !Count )
  {
    v0 = 512;
LABEL_5:
    Count = v0;
    goto LABEL_6;
  }
  if ( (int)Count < 20 )
  {
    v0 = 20;
    goto LABEL_5;
  }
LABEL_6:
  dword_4CB688 = (int)calloc(v0, 4u);
  if ( !dword_4CB688 )
  {
    Count = 20;
    dword_4CB688 = (int)calloc(0x14u, 4u);
    if ( !dword_4CB688 )
      _amsg_exit(0x1Au);
  }
  v1 = 0;
  v2 = (void**) & off_4B8900;
  do
  {
    *(_DWORD *)(v1 + dword_4CB688) = (_DWORD)v2;
    v2 += 8;
    v1 += 4;
  }
  while ( (int)v2 < (int)&byte_4B8B80 );
  v3 = 0;
  v4 = (_DWORD*) & unk_4B8910;
  do
  {
    result = *(_DWORD *)(dword_4CC6C0[v3 >> 5] + 8 * (v3 & 0x1F));
    if ( result == -1 || !result )
      *v4 = -1;
    v4 += 8;
    ++v3;
  }
  //while ( (int)v4 < int)unk_4B8970);//ÕâÊÇÔ­À´µÄ
  while ( (int)v4 < *(int*)unk_4B8970);
  return result;
}
int  __InternalCxxFrameHandler(
        EXCEPTION_POINTERS *a1,
        int a2,
        PEXCEPTION_RECORD ExceptionRecord,
        struct EHRegistrationNode *a4,
        struct _CONTEXT *a5,
        void *a6,
        struct _s_FuncInfo *a7,
        int a8,
        PVOID TargetFrame,
        char a10)
{
  if ( *(_DWORD *)a7 != 429065504 )
    sub_4A4022(a1, a2, 429065504, (int)a7);
  if ( (ExceptionRecord->ExceptionFlags & 0x66) != 0 )
  {
    if ( a7->maxState )
    {
      if ( !a8 )
        __FrameUnwindToState((int)a4, (int)a6, (int)a7, -1);
    }
  }
  else if ( a7->nTryBlocks )
  {
    if ( ExceptionRecord->ExceptionCode == -529697949 && ExceptionRecord->ExceptionInformation[0] > 0x19930520 )
    {
      a1 = *(EXCEPTION_POINTERS **)(ExceptionRecord->ExceptionInformation[2] + 8);
      if ( a1 )
        return ((int (__cdecl *)(PEXCEPTION_RECORD, struct EHRegistrationNode *, struct _CONTEXT *, void *, struct _s_FuncInfo *, int, PVOID, _DWORD))a1)(
                 ExceptionRecord,
                 a4,
                 a5,
                 a6,
                 a7,
                 a8,
                 TargetFrame,
                 (unsigned __int8)a10);
    }
    FindHandler(a1, a2, 429065504, (int)a7, ExceptionRecord, a4, a5, a6, a7, a10, a8, TargetFrame);
  }
  return 1;
}
int __cdecl __ld12mul(int a1, int a2)
{
  __int16 v4; // cx
  __int16 v5; // ax
  __int16 v6; // di
  int result; // eax
  int v8; // ecx
  int v9; // edi
  unsigned __int16 v10; // dx
  int v11; // eax
  int v12; // ebx
  int v13[3]; // [esp+Ch] [ebp-24h] BYREF
  int v14; // [esp+18h] [ebp-18h]
  int v15; // [esp+1Ch] [ebp-14h]
  int v16; // [esp+20h] [ebp-10h]
  unsigned __int16 *v17; // [esp+24h] [ebp-Ch]
  unsigned __int16 *v18; // [esp+28h] [ebp-8h]
  int *v19; // [esp+2Ch] [ebp-4h]
  int v20; // [esp+38h] [ebp+8h]
  int v21; // [esp+38h] [ebp+8h]
  int i; // [esp+3Ch] [ebp+Ch]

  v4 = *(_WORD *)(a2 + 10);
  v15 = 0;
  memset(v13, 0, sizeof(v13));
  v5 = *(_WORD *)(a1 + 10);
  v6 = v5 ^ v4;
  result = v5 & 0x7FFF;
  v8 = v4 & 0x7FFF;
  v9 = v6 & 0x8000;
  v10 = v8 + result;
  v20 = v8 + result;
  if ( (unsigned __int16)result < 0x7FFFu && (unsigned __int16)v8 < 0x7FFFu && v10 <= 0xBFFDu )
  {
    if ( v10 <= 0x3FBFu )
    {
      result = 0;
LABEL_16:
      *(_DWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)a1 = 0;
      return result;
    }
    if ( (_WORD)result || (++v20, (*(_DWORD *)(a1 + 8) & 0x7FFFFFFF) != 0) )
    {
      result = 0;
    }
    else
    {
      result = 0;
      if ( !*(_DWORD *)(a1 + 4) && !*(_DWORD *)a1 )
        goto LABEL_45;
    }
    if ( !(_WORD)v8 )
    {
      ++v20;
      if ( (*(_DWORD *)(a2 + 8) & 0x7FFFFFFF) == 0 && !*(_DWORD *)(a2 + 4) && !*(_DWORD *)a2 )
        goto LABEL_16;
    }
    v16 = 0;
    v19 = &v13[1];
    for ( i = 5; i > 0; --i )
    {
      v18 = (unsigned __int16 *)(a1 + 2 * v16);
      v17 = (unsigned __int16 *)(a2 + 8);
      v14 = i;
      do
      {
        if ( __addl(*(v19 - 1), *v17 * *v18, (unsigned int *)v19 - 1) )
          ++*(_WORD *)v19;
        ++v18;
        --v17;
        --v14;
      }
      while ( v14 );
      v19 = (int *)((char *)v19 + 2);
      ++v16;
    }
    v21 = v20 + 49154;
    if ( (__int16)v21 <= 0 )
      goto LABEL_49;
    do
    {
      if ( v13[2] < 0 )
        break;
      __shl_12(v13);
      v21 += 0xFFFF;
    }
    while ( (__int16)v21 > 0 );
    if ( (__int16)v21 <= 0 )
    {
LABEL_49:
      v21 += 0xFFFF;
      if ( (v21 & 0x8000u) != 0 )
      {
        v11 = -(__int16)v21;
        v21 -= (__int16)v21;
        v12 = v11;
        do
        {
          if ( (v13[0] & 1) != 0 )
            ++v15;
          __shr_12(v13);
          --v12;
        }
        while ( v12 );
        if ( v15 )
          LOBYTE(v13[0]) |= 1u;
      }
    }
    if ( LOWORD(v13[0]) > 0x8000u || (v13[0] & 0x1FFFF) == 98304 )
    {
      if ( *(int *)((char *)v13 + 2) == -1 )
      {
        *(int *)((char *)v13 + 2) = 0;
        if ( *(int *)((char *)&v13[1] + 2) == -1 )
        {
          *(int *)((char *)&v13[1] + 2) = 0;
          if ( HIWORD(v13[2]) == 0xFFFF )
          {
            ++v21;
            HIWORD(v13[2]) = 0x8000;
          }
          else
          {
            ++HIWORD(v13[2]);
          }
        }
        else
        {
          ++*(int *)((char *)&v13[1] + 2);
        }
      }
      else
      {
        ++*(int *)((char *)v13 + 2);
      }
    }
    result = v21;
    if ( (unsigned __int16)v21 < 0x7FFFu )
    {
      result = v9 | v21;
      *(_WORD *)a1 = HIWORD(v13[0]);
      *(_DWORD *)(a1 + 2) = v13[1];
      *(_DWORD *)(a1 + 6) = v13[2];
LABEL_45:
      *(_WORD *)(a1 + 10) = result;
      return result;
    }
  }
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 8) = (_WORD)v9 != 0 ? -32768 : 2147450880;
  return result;
}
__int16 __cdecl __mtold12(char *a1, int a2, int a3)
{
  unsigned int v4; // ecx
  int v5; // esi
  int v6; // eax
  __int16 result; // ax
  int v8; // [esp+8h] [ebp-10h] BYREF
  int v9; // [esp+Ch] [ebp-Ch]
  int v10; // [esp+10h] [ebp-8h]
  int v11; // [esp+14h] [ebp-4h]
  int v12; // [esp+28h] [ebp+10h]

  v11 = 16462;
  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  *(_DWORD *)(a3 + 8) = 0;
  if ( a2 )
  {
    v12 = a2;
    do
    {
      v8 = *(_DWORD *)a3;
      v9 = *(_DWORD *)(a3 + 4);
      v10 = *(_DWORD *)(a3 + 8);
      __shl_12((int*)a3);
      __shl_12((int*)a3);
      __add_12((_DWORD *)a3, &v8);
      __shl_12((int*)a3);
      v9 = 0;
      v10 = 0;
      v8 = *a1;
      __add_12((_DWORD *)a3, &v8);
      ++a1;
      --v12;
    }
    while ( v12 );
  }
  while ( !*(_DWORD *)(a3 + 8) )
  {
    v4 = *(_DWORD *)(a3 + 4);
    *(_DWORD *)(a3 + 8) = HIWORD(v4);
    v5 = (v4 << 16) | HIWORD(*(_DWORD *)a3);
    v6 = *(_DWORD *)a3 << 16;
    v11 += 65520;
    *(_DWORD *)(a3 + 4) = v5;
    *(_DWORD *)a3 = v6;
  }
  while ( (*(_DWORD *)(a3 + 8) & 0x8000) == 0 )
  {
    __shl_12((int*)a3);
    v11 += 0xFFFF;
  }
  result = v11;
  *(_WORD *)(a3 + 10) = v11;
  return result;
}
void __cdecl __multtenpow12(_WORD *a1, int a2, int a3)
{
  char *v3; // ebx
  char v4; // al
  int v5; // eax
  char *v6; // esi
  _DWORD *v7; // esi
  __int64 v8; // [esp+4h] [ebp-Ch] BYREF
  int v9; // [esp+Ch] [ebp-4h]

  v3 = (char *)&unk_4B8F08 - 96;
  if ( a2 )
  {
    if ( a2 < 0 )
    {
      a2 = -a2;
      v3 = (char *)&unk_4B9068 - 96;
    }
    if ( !a3 )
      *a1 = 0;
    while ( a2 )
    {
      v4 = a2;
      v3 += 84;
      a2 >>= 3;
      v5 = v4 & 7;
      if ( v5 )
      {
        v6 = &v3[12 * v5];
        if ( *(_WORD *)v6 >= 0x8000u )
        {
          LODWORD(v8) = *(_DWORD *)v6;
          v7 = (int*)v6 + 4;
          HIDWORD(v8) = *v7;
          v9 = v7[1];
          --*(_DWORD *)((char *)&v8 + 2);
          v6 = (char *)&v8;
        }
        __ld12mul((int)a1, (int)v6);
      }
    }
  }
}
void __cdecl  _amsg_exit(DWORD NumberOfBytesWritten)
{
  if ( dword_4CB234 == 1 )
    _FF_MSGBANNER();
  _NMSG_WRITE(NumberOfBytesWritten);
  ((void(__stdcall*)(int))   off_4B8300)     (255);
}
void * ___onexitinit()
{
  _DWORD *v0; // eax
  void *result; // eax

  v0 = (_DWORD*)malloc(0x80u);
  dword_4CC7D0 = (_DWORD)v0;
  if ( !v0 )
    _amsg_exit(0x18u);
  *v0 = 0;
  result = (void*)dword_4CC7D0;
  dword_4CC7CC = (int)dword_4CC7D0;
  return result;
}
_DWORD *__cdecl __sbh_alloc_block(int a1)
{
    //ÒòÎª¶ÑÕ»¶¼ÊÇ·´µÄ£¬ËùÒÔ¿ª°ÚÀÃ
  //int v1; // ecx
  //unsigned int v2; // esi
  //char *i; // ebx
  //bool v4; // zf
  //bool v5; // zf
  //bool v6; // zf
  //_DWORD *v8; // eax
  //int v9; // edx
  //_DWORD *v10; // ecx
  //int v11; // edx
  //int v12; // edi
  //int v13; // ecx
  //int *v14; // edx
  //int v15; // ecx
  //int v16; // esi
  //unsigned int v17; // ebx
  //_BYTE *v18; // edi
  //unsigned int v19; // ebx
  //_BYTE *v20; // edi
  //int v21; // ebx
  //_DWORD *v22; // ecx
  //char v23; // cl
  //_DWORD *v24; // edx
  //int v25; // [esp+Ch] [ebp-14h]
  //int v26; // [esp+Ch] [ebp-14h]
  //signed int v27; // [esp+10h] [ebp-10h]
  //unsigned int v28; // [esp+14h] [ebp-Ch]
  //_DWORD *v29; // [esp+14h] [ebp-Ch]
  //unsigned int v30; // [esp+18h] [ebp-8h]
  //int v31; // [esp+18h] [ebp-8h]
  //char *v32; // [esp+1Ch] [ebp-4h]
  //int v33; // [esp+1Ch] [ebp-4h]
  //char *v34; // [esp+28h] [ebp+8h]


    char* v34; // [esp+28h] [ebp+8h]
    int v33; // [esp+1Ch] [ebp-4h]
    char* v32; // [esp+1Ch] [ebp-4h]
    int v31; // [esp+18h] [ebp-8h]
    unsigned int v30; // [esp+18h] [ebp-8h]
    _DWORD* v29; // [esp+14h] [ebp-Ch]
    unsigned int v28; // [esp+14h] [ebp-Ch]
    signed int v27; // [esp+10h] [ebp-10h]
    int v26; // [esp+Ch] [ebp-14h]
    int v25; // [esp+Ch] [ebp-14h]
    _DWORD* v24; // edx
    char v23; // cl
    _DWORD* v22; // ecx
    int v21; // ebx
    _BYTE* v20; // edi
    unsigned int v19; // ebx
    _BYTE* v18; // edi
    unsigned int v17; // ebx
    int v16; // esi
    int v15; // ecx
    int* v14; // edx
    int v13; // ecx
    int v12; // edi
    int v11; // edx
    _DWORD* v10; // ecx
    int v9; // edx
    _DWORD* v8; // eax
    bool v6; // zf
    bool v5; // zf
    bool v4; // zf
    char* i; // ebx
    unsigned int v2; // esi
  int v1; // ecx











  v32 = (char *)lpMem + 20 * dword_4CC6B4;
  v27 = (a1 + 23) & 0xFFFFFFF0;
  v1 = (v27 >> 4) - 1;
  if ( v1 >= 32 )
  {
    v2 = 0;
    v28 = 0;
    v30 = 0xFFFFFFFF >> ((v27 >> 4) - 33);
  }
  else
  {
    v2 = 0xFFFFFFFF >> v1;
    v30 = -1;
    v28 = 0xFFFFFFFF >> v1;
  }
  i = (char *)dword_4CC6AC;
  v34 = (char *)dword_4CC6AC;
  if ( dword_4CC6AC < (unsigned int)lpMem + 20 * dword_4CC6B4 )
  {
    do
    {
      if ( v2 & *(_DWORD *)i | v30 & *((_DWORD *)i + 1) )
        break;
      i += 20;
      v34 = i;
    }
    while ( i < v32 );
  }
  if ( i == v32 )
  {
    for ( i = (char *)lpMem; ; i += 20 )
    {
      v4 = i == (char *)dword_4CC6AC;
      v34 = i;
      if ( (unsigned int)i >= dword_4CC6AC )
        break;
      if ( v2 & *(_DWORD *)i | v30 & *((_DWORD *)i + 1) )
      {
        v4 = i == (char *)dword_4CC6AC;
        break;
      }
    }
    if ( v4 )
    {
      while ( 1 )
      {
        v5 = i == v32;
        if ( i >= v32 )
          break;
        if ( *((_DWORD *)i + 2) )
        {
          v5 = i == v32;
          break;
        }
        i += 20;
        v34 = i;
      }
      if ( v5 )
      {
        for ( i = (char *)lpMem; ; i += 20 )
        {
          v6 = i == (char *)dword_4CC6AC;
          v34 = i;
          if ( (unsigned int)i >= dword_4CC6AC )
            break;
          if ( *((_DWORD *)i + 2) )
          {
            v6 = i == (char *)dword_4CC6AC;
            break;
          }
        }
        if ( v6 )
        {
          i = __sbh_alloc_new_region();
          v34 = i;
          if ( !i )
            return 0;
        }
      }
      **((_DWORD **)i + 4) = __sbh_alloc_new_group((_DWORD*)i);
      if ( **((_DWORD **)i + 4) == -1 )
        return 0;
    }
  }
  dword_4CC6AC = (int)i;
  v8 = (_DWORD *)*((_DWORD *)i + 4);
  v9 = *v8;
  v33 = *v8;
  if ( *v8 == -1 || !(v2 & v8[v9 + 17] | v30 & v8[v9 + 49]) )
  {
    v33 = 0;
    v10 = v8 + 17;
    v2 = v28;
    if ( !(v28 & v8[17] | v30 & v8[49]) )
    {
      do
      {
        v11 = v10[33];
        ++v33;
        ++v10;
      }
      while ( !(*v10 & v28 | v30 & v11) );
    }
    v9 = v33;
  }
  v12 = 0;
  v29 = &v8[129 * v9 + 81];
  v13 = v2 & v8[v9 + 17];
  if ( !v13 )
  {
    v13 = v30 & v8[v9 + 49];
    v12 = 32;
  }
  while ( v13 >= 0 )
  {
    v13 *= 2;
    ++v12;
  }
  v14 = (int *)v29[2 * v12 + 1];
  v31 = *v14 - v27;
  v15 = v31;
  v16 = (v31 >> 4) - 1;
  if ( v16 > 63 )
    v16 = 63;
  if ( v16 == v12 )
    goto LABEL_57;
  if ( v14[1] != v14[2] )
    goto LABEL_47;
  if ( v12 >= 32 )
  {
    v19 = 0x80000000 >> (v12 - 32);
    v20 = (char *)v8 + v12 + 4;
    v21 = ~v19;
    v8[v33 + 49] &= v21;
    v4 = (*v20)-- == 1;
    v26 = v21;
    if ( v4 )
    {
      i = v34;
      *((_DWORD *)v34 + 1) &= v26;
      goto LABEL_47;
    }
  }
  else
  {
    v17 = 0x80000000 >> v12;
    v18 = (char *)v8 + v12 + 4;
    v25 = ~v17;
    v8[v33 + 17] &= ~v17;
    v4 = (*v18)-- == 1;
    if ( v4 )
    {
      i = v34;
      *(_DWORD *)v34 &= v25;
      goto LABEL_47;
    }
  }
  i = v34;
LABEL_47:
  *(_DWORD *)(v14[2] + 4) = v14[1];
  *(_DWORD *)(v14[1] + 8) = v14[2];
  if ( v31 )
  {
    v22 = &v29[2 * v16];
    v14[1] = v22[1];
    v14[2] = (int)v22;
    v22[1] = (_DWORD)v14;
    *(_DWORD *)(v14[1] + 8) = (_DWORD)v14;
    if ( v14[1] == v14[2] )
    {
      v23 = *((_BYTE *)v8 + v16 + 4);
      if ( v16 >= 32 )
      {
        *((_BYTE *)v8 + v16 + 4) = v23 + 1;
        if ( !v23 )
          *((_DWORD *)i + 1) |= 0x80000000 >> (v16 - 32);
        v8[v33 + 49] |= 0x80000000 >> (v16 - 32);
      }
      else
      {
        *((_BYTE *)v8 + v16 + 4) = v23 + 1;
        if ( !v23 )
          *(_DWORD *)i |= 0x80000000 >> v16;
        v8[v33 + 17] |= 0x80000000 >> v16;
      }
    }
    v15 = v31;
LABEL_57:
    if ( v15 )
    {
      *v14 = v15;
      *(int *)((char *)v14 + v15 - 4) = v15;
    }
    goto LABEL_60;
  }
  v15 = 0;
LABEL_60:
  v24 = (int *)((char *)v14 + v15);
  *v24 = v27 + 1;
  *(_DWORD *)((char *)v24 + v27 - 4) = v27 + 1;
  v4 = (*v29)++ == 0;
  if ( v4 && (int)i == dword_4CC6B0 && v33 == dword_4CC6A8 )
    dword_4CC6B0 = 0;
  *v8 = v33;
  return v24 + 1;
}
int __cdecl __sbh_alloc_new_group(_DWORD *a1)
{
  int v1; // esi
  int v2; // eax
  int v3; // ebx
  int v4; // edx
  int v5; // eax
  _DWORD *v6; // edi
  _DWORD *v8; // eax

  v1 = a1[4];
  v2 = a1[2];
  v3 = 0;
  while ( v2 >= 0 )
  {
    v2 *= 2;
    ++v3;
  }
  v4 = 63;
  v5 = 516 * v3 + v1 + 324;
  do
  {
    *(_DWORD *)(v5 + 8) = v5;
    *(_DWORD *)(v5 + 4) = v5;
    v5 += 8;
    --v4;
  }
  while ( v4 );
  v6 = (_DWORD *)(a1[3] + (v3 << 15));
  if ( !VirtualAlloc(v6, 0x8000u, 0x1000u, 4u) )
    return -1;
  if ( v6 <= v6 + 7168 )
  {
    v8 = v6 + 4;
    do
    {
      *(v8 - 2) = -1;
      v8[1019] = -1;
      *(v8 - 1) = 4080;
      *v8 = (_DWORD)v8 + 1023;
      v8[1] = (_DWORD)v8 - 1025;
      v8[1018] = 4080;
      v8 += 1024;
    }
    while ( v8 - 4 <= v6 + 7168 );
  }
  *(_DWORD *)(516 * v3 + v1 + 832) = (_DWORD)v6 + 3;
  v6[5] = 516 * v3 + v1 + 828;
  *(_DWORD *)(516 * v3 + v1 + 836) = (_DWORD)v6 + 7171;
  v6[7172] = 516 * v3 + v1 + 828;
  *(_DWORD *)(v1 + 4 * v3 + 68) = 0;
  *(_DWORD *)(v1 + 4 * v3 + 196) = 1;
  if ( (*(_BYTE *)(v1 + 67))++ == 0 )
    a1[1] |= 1u;
  a1[2] &= ~(0x80000000 >> v3);
  return v3;
}
char *__sbh_alloc_new_region()
{
  int v0; // eax
  void *v1; // eax
  char *v2; // esi
  LPVOID v3; // eax
  LPVOID v4; // eax

  v0 = dword_4CC6B4;
  if ( dword_4CC6B4 == dword_4CC6A4 )
  {
    v1 = HeapReAlloc((HANDLE)hHeap, 0, (LPVOID)lpMem, 4 * (5 * dword_4CC6A4 + 80));
    if ( !v1 )
      return 0;
    dword_4CC6A4 += 16;
    lpMem = (LPVOID)v1;
    v0 = dword_4CC6B4;
  }
  v2 = (char *)lpMem + 20 * v0;
  v3 = HeapAlloc((HANDLE)hHeap, 8u, 0x41C4u);
  *((_DWORD *)v2 + 4) = (_DWORD)v3;
  if ( !v3 )
    return 0;
  v4 = VirtualAlloc(0, 0x100000u, 0x2000u, 4u);
  *((_DWORD *)v2 + 3) = (_DWORD)v4;
  if ( !v4 )
  {
    HeapFree((HANDLE)hHeap, 0, *((LPVOID *)v2 + 4));
    return 0;
  }
  *((_DWORD *)v2 + 2) = -1;
  *(_DWORD *)v2 = 0;
  *((_DWORD *)v2 + 1) = 0;
  ++dword_4CC6B4;
  **((_DWORD **)v2 + 4) = -1;
  return v2;
}
char *__cdecl __sbh_find_block(int a1)
{
  char *result; // eax

  for ( result = (char *)lpMem; result < (char *)lpMem + 20 * dword_4CC6B4; result += 20 )
  {
    if ( (unsigned int)(a1 - *((_DWORD *)result + 3)) < 0x100000 )
      return result;
  }
  return 0;
}
_DWORD *__cdecl __sbh_free_block(_DWORD *a1, unsigned int a2)
{
  int v2; // eax
  int *v3; // edx
  unsigned int v4; // esi
  int v5; // ebx
  int v6; // ecx
  _BYTE *v7; // ecx
  unsigned int v8; // edi
  bool v9; // zf
  _BYTE *v10; // ecx
  unsigned int v11; // edi
  int v12; // ecx
  int v13; // edi
  unsigned int v14; // edi
  unsigned int v15; // ecx
  _BYTE *v16; // ecx
  unsigned int v17; // edx
  _BYTE *v18; // ecx
  unsigned int v19; // edx
  _DWORD *v20; // ecx
  _DWORD *result; // eax
  LPVOID *v22; // eax
  _DWORD *v23; // [esp+10h] [ebp-10h]
  int v24; // [esp+14h] [ebp-Ch]
  int v25; // [esp+18h] [ebp-8h]
  int *v26; // [esp+18h] [ebp-8h]
  int v27; // [esp+1Ch] [ebp-4h]
  char v28; // [esp+2Fh] [ebp+Fh]

  v2 = a1[4];
  v3 = (int *)(a2 - 4);
  v4 = (a2 - a1[3]) >> 15;
  v5 = *(_DWORD *)(a2 - 4) - 1;
  v27 = *(_DWORD *)(a2 - 8);
  v24 = v5;
  v23 = (_DWORD *)(516 * v4 + v2 + 324);
  v6 = *(_DWORD *)(v5 + a2 - 4);
  v25 = v6;
  if ( (v6 & 1) == 0 )
  {
    a2 = (v6 >> 4) - 1;
    if ( a2 > 0x3F )
      a2 = 63;
    if ( *(int *)((char *)v3 + v5 + 4) == *(int *)((char *)v3 + v5 + 8) )
    {
      if ( a2 >= 0x20 )
      {
        v10 = (_BYTE *)(a2 + v2 + 4);
        v11 = ~(0x80000000 >> (a2 - 32));
        *(_DWORD *)(v2 + 4 * v4 + 196) &= v11;
        v9 = (*v10)-- == 1;
        if ( v9 )
          a1[1] &= v11;
      }
      else
      {
        v7 = (_BYTE *)(a2 + v2 + 4);
        v8 = ~(0x80000000 >> a2);
        *(_DWORD *)(v2 + 4 * v4 + 68) &= v8;
        v9 = (*v7)-- == 1;
        if ( v9 )
          *a1 &= v8;
      }
    }
    *(_DWORD *)(*(int *)((char *)v3 + v5 + 8) + 4) = *(int *)((char *)v3 + v5 + 4);
    v12 = *(int *)((char *)v3 + v5 + 4);
    v13 = *(int *)((char *)v3 + v5 + 8);
    v5 += v25;
    *(_DWORD *)(v12 + 8) = v13;
    v24 = v5;
  }
  v14 = (v5 >> 4) - 1;
  if ( v14 > 0x3F )
    v14 = 63;
  if ( (v27 & 1) == 0 )
  {
    v26 = (int *)((char *)v3 - v27);
    v15 = (v27 >> 4) - 1;
    a2 = v15;
    if ( v15 > 0x3F )
    {
      a2 = 63;
      v15 = 63;
    }
    v5 += v27;
    v24 = v5;
    v14 = (v5 >> 4) - 1;
    if ( v14 > 0x3F )
      v14 = 63;
    if ( v15 != v14 )
    {
      if ( v26[1] == v26[2] )
      {
        if ( a2 >= 0x20 )
        {
          v18 = (_BYTE *)(a2 + v2 + 4);
          v19 = ~(0x80000000 >> (a2 - 32));
          *(_DWORD *)(v2 + 4 * v4 + 196) &= v19;
          v9 = (*v18)-- == 1;
          if ( v9 )
            a1[1] &= v19;
        }
        else
        {
          v16 = (_BYTE *)(a2 + v2 + 4);
          v17 = ~(0x80000000 >> a2);
          *(_DWORD *)(v2 + 4 * v4 + 68) &= v17;
          v9 = (*v16)-- == 1;
          if ( v9 )
            *a1 &= v17;
        }
      }
      *(_DWORD *)(v26[2] + 4) = v26[1];
      *(_DWORD *)(v26[1] + 8) = v26[2];
    }
    v3 = v26;
  }
  if ( (v27 & 1) != 0 || a2 != v14 )
  {
    v3[1] = v23[2 * v14 + 1];
    v20 = &v23[2 * v14];
    v3[2] = (int)v20;
    v20[1] = (_DWORD)v3;
    *(_DWORD *)(v3[1] + 8) = (_DWORD)v3;
    if ( v3[1] == v3[2] )
    {
      v28 = *(_BYTE *)(v14 + v2 + 4);
      *(_BYTE *)(v14 + v2 + 4) = v28 + 1;
      if ( v14 >= 0x20 )
      {
        if ( !v28 )
          a1[1] |= 0x80000000 >> (v14 - 32);
        *(_DWORD *)(v2 + 4 * v4 + 196) |= 0x80000000 >> (v14 - 32);
      }
      else
      {
        if ( !v28 )
          *a1 |= 0x80000000 >> v14;
        *(_DWORD *)(v2 + 4 * v4 + 68) |= 0x80000000 >> v14;
      }
      v5 = v24;
    }
  }
  result = (_DWORD *)(516 * v4 + v2 + 324);
  *v3 = v5;
  *(int *)((char *)v3 + v5 - 4) = v5;
  v9 = (*v23)-- == 1;
  if ( v9 )
  {
    if ( !dword_4CC6B0 )
      goto LABEL_46;
    VirtualFree((LPVOID)(*((_DWORD *)dword_4CC6B0 + 3) + (dword_4CC6A8 << 15)), 0x8000u, 0x4000u);
    *((_DWORD *)dword_4CC6B0 + 2) |= 0x80000000 >> dword_4CC6A8;
    *(_DWORD *)(*((_DWORD *)dword_4CC6B0 + 4) + 4 * dword_4CC6A8 + 196) = 0;
    --*(_BYTE *)(*((_DWORD *)dword_4CC6B0 + 4) + 67);
    v22 = (LPVOID *)dword_4CC6B0;
    if ( !*(_BYTE *)(*((_DWORD *)dword_4CC6B0 + 4) + 67) )
    {
      *((_DWORD *)dword_4CC6B0 + 1) &= ~1u;
      v22 = (LPVOID *)dword_4CC6B0;
    }
    if ( v22[2] == (LPVOID)-1 )
    {
      VirtualFree(v22[3], 0, 0x8000u);
      HeapFree((HANDLE)hHeap, 0, *((LPVOID *)dword_4CC6B0 + 4));
      memcpy_0((void*)dword_4CC6B0, (char *)dword_4CC6B0 + 20, (size_t)lpMem + 20 * dword_4CC6B4 - (_DWORD)dword_4CC6B0 - 20);
      result = a1;
      --dword_4CC6B4;
      if ( (int)a1 > dword_4CC6B0 )
        result = a1 - 5;
      dword_4CC6AC = (int)lpMem;
    }
    else
    {
LABEL_46:
      result = a1;
    }
    dword_4CC6B0 = (_DWORD)result;
    dword_4CC6A8 = v4;
  }
  return result;
}
int __sbh_heap_init()
{
  int result; // eax

  result = (int)HeapAlloc((HANDLE)hHeap, 0, 0x140u);
  lpMem = (LPVOID)result;
  if ( result )
  {
    dword_4CC6B0 = 0;
    dword_4CC6B4 = 0;
    dword_4CC6AC = result;
    dword_4CC6A4 = 16;
    return 1;
  }
  return result;
}
int __cdecl __sbh_resize_block(_DWORD *a1, int a2, int a3)
{
  int v3; // eax
  signed int v4; // esi
  unsigned int v5; // edx
  int v6; // ecx
  int v7; // ebx
  int v8; // edi
  unsigned int v9; // ecx
  unsigned int v10; // ebx
  _BYTE *v11; // ecx
  int v12; // ebx
  bool v13; // zf
  unsigned int v14; // ebx
  _BYTE *v15; // ecx
  int v16; // ebx
  unsigned int v17; // edi
  int v18; // ecx
  _DWORD *v19; // eax
  char v20; // cl
  int v21; // edx
  int *v22; // eax
  int v24; // ecx
  int *v25; // ebx
  unsigned int v26; // esi
  unsigned int v27; // esi
  unsigned int v28; // ebx
  _BYTE *v29; // esi
  int v30; // ebx
  _BYTE *v31; // ecx
  unsigned int v32; // ebx
  unsigned int v33; // ecx
  _DWORD *v34; // eax
  char v35; // cl
  int v36; // [esp+Ch] [ebp-Ch]
  int v37; // [esp+10h] [ebp-8h]
  int v38; // [esp+14h] [ebp-4h]
  int v39; // [esp+14h] [ebp-4h]
  int *v40; // [esp+24h] [ebp+Ch]
  char v41; // [esp+27h] [ebp+Fh]
  int v42; // [esp+28h] [ebp+10h]
  unsigned int v43; // [esp+28h] [ebp+10h]
  int v44; // [esp+28h] [ebp+10h]
  char v45; // [esp+2Bh] [ebp+13h]

  v3 = a1[4];
  v4 = (a3 + 23) & 0xFFFFFFF0;
  v5 = (unsigned int)(a2 - a1[3]) >> 15;
  v36 = 516 * v5 + v3 + 324;
  v6 = *(_DWORD *)(a2 - 4) - 1;
  v42 = v6;
  v7 = *(_DWORD *)(v6 + a2 - 4);
  v8 = v6 + a2 - 4;
  v38 = v7;
  if ( v4 <= v6 )
  {
    if ( v4 < v6 )
    {
      v44 = v6 - v4;
      v24 = v4 + 1;
      *(_DWORD *)(a2 - 4) = v4 + 1;
      v25 = (int *)(a2 + v4 - 4);
      v40 = v25;
      v26 = (v44 >> 4) - 1;
      *(v25 - 1) = v24;
      if ( v26 > 0x3F )
        v26 = 63;
      if ( (v38 & 1) == 0 )
      {
        v27 = (v38 >> 4) - 1;
        if ( v27 > 0x3F )
          v27 = 63;
        if ( *(_DWORD *)(v8 + 4) == *(_DWORD *)(v8 + 8) )
        {
          if ( v27 >= 0x20 )
          {
            v31 = (_BYTE *)(v27 + v3 + 4);
            v32 = ~(0x80000000 >> (v27 - 32));
            *(_DWORD *)(v3 + 4 * v5 + 196) &= v32;
            v13 = (*v31)-- == 1;
            if ( v13 )
              a1[1] &= v32;
          }
          else
          {
            v28 = 0x80000000 >> v27;
            v29 = (_BYTE *)(v27 + v3 + 4);
            v30 = ~v28;
            *(_DWORD *)(v3 + 4 * v5 + 68) &= v30;
            v13 = (*v29)-- == 1;
            if ( v13 )
              *a1 &= v30;
          }
          v25 = v40;
        }
        *(_DWORD *)(*(_DWORD *)(v8 + 8) + 4) = *(_DWORD *)(v8 + 4);
        *(_DWORD *)(*(_DWORD *)(v8 + 4) + 8) = *(_DWORD *)(v8 + 8);
        v44 += v38;
        v26 = (v44 >> 4) - 1;
        if ( v26 > 0x3F )
          v26 = 63;
      }
      v33 = v36 + 8 * v26;
      v25[1] = *(_DWORD *)(v33 + 4);
      v25[2] = v33;
      *(_DWORD *)(v33 + 4) = (_DWORD)v25;
      *(_DWORD *)(v25[1] + 8) = (_DWORD)v25;
      if ( v25[1] == v25[2] )
      {
        v41 = *(_BYTE *)(v26 + v3 + 4);
        *(_BYTE *)(v26 + v3 + 4) = v41 + 1;
        if ( v26 >= 0x20 )
        {
          if ( !v41 )
            a1[1] |= 0x80000000 >> (v26 - 32);
          v34 = (_DWORD *)(v3 + 4 * v5 + 196);
          v35 = v26 - 32;
        }
        else
        {
          if ( !v41 )
            *a1 |= 0x80000000 >> v26;
          v34 = (_DWORD *)(v3 + 4 * v5 + 68);
          v35 = v26;
        }
        *v34 |= 0x80000000 >> v35;
      }
      *v25 = v44;
      *(int *)((char *)v25 + v44 - 4) = v44;
    }
  }
  else
  {
    if ( (v7 & 1) != 0 || v4 > v6 + v7 )
      return 0;
    v9 = (v7 >> 4) - 1;
    v37 = v9;
    if ( v9 > 0x3F )
    {
      v9 = 63;
      v37 = 63;
    }
    if ( *(_DWORD *)(v8 + 4) == *(_DWORD *)(v8 + 8) )
    {
      if ( v9 >= 0x20 )
      {
        v14 = 0x80000000 >> (v9 - 32);
        v15 = (_BYTE *)(v37 + v3 + 4);
        v16 = ~v14;
        *(_DWORD *)(v3 + 4 * v5 + 196) &= v16;
        v13 = (*v15)-- == 1;
        if ( v13 )
          a1[1] &= v16;
      }
      else
      {
        v10 = 0x80000000 >> v9;
        v11 = (_BYTE *)(v37 + v3 + 4);
        v12 = ~v10;
        *(_DWORD *)(v3 + 4 * v5 + 68) &= v12;
        v13 = (*v11)-- == 1;
        if ( v13 )
          *a1 &= v12;
      }
    }
    *(_DWORD *)(*(_DWORD *)(v8 + 8) + 4) = *(_DWORD *)(v8 + 4);
    *(_DWORD *)(*(_DWORD *)(v8 + 4) + 8) = *(_DWORD *)(v8 + 8);
    v39 = v42 - v4 + v38;
    if ( v39 <= 0 )
    {
      v21 = a2;
    }
    else
    {
      v17 = (v39 >> 4) - 1;
      v18 = a2 + v4 - 4;
      if ( v17 > 0x3F )
        v17 = 63;
      v43 = v36 + 8 * v17;
      *(_DWORD *)(a2 + v4) = *(_DWORD *)(v43 + 4);
      *(_DWORD *)(v18 + 8) = v43;
      *(_DWORD *)(v43 + 4) = v18;
      *(_DWORD *)(*(_DWORD *)(a2 + v4) + 8) = a2 + v4 - 4;
      if ( *(_DWORD *)(a2 + v4) == *(_DWORD *)(a2 + v4 - 4 + 8) )
      {
        v45 = *(_BYTE *)(v17 + v3 + 4);
        *(_BYTE *)(v17 + v3 + 4) = v45 + 1;
        if ( v17 >= 0x20 )
        {
          if ( !v45 )
            a1[1] |= 0x80000000 >> (v17 - 32);
          v19 = (_DWORD *)(v3 + 4 * v5 + 196);
          v20 = v17 - 32;
        }
        else
        {
          if ( !v45 )
            *a1 |= 0x80000000 >> v17;
          v19 = (_DWORD *)(v3 + 4 * v5 + 68);
          v20 = v17;
        }
        *v19 |= 0x80000000 >> v20;
      }
      v21 = a2;
      v22 = (int *)(a2 + v4 - 4);
      *v22 = v39;
      *(int *)((char *)v22 + v39 - 4) = v39;
    }
    *(_DWORD *)(v21 - 4) = v4 + 1;
    *(_DWORD *)(v21 + v4 - 8) = v4 + 1;
  }
  return 1;
}
_DWORD *__cdecl __shl_12(_DWORD *a1)
{
  _DWORD *result; // eax
  unsigned int v2; // edi
  unsigned int v3; // ecx
  int v4; // esi
  int v5; // ecx

  result = a1;
  v2 = a1[1];
  v3 = *a1;
  *a1 *= 2;
  v4 = (v3 >> 31) | (2 * v2);
  v5 = a1[2];
  a1[1] = v4;
  a1[2] = (v2 >> 31) | (2 * v5);
  return result;
}
int *__cdecl __shr_12(int *a1)
{
  int *result; // eax
  unsigned int v2; // edx
  int v3; // edi
  int v4; // ecx

  result = a1;
  v2 = a1[2];
  v3 = a1[1];
  a1[1] = *(__int64 *)(a1 + 1) >> 1;
  v4 = (v3 << 31) | ((unsigned int)*a1 >> 1);
  a1[2] = v2 >> 1;
  *a1 = v4;
  return result;
}
int __cdecl __strgtold12(int a1, char **a2, char *a3, int a4, int a5, int a6, int a7)
{
  char *v7; // edi
  int v8; // eax
  char v9; // cl
  char v10; // bl
  char *v12; // eax
  char *v14; // eax
  int v15; // eax
  char *v16; // ecx
  int v17; // esi
  int v18; // eax
  bool v20; // zf
  int v21; // eax
  int v22; // eax
  int v23; // eax
  char *v24; // ebx
  unsigned int v25; // esi
  __int16 v26; // ax
  __int16 v27; // dx
  __int16 v28; // ax
  int result; // eax
  int v30; // [esp-4h] [ebp-6Ch]
  int v31; // [esp-4h] [ebp-6Ch]
  char v32[23]; // [esp+Ch] [ebp-5Ch] BYREF
  char v33; // [esp+23h] [ebp-45h]
  _WORD v34[3]; // [esp+28h] [ebp-40h] BYREF
  unsigned int v35; // [esp+2Eh] [ebp-3Ah]
  int v36; // [esp+32h] [ebp-36h]
  int v37; // [esp+38h] [ebp-30h]
  int v38; // [esp+3Ch] [ebp-2Ch]
  int v39; // [esp+40h] [ebp-28h]
  int v40; // [esp+44h] [ebp-24h]
  int v41; // [esp+48h] [ebp-20h]
  int v42; // [esp+4Ch] [ebp-1Ch]
  int v43; // [esp+50h] [ebp-18h]
  int v44; // [esp+54h] [ebp-14h]
  int v45; // [esp+58h] [ebp-10h]
  char *v46; // [esp+5Ch] [ebp-Ch]
  int v47; // [esp+60h] [ebp-8h]
  unsigned int v48; // [esp+64h] [ebp-4h]

  v7 = a3;
  v46 = v32;
  v8 = 0;
  v39 = 0;
  v43 = 1;
  v48 = 0;
  v45 = 0;
  v40 = 0;
  v41 = 0;
  v38 = 0;
  v37 = 0;
  v42 = 0;
  v47 = 0;
  v44 = 0;
  while ( 1 )
  {
    v9 = *v7;
    if ( *v7 != 32 && v9 != 9 && v9 != 10 && v9 != 13 )
      break;
    ++v7;
  }
  while ( 2 )
  {
    v10 = *v7++;
    switch ( v8 )
    {
      case 0:
        if ( v10 >= 49 && v10 <= 57 )
          goto LABEL_10;
        if ( v10 == *(byte*)byte_4B8624 )
          goto LABEL_12;
        if ( v10 == 43 )
        {
          v39 = 0;
          v8 = 2;
          continue;
        }
        if ( v10 == 45 )
        {
          v39 = 0x8000;
          v8 = 2;
          continue;
        }
        if ( v10 != 48 )
          goto LABEL_108;
        goto LABEL_35;
      case 1:
        v45 = 1;
        if ( v10 >= 49 && v10 <= 57 )
          goto LABEL_10;
        if ( v10 == *(byte*)byte_4B8624 )
          goto LABEL_46;
        if ( v10 == 43 || v10 == 45 )
          goto LABEL_30;
        if ( v10 != 48 )
          goto LABEL_25;
        goto LABEL_35;
      case 2:
        if ( v10 >= 49 && v10 <= 57 )
        {
LABEL_10:
          v30 = 3;
LABEL_80:
          v8 = v30;
LABEL_81:
          --v7;
        }
        else
        {
          if ( v10 == *(byte*)byte_4B8624 )
          {
LABEL_12:
            v31 = 5;
            goto LABEL_89;
          }
          if ( v10 != 48 )
          {
LABEL_93:
            v7 = a3;
            goto LABEL_110;
          }
LABEL_35:
          v8 = 1;
        }
        continue;
      case 3:
        v45 = 1;
        while ( cbMultiByte <= 1 ? *((_BYTE *)off_4B8414 + 2 * (unsigned __int8)v10) & 4 : _isctype(
                                                                                             (unsigned __int8)v10,
                                                                                             4) )
        {
          if ( v48 >= 0x19 )
          {
            ++v47;
          }
          else
          {
            v12 = v46;
            ++v48;
            ++v46;
            *v12 = v10 - 48;
          }
          v10 = *v7++;
        }
        if ( v10 != *(byte*)byte_4B8624 )
          goto LABEL_57;
LABEL_46:
        v8 = 4;
        continue;
      case 4:
        v45 = 1;
        v40 = 1;
        if ( !v48 )
        {
          while ( v10 == 48 )
          {
            --v47;
            v10 = *v7++;
          }
        }
        while ( cbMultiByte <= 1 ? *((_BYTE *)off_4B8414 + 2 * (unsigned __int8)v10) & 4 : _isctype(
                                                                                             (unsigned __int8)v10,
                                                                                             4) )
        {
          if ( v48 < 0x19 )
          {
            v14 = v46;
            ++v48;
            ++v46;
            --v47;
            *v14 = v10 - 48;
          }
          v10 = *v7++;
        }
LABEL_57:
        if ( v10 == 43 || v10 == 45 )
        {
LABEL_30:
          --v7;
          v31 = 11;
        }
        else
        {
LABEL_25:
          if ( v10 <= 67 || v10 > 69 && (v10 <= 99 || v10 > 101) )
          {
LABEL_108:
            --v7;
            goto LABEL_110;
          }
          v31 = 6;
        }
        goto LABEL_89;
      case 5:
        v40 = 1;
        if ( cbMultiByte <= 1 )
          v15 = *((_BYTE *)off_4B8414 + 2 * (unsigned __int8)v10) & 4;
        else
          v15 = _isctype((unsigned __int8)v10, 4);
        if ( !v15 )
          goto LABEL_93;
        v8 = 4;
        goto LABEL_81;
      case 6:
        v16 = v7 - 2;
        a3 = v7 - 2;
        if ( v10 >= 49 && v10 <= 57 )
          goto LABEL_79;
        if ( v10 == 43 )
          goto LABEL_88;
        if ( v10 == 45 )
          goto LABEL_87;
        if ( v10 != 48 )
          goto LABEL_109;
LABEL_70:
        v31 = 8;
        goto LABEL_89;
      case 7:
        if ( v10 >= 49 && v10 <= 57 )
          goto LABEL_79;
        if ( v10 == 48 )
          goto LABEL_70;
        goto LABEL_93;
      case 8:
        v41 = 1;
        while ( v10 == 48 )
          v10 = *v7++;
        if ( v10 < 49 || v10 > 57 )
          goto LABEL_108;
LABEL_79:
        v30 = 9;
        goto LABEL_80;
      case 9:
        v41 = 1;
        v17 = 0;
        while ( 2 )
        {
          if ( cbMultiByte <= 1 )
            v18 = *((_BYTE *)off_4B8414 + 2 * (unsigned __int8)v10) & 4;
          else
            v18 = _isctype((unsigned __int8)v10, 4);
          if ( v18 )
          {
            v17 = v10 + 10 * v17 - 48;
            if ( v17 <= 5200 )
            {
              v10 = *v7++;
              continue;
            }
            v17 = 5201;
          }
          break;
        }
        v42 = v17;
        while ( cbMultiByte <= 1 ? *((_BYTE *)off_4B8414 + 2 * (unsigned __int8)v10) & 4 : _isctype(
                                                                                             (unsigned __int8)v10,
                                                                                             4) )
          v10 = *v7++;
        goto LABEL_108;
      case 11:
        if ( !a7 )
        {
          --v7;
          v8 = 10;
LABEL_91:
          if ( v8 == 10 )
            goto LABEL_110;
          continue;
        }
        v16 = v7 - 1;
        a3 = v7 - 1;
        if ( v10 == 43 )
        {
LABEL_88:
          v31 = 7;
LABEL_89:
          v8 = v31;
          continue;
        }
        if ( v10 == 45 )
        {
LABEL_87:
          v43 = -1;
          v8 = 7;
          continue;
        }
LABEL_109:
        v7 = v16;
LABEL_110:
        v20 = v45 == 0;
        *a2 = v7;
        if ( v20 )
        {
          v27 = 0;
          v26 = 0;
          v25 = 0;
          v24 = 0;
          v44 = 4;
        }
        else
        {
          if ( v48 <= 0x18 )
          {
            v21 = (int)v46;
          }
          else
          {
            if ( v33 >= 5 )
              ++v33;
            v48 = 24;
            v21 = (int)(v46 - 1);
            ++v47;
          }
          if ( v48 )
          {
            while ( !*(_BYTE *)--v21 )
            {
              --v48;
              ++v47;
            }
            __mtold12(v32, v48, (int)v34);
            v22 = v42;
            if ( v43 < 0 )
              v22 = -v42;
            v23 = v47 + v22;
            if ( !v41 )
              v23 += a5;
            if ( !v40 )
              v23 -= a6;
            if ( v23 > 5200 )
            {
              v38 = 1;
              goto LABEL_127;
            }
            if ( v23 >= -5200 )
            {
              __multtenpow12(v34, v23, a4);
              v27 = v34[0];
              v24 = *(char **)&v34[1];
              v25 = v35;
              v26 = v36;
            }
            else
            {
              v37 = 1;
LABEL_127:
              v24 = a3;
              v25 = (unsigned int)a3;
              v26 = (__int16)a3;
              v27 = (__int16)a3;
            }
          }
          else
          {
            v27 = 0;
            v26 = 0;
            v25 = 0;
            v24 = 0;
          }
          if ( v38 )
          {
            v24 = 0;
            v26 = 0x7FFF;
            v25 = 0x80000000;
            v27 = 0;
            v44 = 2;
          }
          else if ( v37 )
          {
            v27 = 0;
            v26 = 0;
            v25 = 0;
            v24 = 0;
            v44 = 1;
          }
        }
        v28 = v39 | v26;
        *(_DWORD *)(a1 + 6) = v25;
        *(_DWORD *)(a1 + 2) = (int)v24;
        *(_WORD *)(a1 + 10) = v28;
        result = v44;
        *(_WORD *)a1 = v27;
        return result;
      default:
        goto LABEL_91;
    }
  }
}